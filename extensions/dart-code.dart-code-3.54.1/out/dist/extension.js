/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 5623:
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ 3644:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var balanced = __webpack_require__(5623);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,.*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}



/***/ }),

/***/ 1048:
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ 9593:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(4411)

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ 8696:
/***/ ((module) => {

const isWindows = typeof process === 'object' &&
  process &&
  process.platform === 'win32'
module.exports = isWindows ? { sep: '\\' } : { sep: '/' }


/***/ }),

/***/ 1171:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const minimatch = module.exports = (p, pattern, options = {}) => {
  assertValidPattern(pattern)

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

module.exports = minimatch

const path = __webpack_require__(8696)
minimatch.sep = path.sep

const GLOBSTAR = Symbol('globstar **')
minimatch.GLOBSTAR = GLOBSTAR
const expand = __webpack_require__(3644)

const plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]'

// * => any number of characters
const star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// "abc" -> { a:true, b:true, c:true }
const charSet = s => s.split('').reduce((set, c) => {
  set[c] = true
  return set
}, {})

// characters that need to be escaped in RegExp.
const reSpecials = charSet('().*{}+?[]^$\\!')

// characters that indicate we have to add the pattern start
const addPatternStartSet = charSet('[.(')

// normalizes slashes.
const slashSplit = /\/+/

minimatch.filter = (pattern, options = {}) =>
  (p, i, list) => minimatch(p, pattern, options)

const ext = (a, b = {}) => {
  const t = {}
  Object.keys(a).forEach(k => t[k] = a[k])
  Object.keys(b).forEach(k => t[k] = b[k])
  return t
}

minimatch.defaults = def => {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  const orig = minimatch

  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))
  m.Minimatch = class Minimatch extends orig.Minimatch {
    constructor (pattern, options) {
      super(pattern, ext(def, options))
    }
  }
  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch
  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))
  m.defaults = options => orig.defaults(ext(def, options))
  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))
  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))
  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))

  return m
}





// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)

const braceExpand = (pattern, options = {}) => {
  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

const MAX_PATTERN_LENGTH = 1024 * 64
const assertValidPattern = pattern => {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const SUBPARSE = Symbol('subparse')

minimatch.makeRe = (pattern, options) =>
  new Minimatch(pattern, options || {}).makeRe()

minimatch.match = (list, pattern, options = {}) => {
  const mm = new Minimatch(pattern, options)
  list = list.filter(f => mm.match(f))
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

// replace stuff like \* with *
const globUnescape = s => s.replace(/\\(.)/g, '$1')
const regExpEscape = s => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')

class Minimatch {
  constructor (pattern, options) {
    assertValidPattern(pattern)

    if (!options) options = {}

    this.options = options
    this.set = []
    this.pattern = pattern
    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||
      options.allowWindowsEscape === false
    if (this.windowsPathsNoEscape) {
      this.pattern = this.pattern.replace(/\\/g, '/')
    }
    this.regexp = null
    this.negate = false
    this.comment = false
    this.empty = false
    this.partial = !!options.partial

    // make the set of regexps etc.
    this.make()
  }

  debug () {}

  make () {
    const pattern = this.pattern
    const options = this.options

    // empty patterns and comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
      this.comment = true
      return
    }
    if (!pattern) {
      this.empty = true
      return
    }

    // step 1: figure out negation, etc.
    this.parseNegate()

    // step 2: expand braces
    let set = this.globSet = this.braceExpand()

    if (options.debug) this.debug = (...args) => console.error(...args)

    this.debug(this.pattern, set)

    // step 3: now we have a set, so turn each one into a series of path-portion
    // matching patterns.
    // These will be regexps, except in the case of "**", which is
    // set to the GLOBSTAR object for globstar behavior,
    // and will not contain any / characters
    set = this.globParts = set.map(s => s.split(slashSplit))

    this.debug(this.pattern, set)

    // glob --> regexps
    set = set.map((s, si, set) => s.map(this.parse, this))

    this.debug(this.pattern, set)

    // filter out everything that didn't compile properly.
    set = set.filter(s => s.indexOf(false) === -1)

    this.debug(this.pattern, set)

    this.set = set
  }

  parseNegate () {
    if (this.options.nonegate) return

    const pattern = this.pattern
    let negate = false
    let negateOffset = 0

    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
      negate = !negate
      negateOffset++
    }

    if (negateOffset) this.pattern = pattern.substr(negateOffset)
    this.negate = negate
  }

  // set partial to true to test if, for example,
  // "/a/b" matches the start of "/*/b/*/d"
  // Partial means, if you run out of file before you run
  // out of pattern, then that's fine, as long as all
  // the parts match.
  matchOne (file, pattern, partial) {
    var options = this.options

    this.debug('matchOne',
      { 'this': this, file: file, pattern: pattern })

    this.debug('matchOne', file.length, pattern.length)

    for (var fi = 0,
        pi = 0,
        fl = file.length,
        pl = pattern.length
        ; (fi < fl) && (pi < pl)
        ; fi++, pi++) {
      this.debug('matchOne loop')
      var p = pattern[pi]
      var f = file[fi]

      this.debug(pattern, p, f)

      // should be impossible.
      // some invalid regexp stuff in the set.
      /* istanbul ignore if */
      if (p === false) return false

      if (p === GLOBSTAR) {
        this.debug('GLOBSTAR', [pattern, p, f])

        // "**"
        // a/**/b/**/c would match the following:
        // a/b/x/y/z/c
        // a/x/y/z/b/c
        // a/b/x/b/x/c
        // a/b/c
        // To do this, take the rest of the pattern after
        // the **, and see if it would match the file remainder.
        // If so, return success.
        // If not, the ** "swallows" a segment, and try again.
        // This is recursively awful.
        //
        // a/**/b/**/c matching a/b/x/y/z/c
        // - a matches a
        // - doublestar
        //   - matchOne(b/x/y/z/c, b/**/c)
        //     - b matches b
        //     - doublestar
        //       - matchOne(x/y/z/c, c) -> no
        //       - matchOne(y/z/c, c) -> no
        //       - matchOne(z/c, c) -> no
        //       - matchOne(c, c) yes, hit
        var fr = fi
        var pr = pi + 1
        if (pr === pl) {
          this.debug('** at the end')
          // a ** at the end will just swallow the rest.
          // We have found a match.
          // however, it will not swallow /.x, unless
          // options.dot is set.
          // . and .. are *never* matched by **, for explosively
          // exponential reasons.
          for (; fi < fl; fi++) {
            if (file[fi] === '.' || file[fi] === '..' ||
              (!options.dot && file[fi].charAt(0) === '.')) return false
          }
          return true
        }

        // ok, let's see if we can swallow whatever we can.
        while (fr < fl) {
          var swallowee = file[fr]

          this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

          // XXX remove this slice.  Just pass the start index.
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug('globstar found match!', fr, fl, swallowee)
            // found a match.
            return true
          } else {
            // can't swallow "." or ".." ever.
            // can only swallow ".foo" when explicitly asked.
            if (swallowee === '.' || swallowee === '..' ||
              (!options.dot && swallowee.charAt(0) === '.')) {
              this.debug('dot detected!', file, fr, pattern, pr)
              break
            }

            // ** swallows a segment, and continue.
            this.debug('globstar swallow a segment, and continue')
            fr++
          }
        }

        // no match was found.
        // However, in partial mode, we can't say this is necessarily over.
        // If there's more *pattern* left, then
        /* istanbul ignore if */
        if (partial) {
          // ran out of file
          this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
          if (fr === fl) return true
        }
        return false
      }

      // something other than **
      // non-magic patterns just have to match exactly
      // patterns with magic have been turned into regexps.
      var hit
      if (typeof p === 'string') {
        hit = f === p
        this.debug('string match', p, f, hit)
      } else {
        hit = f.match(p)
        this.debug('pattern match', p, f, hit)
      }

      if (!hit) return false
    }

    // Note: ending in / means that we'll get a final ""
    // at the end of the pattern.  This can only match a
    // corresponding "" at the end of the file.
    // If the file ends in /, then it can only match a
    // a pattern that ends in /, unless the pattern just
    // doesn't have any more for it. But, a/b/ should *not*
    // match "a/b/*", even though "" matches against the
    // [^/]*? pattern, except in partial mode, where it might
    // simply not be reached yet.
    // However, a/b/ should still satisfy a/*

    // now either we fell off the end of the pattern, or we're done.
    if (fi === fl && pi === pl) {
      // ran out of pattern and filename at the same time.
      // an exact hit!
      return true
    } else if (fi === fl) {
      // ran out of file, but still had pattern left.
      // this is ok if we're doing the match as part of
      // a glob fs traversal.
      return partial
    } else /* istanbul ignore else */ if (pi === pl) {
      // ran out of pattern, still have file left.
      // this is only acceptable if we're on the very last
      // empty segment of a file with a trailing slash.
      // a/* should match a/b/
      return (fi === fl - 1) && (file[fi] === '')
    }

    // should be unreachable.
    /* istanbul ignore next */
    throw new Error('wtf?')
  }

  braceExpand () {
    return braceExpand(this.pattern, this.options)
  }

  parse (pattern, isSub) {
    assertValidPattern(pattern)

    const options = this.options

    // shortcuts
    if (pattern === '**') {
      if (!options.noglobstar)
        return GLOBSTAR
      else
        pattern = '*'
    }
    if (pattern === '') return ''

    let re = ''
    let hasMagic = !!options.nocase
    let escaping = false
    // ? => one single character
    const patternListStack = []
    const negativeLists = []
    let stateChar
    let inClass = false
    let reClassStart = -1
    let classStart = -1
    let cs
    let pl
    let sp
    // . and .. never match anything that doesn't start with .,
    // even when options.dot is set.
    const patternStart = pattern.charAt(0) === '.' ? '' // anything
    // not (start or / followed by . or .. followed by / or end)
    : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
    : '(?!\\.)'

    const clearStateChar = () => {
      if (stateChar) {
        // we had some state-tracking character
        // that wasn't consumed by this pass.
        switch (stateChar) {
          case '*':
            re += star
            hasMagic = true
          break
          case '?':
            re += qmark
            hasMagic = true
          break
          default:
            re += '\\' + stateChar
          break
        }
        this.debug('clearStateChar %j %j', stateChar, re)
        stateChar = false
      }
    }

    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {
      this.debug('%s\t%s %s %j', pattern, i, re, c)

      // skip over any that are escaped.
      if (escaping) {
        /* istanbul ignore next - completely not allowed, even escaped. */
        if (c === '/') {
          return false
        }

        if (reSpecials[c]) {
          re += '\\'
        }
        re += c
        escaping = false
        continue
      }

      switch (c) {
        /* istanbul ignore next */
        case '/': {
          // Should already be path-split by now.
          return false
        }

        case '\\':
          clearStateChar()
          escaping = true
        continue

        // the various stateChar values
        // for the "extglob" stuff.
        case '?':
        case '*':
        case '+':
        case '@':
        case '!':
          this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

          // all of those are literals inside a class, except that
          // the glob [!a] means [^a] in regexp
          if (inClass) {
            this.debug('  in class')
            if (c === '!' && i === classStart + 1) c = '^'
            re += c
            continue
          }

          // if we already have a stateChar, then it means
          // that there was something like ** or +? in there.
          // Handle the stateChar, then proceed with this one.
          this.debug('call clearStateChar %j', stateChar)
          clearStateChar()
          stateChar = c
          // if extglob is disabled, then +(asdf|foo) isn't a thing.
          // just clear the statechar *now*, rather than even diving into
          // the patternList stuff.
          if (options.noext) clearStateChar()
        continue

        case '(':
          if (inClass) {
            re += '('
            continue
          }

          if (!stateChar) {
            re += '\\('
            continue
          }

          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          })
          // negation is (?:(?!js)[^/]*)
          re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
          this.debug('plType %j %j', stateChar, re)
          stateChar = false
        continue

        case ')':
          if (inClass || !patternListStack.length) {
            re += '\\)'
            continue
          }

          clearStateChar()
          hasMagic = true
          pl = patternListStack.pop()
          // negation is (?:(?!js)[^/]*)
          // The others are (?:<pattern>)<type>
          re += pl.close
          if (pl.type === '!') {
            negativeLists.push(pl)
          }
          pl.reEnd = re.length
        continue

        case '|':
          if (inClass || !patternListStack.length) {
            re += '\\|'
            continue
          }

          clearStateChar()
          re += '|'
        continue

        // these are mostly the same in regexp and glob
        case '[':
          // swallow any state-tracking char before the [
          clearStateChar()

          if (inClass) {
            re += '\\' + c
            continue
          }

          inClass = true
          classStart = i
          reClassStart = re.length
          re += c
        continue

        case ']':
          //  a right bracket shall lose its special
          //  meaning and represent itself in
          //  a bracket expression if it occurs
          //  first in the list.  -- POSIX.2 2.8.3.2
          if (i === classStart + 1 || !inClass) {
            re += '\\' + c
            continue
          }

          // handle the case where we left a class open.
          // "[z-a]" is valid, equivalent to "\[z-a\]"
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }

          // finish up the class.
          hasMagic = true
          inClass = false
          re += c
        continue

        default:
          // swallow any state char that wasn't consumed
          clearStateChar()

          if (reSpecials[c] && !(c === '^' && inClass)) {
            re += '\\'
          }

          re += c
          break

      } // switch
    } // for

    // handle the case where we left a class open.
    // "[abc" is valid, equivalent to "\[abc"
    if (inClass) {
      // split where the last [ was, and escape it
      // this is a huge pita.  We now have to re-walk
      // the contents of the would-be class to re-translate
      // any characters that were passed through as-is
      cs = pattern.substr(classStart + 1)
      sp = this.parse(cs, SUBPARSE)
      re = re.substr(0, reClassStart) + '\\[' + sp[0]
      hasMagic = hasMagic || sp[1]
    }

    // handle the case where we had a +( thing at the *end*
    // of the pattern.
    // each pattern list stack adds 3 chars, and we need to go through
    // and escape any | chars that were passed through as-is for the regexp.
    // Go through and escape them, taking care not to double-escape any
    // | chars that were already escaped.
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      let tail
      tail = re.slice(pl.reStart + pl.open.length)
      this.debug('setting tail', re, pl)
      // maybe some even number of \, then maybe 1 \, followed by a |
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
        /* istanbul ignore else - should already be done */
        if (!$2) {
          // the | isn't already escaped, so escape it.
          $2 = '\\'
        }

        // need to escape all those slashes *again*, without escaping the
        // one that we need for escaping the | character.  As it works out,
        // escaping an even number of slashes can be done by simply repeating
        // it exactly after itself.  That's why this trick works.
        //
        // I am sorry that you have to see this.
        return $1 + $1 + $2 + '|'
      })

      this.debug('tail=%j\n   %s', tail, tail, pl, re)
      const t = pl.type === '*' ? star
        : pl.type === '?' ? qmark
        : '\\' + pl.type

      hasMagic = true
      re = re.slice(0, pl.reStart) + t + '\\(' + tail
    }

    // handle trailing things that only matter at the very end.
    clearStateChar()
    if (escaping) {
      // trailing \\
      re += '\\\\'
    }

    // only need to apply the nodot start if the re starts with
    // something that could conceivably capture a dot
    const addPatternStart = addPatternStartSet[re.charAt(0)]

    // Hack to work around lack of negative lookbehind in JS
    // A pattern like: *.!(x).!(y|z) needs to ensure that a name
    // like 'a.xyz.yz' doesn't match.  So, the first negative
    // lookahead, has to look ALL the way ahead, to the end of
    // the pattern.
    for (let n = negativeLists.length - 1; n > -1; n--) {
      const nl = negativeLists[n]

      const nlBefore = re.slice(0, nl.reStart)
      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
      let nlAfter = re.slice(nl.reEnd)
      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter

      // Handle nested stuff like *(*.js|!(*.json)), where open parens
      // mean that we should *not* include the ) in the bit that is considered
      // "after" the negated section.
      const openParensBefore = nlBefore.split('(').length - 1
      let cleanAfter = nlAfter
      for (let i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
      }
      nlAfter = cleanAfter

      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : ''
      re = nlBefore + nlFirst + nlAfter + dollar + nlLast
    }

    // if the re is not "" at this point, then we need to make sure
    // it doesn't match against an empty path part.
    // Otherwise a/* will match a/, which it should not.
    if (re !== '' && hasMagic) {
      re = '(?=.)' + re
    }

    if (addPatternStart) {
      re = patternStart + re
    }

    // parsing just a piece of a larger pattern.
    if (isSub === SUBPARSE) {
      return [re, hasMagic]
    }

    // skip the regexp for non-magical patterns
    // unescape anything in it, though, so that it'll be
    // an exact match against a file etc.
    if (!hasMagic) {
      return globUnescape(pattern)
    }

    const flags = options.nocase ? 'i' : ''
    try {
      return Object.assign(new RegExp('^' + re + '$', flags), {
        _glob: pattern,
        _src: re,
      })
    } catch (er) /* istanbul ignore next - should be impossible */ {
      // If it was an invalid regular expression, then it can't match
      // anything.  This trick looks for a character after the end of
      // the string, which is of course impossible, except in multi-line
      // mode, but it's not a /m regex.
      return new RegExp('$.')
    }
  }

  makeRe () {
    if (this.regexp || this.regexp === false) return this.regexp

    // at this point, this.set is a 2d array of partial
    // pattern strings, or "**".
    //
    // It's better to use .match().  This function shouldn't
    // be used, really, but it's pretty convenient sometimes,
    // when you just want to work with a regex.
    const set = this.set

    if (!set.length) {
      this.regexp = false
      return this.regexp
    }
    const options = this.options

    const twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    const flags = options.nocase ? 'i' : ''

    // coalesce globstars and regexpify non-globstar patterns
    // if it's the only item, then we just do one twoStar
    // if it's the first, and there are more, prepend (\/|twoStar\/)? to next
    // if it's the last, append (\/twoStar|) to previous
    // if it's in the middle, append (\/|\/twoStar\/) to previous
    // then filter out GLOBSTAR symbols
    let re = set.map(pattern => {
      pattern = pattern.map(p =>
        typeof p === 'string' ? regExpEscape(p)
        : p === GLOBSTAR ? GLOBSTAR
        : p._src
      ).reduce((set, p) => {
        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
          set.push(p)
        }
        return set
      }, [])
      pattern.forEach((p, i) => {
        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {
          return
        }
        if (i === 0) {
          if (pattern.length > 1) {
            pattern[i+1] = '(?:\\\/|' + twoStar + '\\\/)?' + pattern[i+1]
          } else {
            pattern[i] = twoStar
          }
        } else if (i === pattern.length - 1) {
          pattern[i-1] += '(?:\\\/|' + twoStar + ')?'
        } else {
          pattern[i-1] += '(?:\\\/|\\\/' + twoStar + '\\\/)' + pattern[i+1]
          pattern[i+1] = GLOBSTAR
        }
      })
      return pattern.filter(p => p !== GLOBSTAR).join('/')
    }).join('|')

    // must match entire pattern
    // ending in a * or ** will make it less strict.
    re = '^(?:' + re + ')$'

    // can match anything, as long as it's not this.
    if (this.negate) re = '^(?!' + re + ').*$'

    try {
      this.regexp = new RegExp(re, flags)
    } catch (ex) /* istanbul ignore next - should be impossible */ {
      this.regexp = false
    }
    return this.regexp
  }

  match (f, partial = this.partial) {
    this.debug('match', f, this.pattern)
    // short-circuit in the case of busted things.
    // comments, etc.
    if (this.comment) return false
    if (this.empty) return f === ''

    if (f === '/' && partial) return true

    const options = this.options

    // windows: need to use /, not \
    if (path.sep !== '/') {
      f = f.split(path.sep).join('/')
    }

    // treat the test path as a set of pathparts.
    f = f.split(slashSplit)
    this.debug(this.pattern, 'split', f)

    // just ONE of the pattern sets in this.set needs to match
    // in order for it to be valid.  If negating, then just one
    // match means that we have failed.
    // Either way, return on the first hit.

    const set = this.set
    this.debug(this.pattern, 'set', set)

    // Find the basename of the path by looking for the last non-empty segment
    let filename
    for (let i = f.length - 1; i >= 0; i--) {
      filename = f[i]
      if (filename) break
    }

    for (let i = 0; i < set.length; i++) {
      const pattern = set[i]
      let file = f
      if (options.matchBase && pattern.length === 1) {
        file = [filename]
      }
      const hit = this.matchOne(file, pattern, partial)
      if (hit) {
        if (options.flipNegate) return true
        return !this.negate
      }
    }

    // didn't get any hits.  this is success if it's a negative
    // pattern, failure otherwise.
    if (options.flipNegate) return false
    return this.negate
  }

  static defaults (def) {
    return minimatch.defaults(def).Minimatch
  }
}

minimatch.Minimatch = Minimatch


/***/ }),

/***/ 2257:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(2893)
const { re, t } = __webpack_require__(5765)
const cmp = __webpack_require__(7539)
const debug = __webpack_require__(4225)
const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)


/***/ }),

/***/ 6902:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(9593)
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(2893)
const Comparator = __webpack_require__(2257)
const debug = __webpack_require__(4225)
const SemVer = __webpack_require__(6376)
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(5765)

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ 6376:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(4225)
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(3295)
const { re, t } = __webpack_require__(5765)

const parseOptions = __webpack_require__(2893)
const { compareIdentifiers } = __webpack_require__(6742)
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ 3507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ 7539:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(8718)
const neq = __webpack_require__(1194)
const gt = __webpack_require__(1312)
const gte = __webpack_require__(5903)
const lt = __webpack_require__(1544)
const lte = __webpack_require__(2056)

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ 9038:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const parse = __webpack_require__(3959)
const { re, t } = __webpack_require__(5765)

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ 8880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ 7880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ 6269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ 2378:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const eq = __webpack_require__(8718)

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ 8718:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ 1312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ 5903:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ 253:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ 1544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ 2056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ 8679:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ 7789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ 1194:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ 3959:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { MAX_LENGTH } = __webpack_require__(3295)
const { re, t } = __webpack_require__(5765)
const SemVer = __webpack_require__(6376)

const parseOptions = __webpack_require__(2893)
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ 2358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ 7559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ 9795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(6269)
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ 3657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(8880)
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ 5712:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ 1100:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(8880)
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ 6397:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(3959)
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ 1249:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(5765)
module.exports = {
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: (__webpack_require__(3295).SEMVER_SPEC_VERSION),
  SemVer: __webpack_require__(6376),
  compareIdentifiers: (__webpack_require__(6742).compareIdentifiers),
  rcompareIdentifiers: (__webpack_require__(6742).rcompareIdentifiers),
  parse: __webpack_require__(3959),
  valid: __webpack_require__(6397),
  clean: __webpack_require__(3507),
  inc: __webpack_require__(253),
  diff: __webpack_require__(2378),
  major: __webpack_require__(8679),
  minor: __webpack_require__(7789),
  patch: __webpack_require__(2358),
  prerelease: __webpack_require__(7559),
  compare: __webpack_require__(6269),
  rcompare: __webpack_require__(9795),
  compareLoose: __webpack_require__(7880),
  compareBuild: __webpack_require__(8880),
  sort: __webpack_require__(1100),
  rsort: __webpack_require__(3657),
  gt: __webpack_require__(1312),
  lt: __webpack_require__(1544),
  eq: __webpack_require__(8718),
  neq: __webpack_require__(1194),
  gte: __webpack_require__(5903),
  lte: __webpack_require__(2056),
  cmp: __webpack_require__(7539),
  coerce: __webpack_require__(9038),
  Comparator: __webpack_require__(2257),
  Range: __webpack_require__(6902),
  satisfies: __webpack_require__(5712),
  toComparators: __webpack_require__(1042),
  maxSatisfying: __webpack_require__(5775),
  minSatisfying: __webpack_require__(1657),
  minVersion: __webpack_require__(5316),
  validRange: __webpack_require__(9042),
  outside: __webpack_require__(6826),
  gtr: __webpack_require__(7606),
  ltr: __webpack_require__(32),
  intersects: __webpack_require__(2937),
  simplifyRange: __webpack_require__(7908),
  subset: __webpack_require__(799),
}


/***/ }),

/***/ 3295:
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH,
}


/***/ }),

/***/ 4225:
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ 6742:
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ 2893:
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((o, k) => {
    o[k] = true
    return o
  }, {})
module.exports = parseOptions


/***/ }),

/***/ 5765:
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(3295)
const debug = __webpack_require__(4225)
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ 7606:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(6826)
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ 2937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ 32:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(6826)
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ 5775:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ 1657:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ 5316:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Range = __webpack_require__(6902)
const gt = __webpack_require__(1312)

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ 6826:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(6376)
const Comparator = __webpack_require__(2257)
const { ANY } = Comparator
const Range = __webpack_require__(6902)
const satisfies = __webpack_require__(5712)
const gt = __webpack_require__(1312)
const lt = __webpack_require__(1544)
const lte = __webpack_require__(2056)
const gte = __webpack_require__(5903)

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ 7908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(5712)
const compare = __webpack_require__(6269)
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ 799:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const Comparator = __webpack_require__(2257)
const { ANY } = Comparator
const satisfies = __webpack_require__(5712)
const compare = __webpack_require__(6269)

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = [new Comparator('>=0.0.0-0')]
    } else {
      sub = [new Comparator('>=0.0.0')]
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = [new Comparator('>=0.0.0')]
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ 1042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ 9042:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(6902)
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ 4256:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getAnalyzerArgs = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const extension_utils_1 = __webpack_require__(6143);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
function getAnalyzerArgs(logger, sdks, dartCapabilities, isLsp, vmServicePort) {
    const analyzerPath = config_1.config.analyzerPath || (dartCapabilities.supportsLanguageServerCommand
        ? "language-server"
        : path.join(sdks.dart, constants_1.analyzerSnapshotPath));
    // If the ssh host is set, then we are running the analyzer on a remote machine, that same analyzer
    // might not exist on the local machine.
    if (!config_1.config.analyzerSshHost && analyzerPath !== "language-server" && !fs.existsSync(analyzerPath)) {
        const msg = "Could not find a Dart Analysis Server at " + analyzerPath;
        vs.window.showErrorMessage(msg);
        logger.error(msg);
        throw new Error(msg);
    }
    return buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp, vmServicePort);
}
exports.getAnalyzerArgs = getAnalyzerArgs;
function buildAnalyzerArgs(analyzerPath, dartCapabilities, isLsp, vmServicePort) {
    let analyzerArgs = [];
    // Optionally start the VM service for the analyzer.
    if (vmServicePort) {
        analyzerArgs.push(`--enable-vm-service=${vmServicePort}`);
        // When using LSP, printing the VM Service URI will break the protocol and
        // stop the client from working, so it needs to be hidden.
        analyzerArgs.push(`-DSILENT_OBSERVATORY=true`);
        analyzerArgs.push(`--disable-service-auth-codes`);
        analyzerArgs.push(`--no-dds`);
        if (dartCapabilities.supportsNoServeDevTools)
            analyzerArgs.push("--no-serve-devtools");
    }
    analyzerArgs.push(analyzerPath);
    if (analyzerPath === "language-server") {
        if (!isLsp)
            analyzerArgs.push("--protocol=analyzer");
        else
            analyzerArgs.push("--protocol=lsp");
    }
    else {
        if (isLsp)
            analyzerArgs.push("--lsp");
    }
    // Optionally start the analyzer's diagnostic web server on the given port.
    if (config_1.config.analyzerDiagnosticsPort)
        analyzerArgs.push(`--port=${config_1.config.analyzerDiagnosticsPort}`);
    // Add info about the extension that will be collected for crash reports etc.
    const clientID = utils_1.isRunningLocally ? "VS-Code" : "VS-Code-Remote";
    analyzerArgs.push(`--client-id=${clientID}`);
    analyzerArgs.push(`--client-version=${extension_utils_1.extensionVersion}`);
    // The analysis server supports a verbose instrumentation log file.
    if (config_1.config.analyzerInstrumentationLogFile)
        analyzerArgs.push(`--instrumentation-log-file=${config_1.config.analyzerInstrumentationLogFile}`);
    // Allow arbitrary args to be passed to the analysis server.
    if (config_1.config.analyzerAdditionalArgs)
        analyzerArgs = analyzerArgs.concat(config_1.config.analyzerAdditionalArgs);
    return analyzerArgs;
}


/***/ }),

/***/ 2061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getSymbolKindForElementKind = exports.DasAnalyzerClient = exports.DasAnalyzer = exports.AnalyzerCapabilities = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const analyzer_1 = __webpack_require__(458);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const constants_2 = __webpack_require__(6249);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
const analyzer_2 = __webpack_require__(4256);
const analyzer_gen_1 = __webpack_require__(1271);
const file_tracker_das_1 = __webpack_require__(9016);
class AnalyzerCapabilities {
    constructor(analyzerVersion) {
        this.version = analyzerVersion;
    }
    static get empty() { return new AnalyzerCapabilities("0.0.0"); }
    get hasCompleteStatementFix() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.2"); }
    get supportsPriorityFilesOutsideAnalysisRoots() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.2"); }
    get supportsDiagnostics() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.1"); }
    get supportsClosingLabels() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.4"); }
    get supportsCustomFolding() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.3"); }
    // 1.26.0 is stable Flutter at time of writing. Unclear what version had Outline, but
    // we don't need to support older.
    get supportsFlutterOutline() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsGetDeclerations() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.7"); }
    get supportsGetDeclerationsForFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.19.0"); }
    get supportsGetSignature() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.5"); }
    get supportsMoveFile() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.0"); }
    get supportsAvailableSuggestions() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0"); }
    get supportsIncludedImports() { return (0, utils_1.versionIsAtLeast)(this.version, "1.27.1"); }
}
exports.AnalyzerCapabilities = AnalyzerCapabilities;
class DasAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, analytics, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.statusItem = vs.languages.createLanguageStatusItem("dart.analysisServer", constants_2.ANALYSIS_FILTERS);
        this.setupStatusItem();
        this.vmServicePort = config_1.config.analyzerVmServicePort;
        this.client = new DasAnalyzerClient(this.logger, sdks, dartCapabilities, this.vmServicePort);
        this.fileTracker = new file_tracker_das_1.DasFileTracker(logger, this.client, wsContext);
        this.disposables.push(this.client);
        this.disposables.push(this.fileTracker);
        const connectedEvent = this.client.registerForServerConnected((sc) => {
            this.statusItem.detail = "Started";
            this.onReadyCompleter.resolve();
            connectedEvent.dispose();
        });
        this.client.registerForServerStatus((params) => {
            if (params.analysis) {
                this.statusItem.busy = params.analysis.isAnalyzing;
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.analysis.isAnalyzing });
            }
        });
    }
    setupStatusItem() {
        const statusItem = this.statusItem;
        statusItem.text = "Dart Analysis Server";
        statusItem.detail = "Starting…";
        statusItem.command = {
            command: "dart.restartAnalysisServer",
            title: "restart",
            tooltip: "Restarts the Dart Analysis Server",
        };
    }
    getDiagnosticServerPort() {
        return this.client.diagnosticGetServerPort();
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client.analysisReanalyze();
        });
    }
}
exports.DasAnalyzer = DasAnalyzer;
class DasAnalyzerClient extends analyzer_gen_1.AnalyzerGen {
    constructor(logger, sdks, dartCapabilities, vmServicePort) {
        var _a;
        super(logger, config_1.config.maxLogLineLength);
        this.isAnalyzing = false;
        this.capabilities = AnalyzerCapabilities.empty;
        this.resolvedPromise = Promise.resolve();
        this.serverTerminatedSubscriptions = [];
        this.launchArgs = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, false, vmServicePort);
        // Hook error subscriptions so we can try and get diagnostic info if this happens.
        this.registerForServerError((e) => this.requestDiagnosticsUpdate());
        this.registerForRequestError((e) => this.requestDiagnosticsUpdate());
        // Register for version.
        this.registerForServerConnected((e) => { this.version = e.version; this.capabilities.version = this.version; });
        const fullDartVmPath = path.join(sdks.dart, constants_1.dartVMPath);
        let binaryPath = fullDartVmPath;
        let processArgs = this.launchArgs.slice();
        // Since we communicate with the analysis server over STDOUT/STDIN, it is trivial for us
        // to support launching it on a remote machine over SSH. This can be useful if the codebase
        // is being modified remotely over SSHFS, and running the analysis server locally would
        // result in excessive file reading over SSHFS.
        if (config_1.config.analyzerSshHost) {
            binaryPath = "ssh";
            processArgs.unshift(fullDartVmPath);
            processArgs = [
                // SSH quiet mode, which prevents SSH from interfering with the STDOUT/STDIN communication
                // with the analysis server.
                "-q",
                config_1.config.analyzerSshHost,
                (0, utils_2.escapeShell)(processArgs),
            ];
        }
        this.createProcess(undefined, binaryPath, processArgs, { toolEnv: (0, processes_1.getToolEnv)() });
        (_a = this.process) === null || _a === void 0 ? void 0 : _a.on("exit", (code, signal) => {
            this.handleAnalyzerTerminated(!!code);
        });
        this.registerForServerStatus((n) => {
            if (n.analysis) {
                if (n.analysis.isAnalyzing) {
                    this.isAnalyzing = true;
                }
                else {
                    this.isAnalyzing = false;
                    if (this.currentAnalysisCompleter) {
                        this.currentAnalysisCompleter.resolve();
                        this.currentAnalysisCompleter = undefined;
                    }
                }
            }
        });
        // tslint:disable-next-line: no-floating-promises
        this.serverSetSubscriptions({
            subscriptions: ["STATUS"],
        });
    }
    get currentAnalysis() {
        if (!this.isAnalyzing)
            return this.resolvedPromise;
        if (!this.currentAnalysisCompleter)
            this.currentAnalysisCompleter = new utils_1.PromiseCompleter();
        return this.currentAnalysisCompleter.promise;
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            this.handleAnalyzerTerminated(true);
            throw e;
        }
    }
    handleAnalyzerTerminated(withError) {
        const serverHasStarted = !!this.version;
        if (withError)
            (0, misc_1.reportAnalyzerTerminatedWithError)(!serverHasStarted);
        this.notify(this.serverTerminatedSubscriptions, undefined);
    }
    shouldHandleMessage(message) {
        // This will include things like Observatory output and some analyzer logging code.
        return !message.startsWith("--- ")
            && !message.startsWith("+++ ")
            && !message.startsWith("Observatory listening on")
            && !message.startsWith("The Dart VM service is listening on")
            && !message.startsWith("Observatory server");
    }
    requestDiagnosticsUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            this.lastDiagnostics = undefined;
            if (!this.capabilities.supportsDiagnostics)
                return;
            this.lastDiagnostics = (yield this.diagnosticGetDiagnostics()).contexts;
        });
    }
    getLastDiagnostics() {
        return this.lastDiagnostics;
    }
    getAnalyzerLaunchArgs() {
        return this.launchArgs;
    }
    forceNotificationsFor(file) {
        // Send a dummy edit (https://github.com/dart-lang/sdk/issues/30238)
        const files = {};
        files[file] = {
            edits: [{ offset: 0, length: 0, replacement: "", id: "" }],
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analysisUpdateContent({ files });
    }
    // Wraps completionGetSuggestions to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    completionGetSuggestionsResults(request) {
        return this.requestWithStreamedResults(() => this.completionGetSuggestions(request), this.registerForCompletionResults);
    }
    // Wraps searchFindElementReferences to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindElementReferencesResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindElementReferences(request), this.registerForSearchResults);
    }
    // Wraps searchFindTopLevelDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindTopLevelDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindTopLevelDeclarations(request), this.registerForSearchResults);
    }
    // Wraps searchFindMemberDeclarations to return the final result automatically in the original promise
    // to avoid race conditions.
    // https://github.com/Dart-Code/Dart-Code/issues/471
    searchFindMemberDeclarationsResults(request) {
        return this.requestWithStreamedResults(() => this.searchFindMemberDeclarations(request), this.registerForSearchResults);
    }
    // We need to subscribe before we send the request to avoid races in registering
    // for results (see https://github.com/Dart-Code/Dart-Code/issues/471).
    // Since we don't have the ID yet, we'll have to buffer them for the duration
    // and check inside the buffer when we get the ID back.
    requestWithStreamedResults(sendRequest, registerForResults) {
        return new Promise((resolve, reject) => {
            const buffer = []; // Buffer to store results that come in before we're ready.
            let searchResultsID; // ID that'll be set once we get it back.
            const disposable = registerForResults.bind(this)((notification) => {
                // If we know our ID and this is it, and it's the last result, then resolve.
                if (searchResultsID && notification.id === searchResultsID && notification.isLast) {
                    disposable.dispose();
                    resolve(notification);
                }
                else if (!searchResultsID && notification.isLast) // Otherwise if we didn't know our ID and this might be what we want, stash it.
                    buffer.push(notification);
            });
            // Now we have the above handler set up, send the actual request.
            sendRequest.bind(this)().then((resp) => {
                if (!resp.id) {
                    disposable.dispose();
                    reject();
                }
                // When the ID comes back, stash it...
                searchResultsID = resp.id;
                // And also check the buffer.
                const result = buffer.find((b) => b.id === searchResultsID);
                if (result) {
                    disposable.dispose();
                    resolve(result);
                }
            }, () => reject());
        });
    }
    registerForServerTerminated(subscriber) {
        return this.subscribe(this.serverTerminatedSubscriptions, subscriber);
    }
}
exports.DasAnalyzerClient = DasAnalyzerClient;
function getSymbolKindForElementKind(logger, kind) {
    switch (kind) {
        case "CLASS":
        case "CLASS_TYPE_ALIAS":
        case "MIXIN":
            return vs.SymbolKind.Class;
        case "COMPILATION_UNIT":
        case "EXTENSION":
            return vs.SymbolKind.Module;
        case "CONSTRUCTOR":
        case "CONSTRUCTOR_INVOCATION":
            return vs.SymbolKind.Constructor;
        case "ENUM":
            return vs.SymbolKind.Enum;
        case "ENUM_CONSTANT":
            return vs.SymbolKind.EnumMember;
        case "FIELD":
            return vs.SymbolKind.Field;
        case "FILE":
            return vs.SymbolKind.File;
        case "FUNCTION":
        case "FUNCTION_INVOCATION":
        case "FUNCTION_TYPE_ALIAS":
            return vs.SymbolKind.Function;
        case "GETTER":
            return vs.SymbolKind.Property;
        case "LABEL":
            return vs.SymbolKind.Module;
        case "LIBRARY":
            return vs.SymbolKind.Namespace;
        case "LOCAL_VARIABLE":
            return vs.SymbolKind.Variable;
        case "METHOD":
            return vs.SymbolKind.Method;
        case "PARAMETER":
        case "PREFIX":
            return vs.SymbolKind.Variable;
        case "SETTER":
            return vs.SymbolKind.Property;
        case "TOP_LEVEL_VARIABLE":
        case "TYPE_PARAMETER":
            return vs.SymbolKind.Variable;
        case "UNIT_TEST_GROUP":
            return vs.SymbolKind.Module;
        case "UNIT_TEST_TEST":
            return vs.SymbolKind.Method;
        case "UNKNOWN":
            return vs.SymbolKind.Object;
        default:
            logger.error(`Unknown kind: ${kind}`, enums_1.LogCategory.Analyzer);
            return vs.SymbolKind.Object;
    }
}
exports.getSymbolKindForElementKind = getSymbolKindForElementKind;


/***/ }),

/***/ 1271:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* eslint-disable */
// This file was generated by Dart-Code-Class-Builder
// and should not be hand-edited!
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerGen = void 0;
const stdio_service_1 = __webpack_require__(3058);
class AnalyzerGen extends stdio_service_1.StdIOService {
    constructor(logger, maxLogLineLength) {
        super(logger, maxLogLineLength);
        this.serverConnectedSubscriptions = [];
        this.serverErrorSubscriptions = [];
        this.serverStatusSubscriptions = [];
        this.analysisAnalyzedFilesSubscriptions = [];
        this.analysisClosingLabelsSubscriptions = [];
        this.analysisErrorsSubscriptions = [];
        this.analysisFlushResultsSubscriptions = [];
        this.analysisFoldingSubscriptions = [];
        this.analysisHighlightsSubscriptions = [];
        this.analysisImplementedSubscriptions = [];
        this.analysisInvalidateSubscriptions = [];
        this.analysisNavigationSubscriptions = [];
        this.analysisOccurrencesSubscriptions = [];
        this.analysisOutlineSubscriptions = [];
        this.analysisOverridesSubscriptions = [];
        this.completionResultsSubscriptions = [];
        this.completionAvailableSuggestionsSubscriptions = [];
        this.completionExistingImportsSubscriptions = [];
        this.searchResultsSubscriptions = [];
        this.executionLaunchDataSubscriptions = [];
        this.flutterOutlineSubscriptions = [];
    }
    buildRequest(id, method, params) {
        return Object.assign(super.buildRequest(id, method, params), { clientRequestTime: Date.now() });
    }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "server.connected":
                    yield this.notify(this.serverConnectedSubscriptions, evt.params);
                    break;
                case "server.error":
                    yield this.notify(this.serverErrorSubscriptions, evt.params);
                    break;
                case "server.status":
                    yield this.notify(this.serverStatusSubscriptions, evt.params);
                    break;
                case "analysis.analyzedFiles":
                    yield this.notify(this.analysisAnalyzedFilesSubscriptions, evt.params);
                    break;
                case "analysis.closingLabels":
                    yield this.notify(this.analysisClosingLabelsSubscriptions, evt.params);
                    break;
                case "analysis.errors":
                    yield this.notify(this.analysisErrorsSubscriptions, evt.params);
                    break;
                case "analysis.flushResults":
                    yield this.notify(this.analysisFlushResultsSubscriptions, evt.params);
                    break;
                case "analysis.folding":
                    yield this.notify(this.analysisFoldingSubscriptions, evt.params);
                    break;
                case "analysis.highlights":
                    yield this.notify(this.analysisHighlightsSubscriptions, evt.params);
                    break;
                case "analysis.implemented":
                    yield this.notify(this.analysisImplementedSubscriptions, evt.params);
                    break;
                case "analysis.invalidate":
                    yield this.notify(this.analysisInvalidateSubscriptions, evt.params);
                    break;
                case "analysis.navigation":
                    yield this.notify(this.analysisNavigationSubscriptions, evt.params);
                    break;
                case "analysis.occurrences":
                    yield this.notify(this.analysisOccurrencesSubscriptions, evt.params);
                    break;
                case "analysis.outline":
                    yield this.notify(this.analysisOutlineSubscriptions, evt.params);
                    break;
                case "analysis.overrides":
                    yield this.notify(this.analysisOverridesSubscriptions, evt.params);
                    break;
                case "completion.results":
                    yield this.notify(this.completionResultsSubscriptions, evt.params);
                    break;
                case "completion.availableSuggestions":
                    yield this.notify(this.completionAvailableSuggestionsSubscriptions, evt.params);
                    break;
                case "completion.existingImports":
                    yield this.notify(this.completionExistingImportsSubscriptions, evt.params);
                    break;
                case "search.results":
                    yield this.notify(this.searchResultsSubscriptions, evt.params);
                    break;
                case "execution.launchData":
                    yield this.notify(this.executionLaunchDataSubscriptions, evt.params);
                    break;
                case "flutter.outline":
                    yield this.notify(this.flutterOutlineSubscriptions, evt.params);
                    break;
            }
        });
    }
    /**
    Reports that the server is running. This notification is
    issued once after the server has started running but before
    any requests are processed to let the client know that it
    started correctly.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerConnected(subscriber) {
        return this.subscribe(this.serverConnectedSubscriptions, subscriber);
    }
    /**
    Reports that an unexpected error has occurred while
    executing the server. This notification is not used for
    problems with specific requests (which are returned as part
    of the response) but is used for exceptions that occur while
    performing other tasks, such as analysis or preparing
    notifications.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForServerError(subscriber) {
        return this.subscribe(this.serverErrorSubscriptions, subscriber);
    }
    /**
    Reports the current status of the server. Parameters are
    omitted if there has been no change in the status
    represented by that parameter.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "STATUS" in
    the list of services passed in a server.setSubscriptions
    request.
    */
    registerForServerStatus(subscriber) {
        return this.subscribe(this.serverStatusSubscriptions, subscriber);
    }
    /**
    Reports the paths of the files that are being analyzed.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "ANALYZED_FILES" in the list
    of services passed in an analysis.setGeneralSubscriptions request.
    */
    registerForAnalysisAnalyzedFiles(subscriber) {
        return this.subscribe(this.analysisAnalyzedFilesSubscriptions, subscriber);
    }
    /**
    Reports closing labels relevant to a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "CLOSING_LABELS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisClosingLabels(subscriber) {
        return this.subscribe(this.analysisClosingLabelsSubscriptions, subscriber);
    }
    /**
    Reports the errors associated with a given file. The set of
    errors included in the notification is always a complete
    list that supersedes any previously reported errors.
    */
    registerForAnalysisErrors(subscriber) {
        return this.subscribe(this.analysisErrorsSubscriptions, subscriber);
    }
    /**
    Reports that any analysis results that were previously
    associated with the given files should be considered to be
    invalid because those files are no longer being analyzed,
    either because the analysis root that contained it is no
    longer being analyzed or because the file no longer exists.
    If a file is included in this notification and at some later
    time a notification with results for the file is received,
    clients should assume that the file is once again being
    analyzed and the information should be processed.
    It is not possible to subscribe to or unsubscribe from this
    notification.
    */
    registerForAnalysisFlushResults(subscriber) {
        return this.subscribe(this.analysisFlushResultsSubscriptions, subscriber);
    }
    /**
    Reports the folding regions associated with a given
    file. Folding regions can be nested, but will not be
    overlapping. Nesting occurs when a foldable element, such as
    a method, is nested inside another foldable element such as
    a class.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "FOLDING" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisFolding(subscriber) {
        return this.subscribe(this.analysisFoldingSubscriptions, subscriber);
    }
    /**
    Reports the highlight regions associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "HIGHLIGHTS"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisHighlights(subscriber) {
        return this.subscribe(this.analysisHighlightsSubscriptions, subscriber);
    }
    /**
    Reports the classes that are implemented or extended and
    class members that are implemented or overridden in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "IMPLEMENTED" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisImplemented(subscriber) {
        return this.subscribe(this.analysisImplementedSubscriptions, subscriber);
    }
    /**
    Reports that the navigation information associated with a region of a
    single file has become invalid and should be re-requested.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "INVALIDATE" in the list of
    services passed in an analysis.setSubscriptions request.
    */
    registerForAnalysisInvalidate(subscriber) {
        return this.subscribe(this.analysisInvalidateSubscriptions, subscriber);
    }
    /**
    Reports the navigation targets associated with a given file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "NAVIGATION"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisNavigation(subscriber) {
        return this.subscribe(this.analysisNavigationSubscriptions, subscriber);
    }
    /**
    Reports the occurrences of references to elements within a
    single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OCCURRENCES"
    in the list of services passed in an
    analysis.setSubscriptions request.
    */
    registerForAnalysisOccurrences(subscriber) {
        return this.subscribe(this.analysisOccurrencesSubscriptions, subscriber);
    }
    /**
    Reports the outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOutline(subscriber) {
        return this.subscribe(this.analysisOutlineSubscriptions, subscriber);
    }
    /**
    Reports the overriding members in a file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OVERRIDES" in
    the list of services passed in an analysis.setSubscriptions
    request.
    */
    registerForAnalysisOverrides(subscriber) {
        return this.subscribe(this.analysisOverridesSubscriptions, subscriber);
    }
    /**
    Reports the completion suggestions that should be presented
    to the user. The set of suggestions included in the
    notification is always a complete list that supersedes any
    previously reported suggestions.
    */
    registerForCompletionResults(subscriber) {
        return this.subscribe(this.completionResultsSubscriptions, subscriber);
    }
    /**
    Reports the pre-computed, candidate completions from symbols defined
    in a corresponding library. This notification may be sent multiple times.
    When a notification is processed, clients should replace any previous
    information about the libraries in the list of changedLibraries, discard
    any information about the libraries in the list of removedLibraries, and
    preserve any previously received information about any libraries that are
    not included in either list.
    */
    registerForCompletionAvailableSuggestions(subscriber) {
        return this.subscribe(this.completionAvailableSuggestionsSubscriptions, subscriber);
    }
    /**
    Reports existing imports in a library. This notification may be sent
    multiple times for a library. When a notification is processed, clients
    should replace any previous information for the library.
    */
    registerForCompletionExistingImports(subscriber) {
        return this.subscribe(this.completionExistingImportsSubscriptions, subscriber);
    }
    /**
    Reports some or all of the results of performing a requested
    search. Unlike other notifications, this notification
    contains search results that should be added to any
    previously received search results associated with the same
    search id.
    */
    registerForSearchResults(subscriber) {
        return this.subscribe(this.searchResultsSubscriptions, subscriber);
    }
    /**
    Reports information needed to allow a single file to be launched.
    This notification is not subscribed to by default. Clients can
    subscribe by including the value "LAUNCH_DATA" in the list of services
    passed in an execution.setSubscriptions request.
    */
    registerForExecutionLaunchData(subscriber) {
        return this.subscribe(this.executionLaunchDataSubscriptions, subscriber);
    }
    /**
    Reports the Flutter outline associated with a single file.
    This notification is not subscribed to by default. Clients
    can subscribe by including the value "OUTLINE" in
    the list of services passed in an flutter.setSubscriptions
    request.
    */
    registerForFlutterOutline(subscriber) {
        return this.subscribe(this.flutterOutlineSubscriptions, subscriber);
    }
    /**
    Return the version number of the analysis server.
    */
    serverGetVersion() {
        return this.sendRequest("server.getVersion");
    }
    /**
    Cleanly shutdown the analysis server. Requests that are
    received after this request will not be processed. Requests
    that were received before this request, but for which a
    response has not yet been sent, will not be responded to. No
    further responses or notifications will be sent after the
    response to this request has been sent.
    */
    serverShutdown() {
        return this.sendRequest("server.shutdown");
    }
    /**
    Subscribe for services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not
    valid services. If there is an error, then the current
    subscriptions will remain unchanged.
    */
    serverSetSubscriptions(request) {
        return this.sendRequest("server.setSubscriptions", request);
    }
    /**
    Return the errors associated with the given file. If the
    errors for the given file have not yet been computed, or the
    most recently computed errors for the given file are out of
    date, then the response for this request will be delayed
    until they have been computed. If some or all of the errors
    for the file cannot be computed, then the subset of the
    errors that can be computed will be returned and the
    response will contain an error to indicate why the errors
    could not be computed. If the content of the file changes after this
    request was received but before a response could be sent, then an
    error of type CONTENT_MODIFIED will be generated.
    This request is intended to be used by clients that cannot
    asynchronously apply updated error information. Clients that
    can apply error information as it becomes available
    should use the information provided by the 'analysis.errors'
    notification.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_ERRORS_INVALID_FILE will be generated.
    */
    analysisGetErrors(request) {
        return this.sendRequest("analysis.getErrors", request);
    }
    /**
    Return the hover information associate with the given
    location. If some or all of the hover information is not
    available at the time this request is processed the
    information will be omitted from the response.
    */
    analysisGetHover(request) {
        return this.sendRequest("analysis.getHover", request);
    }
    /**
    Return a description of all of the elements referenced in a given region
    of a given file that come from imported libraries.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    GET_IMPORTED_ELEMENTS_INVALID_FILE will be generated.
    */
    analysisGetImportedElements(request) {
        return this.sendRequest("analysis.getImportedElements", request);
    }
    /**
    Return library dependency information for use in client-side indexing
    and package URI resolution.
    Clients that are only using the libraries field should consider using the
    analyzedFiles notification instead.
    */
    analysisGetLibraryDependencies() {
        return this.sendRequest("analysis.getLibraryDependencies");
    }
    /**
    Return the navigation information associated with the given region of
    the given file. If the navigation information for the given file has
    not yet been computed, or the most recently computed navigation
    information for the given file is out of date, then the response for
    this request will be delayed until it has been computed. If the
    content of the file changes after this request was received but before
    a response could be sent, then an error of type
    CONTENT_MODIFIED will be generated.
    If a navigation region overlaps (but extends either before or after)
    the given region of the file it will be included in the result. This
    means that it is theoretically possible to get the same navigation
    region in response to multiple requests. Clients can avoid this by
    always choosing a region that starts at the beginning of a line and
    ends at the end of a (possibly different) line in the file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_NAVIGATION_INVALID_FILE will be generated.
    */
    analysisGetNavigation(request) {
        return this.sendRequest("analysis.getNavigation", request);
    }
    /**
    Return the transitive closure of reachable sources for a given file.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_REACHABLE_SOURCES_INVALID_FILE will be generated.
    */
    analysisGetReachableSources(request) {
        return this.sendRequest("analysis.getReachableSources", request);
    }
    /**
    Return the signature information associated with the given
    location in the given file. If the signature information
    for the given file has not yet been computed, or the most
    recently computed signature information for the given file
    is out of date, then the response for this request will be
    delayed until it has been computed.
    If a request is made for a file which does not exist, or
    which is not currently subject to analysis (e.g. because it
    is not associated with any analysis root specified to
    analysis.setAnalysisRoots), an error of type
    GET_SIGNATURE_INVALID_FILE will be generated.
    If the location given is not inside the argument list for a
    function (including method and constructor) invocation, then
    an error of type GET_SIGNATURE_INVALID_OFFSET will
    be generated. If the location is inside an argument list but
    the function is not defined or cannot be determined (such as
    a method invocation where the target has type 'dynamic')
    then an error of type GET_SIGNATURE_UNKNOWN_FUNCTION
    will be generated.
    */
    analysisGetSignature(request) {
        return this.sendRequest("analysis.getSignature", request);
    }
    /**
    Force re-reading of all potentially changed files, re-resolving of all
    referenced URIs, and corresponding re-analysis of everything affected in
    the current analysis roots.
    */
    analysisReanalyze() {
        return this.sendRequest("analysis.reanalyze");
    }
    /**
    Sets the root paths used to determine which files to analyze. The set
    of files to be analyzed are all of the files in one of the root paths
    that are not either explicitly or implicitly excluded. A file is
    explicitly excluded if it is in one of the excluded paths. A file is
    implicitly excluded if it is in a subdirectory of one of the root
    paths where the name of the subdirectory starts with a period (that
    is, a hidden directory).
    Note that this request determines the set of requested
    analysis roots. The actual set of analysis roots at any
    given time is the intersection of this set with the set of
    files and directories actually present on the
    filesystem. When the filesystem changes, the actual set of
    analysis roots is automatically updated, but the set of
    requested analysis roots is unchanged. This means that if
    the client sets an analysis root before the root becomes
    visible to server in the filesystem, there is no error; once
    the server sees the root in the filesystem it will start
    analyzing it. Similarly, server will stop analyzing files
    that are removed from the file system but they will remain
    in the set of requested roots.
    If an included path represents a file, then server will look
    in the directory containing the file for a pubspec.yaml
    file. If none is found, then the parents of the directory
    will be searched until such a file is found or the root of
    the file system is reached. If such a file is found, it will
    be used to resolve package: URI’s within the file.
    */
    analysisSetAnalysisRoots(request) {
        return this.sendRequest("analysis.setAnalysisRoots", request);
    }
    /**
    Subscribe for general services (that is, services that are not
    specific to individual files). All previous subscriptions are replaced
    by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    analysisSetGeneralSubscriptions(request) {
        return this.sendRequest("analysis.setGeneralSubscriptions", request);
    }
    /**
    Set the priority files to the files in the given list. A
    priority file is a file that is given priority when
    scheduling which analysis work to do first. The list
    typically contains those files that are visible to the user
    and those for which analysis results will have the biggest
    impact on the user experience. The order of the files within
    the list is significant: the first file will be given higher
    priority than the second, the second higher priority than
    the third, and so on.
    Note that this request determines the set of requested
    priority files. The actual set of priority files is the
    intersection of the requested set of priority files with the
    set of files currently subject to analysis. (See
    analysis.setSubscriptions for a description of files that
    are subject to analysis.)
    If a requested priority file is a directory it is ignored,
    but remains in the set of requested priority files so that
    if it later becomes a file it can be included in the set of
    actual priority files.
    */
    analysisSetPriorityFiles(request) {
        return this.sendRequest("analysis.setPriorityFiles", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    analysisSetSubscriptions(request) {
        return this.sendRequest("analysis.setSubscriptions", request);
    }
    /**
    Update the content of one or more files. Files that were
    previously updated but not included in this update remain
    unchanged. This effectively represents an overlay of the
    filesystem. The files whose content is overridden are
    therefore seen by server as being files with the given
    content, even if the files do not exist on the filesystem or
    if the file path represents the path to a directory on the
    filesystem.
    */
    analysisUpdateContent(request) {
        return this.sendRequest("analysis.updateContent", request);
    }
    /**
    Deprecated: all of the options can be set by users in
    an analysis options file.
    Update the options controlling analysis based on the given
    set of options. Any options that are not included in the
    analysis options will not be changed. If there are options
    in the analysis options that are not valid, they will be
    silently ignored.
    */
    analysisUpdateOptions(request) {
        return this.sendRequest("analysis.updateOptions", request);
    }
    /**
    Request that completion suggestions for the given offset in
    the given file be returned.
    */
    completionGetSuggestions(request) {
        return this.sendRequest("completion.getSuggestions", request);
    }
    /**
    Subscribe for completion services. All previous subscriptions are
    replaced by the given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    completionSetSubscriptions(request) {
        return this.sendRequest("completion.setSubscriptions", request);
    }
    /**
    The client can make this request to express interest in certain
    libraries to receive completion suggestions from based on the client path.
    If this request is received before the client has used
    'completion.setSubscriptions' to subscribe to the AVAILABLE_SUGGESTION_SETS
    service, then an error of type NOT_SUBSCRIBED_TO_AVAILABLE_SUGGESTION_SETS
    will be generated. All previous paths are replaced by the given set of paths.
    */
    completionRegisterLibraryPaths(request) {
        return this.sendRequest("completion.registerLibraryPaths", request);
    }
    /**
    Clients must make this request when the user has selected a completion
    suggestion from an AvailableSuggestionSet. Analysis server will respond with
    the text to insert as well as any SourceChange that needs to be applied
    in case the completion requires an additional import to be added. It is an error
    if the id is no longer valid, for instance if the library has been removed after
    the completion suggestion is accepted.
    */
    completionGetSuggestionDetails(request) {
        return this.sendRequest("completion.getSuggestionDetails", request);
    }
    /**
    Inspect analysis server's knowledge about all of a file's tokens including
    their lexeme, type, and what element kinds would have been appropriate for
    the token's program location.
    */
    completionListTokenDetails(request) {
        return this.sendRequest("completion.listTokenDetails", request);
    }
    /**
    Perform a search for references to the element defined or
    referenced at the given offset in the given file.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindElementReferences(request) {
        return this.sendRequest("search.findElementReferences", request);
    }
    /**
    Perform a search for declarations of members whose name is
    equal to the given name.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberDeclarations(request) {
        return this.sendRequest("search.findMemberDeclarations", request);
    }
    /**
    Perform a search for references to members whose name is
    equal to the given name. This search does not check to see
    that there is a member defined with the given name, so it is
    able to find references to undefined members as well.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindMemberReferences(request) {
        return this.sendRequest("search.findMemberReferences", request);
    }
    /**
    Perform a search for declarations of top-level elements
    (classes, typedefs, getters, setters, functions and fields)
    whose name matches the given pattern.
    An identifier is returned immediately, and individual
    results will be returned via the search.results notification
    as they become available.
    */
    searchFindTopLevelDeclarations(request) {
        return this.sendRequest("search.findTopLevelDeclarations", request);
    }
    /**
    Return top-level and class member declarations.
    */
    searchGetElementDeclarations(request) {
        return this.sendRequest("search.getElementDeclarations", request);
    }
    /**
    Return the type hierarchy of the class declared or
    referenced at the given location.
    */
    searchGetTypeHierarchy(request) {
        return this.sendRequest("search.getTypeHierarchy", request);
    }
    /**
    Format the contents of a single file. The currently selected region of
    text is passed in so that the selection can be preserved across the
    formatting operation. The updated selection will be as close to
    matching the original as possible, but whitespace at the beginning or
    end of the selected region will be ignored. If preserving selection
    information is not required, zero (0) can be specified for both the
    selection offset and selection length.
    If a request is made for a file which does not exist, or which is not
    currently subject to analysis (e.g. because it is not associated with
    any analysis root specified to analysis.setAnalysisRoots), an error of
    type FORMAT_INVALID_FILE will be generated. If the source
    contains syntax errors, an error of type FORMAT_WITH_ERRORS
    will be generated.
    */
    editFormat(request) {
        return this.sendRequest("edit.format", request);
    }
    /**
    Return the set of assists that are available at the given
    location. An assist is distinguished from a refactoring
    primarily by the fact that it affects a single file and does
    not require user input in order to be performed.
    */
    editGetAssists(request) {
        return this.sendRequest("edit.getAssists", request);
    }
    /**
    Get a list of the kinds of refactorings that are valid for
    the given selection in the given file.
    */
    editGetAvailableRefactorings(request) {
        return this.sendRequest("edit.getAvailableRefactorings", request);
    }
    /**
    Request information about edit.dartfix
    such as the list of known fixes that can be specified
    in an edit.dartfix request.
    */
    editGetDartfixInfo() {
        return this.sendRequest("edit.getDartfixInfo");
    }
    /**
    Analyze the specified sources for recommended changes
    and return a set of suggested edits for those sources.
    These edits may include changes to sources outside the set
    of specified sources if a change in a specified source requires it.
    If includedFixes is specified, then those fixes will be applied.
    If includeRequiredFixes is specified, then "required" fixes will be applied
    in addition to whatever fixes are specified in includedFixes if any.
    If neither includedFixes nor includeRequiredFixes is specified,
    then all fixes will be applied.
    If excludedFixes is specified, then those fixes will not be applied
    regardless of whether they are "required" or specified in includedFixes.
    */
    editDartfix(request) {
        return this.sendRequest("edit.dartfix", request);
    }
    /**
    Return the set of fixes that are available for the errors at
    a given offset in a given file.
    */
    editGetFixes(request) {
        return this.sendRequest("edit.getFixes", request);
    }
    /**
    Get the changes required to convert the postfix template at the given
    location into the template's expanded form.
    */
    editGetPostfixCompletion(request) {
        return this.sendRequest("edit.getPostfixCompletion", request);
    }
    /**
    Get the changes required to perform a refactoring.
    If another refactoring request is received during the processing
    of this one, an error of type REFACTORING_REQUEST_CANCELLED
    will be generated.
    */
    editGetRefactoring(request) {
        return this.sendRequest("edit.getRefactoring", request);
    }
    /**
    Get the changes required to convert the partial statement at the given
    location into a syntactically valid statement. If the current statement
    is already valid the change will insert a newline plus appropriate
    indentation at the end of the line containing the offset.
    If a change that makes the statement valid cannot be determined (perhaps
    because it has not yet been implemented) the statement will be considered
    already valid and the appropriate change returned.
    */
    editGetStatementCompletion(request) {
        return this.sendRequest("edit.getStatementCompletion", request);
    }
    /**
    Determine if the request postfix completion template is applicable at
    the given location in the given file.
    */
    editIsPostfixCompletionApplicable(request) {
        return this.sendRequest("edit.isPostfixCompletionApplicable", request);
    }
    /**
    Return a list of all postfix templates currently available.
    */
    editListPostfixCompletionTemplates() {
        return this.sendRequest("edit.listPostfixCompletionTemplates");
    }
    /**
    Return a list of edits that would need to be applied in order to ensure
    that all of the elements in the specified list of imported elements are
    accessible within the library.
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified via analysis.setAnalysisRoots), an error of type
    IMPORT_ELEMENTS_INVALID_FILE will be generated.
    */
    editImportElements(request) {
        return this.sendRequest("edit.importElements", request);
    }
    /**
    Sort all of the directives, unit and class members
    of the given Dart file.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    SORT_MEMBERS_INVALID_FILE will be generated.
    If the Dart file has scan or parse errors,
    SORT_MEMBERS_PARSE_ERRORS will be generated.
    */
    editSortMembers(request) {
        return this.sendRequest("edit.sortMembers", request);
    }
    /**
    Organizes all of the directives - removes unused imports and sorts
    directives of the given Dart file according to the
    Dart Style
    Guide.
    If a request is made for a file that does not exist, does not belong
    to an analysis root or is not a Dart file,
    FILE_NOT_ANALYZED will be generated.
    If directives of the Dart file cannot be organized, for example
    because it has scan or parse errors, or by other reasons,
    ORGANIZE_DIRECTIVES_ERROR will be generated. The message
    will provide details about the reason.
    */
    editOrganizeDirectives(request) {
        return this.sendRequest("edit.organizeDirectives", request);
    }
    /**
    Create an execution context for the executable file with the given
    path. The context that is created will persist until
    execution.deleteContext is used to delete it. Clients, therefore, are
    responsible for managing the lifetime of execution contexts.
    */
    executionCreateContext(request) {
        return this.sendRequest("execution.createContext", request);
    }
    /**
    Delete the execution context with the given identifier. The context id
    is no longer valid after this command. The server is allowed to re-use
    ids when they are no longer valid.
    */
    executionDeleteContext(request) {
        return this.sendRequest("execution.deleteContext", request);
    }
    /**
    Request completion suggestions for the given runtime context.
    It might take one or two requests of this type to get completion
    suggestions. The first request should have only "code", "offset",
    and "variables", but not "expressions". If there are sub-expressions that
    can have different runtime types, and are considered to be safe to
    evaluate at runtime (e.g. getters), so using their actual runtime types
    can improve completion results, the server will not include the
    "suggestions" field in the response, and instead will return the
    "expressions" field. The client will use debug API to get current runtime
    types for these sub-expressions and send another request, this time with
    "expressions". If there are no interesting sub-expressions to get
    runtime types for, or when the "expressions" field is provided by the
    client, the server will return "suggestions" in the response.
    */
    executionGetSuggestions(request) {
        return this.sendRequest("execution.getSuggestions", request);
    }
    /**
    Map a URI from the execution context to the file that it corresponds
    to, or map a file to the URI that it corresponds to in the execution
    context.
    Exactly one of the file and uri fields must be provided. If both
    fields are provided, then an error of type INVALID_PARAMETER
    will be generated. Similarly, if neither field is provided, then an
    error of type INVALID_PARAMETER will be generated.
    If the file field is provided and the value is not the path of a file
    (either the file does not exist or the path references something other
    than a file), then an error of type INVALID_PARAMETER will
    be generated.
    If the uri field is provided and the value is not a valid URI or if
    the URI references something that is not a file (either a file that
    does not exist or something other than a file), then an error of type
    INVALID_PARAMETER will be generated.
    If the contextRoot used to create the execution context does not
    exist, then an error of type INVALID_EXECUTION_CONTEXT will
    be generated.
    */
    executionMapUri(request) {
        return this.sendRequest("execution.mapUri", request);
    }
    /**
    Deprecated: the analysis server no longer fires
    LAUNCH_DATA events.
    Subscribe for services. All previous subscriptions are replaced by the
    given set of services.
    It is an error if any of the elements in the list are not valid
    services. If there is an error, then the current subscriptions will
    remain unchanged.
    */
    executionSetSubscriptions(request) {
        return this.sendRequest("execution.setSubscriptions", request);
    }
    /**
    Return server diagnostics.
    */
    diagnosticGetDiagnostics() {
        return this.sendRequest("diagnostic.getDiagnostics");
    }
    /**
    Return the port of the diagnostic web server. If the server is not running
    this call will start the server. If unable to start the diagnostic web
    server,
    this call will return an error of DEBUG_PORT_COULD_NOT_BE_OPENED.
    */
    diagnosticGetServerPort() {
        return this.sendRequest("diagnostic.getServerPort");
    }
    /**
    Query whether analytics is enabled.
    This flag controls whether the analysis server sends any analytics data to
    the cloud. If disabled, the analysis server does not send any analytics
    data, and any data sent to it by clients (from sendEvent and
    sendTiming) will be ignored.
    The value of this flag can be changed by other tools outside of the
    analysis server's process. When you query the flag, you get the value of
    the flag at a given moment. Clients should not use the value returned to
    decide whether or not to send the sendEvent and
    sendTiming requests. Those requests should be used
    unconditionally and server will determine whether or not it is appropriate
    to forward the information to the cloud at the time each request is
    received.
    */
    analyticsIsEnabled() {
        return this.sendRequest("analytics.isEnabled");
    }
    /**
    Enable or disable the sending of analytics data. Note that there are other
    ways for users to change this setting, so clients cannot assume that they
    have complete control over this setting. In particular, there is no
    guarantee that the result returned by the isEnabled request will
    match the last value set via this request.
    */
    analyticsEnable(request) {
        return this.sendRequest("analytics.enable", request);
    }
    /**
    Send information about client events.
    Ask the analysis server to include the fact that an action was performed
    in the client as part of the analytics data being sent. The data will only
    be included if the sending of analytics data is enabled at the time the
    request is processed. The action that was performed is indicated by the
    value of the action field.
    The value of the action field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendEvent(request) {
        return this.sendRequest("analytics.sendEvent", request);
    }
    /**
    Send timing information for client events (e.g. code completions).
    Ask the analysis server to include the fact that a timed event occurred as
    part of the analytics data being sent. The data will only be included if
    the sending of analytics data is enabled at the time the request is
    processed.
    The value of the event field should not include the identity of the
    client. The analytics data sent by server will include the client id
    passed in using the --client-id command-line argument. The
    request will be ignored if the client id was not provided when server was
    started.
    */
    analyticsSendTiming(request) {
        return this.sendRequest("analytics.sendTiming", request);
    }
    /**
    Return the list of KytheEntry objects for some file, given the
    current state of the file system populated by "analysis.updateContent".
    If a request is made for a file that does not exist, or that is not
    currently subject to analysis (e.g. because it is not associated with any
    analysis root specified to analysis.setAnalysisRoots), an error of type
    GET_KYTHE_ENTRIES_INVALID_FILE will be generated.
    */
    kytheGetKytheEntries(request) {
        return this.sendRequest("kythe.getKytheEntries", request);
    }
    /**
    Subscribe for services that are specific to individual files.
    All previous subscriptions are replaced by the current set of
    subscriptions. If a given service is not included as a key in the map
    then no files will be subscribed to the service, exactly as if the
    service had been included in the map with an explicit empty list of
    files.
    Note that this request determines the set of requested
    subscriptions. The actual set of subscriptions at any given
    time is the intersection of this set with the set of files
    currently subject to analysis. The files currently subject
    to analysis are the set of files contained within an actual
    analysis root but not excluded, plus all of the files
    transitively reachable from those files via import, export
    and part directives. (See analysis.setAnalysisRoots for an
    explanation of how the actual analysis roots are
    determined.) When the actual analysis roots change, the
    actual set of subscriptions is automatically updated, but
    the set of requested subscriptions is unchanged.
    If a requested subscription is a directory it is ignored,
    but remains in the set of requested subscriptions so that if
    it later becomes a file it can be included in the set of
    actual subscriptions.
    It is an error if any of the keys in the map are not valid
    services. If there is an error, then the existing
    subscriptions will remain unchanged.
    */
    flutterSetSubscriptions(request) {
        return this.sendRequest("flutter.setSubscriptions", request);
    }
}
exports.AnalyzerGen = AnalyzerGen;


/***/ }),

/***/ 9165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzer = void 0;
const path = __webpack_require__(1017);
const stream = __webpack_require__(2781);
const vs = __webpack_require__(9496);
const ls = __webpack_require__(2850);
const node_1 = __webpack_require__(2847);
const custom_protocol_1 = __webpack_require__(556);
const analyzer_1 = __webpack_require__(458);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const constants_2 = __webpack_require__(6249);
const extension_utils_1 = __webpack_require__(6143);
const interactive_refactors_1 = __webpack_require__(8789);
const config_1 = __webpack_require__(4165);
const ignore_lint_code_action_provider_1 = __webpack_require__(2862);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
const analyzer_2 = __webpack_require__(4256);
const analyzer_lsp_snippet_text_edits_1 = __webpack_require__(9925);
const file_tracker_lsp_1 = __webpack_require__(4002);
class LspAnalyzer extends analyzer_1.Analyzer {
    constructor(logger, sdks, dartCapabilities, wsContext) {
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.Analyzer));
        this.dartCapabilities = dartCapabilities;
        this.statusItem = vs.languages.createLanguageStatusItem("dart.analysisServer", constants_2.ANALYSIS_FILTERS);
        this.onDocumentColorsRequestedCompleter = new utils_1.PromiseCompleter();
        this.onDocumentColorsRequested = this.onDocumentColorsRequestedCompleter.promise;
        this.setupStatusItem();
        this.vmServicePort = config_1.config.analyzerVmServicePort;
        this.snippetTextEdits = new analyzer_lsp_snippet_text_edits_1.SnippetTextEditFeature(dartCapabilities);
        this.refactors = new interactive_refactors_1.InteractiveRefactors(logger, dartCapabilities);
        this.client = createClient(this.logger, sdks, dartCapabilities, wsContext, this.buildMiddleware(), this.vmServicePort);
        this.fileTracker = new file_tracker_lsp_1.LspFileTracker(logger, this.client, wsContext);
        this.client.registerFeature(this.snippetTextEdits.feature);
        this.client.registerFeature(this.refactors.feature);
        this.disposables.push({ dispose: () => this.client.stop() });
        this.disposables.push(this.fileTracker);
        this.disposables.push(this.snippetTextEdits);
        this.disposables.push(this.refactors);
        this.disposables.push(this.statusItem);
        // tslint:disable-next-line: no-floating-promises
        this.client.start().then(() => {
            this.statusItem.detail = "Started";
            // Reminder: These onNotification calls only hold ONE handler!
            // https://github.com/microsoft/vscode-languageserver-node/issues/174
            // TODO: Remove this once Dart/Flutter stable LSP servers are using $/progress.
            this.client.onNotification(custom_protocol_1.AnalyzerStatusNotification.type, (params) => {
                this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: params.isAnalyzing });
            });
            this.onReadyCompleter.resolve();
        });
    }
    setupStatusItem() {
        const statusItem = this.statusItem;
        statusItem.text = "Dart Language Server";
        statusItem.detail = "Starting…";
        statusItem.command = {
            command: "dart.restartAnalysisServer",
            title: "restart",
            tooltip: "Restarts the Dart Language Server",
        };
    }
    buildMiddleware() {
        // Why need this 🤷‍♂️?
        function isLanguageValuePair(input) {
            return "language" in input && typeof input.language === "string" && "value" in input && typeof input.value === "string";
        }
        function cleanDocString(input) {
            if (input instanceof vs.MarkdownString)
                return (0, extension_utils_1.createMarkdownString)((0, extension_utils_1.cleanDartdoc)(input.value));
            else if (typeof input === "string")
                return (0, extension_utils_1.cleanDartdoc)(input);
            else if (isLanguageValuePair(input))
                return { language: input.language, value: (0, extension_utils_1.cleanDartdoc)(input.value) };
            else
                return input;
        }
        /// Whether or not to trigger completion again when completing on this item. This is used
        /// for convenience, eg. when completing the "import '';" snippet people expect completion
        /// to immediately reopen.
        function shouldTriggerCompletionAgain(item) {
            const label = typeof item.label === "string" ? item.label : item.label.label;
            if (label === "import '';")
                return true;
            // When completing on named args, re-trigger for the value.
            if (label.trimRight().endsWith(":"))
                return true;
            if (item.kind === vs.CompletionItemKind.Folder) {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                return label.endsWith("/");
            }
            return false;
        }
        const signatureHelpValidPattern = new RegExp("\\(\\${?[01]");
        /// Whether or not to trigger signature help on this item. This is used because if a user doesn't
        /// type the ( manually (but it's inserted as part of the completion) then the parameter hints do
        /// not show up.
        function shouldTriggerSignatureHelp(item) {
            let insertText;
            if (item.insertText) {
                if (typeof item.insertText === "string")
                    insertText = item.insertText;
                else
                    insertText = item.insertText.value;
            }
            else {
                const label = typeof item.label === "string" ? item.label : item.label.label;
                insertText = label;
            }
            if (insertText && signatureHelpValidPattern.test(insertText))
                return true;
            return false;
        }
        const refactors = this.refactors;
        const snippetTextEdits = this.snippetTextEdits;
        const ignoreActionProvider = new ignore_lint_code_action_provider_1.IgnoreLintCodeActionProvider(constants_2.DART_MODE);
        const startTimer = (message) => {
            const startTime = process.hrtime();
            return {
                end: (endMessage) => {
                    const timeTaken = process.hrtime(startTime);
                    const timeTakenMs = Math.round(timeTaken[0] * 1000 + timeTaken[1] / 1000000);
                    this.logger.info(`[ ${timeTakenMs} ms ] ${message} ${endMessage}`.trim(), enums_1.LogCategory.AnalyzerTiming);
                },
            };
        };
        return {
            handleWorkDoneProgress: (token, params, next) => {
                // TODO: Handle nested/overlapped progresses.
                if (params.kind === "begin") {
                    this.statusItem.busy = true;
                    this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: true, suppressProgress: true });
                }
                else if (params.kind === "end") {
                    this.statusItem.busy = false;
                    this.onAnalysisStatusChangeEmitter.fire({ isAnalyzing: false, suppressProgress: true });
                }
                next(token, params);
            },
            provideCompletionItem: (document, position, context, token, next) => __awaiter(this, void 0, void 0, function* () {
                var _a;
                const range = document.getWordRangeAtPosition(position);
                const prefix = range ? document.getText(range) : undefined;
                const timer = startTimer(`Completion: ${prefix !== null && prefix !== void 0 ? prefix : ""}`);
                const results = yield next(document, position, context, token);
                let items;
                let isIncomplete = false;
                // Handle either a CompletionItem[] or CompletionList.
                if (!results) {
                    items = [];
                }
                else if ("isIncomplete" in results) {
                    items = results.items;
                    isIncomplete = (_a = results.isIncomplete) !== null && _a !== void 0 ? _a : false;
                }
                else {
                    items = results;
                }
                timer.end(`${items.length} results ${isIncomplete ? "(incomplete)" : ""} ${token.isCancellationRequested ? "(cancelled)" : ""}`);
                if (!items.length)
                    return;
                const parameterHintsEnabled = !!vs.workspace.getConfiguration("editor").get("parameterHints.enabled");
                for (const item of items) {
                    if (shouldTriggerCompletionAgain(item)) {
                        item.command = {
                            command: "editor.action.triggerSuggest",
                            title: "Suggest",
                        };
                    }
                    else if (parameterHintsEnabled && shouldTriggerSignatureHelp(item)) {
                        item.command = {
                            command: "editor.action.triggerParameterHints",
                            title: "Suggest",
                        };
                    }
                }
                return results;
            }),
            resolveCompletionItem: (item, token, next) => {
                if (item.documentation)
                    item.documentation = cleanDocString(item.documentation);
                return next(item, token);
            },
            provideHover: (document, position, token, next) => __awaiter(this, void 0, void 0, function* () {
                const item = yield next(document, position, token);
                if (item === null || item === void 0 ? void 0 : item.contents)
                    item.contents = item.contents.map((s) => cleanDocString(s));
                return item;
            }),
            provideDocumentColors: (document, token, next) => {
                this.onDocumentColorsRequestedCompleter.resolve();
                return next(document, token);
            },
            provideCodeActions(document, range, context, token, next) {
                return __awaiter(this, void 0, void 0, function* () {
                    const documentVersion = document.version;
                    let res = (yield next(document, range, context, token)) || [];
                    snippetTextEdits.rewriteSnippetTextEditsToCommands(documentVersion, res);
                    refactors.rewriteCommands(res);
                    const hasExistingIgnoreActions = res.find((r) => r.title.startsWith("Ignore "));
                    if (!hasExistingIgnoreActions) {
                        const ignoreActions = ignoreActionProvider.provideCodeActions(document, range, context, token);
                        if (ignoreActions)
                            res = res.concat(ignoreActions);
                    }
                    return res;
                });
            },
            executeCommand: (command, args, next) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                if (command === "refactor.perform") {
                    // Handle both the old way (6 args as a list) and the new way (a single arg that's a map).
                    const mapArgsIndex = 0;
                    const listArgsKindIndex = 0;
                    const listArgsOptionsIndex = 5;
                    const isValidListArgs = args.length === 6;
                    const isValidMapsArgs = args.length === 1 && ((_b = args[mapArgsIndex]) === null || _b === void 0 ? void 0 : _b.path) !== undefined;
                    if (args && (isValidListArgs || isValidMapsArgs)) {
                        const refactorFailedErrorCode = -32011;
                        const mapArgs = args[mapArgsIndex];
                        const refactorKind = isValidListArgs ? args[listArgsKindIndex] : mapArgs.kind;
                        // Intercept EXTRACT_METHOD and EXTRACT_WIDGET to prompt the user for a name, but first call the validation
                        // so we don't ask for a name if it will fail for a reason like a closure with an argument.
                        const willPrompt = refactorKind === "EXTRACT_METHOD" || refactorKind === "EXTRACT_WIDGET";
                        if (willPrompt) {
                            if (this.dartCapabilities.supportsRefactorValidate) {
                                try {
                                    const validateResult = yield next("refactor.validate", args);
                                    if (validateResult.valid === false) {
                                        vs.window.showErrorMessage(validateResult.message);
                                        return;
                                    }
                                }
                                catch (e) {
                                    // If an error occurs, we'll just continue as if validation passed.
                                    this.logger.error(e);
                                }
                            }
                            let name;
                            switch (refactorKind) {
                                case "EXTRACT_METHOD":
                                    name = yield vs.window.showInputBox({
                                        prompt: "Enter a name for the method",
                                        validateInput: (s) => constants_1.validMethodNameRegex.test(s) ? undefined : "Enter a valid method name",
                                        value: "newMethod",
                                    });
                                    if (!name)
                                        return;
                                    break;
                                case "EXTRACT_WIDGET":
                                    name = yield vs.window.showInputBox({
                                        prompt: "Enter a name for the widget",
                                        validateInput: (s) => constants_1.validClassNameRegex.test(s) ? undefined : "Enter a valid widget name",
                                        value: "NewWidget",
                                    });
                                    if (!name)
                                        return;
                                    break;
                            }
                            if (name) {
                                if (isValidListArgs)
                                    args[listArgsOptionsIndex] = Object.assign({}, args[listArgsOptionsIndex], { name });
                                else
                                    args[0].options = Object.assign({}, args[0].options, { name });
                            }
                        }
                        // The server may return errors for things like invalid names, so
                        // capture the errors and present the error better if it's a refactor
                        // error.
                        try {
                            return yield next(command, args);
                        }
                        catch (e) {
                            if ((e === null || e === void 0 ? void 0 : e.code) === refactorFailedErrorCode) {
                                vs.window.showErrorMessage(e.message);
                                return;
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                }
                return next(command, args);
            }),
            workspace: {
                configuration: (params, token, next) => __awaiter(this, void 0, void 0, function* () {
                    const results = yield next(params, token);
                    if (Array.isArray(results)) {
                        for (const result of results) {
                            // Replace any instance of enableSnippets with the value of enableServerSnippets.
                            result.enableSnippets = config_1.config.enableServerSnippets && this.dartCapabilities.supportsServerSnippets;
                            // Flatten showTodos to a boolean if array not supported.
                            if (Array.isArray(result.showTodos) && !this.dartCapabilities.supportsShowTodoArray) {
                                result.showTodos = result.showTodos.length !== 0;
                            }
                        }
                    }
                    return results;
                }),
            },
        };
    }
    getDiagnosticServerPort() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.DiagnosticServerRequest.type);
        });
    }
    forceReanalyze() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.client.sendRequest(custom_protocol_1.ReanalyzeRequest.type);
            }
            catch (e) {
                vs.window.showErrorMessage("Reanalyze is not supported by this version of the Dart SDK's LSP server.");
            }
        });
    }
    getSuper(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.SuperRequest.type, params);
        });
    }
    completeStatement(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.sendRequest(custom_protocol_1.CompleteStatementRequest.type, params);
        });
    }
}
exports.LspAnalyzer = LspAnalyzer;
function createClient(logger, sdks, dartCapabilities, wsContext, middleware, vmServicePort) {
    const clientOptions = {
        initializationOptions: {
            closingLabels: config_1.config.closingLabels,
            flutterOutline: wsContext.hasAnyFlutterProjects,
            onlyAnalyzeProjectsWithOpenFiles: config_1.config.onlyAnalyzeProjectsWithOpenFiles,
            outline: true,
            suggestFromUnimportedLibraries: config_1.config.autoImportCompletions,
        },
        markdown: {
            supportHtml: true,
        },
        middleware,
        outputChannelName: "LSP",
        revealOutputChannelOn: ls.RevealOutputChannelOn.Never,
        uriConverters: {
            code2Protocol: (uri) => vs.Uri.file((0, fs_1.fsPath)(uri, { useRealCasing: !!config_1.config.normalizeFileCasing })).toString(),
            protocol2Code: (file) => vs.Uri.parse(file),
        },
    };
    const client = new node_1.LanguageClient("dartAnalysisLSP", "Dart Analysis Server", () => __awaiter(this, void 0, void 0, function* () {
        const streamInfo = yield spawnServer(logger, sdks, dartCapabilities, vmServicePort);
        const jsonEncoder = ls.RAL().applicationJson.encoder;
        return {
            detached: streamInfo.detached,
            reader: new node_1.StreamMessageReader(streamInfo.reader),
            writer: new node_1.StreamMessageWriter(streamInfo.writer, {
                contentTypeEncoder: {
                    encode: (msg, options) => {
                        msg.clientRequestTime = Date.now();
                        return jsonEncoder.encode(msg, options);
                    },
                    name: "withTiming",
                },
            }),
        };
    }), clientOptions);
    // HACK: Override the asCodeActionResult result to use our own custom asWorkspaceEdit so we can carry
    //       insertTextFormat from the protocol through to the middleware to handle snippets.
    //       This can be removed when we have a better way to do this.
    //       https://github.com/microsoft/vscode-languageserver-node/issues/1000
    const p2c = client._p2c; // eslint-disable-line no-underscore-dangle
    const originalAsWorkspaceEdit = p2c.asWorkspaceEdit; // eslint-disable-line @typescript-eslint/ban-types
    const originalAsCodeAction = p2c.asCodeAction; // eslint-disable-line @typescript-eslint/ban-types
    function asWorkspaceEdit(item, token) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const result = (yield originalAsWorkspaceEdit(item, token));
            if (!result)
                return;
            const snippetTypes = new Set();
            // Figure out which are Snippets.
            for (const change of (_a = item === null || item === void 0 ? void 0 : item.documentChanges) !== null && _a !== void 0 ? _a : []) {
                if (ls.TextDocumentEdit.is(change)) {
                    const uri = vs.Uri.parse(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (edit.insertTextFormat === ls.InsertTextFormat.Snippet) {
                            snippetTypes.add(`${(0, fs_1.fsPath)(uri)}:${edit.newText}:${edit.range.start.line}:${edit.range.start.character}`);
                        }
                    }
                }
            }
            for (const uriString of Object.keys((_b = item === null || item === void 0 ? void 0 : item.changes) !== null && _b !== void 0 ? _b : {})) {
                const uri = vs.Uri.parse(uriString);
                for (const edit of item.changes[uriString]) {
                    if (edit.insertTextFormat === ls.InsertTextFormat.Snippet) {
                        snippetTypes.add(`${(0, fs_1.fsPath)(uri)}:${edit.newText}:${edit.range.start.line}:${edit.range.start.character}`);
                    }
                }
            }
            if (snippetTypes.size > 0) {
                for (const changeset of result.entries()) {
                    const uri = changeset[0];
                    const changes = changeset[1];
                    for (const change of changes) {
                        if (snippetTypes.has(`${(0, fs_1.fsPath)(uri)}:${change.newText}:${change.range.start.line}:${change.range.start.character}`)) {
                            change.insertTextFormat = ls.InsertTextFormat.Snippet;
                        }
                    }
                }
            }
            return result;
        });
    }
    function asCodeAction(item, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = (yield originalAsCodeAction(item, token));
            if ((item === null || item === void 0 ? void 0 : item.edit) !== undefined) {
                result.edit = yield asWorkspaceEdit(item.edit, token);
            }
            return result;
        });
    }
    function asCodeActionResult(items, token) {
        return Promise.all(items.map((item) => __awaiter(this, void 0, void 0, function* () {
            if (ls.Command.is(item)) {
                return p2c.asCommand(item);
            }
            else {
                return asCodeAction(item, token);
            }
        })));
    }
    p2c.asWorkspaceEdit = asWorkspaceEdit;
    p2c.asCodeAction = asCodeAction;
    p2c.asCodeActionResult = asCodeActionResult;
    return client;
}
function spawnServer(logger, sdks, dartCapabilities, vmServicePort) {
    // TODO: Replace with constructing an Analyzer that passes LSP flag (but still reads config
    // from paths etc) and provide it's process.
    const vmPath = path.join(sdks.dart, constants_1.dartVMPath);
    const args = (0, analyzer_2.getAnalyzerArgs)(logger, sdks, dartCapabilities, true, vmServicePort);
    logger.info(`Spawning ${vmPath} with args ${JSON.stringify(args)}`);
    const process = (0, processes_1.safeToolSpawn)(undefined, vmPath, args);
    logger.info(`    PID: ${process.pid}`);
    const reader = process.stdout.pipe(new LoggingTransform(logger, "<=="));
    const writer = new LoggingTransform(logger, "==>");
    writer.pipe(process.stdin);
    process.stderr.on("data", (data) => logger.error(data.toString()));
    process.on("exit", (code, signal) => {
        if (code)
            (0, misc_1.reportAnalyzerTerminatedWithError)();
    });
    return Promise.resolve({ reader, writer });
}
class LoggingTransform extends stream.Transform {
    constructor(logger, prefix, opts) {
        super(opts);
        this.logger = logger;
        this.prefix = prefix;
    }
    _transform(chunk, encoding, callback) {
        this.logger.info(`${this.prefix} ${chunk}`);
        this.push(chunk, encoding);
        callback();
    }
}


/***/ }),

/***/ 9925:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetTextEditFeature = void 0;
const vs = __webpack_require__(9496);
const ls = __webpack_require__(2850);
const utils_1 = __webpack_require__(4586);
const config_1 = __webpack_require__(4165);
class SnippetTextEditFeature {
    constructor(dartCapabilities) {
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("_dart.applySnippetTextEdit", this.applySnippetTextEdit, this));
    }
    get feature() {
        const supportsSnippetTextEdits = this.dartCapabilities.supportsSnippetTextEdits;
        const snippetTextEditsEnabled = config_1.config.lspSnippetTextEdits;
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                var _a;
                capabilities.experimental = (_a = capabilities.experimental) !== null && _a !== void 0 ? _a : {};
                if (supportsSnippetTextEdits && snippetTextEditsEnabled) {
                    capabilities.experimental.snippetTextEdit = true;
                }
            },
            getState() {
                return { kind: "static" };
            },
            initialize() { },
        };
    }
    rewriteSnippetTextEditsToCommands(documentVersion, res) {
        if (!res)
            return;
        for (const action of res) {
            if ("edit" in action) {
                const edit = action.edit;
                if (edit) {
                    const entries = edit.entries();
                    if (entries.length === 1 && entries[0][1].length === 1) {
                        const uri = entries[0][0];
                        const textEdit = entries[0][1][0];
                        // HACK: Check the injected insertTextFormat added in the asWorkspaceEdit overrides.
                        const hasSnippet = textEdit.insertTextFormat === ls.InsertTextFormat.Snippet;
                        // HACK: Work around the server producing 0th choice tabstops that are not valid until a
                        // server fix lands.
                        // https://github.com/Dart-Code/Dart-Code/issues/3996
                        if (hasSnippet
                            // Has a 0th choice snippet.
                            && textEdit.newText.includes("${0|")
                            && textEdit.newText.includes("|}")
                            // Does not have a 1st snippet.
                            && !textEdit.newText.includes("${1")
                            && !textEdit.newText.includes("$1")) {
                            // "Upgrade" choice from tabstop 0 to tabstop 1.
                            textEdit.newText = textEdit.newText.replace("${0|", "${1|");
                        }
                        if (hasSnippet) {
                            action.edit = undefined;
                            action.command = {
                                arguments: [documentVersion, uri, textEdit],
                                command: "_dart.applySnippetTextEdit",
                                title: "Apply edit",
                            };
                        }
                    }
                }
            }
        }
    }
    applySnippetTextEdit(documentVersion, uri, edit) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(uri);
            const editor = yield vs.window.showTextDocument(doc);
            if (doc.version !== documentVersion)
                vs.window.showErrorMessage(`Unable to apply snippet, document was modified`);
            const leadingIndentCharacters = doc.lineAt(edit.range.start.line).firstNonWhitespaceCharacterIndex;
            const newText = this.compensateForVsCodeIndenting(edit.newText, leadingIndentCharacters);
            const snippet = new vs.SnippetString(newText);
            yield editor.insertSnippet(snippet, edit.range);
        });
    }
    compensateForVsCodeIndenting(newText, leadingIndentCharacters) {
        const indent = " ".repeat(leadingIndentCharacters);
        const indentPattern = new RegExp(`\n${indent}`, "g");
        return newText.replace(indentPattern, "\n");
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.SnippetTextEditFeature = SnippetTextEditFeature;


/***/ }),

/***/ 2975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(9496);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
const maxErrorReportCount = 3;
const sendFakeErrorAtStartup = false;
let errorCount = 0;
class AnalyzerStatusReporter {
    constructor(logger, analyzer, workspaceContext, analytics) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.workspaceContext = workspaceContext;
        this.analytics = analytics;
        this.analysisInProgress = false;
        // TODO: Should these go in disposables?
        // If so, do we need to worry about server cleaning them up if it disposes first?
        analyzer.registerForServerStatus((n) => this.handleServerStatus(n));
        analyzer.registerForServerError((e) => this.handleServerError(e));
        analyzer.registerForRequestError((e) => this.handleRequestError(e));
        analyzer.registerForServerTerminated(() => this.handleServerTerminated());
        if (sendFakeErrorAtStartup) {
            setTimeout(() => {
                this.handleServerError({
                    isFatal: false,
                    message: "This is a fake error for testing the error reporting!",
                    stackTrace: new Error().stack || "",
                }, "testError");
            }, 5000);
        }
    }
    handleServerStatus(status) {
        if (!status.analysis)
            return;
        this.analysisInProgress = status.analysis.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 500);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
    handleServerTerminated() {
        this.analysisInProgress = false;
        if (this.analyzingPromise) {
            this.analyzingPromise.resolve();
            this.analyzingPromise = undefined;
        }
    }
    handleRequestError(error) {
        // Map this request error to a server error to reuse the shared code.
        this.handleServerError({
            isFatal: false,
            message: error.message,
            stackTrace: error.stackTrace || "",
        }, error.method);
    }
    handleServerError(error, method) {
        // Always log to the console.
        this.logger.error(error.message, enums_1.LogCategory.Analyzer);
        if (error.stackTrace)
            this.logger.error(error.stackTrace, enums_1.LogCategory.Analyzer);
        this.analytics.logError(`Analyzer server error${method ? ` (${method})` : ""}`, error.isFatal);
        errorCount++;
        // Offer to report the error.
        if (config_1.config.notifyAnalyzerErrors && errorCount <= maxErrorReportCount) {
            const showLog = "Show log";
            vscode_1.window.showErrorMessage(`Exception from the Dart analysis server: ${error.message}`, showLog).then((res) => {
                if (res === showLog)
                    this.showErrorLog(error, method);
            });
        }
    }
    showErrorLog(error, method) {
        const sdkVersion = this.workspaceContext.sdks.dartVersion;
        const flutterSdkVersion = this.workspaceContext.sdks.flutterVersion;
        const analyzerArgs = this.analyzer.getAnalyzerLaunchArgs();
        const data = `
${method ? "### Request\n\nServer was responding to request: `" + method + "`\n" : ""}
### Versions

- ${vscode_1.env.appName} v${vscode_1.version}
- Dart Code v${extension_utils_1.extensionVersion}
- ${flutterSdkVersion ? `Flutter SDK v${flutterSdkVersion}` : `Dart SDK v${sdkVersion}`}

### Analyzer Info

The analyzer was launched using the arguments:

${analyzerArgs.map((a) => `- ${a}`).join("\n")}

### Exception${error.isFatal ? " (fatal)" : ""}

${error.message}

${error.stackTrace.trim()}
`;
        (0, utils_2.openLogContents)("md", data);
    }
}
exports.AnalyzerStatusReporter = AnalyzerStatusReporter;


/***/ }),

/***/ 7246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeHandler = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const util = __webpack_require__(8779);
class FileChangeHandler {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidOpenTextDocument((td) => this.onDidOpenTextDocument(td)), vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)), vs.workspace.onDidCloseTextDocument((td) => this.onDidCloseTextDocument(td)));
        // Handle already-open files.
        vs.workspace.textDocuments.forEach((td) => this.onDidOpenTextDocument(td));
    }
    onDidOpenTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            content: document.getText(),
            type: "add",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidChangeTextDocument(e) {
        if (!util.isAnalyzable(e.document))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const files = {};
        files[(0, fs_1.fsPath)(e.document.uri)] = {
            edits: e.contentChanges.map((c) => this.convertChange(e.document, c)),
            type: "change",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    onDidCloseTextDocument(document) {
        if (!util.isAnalyzable(document))
            return;
        const files = {};
        files[(0, fs_1.fsPath)(document.uri)] = {
            type: "remove",
        };
        // tslint:disable-next-line: no-floating-promises
        this.analyzer.analysisUpdateContent({ files });
    }
    convertChange(document, change) {
        return {
            id: "",
            length: change.rangeLength,
            offset: change.rangeOffset,
            replacement: change.text,
        };
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeHandler = FileChangeHandler;


/***/ }),

/***/ 4775:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileChangeWarnings = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const util = __webpack_require__(8779);
class FileChangeWarnings {
    constructor() {
        this.disposables = [];
        this.filesWarnedAbout = new Set();
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.onDidChangeTextDocument(e)));
    }
    onDidChangeTextDocument(e) {
        if (!util.isDartFile((0, fs_1.fsPath)(e.document.uri)))
            return;
        if (e.contentChanges.length === 0) // This event fires for metadata changes (dirty?) so don't need to notify AS then.
            return;
        const filePath = (0, fs_1.fsPath)(e.document.uri);
        if (vs.workspace.workspaceFolders
            && vs.workspace.workspaceFolders.length // Only prompt if we actually have workspace folders open
            && !util.isWithinWorkspace(filePath)
            && !this.filesWarnedAbout.has(filePath)) {
            const isInPubCache = filePath.indexOf(`${path.sep}hosted${path.sep}pub.dartlang.org${path.sep}`) !== -1;
            const shouldWarn = isInPubCache
                ? config_1.config.warnWhenEditingFilesInPubCache
                : config_1.config.warnWhenEditingFilesOutsideWorkspace;
            const promptText = isInPubCache
                ? "You are modifying a file in the Pub cache!"
                : "You are modifying a file outside of your open folders";
            const dontShowAgainSetter = isInPubCache
                ? () => config_1.config.setWarnWhenEditingFilesInPubCache(false)
                : () => config_1.config.setWarnWhenEditingFilesOutsideWorkspace(false);
            const dontShowAgainAction = "Don't Warn Me";
            if (shouldWarn) {
                vs.window.showWarningMessage(promptText, constants_1.moreInfoAction, dontShowAgainAction)
                    .then((action) => __awaiter(this, void 0, void 0, function* () {
                    if (action === constants_1.moreInfoAction) {
                        yield utils_2.envUtils.openInBrowser(constants_1.modifyingFilesOutsideWorkspaceInfoUrl);
                    }
                    else if (action === dontShowAgainAction)
                        dontShowAgainSetter();
                }));
                this.filesWarnedAbout.add(filePath);
            }
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FileChangeWarnings = FileChangeWarnings;


/***/ }),

/***/ 9016:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DasFileTracker = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const project_1 = __webpack_require__(3886);
const util = __webpack_require__(8779);
class DasFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.navigations = {};
        this.outlines = {};
        this.flutterOutlines = {};
        this.occurrences = {};
        this.folding = {};
        this.pubRunTestSupport = {};
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        // Reset these, since they're state from the last analysis server
        // (when we change SDK and thus change this).
        this.lastPriorityFiles = [];
        this.lastSubscribedFiles = [];
        this.disposables.push(vscode_1.workspace.onDidOpenTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.workspace.onDidCloseTextDocument((td) => __awaiter(this, void 0, void 0, function* () {
            const path = (0, fs_1.fsPath)(td.uri);
            delete this.navigations[path];
            delete this.outlines[path];
            delete this.flutterOutlines[path];
            delete this.occurrences[path];
            delete this.folding[path];
            delete this.pubRunTestSupport[path];
            yield this.updateSubscriptions();
        })));
        this.disposables.push(vscode_1.window.onDidChangeVisibleTextEditors((e) => this.updatePriorityFiles()));
        this.disposables.push(this.analyzer.registerForAnalysisNavigation((n) => this.navigations[n.file] = n));
        this.disposables.push(this.analyzer.registerForAnalysisOutline((o) => this.outlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForFlutterOutline((o) => this.flutterOutlines[o.file] = o.outline));
        this.disposables.push(this.analyzer.registerForAnalysisOccurrences((o) => this.occurrences[o.file] = o.occurrences));
        this.disposables.push(this.analyzer.registerForAnalysisFolding((f) => this.folding[f.file] = f.regions));
        // It's possible that after the server gives us the version, we may send different subscriptions (eg.
        // based on capabilities, like supporting priority files outside of the workspace root) so we may need
        // to send again.
        this.disposables.push(this.analyzer.registerForServerConnected((s) => this.updateSubscriptions(true)));
        // Handle already-open files.
        // tslint:disable-next-line: no-floating-promises
        this.updatePriorityFiles();
        // tslint:disable-next-line: no-floating-promises
        this.updateSubscriptions();
        this.watchPubspec();
    }
    updatePriorityFiles() {
        return __awaiter(this, void 0, void 0, function* () {
            const visibleFiles = this.validPathsFor(vscode_1.window.visibleTextEditors.map((editor) => editor.document));
            if (!this.pathsHaveChanged(this.lastPriorityFiles, visibleFiles))
                return;
            // Keep track of files to compare next time.
            this.lastPriorityFiles = visibleFiles;
            // Set priority files.
            try {
                yield this.analyzer.analysisSetPriorityFiles({ files: visibleFiles });
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    updateSubscriptions(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const openFiles = this.validPathsFor(vscode_1.workspace.textDocuments);
            if (!force && !this.pathsHaveChanged(this.lastSubscribedFiles, openFiles))
                return;
            // Keep track of files to compare next time.
            this.lastSubscribedFiles = openFiles;
            // Set subscriptions.
            try {
                yield this.analyzer.analysisSetSubscriptions({
                    subscriptions: {
                        CLOSING_LABELS: this.analyzer.capabilities.supportsClosingLabels ? openFiles : undefined,
                        // TODO(dantup): Why are we checking this here? This class is DAS-specific?
                        FOLDING: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                        NAVIGATION: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                        OCCURRENCES: this.wsContext.config.useLegacyProtocol ? openFiles : undefined,
                        OUTLINE: openFiles,
                    },
                });
            }
            catch (e) {
                this.logger.error(e);
            }
            // Set subscriptions.
            if (this.wsContext.hasAnyFlutterProjects && this.analyzer.capabilities.supportsFlutterOutline) {
                try {
                    yield this.analyzer.flutterSetSubscriptions({
                        subscriptions: {
                            OUTLINE: openFiles,
                        },
                    });
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
        });
    }
    pathsHaveChanged(last, current) {
        return last.length !== current.length
            || last.some((f, i) => f !== current[i]);
    }
    validPathsFor(paths) {
        const isAnalyzeable = this.analyzer.capabilities.supportsPriorityFilesOutsideAnalysisRoots
            ? util.isAnalyzable
            : util.isAnalyzableAndInWorkspace;
        return paths
            .filter((doc) => !doc.isClosed && isAnalyzeable(doc))
            .map((doc) => (0, fs_1.fsPath)(doc.uri))
            .sort((path1, path2) => path1.localeCompare(path2));
    }
    getNavigationTargets(file, offset) {
        var _a;
        // Synthesize an AnalysisGetNavigationResponse based on our existing knowledge about navigation links in the file.
        const notification = this.navigations[file];
        const region = (_a = notification === null || notification === void 0 ? void 0 : notification.regions) === null || _a === void 0 ? void 0 : _a.find((region) => this.offsetWithinNavigationRegion(region, offset));
        if (!region)
            return undefined;
        return {
            files: notification.files,
            regions: [region],
            targets: notification.targets,
        };
    }
    offsetWithinNavigationRegion(region, offset) {
        return offset >= region.offset && offset < region.offset + region.length;
    }
    getOutlineFor(file) {
        return this.outlines[(0, fs_1.fsPath)(file)];
    }
    waitForOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.outlines[(0, fs_1.fsPath)(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[(0, fs_1.fsPath)(file)];
    }
    waitForFlutterOutlineWithLength(file, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.flutterOutlines[(0, fs_1.fsPath)(file)];
                return (outline === null || outline === void 0 ? void 0 : outline.length) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getOccurrencesFor(file) {
        return this.occurrences[(0, fs_1.fsPath)(file)];
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = (0, fs_1.fsPath)(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[(0, fs_1.fsPath)(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    getFoldingRegionsFor(file) {
        return this.folding[(0, fs_1.fsPath)(file)];
    }
    getLastPriorityFiles() {
        return this.lastPriorityFiles.slice();
    }
    getLastSubscribedFiles() {
        return this.lastSubscribedFiles.slice();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DasFileTracker = DasFileTracker;


/***/ }),

/***/ 4002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFileTracker = void 0;
const vscode_1 = __webpack_require__(9496);
const custom_protocol_1 = __webpack_require__(556);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const utils_2 = __webpack_require__(7220);
const project_1 = __webpack_require__(3886);
const util = __webpack_require__(8779);
class LspFileTracker {
    constructor(logger, analyzer, wsContext) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.wsContext = wsContext;
        this.disposables = [];
        this.outlines = {};
        this.flutterOutlines = {};
        this.pubRunTestSupport = {};
        this.onOutlineEmitter = new events_1.EventEmitter();
        this.onOutline = this.onOutlineEmitter.event;
        this.onFlutterOutlineEmitter = new events_1.EventEmitter();
        this.onFlutterOutline = this.onFlutterOutlineEmitter.event;
        // tslint:disable-next-line: no-floating-promises
        analyzer.start().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishOutlineNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vscode_1.Uri.parse(n.uri));
                this.outlines[filePath] = n.outline;
                this.onOutlineEmitter.fire(n);
            });
            this.analyzer.onNotification(custom_protocol_1.PublishFlutterOutlineNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vscode_1.Uri.parse(n.uri));
                this.flutterOutlines[filePath] = n.outline;
                this.onFlutterOutlineEmitter.fire(n);
            });
        });
        this.watchPubspec();
    }
    getOutlineFor(file) {
        return this.outlines[(0, fs_1.fsPath)(file)];
    }
    waitForOutline(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => this.outlines[(0, fs_1.fsPath)(document.uri)], 50, 5000, token);
        });
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.outlines[(0, fs_1.fsPath)(document.uri)];
                return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    getFlutterOutlineFor(file) {
        return this.flutterOutlines[(0, fs_1.fsPath)(file)];
    }
    // TODO: Change this to withVersion when server sends versions.
    waitForFlutterOutlineWithLength(document, length, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, promises_1.waitFor)(() => {
                const outline = this.flutterOutlines[(0, fs_1.fsPath)(document.uri)];
                return outline && document.offsetAt((0, utils_2.lspToPosition)(outline.range.end)) === length ? outline : undefined;
            }, 50, 5000, token);
        });
    }
    supportsPubRunTest(file) {
        // TODO: Both FileTrackers have a copy of this!
        const path = (0, fs_1.fsPath)(file);
        if (!util.isPubRunnableTestFile(path))
            return false;
        if (this.pubRunTestSupport[path] === undefined) {
            const projectRoot = (0, project_1.locateBestProjectRoot)(path);
            this.pubRunTestSupport[path] = !!(projectRoot && util.projectShouldUsePubForTests(projectRoot, this.wsContext.config));
        }
        return this.pubRunTestSupport[(0, fs_1.fsPath)(file)];
    }
    watchPubspec() {
        const clearCachedPubRunTestData = () => Object.keys(this.pubRunTestSupport).forEach((f) => delete this.pubRunTestSupport[f]);
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(clearCachedPubRunTestData, this);
        watcher.onDidCreate(clearCachedPubRunTestData, this);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFileTracker = LspFileTracker;


/***/ }),

/***/ 3189:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Analytics = void 0;
const https = __webpack_require__(5687);
const querystring = __webpack_require__(3477);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
// Set to true for analytics to be sent to the debug endpoint (non-logging) for validation.
// This is only required for debugging analytics and needn't be sent for standard Dart Code development (dev hits are already filtered with isDevelopment).
const debug = false;
/// Analytics require that we send a value for uid or cid, but when running in the VS Code
// dev host we don't have either.
const sendAnalyticsFromExtensionDevHost = false;
// Machine ID is not set for extension dev host unless the boolean above is set to true (which
// is usually done for testing purposes).
const machineId = vscode_1.env.machineId !== "someValue.machineId"
    ? vscode_1.env.machineId
    : (sendAnalyticsFromExtensionDevHost ? "35009a79-1a05-49d7-dede-dededededede" : undefined);
var Category;
(function (Category) {
    Category[Category["Extension"] = 0] = "Extension";
    Category[Category["Analyzer"] = 1] = "Analyzer";
    Category[Category["Debugger"] = 2] = "Debugger";
    Category[Category["FlutterSurvey"] = 3] = "FlutterSurvey";
})(Category || (Category = {}));
var EventAction;
(function (EventAction) {
    EventAction[EventAction["Activated"] = 0] = "Activated";
    EventAction[EventAction["SdkDetectionFailure"] = 1] = "SdkDetectionFailure";
    EventAction[EventAction["Deactivated"] = 2] = "Deactivated";
    EventAction[EventAction["Restart"] = 3] = "Restart";
    EventAction[EventAction["HotReload"] = 4] = "HotReload";
    EventAction[EventAction["OpenObservatory"] = 5] = "OpenObservatory";
    EventAction[EventAction["OpenTimeline"] = 6] = "OpenTimeline";
    EventAction[EventAction["OpenDevTools"] = 7] = "OpenDevTools";
    EventAction[EventAction["Shown"] = 8] = "Shown";
    EventAction[EventAction["Clicked"] = 9] = "Clicked";
    EventAction[EventAction["Dismissed"] = 10] = "Dismissed";
})(EventAction || (EventAction = {}));
var TimingVariable;
(function (TimingVariable) {
    TimingVariable[TimingVariable["Startup"] = 0] = "Startup";
    TimingVariable[TimingVariable["FirstAnalysis"] = 1] = "FirstAnalysis";
    TimingVariable[TimingVariable["SessionDuration"] = 2] = "SessionDuration";
})(TimingVariable || (TimingVariable = {}));
class Analytics {
    constructor(logger, workspaceContext) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.dummyDartFile = vscode_1.Uri.parse("untitled:foo.dart");
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
        this.dartConfig = vscode_1.workspace.getConfiguration("", this.dummyDartFile).get("[dart]");
        // If analytics fail, they will be disabled for the rest of the session.
        this.disableAnalyticsForSession = false;
        this.formatter = this.getFormatterSetting();
    }
    getFormatterSetting() {
        try {
            // If there are multiple formatters for Dart, the user can select one, so check
            // that first so we don't record their formatter being enabled as ours.
            const otherDefaultFormatter = this.getAppliedConfig("editor", "defaultFormatter", false);
            if (otherDefaultFormatter && otherDefaultFormatter !== constants_1.dartCodeExtensionIdentifier)
                return otherDefaultFormatter;
            // If the user has explicitly disabled ours (without having another selected
            // then record that).
            if (!config_1.config.enableSdkFormatter)
                return "Disabled";
            // Otherwise record as enabled (and whether on-save).
            return this.getAppliedConfig("editor", "formatOnSave")
                ? "Enabled on Save"
                : "Enabled";
        }
        catch (_a) {
            return "Unknown";
        }
    }
    getAppliedConfig(section, key, isResourceScoped = true) {
        const dartValue = this.dartConfig ? this.dartConfig[`${section}.${key}`] : undefined;
        return dartValue !== undefined && dartValue !== null
            ? dartValue
            : vscode_1.workspace.getConfiguration(section, isResourceScoped ? this.dummyDartFile : undefined).get(key);
    }
    logExtensionStartup(timeInMS) {
        this.event(Category.Extension, EventAction.Activated).catch((e) => this.logger.info(`${e}`));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(`${e}`));
    }
    logExtensionRestart(timeInMS) {
        this.event(Category.Extension, EventAction.Restart).catch((e) => this.logger.info(`${e}`));
        this.time(Category.Extension, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(`${e}`));
    }
    logAnalyzerRestart() {
        this.event(Category.Analyzer, EventAction.Restart).catch((e) => this.logger.info(`${e}`));
    }
    logExtensionShutdown() { return this.event(Category.Extension, EventAction.Deactivated); }
    logSdkDetectionFailure() { this.event(Category.Extension, EventAction.SdkDetectionFailure).catch((e) => this.logger.info(`${e}`)); }
    logError(description, fatal) { this.error(description, fatal).catch((e) => this.logger.info(`${e}`)); }
    logAnalyzerStartupTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.Startup, timeInMS).catch((e) => this.logger.info(`${e}`)); }
    logDebugSessionDuration(debuggerType, timeInMS) { this.time(Category.Debugger, TimingVariable.SessionDuration, timeInMS, debuggerType).catch((e) => this.logger.info(`${e}`)); }
    logAnalyzerFirstAnalysisTime(timeInMS) { this.time(Category.Analyzer, TimingVariable.FirstAnalysis, timeInMS).catch((e) => this.logger.info(`${e}`)); }
    logDebuggerStart(debuggerType, runType, sdkDap) {
        const customData = {
            cd15: debuggerType,
            cd16: runType,
            cd18: sdkDap ? "SDK" : "Legacy",
            cd6: this.getDebuggerPreference(),
        };
        this.event(Category.Debugger, EventAction.Activated, customData).catch((e) => this.logger.info(`${e}`));
    }
    logDebuggerRestart() { this.event(Category.Debugger, EventAction.Restart).catch((e) => this.logger.info(`${e}`)); }
    logDebuggerHotReload() { this.event(Category.Debugger, EventAction.HotReload).catch((e) => this.logger.info(`${e}`)); }
    logDebuggerOpenObservatory() { this.event(Category.Debugger, EventAction.OpenObservatory).catch((e) => this.logger.info(`${e}`)); }
    logDebuggerOpenTimeline() { this.event(Category.Debugger, EventAction.OpenTimeline).catch((e) => this.logger.info(`${e}`)); }
    logDebuggerOpenDevTools() { this.event(Category.Debugger, EventAction.OpenDevTools).catch((e) => this.logger.info(`${e}`)); }
    logFlutterSurveyShown() { this.event(Category.FlutterSurvey, EventAction.Shown).catch((e) => this.logger.info(`${e}`)); }
    logFlutterSurveyClicked() { this.event(Category.FlutterSurvey, EventAction.Clicked).catch((e) => this.logger.info(`${e}`)); }
    logFlutterSurveyDismissed() { this.event(Category.FlutterSurvey, EventAction.Dismissed).catch((e) => this.logger.info(`${e}`)); }
    event(category, action, customData) {
        const data = {
            ea: EventAction[action],
            ec: Category[category],
            t: "event",
        };
        // Copy custom data over.
        Object.assign(data, customData);
        // Force a session start if this is extension activation.
        if (category === Category.Extension && action === EventAction.Activated)
            data.sc = "start";
        // Force a session end if this is extension deactivation.
        if (category === Category.Extension && action === EventAction.Deactivated)
            data.sc = "end";
        return this.send(data);
    }
    time(category, timingVariable, timeInMS, label) {
        const data = {
            t: "timing",
            utc: Category[category],
            utl: label,
            utt: Math.round(timeInMS),
            utv: TimingVariable[timingVariable],
        };
        this.logger.info(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        // if (isDevExtension)
        // 	console.log(`${data.utc}:${data.utv} timing: ${Math.round(timeInMS)}ms ${label ? `(${label})` : ""}`);
        return this.send(data);
    }
    error(description, fatal) {
        const data = {
            exd: description.trim(),
            exf: fatal ? 1 : 0,
            t: "exception",
        };
        return this.send(data);
    }
    send(customData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disableAnalyticsForSession
                || !machineId
                || !config_1.config.allowAnalytics /* Kept for users that opted-out when we used own flag */
                || !this.workspaceContext.config.disableAnalytics
                || !vscode_1.env.isTelemetryEnabled
                || constants_1.isDartCodeTestRun)
                return;
            const data = {
                aip: 1,
                an: "Dart Code",
                av: extension_utils_1.extensionVersion,
                cd1: extension_utils_1.isDevExtension,
                cd10: config_1.config.showTodos ? "On" : "Off",
                cd11: this.workspaceContext.config.useLegacyProtocol ? "DAS" : "LSP",
                cd12: this.formatter,
                cd13: this.flutterSdkVersion,
                cd14: extension_utils_1.hasFlutterExtension ? "Installed" : "Not Installed",
                cd17: this.workspaceContext.hasAnyFlutterProjects
                    ? (config_1.config.previewFlutterUiGuides ? (config_1.config.previewFlutterUiGuidesCustomTracking ? "On + Custom Tracking" : "On") : "Off")
                    : null,
                // cd18: this.workspaceContext.hasAnyFlutterProjects && resourceUri
                // 	? config.for(resourceUri).flutterStructuredErrors ? "On" : "Off"
                // 	: null,
                cd19: vscode_1.env.remoteName || "None",
                cd2: constants_1.isChromeOS ? `${process.platform} (ChromeOS)` : process.platform,
                cd20: vscode_1.env.appName || "Unknown",
                cd3: this.sdkVersion,
                // cd4: this.analysisServerVersion,
                cd5: vscode_1.version,
                cd7: this.workspaceContext.workspaceTypeDescription,
                cd8: config_1.config.closingLabels ? "On" : "Off",
                cd9: this.workspaceContext.hasAnyFlutterProjects ? config_1.config.flutterHotReloadOnSave : null,
                cid: machineId,
                tid: "UA-2201586-19",
                ul: vscode_1.env.language,
                v: "1", // API Version.
            };
            // Copy custom data over.
            Object.assign(data, customData);
            if (debug)
                this.logger.info("Sending analytic: " + JSON.stringify(data));
            const options = {
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                },
                hostname: "www.google-analytics.com",
                method: "POST",
                path: debug ? "/debug/collect" : "/collect",
                port: 443,
            };
            yield new Promise((resolve) => {
                try {
                    const req = https.request(options, (resp) => {
                        if (debug)
                            resp.on("data", (c) => {
                                try {
                                    const gaDebugResp = JSON.parse(c.toString());
                                    if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === true)
                                        this.logger.info("Sent OK!");
                                    else if (gaDebugResp && gaDebugResp.hitParsingResult && gaDebugResp.hitParsingResult[0].valid === false)
                                        this.logger.warn(c.toString());
                                    else
                                        this.logger.warn(`Unexpected GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                                catch (e) {
                                    this.logger.warn(`Error in GA debug response: ${c === null || c === void 0 ? void 0 : c.toString()}`);
                                }
                            });
                        if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                            this.logger.info(`Failed to send analytics ${resp && resp.statusCode}: ${resp && resp.statusMessage}`);
                        }
                        resolve();
                    });
                    req.write(querystring.stringify(data));
                    req.on("error", (e) => {
                        this.handleError(e);
                        resolve();
                    });
                    req.end();
                }
                catch (e) {
                    this.handleError(e);
                    resolve();
                }
            });
        });
    }
    handleError(e) {
        this.logger.info(`Failed to send analytics, disabling for session: ${e}`);
        this.disableAnalyticsForSession = true;
    }
    getDebuggerPreference() {
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            return "All code";
        else if (config_1.config.debugSdkLibraries)
            return "My code + SDK";
        else if (config_1.config.debugExternalPackageLibraries)
            return "My code + Libraries";
        else
            return "My code";
    }
}
exports.Analytics = Analytics;


/***/ }),

/***/ 8237:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartExtensionApi = void 0;
const vs = __webpack_require__(9496);
class DartExtensionApi {
    constructor() {
        this.version = 1;
        this.flutterCreateSampleProject = () => vs.commands.executeCommand("_dart.flutter.createSampleProject");
    }
}
exports.DartExtensionApi = DartExtensionApi;


/***/ }),

/***/ 7525:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_das_1 = __webpack_require__(6074);
const utils_2 = __webpack_require__(7220);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class FlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_2.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = (0, fs_1.fsPath)(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_das_1.ClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText((0, utils_2.toRange)(document, cl.offset, cl.codeOffset - cl.offset));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeOffset && sample.codeLength)
                .map((sample) => new vscode_1.CodeLens((0, utils_2.toRange)(document, sample.codeOffset, sample.codeLength), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterDartPadSamplesCodeLensProvider = FlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 6212:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspFlutterDartPadSamplesCodeLensProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const utils_2 = __webpack_require__(7220);
const dartPadSamplePattern = new RegExp("\\{@tool\\s+dartpad");
class LspFlutterDartPadSamplesCodeLensProvider {
    constructor(logger, analyzer, sdks) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.sdks = sdks;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
        this.disposables.push(vscode_1.commands.registerCommand("_dart.openDartPadSample", (sample) => __awaiter(this, void 0, void 0, function* () {
            // Link down to first code snippet.
            const fragment = `#${sample.libraryName}.${sample.className}.1`;
            const url = `https://api.flutter.dev/flutter/${sample.libraryName}/${sample.className}-class.html${fragment}`;
            yield utils_2.envUtils.openInBrowser(url);
        })));
        this.flutterPackagesFolder = path.join(sdks.flutter, "packages/flutter/lib/src/").toLowerCase();
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure this file is a Flutter package file.
            const filePath = (0, fs_1.fsPath)(document.uri);
            if (!filePath.toLowerCase().startsWith(this.flutterPackagesFolder))
                return;
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const libraryName = filePath.substr(this.flutterPackagesFolder.length).replace("\\", "/").split("/")[0];
            const visitor = new outline_lsp_1.LspClassOutlineVisitor(this.logger);
            visitor.visit(outline);
            // Filter classes to those with DartPad samples.
            const samples = visitor.classes.filter((cl) => {
                // HACK: DartDocs are between the main offset and codeOffset.
                const docs = document.getText(new vscode_1.Range((0, utils_2.lspToPosition)(cl.range.start), (0, utils_2.lspToPosition)(cl.codeRange.start)));
                return dartPadSamplePattern.test(docs);
            }).map((cl) => (Object.assign(Object.assign({}, cl), { libraryName })));
            return samples
                .filter((sample) => sample.codeRange)
                .map((sample) => new vscode_1.CodeLens((0, utils_2.lspToRange)(sample.codeRange), {
                arguments: [sample],
                command: "_dart.openDartPadSample",
                title: `Open online interactive samples for ${sample.className}`,
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspFlutterDartPadSamplesCodeLensProvider = LspFlutterDartPadSamplesCodeLensProvider;


/***/ }),

/***/ 7927:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class MainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, fileType);
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, mainFunction, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, mainFunction, "Debug", true));
            if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
                results.push(this.createCodeLens(document, mainFunction, "Profile", false, { "flutterMode": "profile", "openDevTools": "performance" }));
            return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, !t.noDebug, t)));
        });
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, mainFunction.offset, mainFunction.length), {
            arguments: template ? [document.uri, template] : [document.uri],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.MainCodeLensProvider = MainCodeLensProvider;


/***/ }),

/***/ 5543:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspMainCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class LspMainCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            const fileType = (0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)) ? "test-file" : "file";
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, fileType);
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const templatesHaveProfile = !!templates.find((t) => t.name === "Profile");
            const mainFunction = (_a = outline.children) === null || _a === void 0 ? void 0 : _a.find((o) => o.element.name === "main");
            if (!mainFunction)
                return;
            const results = [];
            if (!templatesHaveRun)
                results.push(this.createCodeLens(document, mainFunction, "Run", false));
            if (!templatesHaveDebug)
                results.push(this.createCodeLens(document, mainFunction, "Debug", true));
            if (fileType === "file" && !templatesHaveProfile && (0, utils_3.isInsideFlutterProject)(document.uri))
                results.push(this.createCodeLens(document, mainFunction, "Profile", false, { "flutterMode": "profile", "openDevTools": "performance" }));
            return results.concat(templates.map((t) => this.createCodeLens(document, mainFunction, t.name, !t.noDebug, t)));
        });
    }
    createCodeLens(document, mainFunction, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(mainFunction.codeRange), {
            arguments: template ? [document.uri, template] : [document.uri],
            command: debug ? "dart.startDebugging" : "dart.startWithoutDebugging",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspMainCodeLensProvider = LspMainCodeLensProvider;


/***/ }),

/***/ 6993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_das_1 = __webpack_require__(6074);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class TestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.client.registerForAnalysisOutline((n) => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document.uri, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
                return;
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, "test");
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const visitor = new outline_das_1.TestOutlineVisitor(this.logger);
            visitor.visit(outline);
            return (0, utils_1.flatMap)(visitor.tests
                .filter((test) => test.offset && test.length)
                .map((test) => {
                const results = [];
                if (!templatesHaveRun)
                    results.push(this.createCodeLens(document, test, "Run", false));
                if (!templatesHaveDebug)
                    results.push(this.createCodeLens(document, test, "Debug", true));
                return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, !t.noDebug, t)));
            }), (x) => x);
        });
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.toRange)(document, test.offset, test.length), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCodeLensProvider = TestCodeLensProvider;


/***/ }),

/***/ 3005:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspTestCodeLensProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const utils_3 = __webpack_require__(8779);
class LspTestCodeLensProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.onDidChangeCodeLensesEmitter = new vscode_1.EventEmitter();
        this.onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;
        this.disposables.push(this.analyzer.fileTracker.onOutline.listen(() => {
            this.onDidChangeCodeLensesEmitter.fire();
        }));
    }
    provideCodeLenses(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Without version numbers, the best we have to tell if an outline is likely correct or stale is
            // if its length matches the document exactly.
            const expectedLength = document.getText().length;
            const outline = yield this.analyzer.fileTracker.waitForOutlineWithLength(document, expectedLength, token);
            if (!outline || !outline.children || !outline.children.length)
                return;
            // We should only show the CodeLens for projects we know can actually handle `pub run` (for ex. the
            // SDK codebase cannot, and will therefore run all tests when you click them).
            if (!this.analyzer.fileTracker.supportsPubRunTest(document.uri))
                return;
            // If we don't consider this a test file, we should also not show links (since we may try to run the
            // app with 'flutter run' instead of 'flutter test' which will fail due to no `-name` argument).
            if (!(0, utils_3.isTestFile)((0, fs_1.fsPath)(document.uri)))
                return;
            const templates = (0, debugger_1.getTemplatedLaunchConfigs)(document.uri, "test");
            const templatesHaveRun = !!templates.find((t) => t.name === "Run");
            const templatesHaveDebug = !!templates.find((t) => t.name === "Debug");
            const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, (0, fs_1.fsPath)(document.uri));
            visitor.visit(outline);
            return (0, utils_1.flatMap)(visitor.tests
                .filter((test) => test.range)
                .map((test) => {
                const results = [];
                if (!templatesHaveRun)
                    results.push(this.createCodeLens(document, test, "Run", false));
                if (!templatesHaveDebug)
                    results.push(this.createCodeLens(document, test, "Debug", true));
                return results.concat(templates.map((t) => this.createCodeLens(document, test, t.name, !t.noDebug, t)));
            }), (x) => x);
        });
    }
    createCodeLens(document, test, name, debug, template) {
        return new vscode_1.CodeLens((0, utils_2.lspToRange)(test.range), {
            arguments: template ? [test, template] : [test],
            command: debug ? "_dart.startDebuggingTestFromOutline" : "_dart.startWithoutDebuggingTestFromOutline",
            title: name,
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspTestCodeLensProvider = LspTestCodeLensProvider;


/***/ }),

/***/ 4954:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCommand = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const util_1 = __webpack_require__(3837);
const vs = __webpack_require__(9496);
const pub_add_1 = __webpack_require__(1119);
const fs_1 = __webpack_require__(300);
const util = __webpack_require__(8779);
const projects_1 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
const cacheFilename = "package_cache.json";
const knownFlutterSdkPackages = [
    "flutter",
    "flutter_test",
    "flutter_driver",
    "flutter_localizations",
    "integration_test",
];
class AddDependencyCommand extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities, pubApi) {
        super(logger, context, workspace, dartCapabilities);
        this.pubApi = pubApi;
        this.disposables.push(vs.commands.registerCommand("dart.addDependency", (uri) => this.promptAndAddDependency(uri, false)));
        this.disposables.push(vs.commands.registerCommand("dart.addDevDependency", (uri) => this.promptAndAddDependency(uri, true)));
        this.disposables.push(vs.commands.registerCommand("_dart.addDependency", this.addDependency, this));
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependency", this.removeDependency, this));
        this.extensionStorageUri = context.extensionStorageUri;
        // Kick off async work to fetch then queue a new check.
        this.loadAndFetch().catch((e) => this.logger.error(e));
    }
    loadAndFetch() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.loadPackageCache();
            }
            finally {
                this.queueNextPackageNameFetch((_b = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.cacheTimeRemainingMs) !== null && _b !== void 0 ? _b : 0);
            }
        });
    }
    loadPackageCache() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const bytes = yield vs.workspace.fs.readFile(this.packageNameCacheUri);
                const contents = new util_1.TextDecoder().decode(bytes);
                this.cache = pub_add_1.PackageCacheData.fromJson(contents.toString());
                this.logger.info(`Loaded ${(_a = this.cache) === null || _a === void 0 ? void 0 : _a.packageNames.length} from ${this.packageNameCacheUri}`);
            }
            catch (e) {
                this.logger.error(`Failed to read package cache file: ${e}`);
            }
        });
    }
    get packageNameCacheUri() {
        return vs.Uri.joinPath(this.extensionStorageUri, cacheFilename);
    }
    savePackageCache() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const json = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.toJson();
                if (json) {
                    const bytes = new util_1.TextEncoder().encode(json);
                    yield vs.workspace.fs.writeFile(this.packageNameCacheUri, bytes);
                }
                this.logger.info(`Saved ${(_b = this.cache) === null || _b === void 0 ? void 0 : _b.packageNames.length} in ${this.packageNameCacheUri}`);
            }
            catch (e) {
                this.logger.error(`Failed to save package cache file: ${e}`);
            }
        });
    }
    queueNextPackageNameFetch(ms) {
        if (this.nextPackageNameFetchTimeout)
            clearTimeout(this.nextPackageNameFetchTimeout);
        this.nextPackageNameFetchTimeout = setTimeout(() => this.fetchPackageNames(), ms);
    }
    fetchPackageNames() {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info(`Caching Pub package names from ${this.pubApi.pubUrlBase}...`);
            let results;
            try {
                results = yield this.pubApi.getPackageNames();
            }
            catch (e) {
                this.logger.error(`Failed to fetch Pub package names: ${e}`);
            }
            if (results && results.packages) {
                try {
                    this.cache = pub_add_1.PackageCacheData.fromPackageNames(results.packages);
                    yield this.savePackageCache();
                }
                catch (e) {
                    this.logger.error(`Failed to cache Pub package names: ${e}`);
                }
            }
            else {
                this.logger.error(`Pub package name results were invalid`);
            }
            this.queueNextPackageNameFetch(pub_add_1.PackageCacheData.maxCacheAgeMs);
        });
    }
    promptAndAddDependency(uri, isDevDependency) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to add the dependency to");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            let selectedOption = yield this.promptForPackageInfo();
            if (!selectedOption)
                return;
            let packageInfo;
            if (typeof selectedOption === "string") {
                selectedOption = selectedOption.trim();
                // For convenience, we handle string URLs/paths too.
                if (selectedOption.startsWith("http://") || selectedOption.startsWith("https://"))
                    packageInfo = yield this.promptForGitPackageInfo(selectedOption);
                else if (selectedOption.includes("/") || selectedOption.includes("\\"))
                    packageInfo = yield this.promptForPathPackageInfo(selectedOption);
                else
                    packageInfo = { packageNames: selectedOption, marker: undefined };
            }
            else {
                switch (selectedOption.marker) {
                    case "PATH":
                        packageInfo = yield this.promptForPathPackageInfo();
                        break;
                    case "GIT":
                        packageInfo = yield this.promptForGitPackageInfo();
                        break;
                    default:
                        packageInfo = selectedOption;
                        break;
                }
            }
            if (!packageInfo)
                return;
            return this.addDependency(uri, packageInfo, isDevDependency);
        });
    }
    /// Note: This is called by quick-fix as well as directly from the command palette.
    addDependency(uri, selectedPackage, isDevDependency) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const args = ["add"];
            let packageName;
            if (selectedPackage.marker === "GIT") {
                packageName = selectedPackage.packageName;
                args.push(packageName);
                args.push(`--git-url=${selectedPackage.url}`);
                if (selectedPackage.ref) {
                    args.push(`--git-ref=${selectedPackage.ref}`);
                }
                if (selectedPackage.path) {
                    args.push(`--git-path=${selectedPackage.path}`);
                }
            }
            else if (selectedPackage.marker === "PATH") {
                packageName = selectedPackage.packageName;
                args.push(packageName);
                args.push(`--path=${selectedPackage.path}`);
            }
            else {
                const packageNames = selectedPackage.packageNames.split(",").map((p) => p.trim());
                for (const packageName of packageNames) {
                    args.push(packageName);
                }
                // We assume when multiple are given, they're all of the same type.
                // The completion list should filter when this is the case.
                packageName = packageNames[0];
            }
            if (isDevDependency)
                args.push("--dev");
            // Handle some known Flutter dependencies.
            const isFlutterSdkPackage = knownFlutterSdkPackages.includes(packageName);
            if (isFlutterSdkPackage) {
                args.push("--sdk");
                args.push("flutter");
            }
            if (this.sdks.flutter && (isFlutterSdkPackage || util.isInsideFlutterProject(uri))) {
                return this.runFlutter(["pub", ...args], uri);
            }
            else {
                return this.runPub(args, uri);
            }
        });
    }
    removeDependency(uri, packageName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const args = ["remove", packageName];
            if (this.sdks.flutter && util.isInsideFlutterProject(uri)) {
                return this.runFlutter(["pub", ...args], uri);
            }
            else {
                return this.runPub(args, uri);
            }
        });
    }
    /// Prompts the user to select a package name, or the option to select a path or Git package (in
    /// which case they must also provide package name etc).
    promptForPackageInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = this.dartCapabilities.supportsPubAddMultiple
                ? "package name (can be comma separated), URL or path"
                : "package name, URL or path";
            quickPick.title = this.dartCapabilities.supportsPubAddMultiple
                ? "Enter package name(s), URL or local path"
                : "Enter a package name, URL or local path";
            quickPick.items = this.getPackageEntries();
            quickPick.onDidChangeValue((userInput) => {
                quickPick.items = this.getPackageEntries(userInput);
            });
            const selectedOption = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0] ? quickPick.selectedItems[0] : quickPick.value));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPick.dispose();
            return selectedOption;
        });
    }
    promptForPathPackageInfo(packagePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!packagePath) {
                const packagePaths = yield vs.window.showOpenDialog({
                    canSelectFiles: false,
                    canSelectFolders: true,
                    canSelectMany: false,
                    openLabel: "Select package folder",
                });
                if (!packagePaths || packagePaths.length !== 1)
                    return;
                packagePath = (0, fs_1.fsPath)(packagePaths[0]);
            }
            if (!packagePath)
                return;
            try {
                const pubspecPackageNameRegex = /^name: (\w+)$/gm;
                const pubspecContent = fs.readFileSync(path.join(packagePath, "pubspec.yaml"), "utf8");
                const packageNameResult = pubspecPackageNameRegex.exec(pubspecContent);
                if (packageNameResult)
                    return { path: packagePath, packageName: packageNameResult[1], marker: "PATH" };
            }
            catch (e) {
                this.logger.error(e);
                vs.window.showErrorMessage("The selected folder does not appear to be a valid Pub package");
                return;
            }
        });
    }
    promptForGitPackageInfo(repoUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!repoUrl)
                repoUrl = yield this.promptForGitUrl();
            if (!repoUrl)
                return;
            const urlSegments = repoUrl.split("/");
            const packageName = yield this.promptForPackageName(urlSegments[urlSegments.length - 1]);
            if (!packageName)
                return;
            const repoRef = yield this.promptForGitRef();
            const repoPath = yield this.promptForGitPath();
            return {
                marker: "GIT",
                packageName,
                path: repoPath,
                ref: repoRef,
                url: repoUrl,
            };
        });
    }
    promptForGitUrl() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "git repo url",
            title: "Enter a Git repository url",
        });
    }
    promptForGitPath() {
        return vs.window.showInputBox({
            ignoreFocusOut: true,
            placeHolder: "path to package",
            title: "Enter the path to the package in the repository (press <enter> for default)",
        });
    }
    promptForGitRef() {
        return __awaiter(this, void 0, void 0, function* () {
            return vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "commit/branch",
                title: "Enter the commit/branch to use (press <enter> for default)",
            });
        });
    }
    promptForPackageName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "package name",
                title: "Enter the Packages name",
                value: name,
            });
        });
    }
    getPackageEntries(userInput) {
        var _a, _b;
        let currentSearchString = userInput;
        let completionItemPrefixes = "";
        if (userInput && this.dartCapabilities.supportsPubAddMultiple) {
            // If we support multiple, we need to split "foo, bar, ba" into "foo, bar, " and "ba". One is the search
            // and the other is a prefix that needs adding to all package names in the completion list.
            const startOfCurrentPackageName = Math.max(userInput.lastIndexOf(" "), userInput.lastIndexOf(","));
            currentSearchString = userInput.substring(startOfCurrentPackageName + 1);
            completionItemPrefixes = userInput.substring(0, startOfCurrentPackageName + 1);
            if (currentSearchString === "" && completionItemPrefixes.endsWith(","))
                completionItemPrefixes = `${completionItemPrefixes} `;
        }
        const max = 50;
        const packageNames = (_b = (_a = this.cache) === null || _a === void 0 ? void 0 : _a.packageNames) !== null && _b !== void 0 ? _b : [];
        let matches = new Set();
        // This list can be quite large, so avoid using .filter() if we can bail out early.
        if (currentSearchString) {
            currentSearchString = currentSearchString.trim();
            for (let i = 0; i < packageNames.length && matches.size < max; i++) {
                const packageName = packageNames[i];
                if (packageName.startsWith(currentSearchString))
                    matches.add(packageName);
            }
            // Also add on any Flutter-SDK packages that match.
            for (const packageName of knownFlutterSdkPackages) {
                if (packageName.startsWith(currentSearchString))
                    matches.add(packageName);
            }
        }
        else {
            matches = new Set(packageNames.slice(0, Math.min(max, packageNames.length)));
        }
        const pickablePackageNames = Array.from(matches).map((packageName) => {
            const fullString = `${completionItemPrefixes}${packageName}`;
            return {
                label: fullString,
                marker: undefined,
                packageNames: fullString,
            };
        });
        if (currentSearchString) {
            return pickablePackageNames;
        }
        else {
            return [
                {
                    description: "add a package from a local path",
                    label: "Local Path Package",
                    marker: "PATH",
                },
                {
                    description: "add a package from a Git repository",
                    label: "Git Repository URL",
                    marker: "GIT",
                },
                ...pickablePackageNames,
            ];
        }
    }
}
exports.AddDependencyCommand = AddDependencyCommand;


/***/ }),

/***/ 8932:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnalyzerCommands = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(7220);
// Must be global, as all classes are created during an extension restart.
let forcedReanalyzeCount = 0;
class AnalyzerCommands {
    constructor(context, logger, analyzer, analytics) {
        this.logger = logger;
        context.subscriptions.push(vs.commands.registerCommand("dart.openAnalyzerDiagnostics", () => __awaiter(this, void 0, void 0, function* () {
            const res = yield analyzer.getDiagnosticServerPort();
            yield utils_1.envUtils.openInBrowser(`http://127.0.0.1:${res.port}/`);
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.restartAnalysisServer", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            vs.commands.executeCommand("_dart.reloadExtension");
        })));
        context.subscriptions.push(vs.commands.registerCommand("dart.forceReanalyze", () => __awaiter(this, void 0, void 0, function* () {
            forcedReanalyzeCount++;
            if (forcedReanalyzeCount === 10)
                this.showServerRestartPrompt().catch((e) => logger.error(e));
            analytics.logAnalyzerRestart();
            yield analyzer.forceReanalyze();
        })));
    }
    showServerRestartPrompt() {
        return __awaiter(this, void 0, void 0, function* () {
            const choice = yield vs.window.showInformationMessage("Needing to reanalyze a lot? Please consider filing a bug with a server instrumentation log", constants_1.issueTrackerAction);
            if (choice === constants_1.issueTrackerAction)
                yield utils_1.envUtils.openInBrowser(constants_1.issueTrackerUri, this.logger);
        });
    }
}
exports.AnalyzerCommands = AnalyzerCommands;


/***/ }),

/***/ 1026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runProcessInOutputChannel = exports.getOutputChannel = void 0;
const vs = __webpack_require__(9496);
const channels = {};
function getOutputChannel(name, insertDivider = false) {
    if (!channels[name]) {
        channels[name] = vs.window.createOutputChannel(name);
    }
    else if (insertDivider) {
        const ch = channels[name];
        ch.appendLine("");
        ch.appendLine("--");
        ch.appendLine("");
    }
    return channels[name];
}
exports.getOutputChannel = getOutputChannel;
function runProcessInOutputChannel(process, channel) {
    process.stdout.on("data", (data) => channel.append(data.toString()));
    process.stderr.on("data", (data) => channel.append(data.toString()));
    process.on("close", (code) => channel.appendLine(`exit code ${code}`));
}
exports.runProcessInOutputChannel = runProcessInOutputChannel;


/***/ }),

/***/ 5836:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
const config_1 = __webpack_require__(4165);
const stagehand_1 = __webpack_require__(5958);
const dart_create_1 = __webpack_require__(3285);
const sdk_1 = __webpack_require__(997);
class DartCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, sdkUtils, pubGlobal, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.pubGlobal = pubGlobal;
        this.disposables.push(vs.commands.registerCommand("dart.createProject", this.createDartProject, this));
        this.disposables.push(vs.commands.registerCommand("_dart.create", this.dartCreate, this));
    }
    dartCreate(projectPath, templateName) {
        // TODO: This should move inside DartCreate/Stagehand, but it requires extracting
        // all the command executing also into a better base class ("run pub in folder" etc.)
        // instead of being directly in here.
        if (this.dartCapabilities.supportsDartCreate) {
            const binPath = path.join(this.sdks.dart, constants_1.dartVMPath);
            const projectContainer = path.dirname(projectPath);
            const projectName = path.basename(projectPath);
            const args = ["create", "-t", templateName, projectName, "--force"];
            return this.runCommandInFolder(templateName, projectContainer, binPath, args, false);
        }
        else {
            const args = ["global", "run", "stagehand", templateName];
            return this.runPubInFolder(projectPath, args, templateName);
        }
    }
    createDartProject() {
        return __awaiter(this, void 0, void 0, function* () {
            const command = "dart.createProject";
            const triggerFilename = constants_1.DART_CREATE_PROJECT_TRIGGER_FILE;
            const autoPickIfSingleItem = false;
            if (!this.sdks || !this.sdks.dart) {
                this.sdkUtils.showDartActivationFailure(command);
                return;
            }
            // Get the JSON for the available templates by calling stagehand or 'dart create'.
            const creator = this.dartCapabilities.supportsDartCreate
                ? new dart_create_1.DartCreate(this.logger, this.sdks)
                : new stagehand_1.Stagehand(this.logger, this.dartCapabilities, this.sdks, this.pubGlobal);
            const isAvailable = yield creator.installIfRequired();
            if (!isAvailable) {
                return;
            }
            let templates;
            try {
                templates = yield creator.getTemplates();
            }
            catch (e) {
                vs.window.showErrorMessage(`Unable to fetch project templates. ${e}`);
                return;
            }
            const sortedTemplates = (0, array_1.sortBy)(templates, (s) => s.label);
            const pickItems = sortedTemplates.map((t) => ({
                description: t.name,
                detail: t.description,
                label: t.label,
                template: t,
            }));
            // Get the user to pick a template (but pick for them if there's only one
            // and autoPickIfSingleItem).
            const selectedTemplate = autoPickIfSingleItem && pickItems.length === 1
                ? pickItems[0]
                : yield vs.window.showQuickPick(pickItems, {
                    matchOnDescription: true,
                    placeHolder: "Which Dart template?",
                });
            if (!selectedTemplate)
                return;
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({
                canSelectFolders: true,
                defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
                openLabel: "Select a folder to create the project in",
            });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = (0, fs_1.fsPath)(folders[0]);
            this.context.lastUsedNewProjectPath = folderPath;
            const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, "dart_application_");
            const name = yield vs.window.showInputBox({ prompt: "Enter a name for your new project", placeHolder: defaultName, value: defaultName, validateInput: (s) => this.validateDartProjectName(s, folderPath) });
            if (!name)
                return;
            const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
            const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            // Create a temp dart file to force extension to load when we open this folder.
            fs.writeFileSync(path.join(projectFolderPath, triggerFilename), JSON.stringify(selectedTemplate.template));
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceSdkPath)
                (0, projects_1.writeDartSdkSettingIntoProject)(config_1.config.workspaceSdkPath, projectFolderPath);
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
        });
    }
    validateDartProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Dart project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["dart", "test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a dart project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
}
exports.DartCommands = DartCommands;


/***/ }),

/***/ 4635:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugCommands = exports.LastTestDebugSession = exports.LastDebugSession = exports.isInFlutterProfileModeDebugSession = exports.isInFlutterDebugModeDebugSession = exports.isInDartDebugSession = exports.debugSessions = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const user_prompts_1 = __webpack_require__(7622);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const vm_service_extensions_1 = __webpack_require__(7253);
const project_1 = __webpack_require__(3886);
const manager_1 = __webpack_require__(34);
const utils_3 = __webpack_require__(8779);
const debug_1 = __webpack_require__(9564);
exports.debugSessions = [];
const CURRENT_FILE_RUNNABLE = "dart-code:currentFileIsRunnable";
// Workaround for https://github.com/microsoft/vscode/issues/100115
const dynamicDebugSessionName = "Dart ";
// As a workaround for https://github.com/Microsoft/vscode/issues/71651 we
// will keep any events that arrive before their session "started" and then
// replace them when the start event comes through.
let pendingCustomEvents = [];
let hasPromptedAboutDebugSettings = false;
exports.isInDartDebugSession = false;
exports.isInFlutterDebugModeDebugSession = false;
exports.isInFlutterProfileModeDebugSession = false;
class LastDebugSession {
}
exports.LastDebugSession = LastDebugSession;
class LastTestDebugSession {
}
exports.LastTestDebugSession = LastTestDebugSession;
class DebugCommands {
    constructor(logger, context, workspaceContext, dartCapabilities, flutterCapabilities, analytics, pubGlobal, flutterDaemon) {
        this.logger = logger;
        this.context = context;
        this.workspaceContext = workspaceContext;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.analytics = analytics;
        this.disposables = [];
        this.debugOptions = vs.window.createStatusBarItem("dartStatusDebugOptions", vs.StatusBarAlignment.Left, 0);
        this.currentDebugOption = enums_1.DebugOption.MyCode;
        this.debugMetrics = vs.window.createStatusBarItem("dartStatusDebugMetrics", vs.StatusBarAlignment.Right, 0);
        this.onWillHotReloadEmitter = new vs.EventEmitter();
        this.onWillHotReload = this.onWillHotReloadEmitter.event;
        this.onWillHotRestartEmitter = new vs.EventEmitter();
        this.onWillHotRestart = this.onWillHotRestartEmitter.event;
        this.onDebugSessionVmServiceAvailableEmitter = new vs.EventEmitter();
        this.onDebugSessionVmServiceAvailable = this.onDebugSessionVmServiceAvailableEmitter.event;
        this.suppressFlutterWidgetErrors = false;
        this.isInspectingWidget = false;
        this.autoCancelNextInspectWidgetMode = false;
        this.vmServices = new vm_service_extensions_1.VmServiceExtensions(logger, this, workspaceContext);
        this.devTools = new manager_1.DevToolsManager(logger, workspaceContext, this, analytics, pubGlobal, dartCapabilities, flutterCapabilities, flutterDaemon);
        this.disposables.push(this.devTools);
        this.debugOptions.name = "Dart Debug Options";
        this.disposables.push(this.debugOptions);
        this.debugMetrics.name = "Dart Debug Metrics";
        this.disposables.push(this.debugMetrics);
        this.disposables.push(vs.debug.onDidChangeBreakpoints((e) => this.handleBreakpointChange(e)));
        this.disposables.push(vs.debug.onDidStartDebugSession((s) => this.handleDebugSessionStart(s)));
        this.disposables.push(vs.debug.onDidReceiveDebugSessionCustomEvent((e) => this.handleDebugSessionCustomEvent(e)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((s) => this.handleDebugSessionEnd(s)));
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
        this.disposables.push(vs.commands.registerCommand("flutter.overridePlatform", () => this.vmServices.overridePlatform()));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugPainting", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugPaint)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePerformanceOverlay", () => this.vmServices.toggle(enums_1.VmServiceExtension.PerformanceOverlay)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleBrightness", () => this.vmServices.toggle(enums_1.VmServiceExtension.BrightnessOverride, "Brightness.dark", "Brightness.light")));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleRepaintRainbow", () => this.vmServices.toggle(enums_1.VmServiceExtension.RepaintRainbow)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleDebugModeBanner", () => this.vmServices.toggle(enums_1.VmServiceExtension.DebugBanner)));
        this.disposables.push(vs.commands.registerCommand("flutter.togglePaintBaselines", () => this.vmServices.toggle(enums_1.VmServiceExtension.PaintBaselines)));
        this.disposables.push(vs.commands.registerCommand("flutter.toggleSlowAnimations", () => this.vmServices.toggle(enums_1.VmServiceExtension.SlowAnimations, vm_service_extensions_1.timeDilationNormal, vm_service_extensions_1.timeDilationSlow)));
        this.disposables.push(vs.commands.registerCommand("flutter.inspectWidget", () => {
            this.autoCancelNextInspectWidgetMode = false;
            this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true);
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.inspectWidget.autoCancel", () => {
            this.autoCancelNextInspectWidgetMode = true;
            this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, true, true);
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.cancelInspectWidget", () => {
            this.autoCancelNextInspectWidgetMode = false;
            this.vmServices.toggle(enums_1.VmServiceExtension.InspectorSelectMode, false, false);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.openObservatory", () => __awaiter(this, void 0, void 0, function* () {
            const session = yield this.getDebugSession();
            if (session && !session.session.configuration.noDebug && session.observatoryUri) {
                yield utils_2.envUtils.openInBrowser(session.observatoryUri);
                analytics.logDebuggerOpenObservatory();
            }
            else if (session) {
                logger.warn("Cannot start Observatory for session without debug/observatoryUri");
            }
        })));
        this.disposables.push(vs.commands.registerCommand("_dart.openDevTools.touchBar", () => vs.commands.executeCommand("dart.openDevTools")));
        constants_1.devToolsPages.forEach((page) => {
            this.disposables.push(vs.commands.registerCommand(page.commandId, (options) => __awaiter(this, void 0, void 0, function* () {
                options = Object.assign({}, options, { page });
                return vs.commands.executeCommand("dart.openDevTools", options);
            })));
        });
        this.disposables.push(vs.commands.registerCommand("flutter.openDevTools", (options) => __awaiter(this, void 0, void 0, function* () { return vs.commands.executeCommand("dart.openDevTools", options); })));
        this.disposables.push(vs.commands.registerCommand("dart.openDevTools", (options) => __awaiter(this, void 0, void 0, function* () {
            if (!exports.debugSessions.length)
                return this.devTools.spawnForNoSession();
            const session = options && options.debugSessionId
                ? exports.debugSessions.find((s) => s.session.id === options.debugSessionId)
                : yield this.getDebugSession();
            if (!session)
                return; // User cancelled or specified session was gone
            // Only show a notification if we were not triggered automatically.
            const notify = !options || options.triggeredAutomatically !== true;
            const page = options === null || options === void 0 ? void 0 : options.page;
            if (session.vmServiceUri) {
                return this.devTools.spawnForSession(session, { notify, page });
            }
            else if (session.session.configuration.noDebug) {
                vs.window.showInformationMessage("You must start your app with debugging in order to use DevTools.");
            }
            else if (session.hasStarted) {
                vs.window.showInformationMessage("DevTools is not available for an app running in this mode.");
            }
            else {
                // TODO: Remove the last part of this after the next Flutter release (after 3.0) when the appStarted event
                //       is passed.
                vs.window.showInformationMessage("This debug session is not ready yet or does not support DevTools.");
            }
        })));
        // Misc custom debug commands.
        this.disposables.push(vs.commands.registerCommand("_dart.hotReload.touchBar", (args) => vs.commands.executeCommand("dart.hotReload", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.hotReload", (args) => vs.commands.executeCommand("dart.hotReload", args)));
        this.disposables.push(vs.commands.registerCommand("dart.hotReload", (args) => __awaiter(this, void 0, void 0, function* () {
            if (!exports.debugSessions.length)
                return;
            const onlyDart = !!(args === null || args === void 0 ? void 0 : args.onlyDart);
            const onlyFlutter = !!(args === null || args === void 0 ? void 0 : args.onlyFlutter);
            this.onWillHotReloadEmitter.fire();
            yield Promise.all(exports.debugSessions.map((s) => __awaiter(this, void 0, void 0, function* () {
                const shouldReload = onlyDart
                    ? (s.debuggerType === enums_1.DebuggerType.Dart || s.debuggerType === enums_1.DebuggerType.Web)
                    : onlyFlutter
                        ? (s.debuggerType === enums_1.DebuggerType.Flutter)
                        : true;
                if (shouldReload)
                    yield s.session.customRequest("hotReload", args);
            })));
            analytics.logDebuggerHotReload();
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.hotRestart", (args) => __awaiter(this, void 0, void 0, function* () {
            if (!exports.debugSessions.length)
                return;
            this.onWillHotRestartEmitter.fire();
            yield Promise.all(exports.debugSessions.map((s) => s.session.customRequest("hotRestart", args)));
            analytics.logDebuggerRestart();
        })));
        this.disposables.push(vs.commands.registerCommand("dart.startDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: false,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.startWithoutDebugging", (resource, launchTemplate) => {
            const launchConfig = Object.assign({
                name: dynamicDebugSessionName,
                noDebug: true,
                request: "launch",
                type: "dart",
            }, launchTemplate, {
                program: (0, fs_1.fsPath)(resource),
            });
            vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(resource), launchConfig);
        }));
        this.disposables.push(vs.commands.registerCommand("dart.createLaunchConfiguration", this.createLaunchConfiguration, this));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastDebugSession", () => {
            if (LastDebugSession.debugConfig) {
                vs.debug.startDebugging(LastDebugSession.workspaceFolder, LastDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous debug session to run.");
            }
        }));
        this.disposables.push(vs.commands.registerCommand("dart.rerunLastTestDebugSession", () => {
            if (LastTestDebugSession.debugConfig) {
                vs.debug.startDebugging(LastTestDebugSession.workspaceFolder, LastTestDebugSession.debugConfig);
            }
            else {
                vs.window.showErrorMessage("There is no previous test session to run.");
            }
        }));
        // Attach commands.
        this.disposables.push(vs.commands.registerCommand("dart.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Dart: Attach to Process",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.attachProcess", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Process",
                request: "attach",
                type: "dart",
                vmServiceUri: "${command:dart.promptForVmService}",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("flutter.runProfileMode", () => __awaiter(this, void 0, void 0, function* () {
            yield vs.debug.startDebugging(undefined, {
                flutterMode: "profile",
                name: "Flutter: Run in Profile Mode",
                openDevTools: "performance",
                request: "launch",
                type: "dart",
            });
            if (!this.context.hasNotifiedAboutProfileModeDefaultConfiguration) {
                this.context.hasNotifiedAboutProfileModeDefaultConfiguration = true;
                vs.window.showInformationMessage("Profiling Flutter app with default configuration. To customize this, create a launch configuration (and include 'flutterMode': 'profile').");
            }
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.runReleaseMode", () => __awaiter(this, void 0, void 0, function* () {
            yield vs.debug.startDebugging(undefined, {
                flutterMode: "release",
                name: "Flutter: Run in Release Mode",
                request: "launch",
                type: "dart",
            });
        })));
        this.disposables.push(vs.commands.registerCommand("flutter.attach", () => {
            vs.debug.startDebugging(undefined, {
                name: "Flutter: Attach to Device",
                request: "attach",
                type: "dart",
            });
        }));
        this.disposables.push(vs.commands.registerCommand("dart.promptForVmService", (defaultValueOrConfig) => __awaiter(this, void 0, void 0, function* () {
            const defaultValue = typeof defaultValueOrConfig === "string" ? defaultValueOrConfig : undefined;
            return vs.window.showInputBox({
                ignoreFocusOut: true,
                placeHolder: "Paste an VM Service URI",
                prompt: "Enter VM Service URI",
                validateInput: (input) => {
                    if (!input)
                        return;
                    input = input.trim();
                    // eslint-disable-next-line id-blacklist
                    if (Number.isInteger(parseFloat(input)))
                        return;
                    // Uri.parse doesn't seem to work as expected, so do our own basic validation
                    // https://github.com/Microsoft/vscode/issues/49818
                    if (!input.startsWith("http://") && !input.startsWith("https://")
                        && !input.startsWith("ws://") && !input.startsWith("wss://"))
                        return "Please enter a valid VM Service URI";
                },
                value: defaultValue,
            });
        })));
        // Debug options.
        if (config_1.config.debugSdkLibraries && config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
        else if (config_1.config.debugSdkLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodeSdk;
        else if (config_1.config.debugExternalPackageLibraries)
            this.currentDebugOption = enums_1.DebugOption.MyCodePackages;
        this.disposables.push(vs.commands.registerCommand("_dart.toggleDebugOptions", this.toggleDebugOptions, this));
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        this.debugOptions.tooltip = `Controls whether to step into or stop at breakpoints in only files in this workspace or also those in SDK and/or external Pub packages`;
        this.debugOptions.command = "_dart.toggleDebugOptions";
    }
    createLaunchConfiguration(resourceUri) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!resourceUri || resourceUri.scheme !== "file")
                return;
            const entryScriptPath = (0, fs_1.fsPath)(resourceUri);
            if (!(0, utils_3.isDartFile)(entryScriptPath))
                return;
            const workspaceFolder = vs.workspace.getWorkspaceFolder(resourceUri);
            if (!workspaceFolder)
                return;
            const workspaceFolderPath = (0, fs_1.fsPath)(workspaceFolder.uri);
            const projectFolderPath = (_a = (0, project_1.locateBestProjectRoot)(entryScriptPath)) !== null && _a !== void 0 ? _a : workspaceFolderPath;
            const relativeCwdPath = path.relative(workspaceFolderPath, projectFolderPath);
            const relativeEntryScriptPath = path.relative(projectFolderPath, entryScriptPath);
            const projectType = (0, fs_1.isFlutterProjectFolder)(projectFolderPath) ? "Flutter" : "Dart";
            const name = `${projectType} (${relativeEntryScriptPath})`;
            const newLaunchConfig = {
                name,
                type: "dart",
                // eslint-disable-next-line @typescript-eslint/tslint/config
                request: "launch",
                cwd: relativeCwdPath ? relativeCwdPath : undefined,
                program: relativeEntryScriptPath,
            };
            // Add to the launch.json config.
            const launchFile = vs.workspace.getConfiguration("launch", workspaceFolder);
            // If we're in a code-workspace that already has workspace-level launch configs,
            // we should add to that. Otherwise add directly to the workspace folder.
            const configInspect = launchFile.inspect("configurations");
            const workspaceConfigs = (_b = configInspect === null || configInspect === void 0 ? void 0 : configInspect.workspaceValue) !== null && _b !== void 0 ? _b : [];
            const workspaceFolderConfigs = (_c = configInspect === null || configInspect === void 0 ? void 0 : configInspect.workspaceFolderValue) !== null && _c !== void 0 ? _c : [];
            const hasWorkspaceConfigs = !!vs.workspace.workspaceFile && !!workspaceConfigs.length;
            const configs = hasWorkspaceConfigs ? workspaceConfigs : workspaceFolderConfigs;
            const target = hasWorkspaceConfigs ? vs.ConfigurationTarget.Workspace : vs.ConfigurationTarget.WorkspaceFolder;
            configs.push(newLaunchConfig);
            yield launchFile.update("configurations", configs, target);
            // Open the correct file based on workspace or workspace folder.
            if (hasWorkspaceConfigs) {
                vs.commands.executeCommand("workbench.action.openWorkspaceConfigFile");
            }
            else {
                const launchConfig = path.join(workspaceFolderPath, ".vscode", "launch.json");
                vs.workspace.openTextDocument(launchConfig).then((doc) => vs.window.showTextDocument(doc));
            }
        });
    }
    getDebugSession() {
        return __awaiter(this, void 0, void 0, function* () {
            if (exports.debugSessions.length === 0) {
                this.logger.info("No debug session to use!");
                return undefined;
            }
            else if (exports.debugSessions.length === 1) {
                this.logger.info("Using only available debug session");
                return exports.debugSessions[0];
            }
            else {
                this.logger.info("Multiple debug sessions available, will prompt user:");
                const sessions = exports.debugSessions.map((s) => ({
                    description: s.session.workspaceFolder ? s.session.workspaceFolder.name : undefined,
                    detail: s.session.configuration.deviceName || `Started ${s.sessionStart.toLocaleTimeString()}`,
                    label: s.session.name,
                    session: s,
                }));
                for (const session of sessions)
                    this.logger.info(`${session.label} ${session.description} (${session.detail})`);
                const selectedItem = yield vs.window.showQuickPick(sessions, { placeHolder: "Which debug session?" });
                return selectedItem && selectedItem.session;
            }
        });
    }
    handleBreakpointChange(e) {
        if (hasPromptedAboutDebugSettings)
            return;
        for (const bp of e.added)
            this.promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(bp);
    }
    promptAboutDebuggerSettingsIfBreakpointOutsideWorkspace(e) {
        if (hasPromptedAboutDebugSettings || this.context.breakpointInNonDebuggableFileDoNotShowAgain || !(e instanceof vs.SourceBreakpoint) || !e.enabled)
            return;
        // Don't consider non-Dart files.
        if (!(0, fs_1.fsPath)(e.location.uri).toLocaleLowerCase().endsWith(".dart"))
            return;
        // If it's inside the workspace we don't want to prompt.
        if (vs.workspace.getWorkspaceFolder(e.location.uri))
            return;
        const isSdkBreakpoint = (0, fs_1.isWithinPath)((0, fs_1.fsPath)(e.location.uri), this.workspaceContext.sdks.dart);
        if (isSdkBreakpoint && config_1.config.debugSdkLibraries)
            return;
        if (!isSdkBreakpoint && config_1.config.debugExternalPackageLibraries)
            return;
        hasPromptedAboutDebugSettings = true;
        const message = `You have a breakpoint outside of your workspace but debug settings are set to 'my code'. Would you like to change settings? You can also change this from the status bar while debugging.`;
        const debugJustMyCodeAction = "Debug my code";
        const debugEverything = "Debug all code";
        vs.window.showWarningMessage(message, debugJustMyCodeAction, debugEverything, constants_1.doNotAskAgainAction).then((choice) => {
            if (choice === constants_1.doNotAskAgainAction)
                this.context.breakpointInNonDebuggableFileDoNotShowAgain = true;
            if (choice !== debugEverything)
                return;
            this.currentDebugOption = enums_1.DebugOption.MyCodePackagesSdk;
            this.applyNewDebugOption();
        });
    }
    handleDebugSessionStart(s) {
        var _a, _b;
        if (s.type !== "dart")
            return;
        const session = new debug_1.DartDebugSessionInformation(s, s.configuration.debuggerType);
        // If we're the first fresh debug session, reset all settings to default.
        // Subsequent launches will inherit the "current" values.
        if (exports.debugSessions.length === 0)
            this.vmServices.resetToDefaults();
        exports.debugSessions.push(session);
        if (s.configuration.debuggerType === enums_1.DebuggerType.Flutter || s.configuration.debuggerType === enums_1.DebuggerType.Web) {
            const isProfileMode = (_a = s.configuration.toolArgs) === null || _a === void 0 ? void 0 : _a.includes("--profile");
            const isReleaseMode = (_b = s.configuration.toolArgs) === null || _b === void 0 ? void 0 : _b.includes("--release");
            if (isReleaseMode) {
                vs.commands.executeCommand("setContext", constants_1.isInFlutterReleaseModeDebugSessionContext, true);
            }
            else if (isProfileMode) {
                exports.isInFlutterProfileModeDebugSession = true;
                vs.commands.executeCommand("setContext", constants_1.isInFlutterProfileModeDebugSessionContext, true);
            }
            else {
                exports.isInFlutterDebugModeDebugSession = true;
                vs.commands.executeCommand("setContext", constants_1.isInFlutterDebugModeDebugSessionContext, true);
            }
        }
        else if (s.configuration.debuggerType === enums_1.DebuggerType.Dart) {
            exports.isInDartDebugSession = true;
            vs.commands.executeCommand("setContext", constants_1.isInDartDebugSessionContext, true);
        }
        // Process any queued events that came in before the session start
        // event.
        const eventsToProcess = pendingCustomEvents.filter((e) => e.session.id === s.id);
        pendingCustomEvents = pendingCustomEvents.filter((e) => e.session.id !== s.id);
        eventsToProcess.forEach((e) => {
            this.logger.info(`Processing delayed event ${e.event} for session ${e.session.id}`);
            // tslint:disable-next-line: no-floating-promises
            this.handleCustomEventWithSession(session, e);
        });
        this.debugOptions.show();
    }
    handleDebugSessionCustomEvent(e) {
        if (this.handleCustomEvent(e))
            return;
        const session = exports.debugSessions.find((ds) => ds.session.id === e.session.id);
        if (!session) {
            this.logger.info(`Did not find session ${e.session.id} to handle ${e.event}. There were ${exports.debugSessions.length} sessions:\n${exports.debugSessions.map((ds) => `  ${ds.session.id}`).join("\n")}`);
            this.logger.info(`Event will be queued and processed when the session start event fires`);
            pendingCustomEvents.push(e);
            return;
        }
        // tslint:disable-next-line: no-floating-promises
        this.handleCustomEventWithSession(session, e);
    }
    handleDebugSessionEnd(s) {
        var _a;
        const sessionIndex = exports.debugSessions.findIndex((ds) => ds.session.id === s.id);
        if (sessionIndex === -1)
            return;
        // Grab the session and remove it from the list so we don't try to interact with it anymore.
        const session = exports.debugSessions[sessionIndex];
        session.hasEnded = true;
        exports.debugSessions.splice(sessionIndex, 1);
        // Close any in-progress progress notifications.
        for (const progressId of Object.keys(session.progress))
            (_a = session.progress[progressId]) === null || _a === void 0 ? void 0 : _a.complete();
        const debugSessionEnd = new Date();
        this.analytics.logDebugSessionDuration(enums_1.DebuggerType[session.debuggerType], debugSessionEnd.getTime() - session.sessionStart.getTime());
        // If this was the last session terminating, then remove all the flags for which service extensions are supported.
        // Really we should track these per-session, but the changes of them being different given we only support one
        // SDK at a time are practically zero.
        if (exports.debugSessions.length === 0) {
            this.vmServices.markAllServicesUnloaded();
            this.vmServices.markAllServiceExtensionsUnloaded();
            this.debugOptions.hide();
            this.debugMetrics.hide();
            exports.isInFlutterDebugModeDebugSession = false;
            exports.isInFlutterProfileModeDebugSession = false;
            for (const debugContext of [
                constants_1.isInDartDebugSessionContext,
                constants_1.isInFlutterDebugModeDebugSessionContext,
                constants_1.isInFlutterProfileModeDebugSessionContext,
                constants_1.isInFlutterReleaseModeDebugSessionContext,
            ])
                vs.commands.executeCommand("setContext", debugContext, false);
        }
    }
    handleCustomEvent(e) {
        if (e.event === "dart.log") {
            const message = e.body;
            const logMessage = `[${e.session.name}] ${message.message}`;
            switch (message.severity) {
                case enums_1.LogSeverity.Warn:
                    this.logger.warn(logMessage, message.category);
                    break;
                case enums_1.LogSeverity.Error:
                    this.logger.error(logMessage, message.category);
                    break;
                default:
                    this.logger.info(logMessage, message.category);
            }
        }
        else if (e.event === "dart.hotRestartRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerRestart();
            this.onWillHotRestartEmitter.fire();
        }
        else if (e.event === "dart.hotReloadRequest") {
            // This event comes back when the user restarts with the Restart button
            // (eg. it wasn't intiated from our extension, so we don't get to log it
            // in the command).
            this.analytics.logDebuggerHotReload();
            this.onWillHotReloadEmitter.fire();
        }
        else if (e.event === "dart.debugMetrics") {
            const memory = e.body.memory;
            const message = `${Math.ceil(memory.current / 1024 / 1024)}MB of ${Math.ceil(memory.total / 1024 / 1024)}MB`;
            this.debugMetrics.text = message;
            this.debugMetrics.tooltip = "This is the amount of memory being consumed by your applications heaps (out of what has been allocated).\n\nNote: memory usage shown in debug builds may not be indicative of usage in release builds. Use profile builds for more accurate figures when testing memory usage.";
            this.debugMetrics.show();
        }
        else if (e.event === "dart.navigate") {
            if (e.body.file && e.body.line && e.body.column) {
                // Only navigate if it's not from inspector, or is from inspector but we're not in full-width mode.
                const navigate = !e.body.fromInspector || config_1.config.devToolsLocation !== "active";
                if (navigate)
                    vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.parse(e.body.file), e.body.line, e.body.column, e.body.inOtherEditorColumn);
                if (this.isInspectingWidget && this.autoCancelNextInspectWidgetMode) {
                    // Add a short delay because this will remove the visible selection.
                    setTimeout(() => vs.commands.executeCommand("flutter.cancelInspectWidget"), 1000);
                }
            }
        }
        else {
            // Not handled, will fall through in the caller.
            return false;
        }
        return true;
    }
    handleCustomEventWithSession(session, e) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            this.vmServices.handleDebugEvent(session, e)
                .catch((e) => this.logger.error(e));
            if (e.event === "dart.webLaunchUrl") {
                const launched = !!e.body.launched;
                if (!launched) {
                    try {
                        yield utils_2.envUtils.openInBrowser(e.body.url, this.logger);
                    }
                    catch (e) {
                        this.logger.error(`Failed to launch URL from Flutter app.webLaunchUrl event: ${e.body.url}`);
                    }
                }
            }
            else if (e.event === "dart.exposeUrl") {
                const originalUrl = e.body.url;
                try {
                    const exposedUrl = yield utils_2.envUtils.exposeUrl(originalUrl, this.logger);
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl });
                }
                catch (e) {
                    this.logger.error(`Failed to expose URL ${originalUrl}: ${e}`);
                    session.session.customRequest("exposeUrlResponse", { originalUrl, exposedUrl: originalUrl });
                }
            }
            else if (e.event === "dart.debuggerUris") {
                session.observatoryUri = e.body.observatoryUri;
                session.vmServiceUri = e.body.vmServiceUri;
                this.onDebugSessionVmServiceAvailableEmitter.fire(session);
                // Open or prompt for DevTools when appropriate.
                const debuggerType = session.session.configuration.debuggerType;
                if (debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.Web) {
                    if (session.session.configuration.openDevTools) {
                        const pageId = session.session.configuration.openDevTools;
                        const page = constants_1.devToolsPages.find((p) => p.id === pageId);
                        if (pageId) {
                            vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, page });
                        }
                        else {
                            vs.window.showWarningMessage(`Debug configuration contain an invalid DevTools page '${pageId}' in 'openDevTools'`);
                        }
                    }
                    else if (config_1.config.openDevTools !== "never") {
                        const shouldLaunch = debuggerType !== enums_1.DebuggerType.Dart || config_1.config.openDevTools === "always";
                        if (shouldLaunch) {
                            // If embedded DevTools is enabled and it's a Flutter app, assume the user wants the Widget inspector.
                            // Otherwise, DevTools will be launched externally (since it's not clear which page they may want).
                            const page = debuggerType === enums_1.DebuggerType.Flutter ? constants_1.widgetInspectorPage : null;
                            vs.commands.executeCommand("dart.openDevTools", { debugSessionId: session.session.id, triggeredAutomatically: true, page });
                        }
                    }
                    else if (debuggerType === enums_1.DebuggerType.Flutter) {
                        // tslint:disable-next-line: no-floating-promises
                        (0, user_prompts_1.showDevToolsNotificationIfAppropriate)(this.context).then((res) => {
                            if (res.shouldAlwaysOpen)
                                config_1.config.setOpenDevTools("flutter");
                        });
                    }
                }
            }
            else if (e.event === "dart.progressStart") {
                // When a debug session is restarted by VS Code (eg. not handled by the DA), the session-end event
                // will not fire so we need to clean up the "Terminating debug session" message manually. Doing it here
                // means it will vanish at the same time as the new one appears, so there are no gaps in progress indicators.
                if (e.body.progressId === constants_1.debugLaunchProgressId) {
                    (_a = session.progress[constants_1.debugTerminatingProgressId]) === null || _a === void 0 ? void 0 : _a.complete();
                    delete session.progress[constants_1.debugTerminatingProgressId];
                }
                const progressId = e.body.progressId;
                const isHotEvent = (progressId === null || progressId === void 0 ? void 0 : progressId.includes("reload")) || (progressId === null || progressId === void 0 ? void 0 : progressId.includes("restart"));
                const progressLocation = isHotEvent && config_1.config.hotReloadProgress === "statusBar" ? vs.ProgressLocation.Window : vs.ProgressLocation.Notification;
                vs.window.withProgress(
                // TODO: This was previously Window to match what we'd get using DAP progress
                // notifications but users prefer larger notifications as they're easier to
                // see (especially when it comes to things like waiting for debug extension).
                // https://github.com/Dart-Code/Dart-Code/issues/2597
                // If this is changed back, ensure the waiting-for-debug-extension notification
                // is still displayed with additional description.
                { location: progressLocation, title: e.body.title }, (progress) => {
                    var _a, _b;
                    // Complete any existing one with this ID.
                    (_a = session.progress[e.body.progressId]) === null || _a === void 0 ? void 0 : _a.complete();
                    // Build a new progress and store it in the session.
                    const completer = new utils_1.PromiseCompleter();
                    session.progress[e.body.progressId] = new debug_1.ProgressMessage(progress, completer);
                    if (e.body.message)
                        (_b = session.progress[e.body.progressId]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
                    return completer.promise;
                });
            }
            else if (e.event === "dart.progressUpdate") {
                (_b = session.progress[e.body.progressId]) === null || _b === void 0 ? void 0 : _b.report(e.body.message);
            }
            else if (e.event === "dart.progressEnd") {
                if (e.body.message) {
                    (_c = session.progress[e.body.progressId]) === null || _c === void 0 ? void 0 : _c.report(e.body.message);
                    yield new Promise((resolve) => setTimeout(resolve, 400));
                }
                (_d = session.progress[e.body.progressId]) === null || _d === void 0 ? void 0 : _d.complete();
            }
            else if (e.event === "dart.flutter.widgetErrorInspectData") {
                if (this.suppressFlutterWidgetErrors || !config_1.config.showInspectorNotificationsForWidgetErrors)
                    return;
                const data = e.body;
                if (data.devToolsUrl !== (yield this.devTools.devtoolsUrl))
                    return;
                // To avoid spam, when we show this dialog we will set a flag that prevents any more
                // of these types of dialogs until it is dismissed or 5 seconds have passed.
                this.suppressFlutterWidgetErrors = true;
                const timer = setTimeout(() => this.suppressFlutterWidgetErrors = false, 5000);
                const inspectAction = `Inspect Widget`;
                const choice = yield vs.window.showWarningMessage(data.errorDescription, inspectAction, constants_1.doNotAskAgainAction);
                if (choice === inspectAction && session.vmServiceUri) {
                    this.devTools.spawnForSession(session, {
                        inspectorRef: data.inspectorReference,
                        page: constants_1.widgetInspectorPage,
                    });
                }
                else if (choice === constants_1.doNotAskAgainAction) {
                    config_1.config.setShowInspectorNotificationsForWidgetErrors(false);
                }
                clearTimeout(timer);
                this.suppressFlutterWidgetErrors = false;
            }
            else if (e.event === "flutter.appStarted") {
                session.hasStarted = true;
            }
        });
    }
    toggleDebugOptions() {
        // -1 is because we skip the last combination when toggling since it seems uncommon.
        this.currentDebugOption = (this.currentDebugOption + 1) % (enums_1.debugOptionNames.length - 1);
        this.applyNewDebugOption();
    }
    applyNewDebugOption() {
        this.debugOptions.text = `Debug ${enums_1.debugOptionNames[this.currentDebugOption]}`;
        const debugExternalPackageLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodePackages || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        const debugSdkLibraries = this.currentDebugOption === enums_1.DebugOption.MyCodeSdk || this.currentDebugOption === enums_1.DebugOption.MyCodePackagesSdk;
        config_1.config.setGlobalDebugExternalPackageLibraries(debugExternalPackageLibraries);
        config_1.config.setGlobalDebugSdkLibraries(debugSdkLibraries);
        exports.debugSessions.forEach((session) => {
            session.session.customRequest("updateDebugOptions", {
                debugExternalPackageLibraries,
                debugSdkLibraries,
            });
        });
    }
    updateEditorContexts(e) {
        const isRunnable = !!(e && e.document && e.document.uri.scheme === "file" && (0, utils_3.isValidEntryFile)((0, fs_1.fsPath)(e.document.uri)));
        vs.commands.executeCommand("setContext", CURRENT_FILE_RUNNABLE, isRunnable);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DebugCommands = DebugCommands;


/***/ }),

/***/ 7244:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditCommands = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(7220);
const editors_1 = __webpack_require__(8805);
const terminals_1 = __webpack_require__(6368);
class EditCommands {
    constructor() {
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.jumpToLineColInUri", this.jumpToLineColInUri, this), vs.commands.registerCommand("_dart.showCode", utils_1.showCode, this), vs.commands.registerCommand("dart.writeRecommendedSettings", this.writeRecommendedSettings, this), vs.commands.registerCommand("dart.printSelectionToTerminal", this.printSelectionToTerminal, this), vs.commands.registerCommand("dart.toggleLineComment", this.toggleLineComment, this), vs.commands.registerCommand("dart.toggleDartdocComment", this.toggleDartdocComment, this));
    }
    jumpToLineColInUri(uri, lineNumber, columnNumber, inOtherEditorColumn) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || uri.scheme !== "file")
                return;
            // When navigating while using the inspector, we don't expect this file to replace
            // the inspector tab, so we always target a column that's showing an editor.
            const column = inOtherEditorColumn
                ? (0, utils_1.firstEditorColumn)() || vs.ViewColumn.Beside
                : vs.ViewColumn.Active;
            const doc = yield vs.workspace.openTextDocument(uri);
            const editor = yield vs.window.showTextDocument(doc, column, inOtherEditorColumn);
            if (lineNumber) {
                const line = doc.lineAt(lineNumber > 0 ? lineNumber - 1 : 0);
                if (!columnNumber || columnNumber > line.range.end.character)
                    columnNumber = line.firstNonWhitespaceCharacterIndex;
                else if (columnNumber > 0) {
                    columnNumber--;
                }
                const char = line.range.start.translate({ characterDelta: columnNumber });
                (0, utils_1.showCode)(editor, line.range, line.range, new vs.Range(char, char));
            }
        });
    }
    writeRecommendedSettings() {
        return __awaiter(this, void 0, void 0, function* () {
            const topLevelConfig = vs.workspace.getConfiguration("", null);
            const dartLanguageConfig = topLevelConfig.inspect("[dart]");
            const existingConfig = dartLanguageConfig ? dartLanguageConfig.globalValue : undefined;
            const newValues = Object.assign({}, constants_1.dartRecommendedConfig, existingConfig);
            yield topLevelConfig.update("[dart]", newValues, vs.ConfigurationTarget.Global);
            const action = yield vs.window.showInformationMessage("Recommended settings were written to the [dart] section of your global settings file", constants_1.openSettingsAction);
            if (action === constants_1.openSettingsAction)
                yield vs.commands.executeCommand("workbench.action.openSettingsJson");
        });
    }
    printSelectionToTerminal() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const editor = (0, editors_1.getActiveRealFileEditor)();
            const selection = editor === null || editor === void 0 ? void 0 : editor.selection;
            const text = (_a = editor === null || editor === void 0 ? void 0 : editor.document) === null || _a === void 0 ? void 0 : _a.getText(selection);
            if (text) {
                (0, terminals_1.writeToPseudoTerminal)([text]);
            }
        });
    }
    toggleDartdocComment() {
        return this.toggleLineComment(true);
    }
    toggleLineComment(onlyDartdoc = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = (0, editors_1.getActiveRealFileEditor)();
            if (!editor || !editor.selections.length)
                return;
            const document = editor.document;
            const selections = editor.selections;
            // Track the prefix that matches all lines in all selections.
            // If any line does not start with `///` then it cannot be TRIPLE.
            // If any line does not start with '//' then it cannot be DOUBLE.
            // We start from the highest and work down as we find lines that don't match.
            let commonPrefix = "TRIPLE";
            check: {
                for (const selection of selections) {
                    for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                        const line = document.lineAt(lineNumber);
                        // Skip over blank lines, as they won't have comment markers and shouldn't
                        // influence which common prefix we find.
                        if (line.isEmptyOrWhitespace)
                            continue;
                        const text = line.text.trim();
                        if (commonPrefix === "TRIPLE" && !text.startsWith("///"))
                            commonPrefix = text.startsWith("//") ? "DOUBLE" : "NONE";
                        else if (commonPrefix === "DOUBLE" && !text.startsWith("//"))
                            commonPrefix = "NONE";
                        // Any time we hit NONE, we can bail out.
                        if (commonPrefix === "NONE")
                            break check;
                    }
                }
            }
            if (onlyDartdoc) {
                switch (commonPrefix) {
                    case "NONE":
                        // If no prefix, insert triples.
                        this.prefixLines(editor, selections, "/// ");
                        break;
                    case "DOUBLE":
                        // If already double, just add the additional one slash.
                        this.prefixLines(editor, selections, "/");
                        break;
                    case "TRIPLE":
                        // If already triple, remove slashes.
                        this.removeLinePrefixes(editor, selections, ["/// ", "///"]);
                        break;
                }
            }
            else {
                switch (commonPrefix) {
                    case "NONE":
                        // If no prefix, insert doubles.
                        this.prefixLines(editor, selections, "// ");
                        break;
                    case "DOUBLE":
                        // If already double, add an additional slash to make triple.
                        this.prefixLines(editor, selections, "/");
                        break;
                    case "TRIPLE":
                        // If already triple, remove slashes.
                        this.removeLinePrefixes(editor, selections, ["/// ", "///"]);
                        break;
                }
            }
        });
    }
    prefixLines(editor, selections, prefix) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        // Find the minimum indent, so we can insert all slashes at the same level even if
        // there is indented code.
        let minIndent;
        for (const selection of selections) {
            for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                const line = document.lineAt(lineNumber);
                if (line.isEmptyOrWhitespace)
                    continue;
                if (!minIndent || line.firstNonWhitespaceCharacterIndex < minIndent)
                    minIndent = line.firstNonWhitespaceCharacterIndex;
            }
        }
        editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const insertionPoint = line.range.start.translate(0, minIndent);
                    edit.insert(insertionPoint, prefix);
                }
            }
        });
    }
    removeLinePrefixes(editor, selections, prefixes) {
        const document = editor.document;
        // In case we have overlapping selections, keep track of lines we've done.
        const doneLines = new Set();
        editor.edit((edit) => {
            for (const selection of selections) {
                for (let lineNumber = selection.start.line; lineNumber <= selection.end.line; lineNumber++) {
                    if (doneLines.has(lineNumber))
                        continue;
                    doneLines.add(lineNumber);
                    const line = document.lineAt(lineNumber);
                    if (line.isEmptyOrWhitespace)
                        continue;
                    const lineContentStart = line.range.start.translate(0, line.firstNonWhitespaceCharacterIndex);
                    for (const prefix of prefixes) {
                        const possiblePrefixRange = new vs.Range(lineContentStart, lineContentStart.translate(0, prefix.length));
                        const possiblePrefix = document.getText(possiblePrefixRange);
                        if (possiblePrefix === prefix) {
                            edit.delete(possiblePrefixRange);
                            break;
                        }
                    }
                }
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.EditCommands = EditCommands;


/***/ }),

/***/ 7511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasOverlappingEdits = exports.DasEditCommands = void 0;
const fs = __webpack_require__(7147);
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const editors = __webpack_require__(8805);
class DasEditCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("_dart.organizeImports", this.organizeImports, this), vs.commands.registerCommand("dart.sortMembers", this.sortMembers, this), vs.commands.registerCommand("_dart.applySourceChange", this.applyEdits, this), vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this));
    }
    getActiveDoc() {
        var _a;
        return (_a = this.getActiveEditor()) === null || _a === void 0 ? void 0 : _a.document;
    }
    getActiveEditor() {
        return editors.getActiveRealFileEditor();
    }
    organizeImports(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editOrganizeDirectives, "Organize Imports", document);
    }
    sortMembers(document) {
        document = document || this.getActiveDoc();
        return this.sendEdit(this.analyzer.editSortMembers, "Sort Members", document);
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = this.getActiveEditor();
            if (!editor || !editor.selection || !this.analyzer.capabilities.hasCompleteStatementFix)
                return;
            const document = editor.document;
            const file = (0, fs_1.fsPath)(document.uri);
            const offset = document.offsetAt(editor.selection.end);
            const res = yield this.analyzer.editGetStatementCompletion({ file, offset });
            if (res && res.change)
                yield this.applyEdits(document, res.change);
        });
    }
    sendEdit(f, commandName, document) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!document || !editors.isDartDocument(document)) {
                vs.window.showWarningMessage("Not a Dart file.");
                return;
            }
            const originalDocumentVersion = document.version;
            f = f.bind(this.analyzer); // Yay JavaScript!
            try {
                const response = yield f({ file: (0, fs_1.fsPath)(document.uri) });
                const edit = response.edit;
                if (edit.edits.length === 0)
                    return;
                if (document.isClosed) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been closed.`);
                    return;
                }
                if (document.version !== originalDocumentVersion) {
                    vs.window.showErrorMessage(`Error running ${commandName}: Document has been modified.`);
                    return;
                }
                const editBuilder = new vs.WorkspaceEdit();
                edit.edits.forEach((edit) => {
                    const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                    editBuilder.replace(document.uri, range, edit.replacement);
                });
                yield vs.workspace.applyEdit(editBuilder);
            }
            catch (error) {
                vs.window.showErrorMessage(`Error running ${commandName}: ${(0, utils_1.errorString)(error)}.`);
            }
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
    applyEdits(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            // We can only apply with snippets if there's a single change.
            if (change.edits.length === 1 && change.linkedEditGroups && change.linkedEditGroups.length !== 0)
                return this.applyEditsWithSnippets(initiatingDocument, change);
            // VS Code expects offsets to be based on the original document, but the analysis server provides
            // them assuming all previous edits have already been made. This means if the server provides us a
            // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
            // If this happens; we will fall back to sequential edits and write a warning.
            const hasProblematicEdits = hasOverlappingEdits(change);
            if (hasProblematicEdits) {
                this.logger.warn("Falling back to sequential edits due to overlapping edits in server.");
            }
            const applyEditsSequentially = hasProblematicEdits;
            // Otherwise, just make all the edits without the snippets.
            let changes = applyEditsSequentially ? undefined : new vs.WorkspaceEdit();
            for (const edit of change.edits) {
                const uri = vs.Uri.file(edit.file);
                // We can only create files with edits that are at 0/0 because we can't open the document if it doesn't exist.
                // If we create the file ourselves, it won't go into the single undo buffer.
                if (!fs.existsSync(edit.file) && edit.edits.find((e) => e.offset !== 0 || e.length !== 0)) {
                    this.logger.error(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    vs.window.showErrorMessage(`Unable to edit file ${edit.file} because it does not exist and had an edit that was not the start of the file`);
                    continue;
                }
                const document = fs.existsSync(edit.file) ? yield vs.workspace.openTextDocument(uri) : undefined;
                if (changes)
                    changes.createFile(uri, { ignoreIfExists: true });
                for (const e of edit.edits) {
                    if (!changes) {
                        changes = new vs.WorkspaceEdit();
                        changes.createFile(uri, { ignoreIfExists: true });
                    }
                    const range = document
                        ? new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length))
                        : new vs.Range(new vs.Position(0, 0), new vs.Position(0, 0));
                    changes.replace(uri, range, e.replacement);
                    if (applyEditsSequentially) {
                        yield vs.workspace.applyEdit(changes);
                        changes = undefined;
                    }
                }
            }
            // If we weren't applying sequentially
            if (changes)
                yield vs.workspace.applyEdit(changes);
            // Set the cursor position.
            if (change.selection) {
                const uri = vs.Uri.file(change.selection.file);
                const document = yield vs.workspace.openTextDocument(uri);
                const editor = yield vs.window.showTextDocument(document);
                const pos = document.positionAt(change.selection.offset);
                const selection = new vs.Selection(pos, pos);
                editor.selection = selection;
            }
        });
    }
    applyEditsWithSnippets(initiatingDocument, change) {
        return __awaiter(this, void 0, void 0, function* () {
            const edit = change.edits[0];
            const document = yield vs.workspace.openTextDocument(edit.file);
            const editor = yield vs.window.showTextDocument(document);
            // Apply of all of the edits.
            yield editor.edit((eb) => {
                edit.edits.forEach((e) => {
                    eb.replace(new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                });
            });
            const documentText = editor.document.getText();
            // Create a list of all the placeholders.
            const placeholders = [];
            let placeholderNumber = 1;
            change.linkedEditGroups.forEach((leg) => {
                leg.positions.forEach((pos) => {
                    const defaultValue = documentText.substr(pos.offset, leg.length);
                    let choices = leg.suggestions ? leg.suggestions.map((s) => s.value) : undefined;
                    if (defaultValue && choices && choices.indexOf(defaultValue) === -1) {
                        choices = [defaultValue, ...choices];
                    }
                    placeholders.push({ offset: pos.offset, length: leg.length, defaultValue, choices, placeholderNumber });
                });
                placeholderNumber++;
            });
            // Ensure they're in offset order so the next maths works!
            placeholders.sort((p1, p2) => p1.offset - p2.offset);
            const snippet = new vs.SnippetString();
            const firstPlaceholder = placeholders[0];
            const lastPlaceholder = placeholders[placeholders.length - 1];
            const startPos = firstPlaceholder.offset;
            const endPos = lastPlaceholder.offset + lastPlaceholder.length;
            let currentPos = startPos;
            placeholders.forEach((p) => {
                // Add the text from where we last were up to current placeholder.
                if (currentPos !== p.offset)
                    snippet.appendText(documentText.substring(currentPos, p.offset));
                // Add the choices / placeholder.
                if (p.choices && p.choices.length > 1)
                    // TODO: Change this back to appendChoice when it handles commas correctly
                    // https://github.com/microsoft/vscode/issues/107220
                    // snippet.appendChoice(p.choices, p.placeholderNumber);
                    snippet.value += "${" + p.placeholderNumber.toString() + "|" + p.choices.map((c) => this.snippetStringEscape(c)).join(",") + "|}";
                else
                    snippet.appendPlaceholder(p.defaultValue, p.placeholderNumber);
                currentPos = p.offset + p.length;
            });
            // Replace the document.
            yield editor.insertSnippet(snippet, new vs.Range(document.positionAt(startPos), document.positionAt(endPos)));
            // Ensure original document is the active one.
            yield vs.window.showTextDocument(initiatingDocument);
        });
    }
    snippetStringEscape(value) {
        return value.replace(/\$|}|\\|,/g, "\\$&");
    }
}
exports.DasEditCommands = DasEditCommands;
function hasOverlappingEdits(change) {
    const priorEdits = {};
    for (const edit of change.edits) {
        if (!priorEdits[edit.file])
            priorEdits[edit.file] = [];
        for (const e of edit.edits) {
            if (priorEdits[edit.file].find((pe) => pe.offset <= e.offset))
                return true;
            priorEdits[edit.file].push(e);
        }
    }
    return false;
}
exports.hasOverlappingEdits = hasOverlappingEdits;


/***/ }),

/***/ 6039:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspEditCommands = void 0;
const vs = __webpack_require__(9496);
const vscode_languageclient_1 = __webpack_require__(2850);
const editors = __webpack_require__(8805);
class LspEditCommands {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.commands = [];
        this.commands.push(vs.commands.registerCommand("dart.sortMembers", () => this.runCodeAction("source.sortMembers")));
        // TODO: Enable this when https://github.com/dart-lang/sdk/issues/33521
        // is resolved.
        // this.commands.push(
        // 	vs.commands.registerCommand("dart.completeStatement", this.completeStatement, this),
        // );
    }
    getActiveEditor() {
        return editors.getActiveRealFileEditor();
    }
    runCodeAction(action) {
        return __awaiter(this, void 0, void 0, function* () {
            return vs.commands.executeCommand("editor.action.codeAction", { kind: action, apply: "ifSingle" });
        });
    }
    completeStatement() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = this.getActiveEditor();
            if (!editor || !editor.selection)
                return;
            const edit = yield this.analyzer.completeStatement({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (edit) {
                if (yield this.validDocumentVersionsStillMatch(edit)) {
                    const codeEdit = yield this.analyzer.client.protocol2CodeConverter.asWorkspaceEdit(edit);
                    if (!(yield vs.workspace.applyEdit(codeEdit))) {
                        vs.window.showErrorMessage("VS Code failed to apply edits");
                    }
                }
                else {
                    vs.window.showErrorMessage("Documents have been modified so edits could not be applied");
                }
            }
        });
    }
    validDocumentVersionsStillMatch(edit) {
        return __awaiter(this, void 0, void 0, function* () {
            // If the edit didn't have any documentChanges (it has changes) we have
            // to assume it's all up-to-date.
            if (!edit.documentChanges)
                return true;
            const openTextDocuments = new Map();
            vs.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
            for (const change of edit.documentChanges) {
                if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    if (vscode_languageclient_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                        const textDocument = openTextDocuments.get(change.textDocument.uri);
                        if (textDocument && textDocument.version !== change.textDocument.version) {
                            return false;
                        }
                    }
                }
            }
            return true;
        });
    }
    dispose() {
        for (const command of this.commands)
            command.dispose();
    }
}
exports.LspEditCommands = LspEditCommands;


/***/ }),

/***/ 2364:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterCommands = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const dartdocs_1 = __webpack_require__(9439);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
const flutter_samples_1 = __webpack_require__(3150);
const config_1 = __webpack_require__(4165);
const flutter_docs_snippets_1 = __webpack_require__(8137);
const util = __webpack_require__(8779);
const input_1 = __webpack_require__(9662);
const projects_2 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
class FlutterCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager) {
        super(logger, context, workspace, dartCapabilities);
        this.sdkUtils = sdkUtils;
        this.flutterCapabilities = flutterCapabilities;
        this.deviceManager = deviceManager;
        this.disposables.push(vs.commands.registerCommand("flutter.clean", this.flutterClean, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.screenshot.touchBar", (args) => vs.commands.executeCommand("flutter.screenshot", args)));
        this.disposables.push(vs.commands.registerCommand("flutter.screenshot", this.flutterScreenshot, this));
        this.disposables.push(vs.commands.registerCommand("flutter.doctor", this.flutterDoctor, this));
        this.disposables.push(vs.commands.registerCommand("flutter.upgrade", this.flutterUpgrade, this));
        this.disposables.push(vs.commands.registerCommand("flutter.createProject", this.createFlutterProject, this));
        this.disposables.push(vs.commands.registerCommand("_dart.flutter.createSampleProject", this.createFlutterSampleProject, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.create", this.flutterCreate, this));
        this.disposables.push(vs.commands.registerCommand("_flutter.clean", this.flutterClean, this));
    }
    flutterClean(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!selection) {
                const path = yield (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter clean" in`, selection, true);
                if (!path)
                    return;
                selection = vs.Uri.file(path);
            }
            return this.runFlutter(["clean"], selection);
        });
    }
    flutterScreenshot() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            let shouldNotify = false;
            // If there is no path for this session, or it differs from config, use the one from config.
            if (!this.flutterScreenshotPath ||
                (config_1.config.flutterScreenshotPath && this.flutterScreenshotPath !== config_1.config.flutterScreenshotPath)) {
                this.flutterScreenshotPath = config_1.config.flutterScreenshotPath;
                shouldNotify = true;
            }
            // If path is still empty, bring up the folder selector.
            if (!this.flutterScreenshotPath) {
                const selectedFolder = yield vs.window.showOpenDialog({ canSelectFolders: true, openLabel: "Set screenshots folder" });
                if (selectedFolder && selectedFolder.length > 0) {
                    // Set variable to selected path. This allows prompting the user only once.
                    this.flutterScreenshotPath = selectedFolder[0].path;
                    shouldNotify = true;
                }
                else {
                    // Do nothing if the user cancelled the folder selection.
                    return;
                }
            }
            // Ensure folder exists.
            (0, fs_1.mkDirRecursive)(this.flutterScreenshotPath);
            const debugSession = vs.debug.activeDebugSession;
            if (!debugSession) {
                vs.window.showErrorMessage("You must have an active Flutter debug session to take screenshots");
                return;
            }
            if (debugSession.type !== "dart") {
                vs.window.showErrorMessage("The active debug session is not a Flutter app");
                return;
            }
            const projectFolder = debugSession.configuration.cwd;
            const deviceId = ((_a = debugSession.configuration.deviceId) !== null && _a !== void 0 ? _a : (_c = (_b = this.deviceManager) === null || _b === void 0 ? void 0 : _b.currentDevice) === null || _c === void 0 ? void 0 : _c.id);
            const outputFilename = (0, fs_1.nextAvailableFilename)(this.flutterScreenshotPath, "flutter_", ".png");
            const args = ["screenshot"];
            if (deviceId) {
                args.push("-d");
                args.push(deviceId);
            }
            args.push("-o");
            args.push(path.join(this.flutterScreenshotPath, outputFilename));
            yield this.runFlutterInFolder(projectFolder, args, "screenshot");
            if (shouldNotify) {
                const res = yield vs.window.showInformationMessage(`Screenshots will be saved to ${this.flutterScreenshotPath}`, "Show Folder");
                if (res)
                    yield vs.commands.executeCommand("revealFileInOS", vs.Uri.file(this.flutterScreenshotPath));
            }
        });
    }
    flutterDoctor() {
        var _a;
        if (!this.workspace.sdks.flutter) {
            this.sdkUtils.showFlutterActivationFailure("flutter.doctor");
            return;
        }
        const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
        if (!fs.existsSync(tempDir))
            fs.mkdirSync(tempDir);
        return this.runFlutterInFolder(tempDir, ["doctor", "-v"], "flutter", true, (_a = this.workspace.config) === null || _a === void 0 ? void 0 : _a.flutterDoctorScript);
    }
    flutterUpgrade() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.workspace.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.upgrade");
                return;
            }
            const tempDir = path.join(os.tmpdir(), "dart-code-cmd-run");
            if (!fs.existsSync(tempDir))
                fs.mkdirSync(tempDir);
            // Don't prompt to reload when the version changes, as we automatically reload here.
            sdk_1.commandState.promptToReloadOnVersionChanges = false;
            yield this.runFlutterInFolder(tempDir, ["upgrade"], "flutter", true);
            yield util.promptToReloadExtension();
        });
    }
    flutterCreate({ projectName, projectPath, triggerData, platform }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!projectPath) {
                projectPath = yield (0, projects_2.getFolderToRunCommandIn)(this.logger, `Select the folder to run "flutter create" in`, undefined, true);
                if (!projectPath)
                    return;
            }
            const template = triggerData === null || triggerData === void 0 ? void 0 : triggerData.template;
            const templateSupportsPlatform = !!constants_1.flutterCreateTemplatesSupportingPlatforms.find((t) => { var _a; return (_a = t === template) !== null && _a !== void 0 ? _a : "app"; });
            const defaultPlatforms = config_1.config.flutterCreatePlatforms;
            const args = ["create"];
            if (config_1.config.flutterCreateOffline || config_1.config.offline) {
                args.push("--offline");
            }
            if (templateSupportsPlatform) {
                if (platform) {
                    args.push("--platforms");
                    args.push(platform);
                }
                else if (defaultPlatforms) {
                    for (const platform of defaultPlatforms) {
                        args.push("--platforms");
                        args.push(platform);
                    }
                }
            }
            if (projectName) {
                args.push("--project-name");
                args.push(projectName);
            }
            if (config_1.config.flutterCreateOrganization) {
                args.push("--org");
                args.push(config_1.config.flutterCreateOrganization);
            }
            if (config_1.config.flutterCreateIOSLanguage && config_1.config.flutterCreateIOSLanguage !== "swift") {
                args.push("--ios-language");
                args.push(config_1.config.flutterCreateIOSLanguage);
            }
            if (config_1.config.flutterCreateAndroidLanguage && config_1.config.flutterCreateAndroidLanguage !== "kotlin") {
                args.push("--android-language");
                args.push(config_1.config.flutterCreateAndroidLanguage);
            }
            if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) {
                args.push("--sample");
                args.push(triggerData.sample);
                args.push("--overwrite");
            }
            if (template) {
                args.push("--template");
                args.push(template);
                if ((triggerData === null || triggerData === void 0 ? void 0 : triggerData.empty) && this.flutterCapabilities.supportsCreateEmpty)
                    args.push("--empty");
                args.push("--overwrite");
            }
            args.push(".");
            const exitCode = yield this.runFlutterInFolder(projectPath, args, projectName);
            if (!vscode_1.vsCodeVersion.supportsDebugWithoutLaunchJson) {
                this.writeDefaultLaunchJson(projectPath);
            }
            return exitCode;
        });
    }
    writeDefaultLaunchJson(projectPath) {
        const launchJsonFolder = path.join(projectPath, vscode_1.vsCodeVersion.editorConfigFolder);
        const launchJsonFile = path.join(launchJsonFolder, "launch.json");
        if (!fs.existsSync(launchJsonFile)) {
            (0, fs_1.mkDirRecursive)(launchJsonFolder);
            fs.writeFileSync(launchJsonFile, constants_1.defaultLaunchJson);
        }
    }
    getFlutterTemplates() {
        const templates = [
            {
                detail: "Generate a Flutter application with descriptive comments and tests.",
                label: "Application",
                template: { id: "app" },
            },
            {
                condition: this.flutterCapabilities.supportsCreateEmpty,
                detail: "Generate a Flutter application without descriptive comments or tests.",
                label: "Application (empty)",
                template: { id: "app", empty: true },
            },
            {
                detail: "Generate a project to add a Flutter module to an existing Android or iOS application.",
                label: "Module",
                template: { id: "module" },
            },
            {
                detail: "Generate a shareable Flutter project containing modular Dart code.",
                label: "Package",
                template: { id: "package" },
            },
            {
                detail: "Generate a shareable Flutter project containing an API in Dart code with a platform-specific implementation for Android, for iOS code, or for both.",
                label: "Plugin",
                template: { id: "plugin" },
            },
            {
                condition: this.flutterCapabilities.supportsCreateSkeleton,
                detail: "Generate a List View / Detail View Flutter application that follows community best practices.",
                label: "Skeleton",
                template: { id: "skeleton" },
            },
        ].filter((t) => t.condition !== false);
        return templates;
    }
    createFlutterProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
                return;
            }
            const pickItems = this.getFlutterTemplates();
            const selectedTemplate = yield vs.window.showQuickPick(pickItems, {
                matchOnDescription: true,
                placeHolder: "Which Flutter template?",
            });
            if (!selectedTemplate)
                return;
            return this.createFlutterProjectForTemplate(selectedTemplate.template);
        });
    }
    createFlutterProjectForTemplate(template) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("flutter.createProject");
                return;
            }
            // If already in a workspace, set the default folder to something nearby.
            const folders = yield vs.window.showOpenDialog({
                canSelectFolders: true,
                defaultUri: this.context.lastUsedNewProjectPath ? vs.Uri.file(this.context.lastUsedNewProjectPath) : undefined,
                openLabel: "Select a folder to create the project in",
            });
            if (!folders || folders.length !== 1)
                return;
            const folderPath = (0, fs_1.fsPath)(folders[0]);
            this.context.lastUsedNewProjectPath = folderPath;
            const defaultName = (0, fs_1.nextAvailableFilename)(folderPath, "flutter_application_");
            const name = yield this.promptForNameWithSettings(defaultName, folderPath);
            if (!name)
                return;
            const projectFolderUri = vs.Uri.file(path.join(folderPath, name));
            const projectFolderPath = (0, fs_1.fsPath)(projectFolderUri);
            if (fs.existsSync(projectFolderPath)) {
                vs.window.showErrorMessage(`A folder named ${name} already exists in ${folderPath}`);
                return;
            }
            // Create the empty folder so we can open it.
            fs.mkdirSync(projectFolderPath);
            const triggerData = template
                ? { template: template.id, empty: template.empty }
                : undefined;
            (0, projects_1.writeFlutterTriggerFile)(projectFolderPath, triggerData);
            // If we're using a custom SDK, we need to apply it to the new project too.
            if (config_1.config.workspaceFlutterSdkPath)
                (0, projects_1.writeFlutterSdkSettingIntoProject)(config_1.config.workspaceFlutterSdkPath, projectFolderPath);
            vs.commands.executeCommand("vscode.openFolder", projectFolderUri);
            return projectFolderUri;
        });
    }
    promptForNameWithSettings(defaultName, folderPath) {
        return __awaiter(this, void 0, void 0, function* () {
            while (true) {
                const response = yield (0, input_1.showInputBoxWithSettings)(this.context, {
                    placeholder: defaultName,
                    prompt: "Enter a name for your new project",
                    title: "Project Name",
                    validation: (s) => this.validateFlutterProjectName(s, folderPath),
                    value: defaultName,
                });
                if (response === "SETTINGS") {
                    yield (0, input_1.showSimpleSettingsEditor)("Settings for new Flutter projects", "Select a setting to change (or 'Escape' to cancel)", () => getCurrentFlutterCreateSettings());
                    continue;
                }
                else if (response) {
                    return response.value;
                }
                else {
                    return undefined;
                }
            }
        });
    }
    createFlutterSampleProject() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.sdks || !this.sdks.flutter) {
                this.sdkUtils.showFlutterActivationFailure("_dart.flutter.createSampleProject");
                return;
            }
            // Fetch the JSON for the available samples.
            let snippets;
            try {
                snippets = yield (0, flutter_docs_snippets_1.getFlutterSnippets)(this.logger, this.sdks, this.flutterCapabilities);
            }
            catch (_a) {
                vs.window.showErrorMessage("Unable to retrieve Flutter documentation snippets");
                return;
            }
            const sortedSnippets = (0, array_1.sortBy)(snippets, (s) => s.element);
            const selectedSnippet = yield vs.window.showQuickPick(sortedSnippets.map((s) => ({
                description: `${s.package}/${s.library}`,
                detail: (0, dartdocs_1.stripMarkdown)(s.description),
                label: s.element,
                snippet: s,
            })), {
                matchOnDescription: true,
                placeHolder: "Which Flutter sample?",
            });
            if (!selectedSnippet)
                return;
            return (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, selectedSnippet.snippet.id, config_1.config.workspaceFlutterSdkPath);
        });
    }
    validateFlutterProjectName(input, folderDir) {
        if (!sdk_1.packageNameRegex.test(input))
            return "Flutter project names should be all lowercase, with underscores to separate words";
        const bannedNames = ["flutter", "flutter_test", "test", "integration_test"];
        if (bannedNames.includes(input))
            return `You may not use ${input} as the name for a flutter project`;
        if (fs.existsSync(path.join(folderDir, input)))
            return `A project with this name already exists within the selected directory`;
    }
}
exports.FlutterCommands = FlutterCommands;
function getCurrentFlutterCreateSettings() {
    var _a;
    return [
        {
            currentValue: config_1.config.flutterCreateOrganization || "com.example",
            description: config_1.config.flutterCreateOrganization || "com.example",
            detail: "The organization responsible for your new Flutter project, in reverse domain name notation. This string is used in Java package names and as prefix in the iOS bundle identifier.",
            label: "Organization",
            setValue: (newValue) => config_1.config.setFlutterCreateOrganization(newValue),
            settingKind: "STRING",
        },
        {
            currentValue: config_1.config.flutterCreateAndroidLanguage || "kotlin",
            description: config_1.config.flutterCreateAndroidLanguage || "kotlin",
            detail: "The language to use for Android-specific code, either Java (legacy) or Kotlin (recommended).",
            enumValues: ["kotlin", "java"],
            label: "Android Language",
            setValue: (newValue) => config_1.config.setFlutterCreateAndroidLanguage(newValue),
            settingKind: "ENUM",
        },
        {
            currentValue: config_1.config.flutterCreateIOSLanguage || "swift",
            description: config_1.config.flutterCreateIOSLanguage || "swift",
            detail: "The language to use for iOS-specific code, either ObjectiveC (legacy) or Swift (recommended).",
            enumValues: ["swift", "objc"],
            label: "iOS Language",
            setValue: (newValue) => config_1.config.setFlutterCreateIOSLanguage(newValue),
            settingKind: "ENUM",
        },
        {
            currentValue: config_1.config.offline ? "enabled" : "not enabled",
            description: config_1.config.offline ? "enabled" : "not enabled",
            detail: "When commands like \"flutter pub get\" or \"flutter create\" are run, this indicates whether to run in offline mode or not. In offline mode, it will need to have all dependencies already available in the pub cache to succeed.",
            label: "Offline Mode",
            setValue: (newValue) => config_1.config.setOffline(newValue),
            settingKind: "BOOL",
        },
        {
            currentValue: (_a = config_1.config.flutterCreatePlatforms) !== null && _a !== void 0 ? _a : constants_1.flutterCreateAvailablePlatforms,
            description: config_1.config.flutterCreatePlatforms ? config_1.config.flutterCreatePlatforms.join(", ") : "all",
            detail: "The platforms that should be enabled for new Flutter applications.",
            enumValues: [{
                    values: constants_1.flutterCreateAvailablePlatforms,
                },
                /* {
                    group: "Defaults",
                    values: ["Set as default..."],
                } */ 
            ],
            label: "Platforms",
            setValue: (newValues) => __awaiter(this, void 0, void 0, function* () {
                const valueToSave = newValues.length === constants_1.flutterCreateAvailablePlatforms.length
                    ? undefined // all
                    : newValues;
                yield config_1.config.setFlutterCreatePlatforms(valueToSave);
            }),
            settingKind: "MULTI_ENUM",
        },
    ];
}


/***/ }),

/***/ 9021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineCommands = exports.flutterOutlineCommands = void 0;
const vs = __webpack_require__(9496);
exports.flutterOutlineCommands = [
    "refactor.flutter.wrap.center",
    "refactor.flutter.wrap.padding",
    "refactor.flutter.wrap.column",
    "refactor.flutter.move.up",
    "refactor.flutter.move.down",
    "refactor.flutter.removeWidget",
];
class FlutterOutlineCommands {
    constructor(tree, context) {
        this.tree = tree;
        for (const id of exports.flutterOutlineCommands) {
            context.subscriptions.push(vs.commands.registerCommand("_flutter.outline." + id, () => this.applyRefactoring(id)));
        }
    }
    applyRefactoring(refactorType) {
        if (!this.tree.selection || this.tree.selection.length !== 1) {
            console.error(`Invalid selection when running Flutter Outline refactor: ${refactorType}`);
            return;
        }
        const widget = this.tree.selection[0];
        const fix = widget.fixes.find((f) => f.kind && f.kind.value.endsWith(refactorType));
        if (fix) {
            if (fix.command && fix.command.arguments)
                vs.commands.executeCommand(fix.command.command, ...fix.command.arguments); // eslint-disable-line @typescript-eslint/no-unsafe-argument
            else if (fix.edit)
                vs.workspace.applyEdit(fix.edit);
            else
                console.error(`Flutter Outline fix was missing command/arguments`);
        }
        else {
            console.error(`Unable to find command for Flutter Outline: ${refactorType}`);
        }
    }
}
exports.FlutterOutlineCommands = FlutterOutlineCommands;


/***/ }),

/***/ 1471:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GoToSuperCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
const outline_1 = __webpack_require__(7104);
class GoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const position = editor.selection.start;
            const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
                superOnly: true,
            });
            if (!hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // The first item is the current node, so skip that one and walk up till we find a matching member.
            const isClass = !hierarchy.hierarchyItems[0].memberElement;
            const item = hierarchy.hierarchyItems.slice(1).find((h) => isClass ? !!h.classElement : !!h.memberElement);
            const element = isClass ? item && item.classElement : item && item.memberElement;
            if (!element || !element.location)
                return;
            const elementDocument = yield vs.workspace.openTextDocument(element.location.file);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            const range = (0, utils_2.toRangeOnLine)(element.location);
            (0, utils_2.showCode)(elementEditor, range, range, range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.GoToSuperCommand = GoToSuperCommand;


/***/ }),

/***/ 9475:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoggingCommands = exports.isLogging = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(8779);
const log_1 = __webpack_require__(8202);
exports.isLogging = false;
class LoggingCommands {
    constructor(logger, extensionLogPath) {
        this.logger = logger;
        this.extensionLogPath = extensionLogPath;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.startLogging", this.startLoggingViaPicker, this), vs.commands.registerCommand("dart.startLoggingDebugging", this.startLoggingDebugging, this), vs.commands.registerCommand("dart.startLoggingAnalysisServer", this.startLoggingAnalysisServer, this), vs.commands.registerCommand("dart.startLoggingAnalysisServerTimings", this.startLoggingAnalysisServerTimings, this), vs.commands.registerCommand("dart.startLoggingExtensionOnly", this.startLoggingExtensionOnly, this), vs.commands.registerCommand("dart.openExtensionLog", this.openExtensionLog, this), vs.commands.registerCommand("dart.stopLogging", this.stopLogging, this));
    }
    startLoggingViaPicker() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedLogCategories = yield vs.window.showQuickPick(Object.keys(log_1.userSelectableLogCategories).map((k) => ({
                label: k,
                logCategory: log_1.userSelectableLogCategories[k],
                picked: true,
            })), {
                canPickMany: true,
                placeHolder: "Select which categories to include in the log",
            });
            if (!selectedLogCategories || !selectedLogCategories.length)
                return;
            return this.startLogging(selectedLogCategories.map((s) => s.logCategory));
        });
    }
    startLoggingDebugging() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.debuggingLogCategories);
        });
    }
    startLoggingAnalysisServer() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.analysisServerLogCategories);
        });
    }
    startLoggingAnalysisServerTimings() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging([enums_1.LogCategory.AnalyzerTiming]);
        });
    }
    startLoggingExtensionOnly() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.startLogging(log_1.extensionsLogCategories);
        });
    }
    startLogging(categoriesToLog) {
        return __awaiter(this, void 0, void 0, function* () {
            const logFilename = path.join((0, fs_1.forceWindowsDriveLetterToUppercase)(this.extensionLogPath), this.generateFilename());
            const logUri = vs.Uri.file(logFilename);
            (0, utils_2.createFolderForFile)(logFilename);
            const allLoggedCategories = [enums_1.LogCategory.General].concat(categoriesToLog);
            const logger = (0, logging_1.captureLogs)(this.logger, (0, fs_1.fsPath)(logUri), (0, log_1.getLogHeader)(), constants_1.captureLogsMaxLineLength, allLoggedCategories);
            exports.isLogging = true;
            this.disposables.push(logger);
            vs.commands.executeCommand("setContext", constants_1.DART_IS_CAPTURING_LOGS_CONTEXT, true);
            const completer = new utils_1.PromiseCompleter();
            this.currentLogCompleter = completer;
            yield vs.window.withProgress({
                cancellable: true,
                location: vs.ProgressLocation.Notification,
                title: `Dart and Flutter logs are being captured. Reproduce your issue then click Cancel.`,
            }, (_, token) => {
                token.onCancellationRequested(() => completer.resolve());
                return completer.promise;
            });
            exports.isLogging = false;
            yield logger.dispose();
            const doc = yield vs.workspace.openTextDocument(logUri);
            yield vs.window.showTextDocument(doc);
            return logFilename;
        });
    }
    openExtensionLog() {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(vs.Uri.file((0, log_1.getExtensionLogPath)()));
            yield vs.window.showTextDocument(doc);
        });
    }
    stopLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentLogCompleter)
                this.currentLogCompleter.resolve();
        });
    }
    generateFilename() {
        const pad = (s) => `0${s.toString()}`.slice(-2);
        const now = new Date();
        const formattedDate = `${now.getFullYear()}-${pad(now.getMonth())}-${pad(now.getDay())} ${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}`;
        return `Dart-Code-Log-${formattedDate}.txt`;
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.LoggingCommands = LoggingCommands;


/***/ }),

/***/ 7809:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenInOtherEditorCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
class OpenInOtherEditorCommands {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("flutter.openInAndroidStudio", this.openInAndroidStudio, this), vs.commands.registerCommand("flutter.openInXcode", this.openInXcode, this));
    }
    openInAndroidStudio(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = (0, fs_1.fsPath)(resource);
            let androidStudioDir = yield this.getAndroidStudioDir(folder);
            if (!androidStudioDir) {
                vs.window.showErrorMessage("Unable to find Android Studio");
                return;
            }
            if (constants_1.isMac && androidStudioDir.endsWith("/Contents")) {
                androidStudioDir = androidStudioDir.substr(0, androidStudioDir.length - "/Contents".length);
                (0, processes_1.safeToolSpawn)(folder, "open", ["-a", androidStudioDir, folder]);
                return;
            }
            else {
                for (const androidStudioPath of constants_1.androidStudioPaths) {
                    const fullPath = path.join(androidStudioDir, androidStudioPath);
                    if (fs.existsSync(fullPath)) {
                        (0, processes_1.safeToolSpawn)(folder, fullPath, [folder]);
                        return;
                    }
                }
            }
            vs.window.showErrorMessage("Unable to locate Android Studio executable");
        });
    }
    openInXcode(resource) {
        return __awaiter(this, void 0, void 0, function* () {
            const folder = (0, fs_1.fsPath)(resource);
            const files = fs
                .readdirSync(folder, { withFileTypes: true })
                .filter((item) => item.isDirectory())
                .filter((item) => item.name.endsWith(".xcworkspace") || item.name.endsWith(".xcodeproj"))
                .sort((f1, f2) => f1.name.endsWith(".xcworkspace") ? -1 : 1);
            if (!files || !files.length) {
                const basename = path.basename(folder);
                vs.window.showErrorMessage(`Unable to find an Xcode project in your '${basename}' folder`);
                return;
            }
            const file = path.join(folder, files[0].name);
            (0, processes_1.safeToolSpawn)(folder, "open", [file]);
        });
    }
    getAndroidStudioDir(folder) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, misc_1.getFlutterConfigValue)(this.logger, this.sdks.flutter, folder, "android-studio-dir");
        });
    }
    dispose() {
        for (const command of this.disposables)
            command.dispose();
    }
}
exports.OpenInOtherEditorCommands = OpenInOtherEditorCommands;


/***/ }),

/***/ 8128:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCommands = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const pub_1 = __webpack_require__(2105);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const util = __webpack_require__(8779);
const projects_1 = __webpack_require__(6417);
const sdk_1 = __webpack_require__(997);
let isFetchingPackages = false;
let runPubGetDelayTimer;
let lastPubspecSaveReason;
class PackageCommands extends sdk_1.BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        this.disposables.push(vs.commands.registerCommand("dart.getPackages", this.getPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.listOutdatedPackages", this.listOutdatedPackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages", this.upgradePackages, this));
        this.disposables.push(vs.commands.registerCommand("dart.upgradePackages.majorVersions", this.upgradePackagesMajorVersions, this));
        // Pub commands.
        this.disposables.push(vs.commands.registerCommand("pub.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("pub.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Flutter commands.
        this.disposables.push(vs.commands.registerCommand("flutter.packages.get", (selection) => vs.commands.executeCommand("dart.getPackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade", (selection) => vs.commands.executeCommand("dart.upgradePackages", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.upgrade.majorVersions", (selection) => vs.commands.executeCommand("dart.upgradePackages.majorVersions", selection)));
        this.disposables.push(vs.commands.registerCommand("flutter.packages.outdated", (selection) => vs.commands.executeCommand("dart.listOutdatedPackages", selection)));
        // Hook saving pubspec to run pub.get.
        this.setupPubspecWatcher();
    }
    getPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(uri)) {
                for (const item of uri) {
                    yield this.getPackages(item);
                }
                return;
            }
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to get packages for");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            const additionalArgs = config_1.config.offline ? ["--offline"] : [];
            if (util.isInsideFlutterProject(uri)) {
                return this.runFlutter(["pub", "get", ...additionalArgs], uri);
            }
            else {
                return this.runPub(["get", ...additionalArgs], uri);
            }
        });
    }
    listOutdatedPackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to check for outdated packages");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "outdated"], uri, true);
            else
                return this.runPub(["outdated"], uri, true);
        });
    }
    upgradePackages(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (Array.isArray(uri)) {
                for (const item of uri) {
                    yield this.upgradePackages(item);
                }
                return;
            }
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages in");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "upgrade"], uri);
            else
                return this.runPub(["upgrade"], uri);
        });
    }
    upgradePackagesMajorVersions(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dartCapabilities.supportsPubUpgradeMajorVersions) {
                vs.window.showErrorMessage("Your current Dart SDK does not support 'pub upgrade --major-versions'");
                return;
            }
            if (!this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation) {
                const resp = yield vs.window.showWarningMessage("Running 'pub get --major-versions' will update your pubspec.yaml to match the 'resolvable' column reported in 'pub outdated'", constants_1.iUnderstandAction);
                if (resp !== constants_1.iUnderstandAction) {
                    return;
                }
                this.context.hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation = true;
            }
            if (!uri || !(uri instanceof vs.Uri)) {
                uri = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which folder to upgrade packages --major-versions in");
                // If the user cancelled, bail out (otherwise we'll prompt them again below).
                if (!uri)
                    return;
            }
            if (typeof uri === "string")
                uri = vs.Uri.file(uri);
            if (util.isInsideFlutterProject(uri))
                return this.runFlutter(["pub", "upgrade", "--major-versions"], uri);
            else
                return this.runPub(["upgrade", "--major-versions"], uri);
        });
    }
    setupPubspecWatcher() {
        this.disposables.push(vs.workspace.onWillSaveTextDocument((e) => {
            if (path.basename((0, fs_1.fsPath)(e.document.uri)).toLowerCase() === "pubspec.yaml")
                lastPubspecSaveReason = e.reason;
        }));
        const watcher = vs.workspace.createFileSystemWatcher("**/pubspec.yaml");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handlePubspecChange, this);
        watcher.onDidCreate(this.handlePubspecChange, this);
    }
    handlePubspecChange(uri) {
        const filePath = (0, fs_1.fsPath)(uri);
        // Never do anything for files inside hidden or build folders.
        if (filePath.includes(`${path.sep}.`) || filePath.includes(`${path.sep}build${path.sep}`)) {
            this.logger.info(`Skipping pubspec change for ignored folder ${filePath}`);
            return;
        }
        this.logger.info(`Pubspec ${filePath} was modified`);
        const conf = config_1.config.for(uri);
        // Don't do anything if we're disabled.
        if (conf.runPubGetOnPubspecChanges === "never") {
            this.logger.info(`Automatically running "pub get" is disabled`);
            return;
        }
        // Or if the workspace config says we shouldn't run.
        if (this.workspace.config.disableAutomaticPackageGet) {
            this.logger.info(`Workspace suppresses automatic "pub get"`);
            return;
        }
        // Don't do anything if we're in the middle of creating projects, as packages
        // may  be fetched automatically.
        if (sdk_1.commandState.numProjectCreationsInProgress > 0) {
            this.logger.info("Skipping package fetch because project creation is in progress");
            return;
        }
        // Cancel any existing delayed timer.
        if (runPubGetDelayTimer) {
            clearTimeout(runPubGetDelayTimer);
        }
        // If the save was triggered by one of the auto-save options, then debounce longer.
        const debounceDuration = lastPubspecSaveReason === vs.TextDocumentSaveReason.FocusOut
            || lastPubspecSaveReason === vs.TextDocumentSaveReason.AfterDelay
            ? 10000
            : 1000;
        const projectUri = vs.Uri.file(path.dirname(filePath));
        runPubGetDelayTimer = setTimeout(() => {
            runPubGetDelayTimer = undefined;
            lastPubspecSaveReason = undefined;
            // tslint:disable-next-line: no-floating-promises
            this.fetchPackagesOrPrompt(projectUri, { alwaysPrompt: conf.runPubGetOnPubspecChanges === "prompt" });
        }, debounceDuration); // TODO: Does this need to be configurable?
    }
    fetchPackagesOrPrompt(uri, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (isFetchingPackages) {
                this.logger.info(`Already running pub get, skipping!`);
                return;
            }
            isFetchingPackages = true;
            // TODO: Extract this into a Pub class with the things in pub.ts.
            try {
                const forcePrompt = options && options.alwaysPrompt;
                // We debounced so we might get here and have multiple projects to fetch for
                // for ex. when we change Git branch we might change many files at once. So
                // check how many there are, and if there are:
                //   0 - then just use Uri
                //   1 - then just do that one
                //   more than 1 - prompt to do all
                const projectFolders = yield (0, utils_2.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
                const pubStatuses = (0, utils_1.uniq)(projectFolders)
                    .map(vs.Uri.file)
                    .filter((uri) => config_1.config.for(uri).promptToGetPackages)
                    .map((uri) => ({ uri, status: (0, pub_1.getPubPackageStatus)(this.sdks, this.logger, uri) }))
                    .filter((result) => result.status !== undefined);
                this.logger.info(`Found ${pubStatuses.length} folders requiring "pub get" or "pub upgrade":${pubStatuses.map((result) => { var _a, _b; return `\n    ${(0, fs_1.fsPath)(result.uri)} (get: ${(_a = result.status) === null || _a === void 0 ? void 0 : _a.probablyRequiresGet}, upgrade: ${(_b = result.status) === null || _b === void 0 ? void 0 : _b.probablyRequiresUpgrade})`; }).join("")}`);
                const someProjectsRequirePubUpgrade = pubStatuses.some((result) => { var _a; return (_a = result.status) === null || _a === void 0 ? void 0 : _a.probablyRequiresUpgrade; });
                const projectsRequiringPub = pubStatuses.map((result) => result.uri);
                if ((options === null || options === void 0 ? void 0 : options.upgradeOnSdkChange) && someProjectsRequirePubUpgrade)
                    yield (0, pub_1.promptToRunPubUpgrade)(projectsRequiringPub);
                else if (!forcePrompt && projectsRequiringPub.length === 0 && uri)
                    yield this.runPubGetWithRelatives(projectFolders, uri);
                else if (!forcePrompt && projectsRequiringPub.length === 1)
                    yield this.runPubGetWithRelatives(projectFolders, projectsRequiringPub[0]);
                else if (projectsRequiringPub.length)
                    yield (0, pub_1.promptToRunPubGet)(projectsRequiringPub);
            }
            finally {
                isFetchingPackages = false;
            }
        });
    }
    runPubGetWithRelatives(allProjectFolders, triggeredProjectUri) {
        return __awaiter(this, void 0, void 0, function* () {
            const triggeredProjectFolder = (0, fs_1.fsPath)(triggeredProjectUri);
            const walkDirection = config_1.config.runPubGetOnNestedProjects;
            const fetchBoth = walkDirection === "both";
            const fetchUp = walkDirection === "above" || fetchBoth;
            const fetchDown = walkDirection === "below" || fetchBoth;
            let projectsToFetch = [triggeredProjectFolder];
            if (walkDirection) {
                for (const projectFolder of allProjectFolders) {
                    if (fetchUp && triggeredProjectFolder.startsWith(projectFolder))
                        projectsToFetch.push(projectFolder);
                    if (fetchDown && projectFolder.startsWith(triggeredProjectFolder))
                        projectsToFetch.push(projectFolder);
                }
            }
            projectsToFetch = (0, utils_1.uniq)(projectsToFetch);
            yield (0, pub_1.runPubGet)(projectsToFetch.map((path) => vs.Uri.file(path)));
        });
    }
}
exports.PackageCommands = PackageCommands;


/***/ }),

/***/ 883:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCommands = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const config_1 = __webpack_require__(4165);
const edit_das_1 = __webpack_require__(7511);
const refactorOptions = {
    EXTRACT_LOCAL_VARIABLE: getExtractLocalVariableArgs,
    EXTRACT_METHOD: getExtractMethodArgs,
    EXTRACT_WIDGET: getExtractWidgetArgs,
};
class RefactorCommands {
    constructor(logger, context, analyzer) {
        this.logger = logger;
        this.context = context;
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.isProcessingMoveEvent = false;
        /// Server only supports one refactoring at a time, so we need to ensure we
        /// wait for any previous one to finish before sending this.
        this.inProgressRefactor = promises_1.resolvedPromise;
        this.subscriptions.push(vs.commands.registerCommand("_dart.performRefactor", this.performRefactor, this));
        if (analyzer.capabilities.supportsMoveFile && config_1.config.updateImportsOnRename)
            this.subscriptions.push(vs.workspace.onWillRenameFiles((e) => this.onWillRenameFiles(e)));
    }
    performRefactor(document, range, refactorKind) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure the document is still valid.
            if (!document || document.isClosed)
                return;
            const originalDocumentVersion = document.version;
            // Validate that there are no problems if we execute this refactor.
            const validationResult = yield this.getRefactor(document, refactorKind, range, true);
            if (this.shouldAbortRefactor(validationResult))
                return;
            // Request the options from the user if required.
            let options;
            if (refactorOptions[refactorKind]) {
                options = yield refactorOptions[refactorKind](validationResult.feedback);
                if (!options)
                    return;
            }
            // Send the request for the refactor edits and prompt to apply if required.
            const editResult = yield this.getRefactor(document, refactorKind, range, false, options);
            const applyEdits = yield this.shouldApplyEdits(editResult, document, originalDocumentVersion);
            if (applyEdits)
                yield vs.commands.executeCommand("_dart.applySourceChange", document, editResult.change);
        });
    }
    getRefactor(document, refactorKind, range, validateOnly, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let remainingTries = 3;
            while (true) {
                try {
                    remainingTries--;
                    // await is important for the catch!
                    return yield this.analyzer.editGetRefactoring({
                        file: (0, fs_1.fsPath)(document.uri),
                        kind: refactorKind,
                        length: document.offsetAt(range.end) - document.offsetAt(range.start),
                        offset: document.offsetAt(range.start),
                        options,
                        validateOnly,
                    });
                }
                catch (e) {
                    this.logger.error(e);
                    if (remainingTries <= 0 || e.code !== "REFACTORING_REQUEST_CANCELLED")
                        throw e;
                    else
                        this.logger.info(`getRefactor failed, will try ${remainingTries} more times...`);
                }
            }
        });
    }
    shouldAbortRefactor(validationResult) {
        const validationProblems = validationResult.initialProblems
            .concat(validationResult.optionsProblems)
            .concat(validationResult.finalProblems)
            .filter((e) => e.severity === "FATAL");
        if (validationProblems.length) {
            vs.window.showErrorMessage(validationProblems[0].message);
            return true;
        }
        return false;
    }
    shouldApplyEdits(editResult, document, originalDocumentVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            const allProblems = editResult.initialProblems
                .concat(editResult.optionsProblems)
                .concat(editResult.finalProblems);
            const editFatals = allProblems.filter((e) => e.severity === "FATAL");
            const editWarnings = allProblems.filter((e) => e.severity === "ERROR" || e.severity === "WARNING");
            const hasErrors = !!allProblems.find((e) => e.severity === "ERROR");
            // Fatal errors can never be applied, just tell the user and quit.
            if (editFatals.length) {
                vs.window.showErrorMessage((0, array_1.unique)(editFatals.map((e) => e.message)).join("\n\n") + "\n\nYour refactor was not applied.");
                return false;
            }
            // If we somehow got here with no change, we also cannot apply them.
            if (!editResult.change)
                return false;
            let applyEdits = true;
            // If we have warnings/errors, the user can decide whether to go ahead.
            if (editWarnings.length) {
                const show = hasErrors ? vs.window.showErrorMessage : vs.window.showWarningMessage;
                applyEdits = (constants_1.REFACTOR_ANYWAY === (yield show((0, array_1.unique)(editWarnings.map((w) => w.message)).join("\n\n"), constants_1.REFACTOR_ANYWAY)));
            }
            // If we're trying to apply changes but the document is modified, we have to quit.
            if (applyEdits && document && document.version !== originalDocumentVersion) {
                vs.window.showErrorMessage(constants_1.REFACTOR_FAILED_DOC_MODIFIED);
                return false;
            }
            return applyEdits;
        });
    }
    onWillRenameFiles(e) {
        // TODO: VS Code always calls this once-per-file, concurrently for multiple files moved at once
        // which currently results in REFACTOR_CANCELLED for all but the first since the server doesn't
        // support multiple refactors at the same time. Running them sequentially fixes this, however it
        // hits an issue in VS Code (https://github.com/microsoft/vscode/issues/98309) so for now, we will
        // only process a single event at a time.
        if (this.isProcessingMoveEvent) {
            this.logger.info(`Skipping rename event for some files because another is in progress`);
            return;
        }
        try {
            const filesToRename = (0, utils_1.flatMap)(e.files, (f) => this.getResourcesToRename({ oldPath: (0, fs_1.fsPath)(f.oldUri), newPath: (0, fs_1.fsPath)(f.newUri) }))
                // Renames are only supported for Dart files, so filter out anything else to avoid producing an edit that will
                // trigger VS Code to show the rename dialog.
                .filter((f) => path.extname(f.oldPath).toLowerCase() === ".dart");
            if (filesToRename.length === 0)
                return;
            this.isProcessingMoveEvent = true;
            const edits = this.getRenameEdits(filesToRename);
            e.waitUntil(edits.finally(() => this.isProcessingMoveEvent = false));
        }
        catch (e) {
            this.isProcessingMoveEvent = false;
        }
    }
    runSequentially(func) {
        return __awaiter(this, void 0, void 0, function* () {
            this.inProgressRefactor = this.inProgressRefactor.then(() => func());
            return this.inProgressRefactor;
        });
    }
    getRenameEdits(filesToRename) {
        return __awaiter(this, void 0, void 0, function* () {
            const changes = new vs.WorkspaceEdit();
            for (const file of filesToRename) {
                const editResult = yield this.runSequentially(() => this.analyzer.editGetRefactoring({
                    file: file.oldPath,
                    kind: "MOVE_FILE",
                    length: 0,
                    offset: 0,
                    options: { newFile: file.newPath },
                    validateOnly: false,
                }));
                if (!editResult.change)
                    continue;
                const applyEdits = yield this.shouldApplyEdits(editResult);
                if (!applyEdits)
                    continue;
                if ((0, edit_das_1.hasOverlappingEdits)(editResult.change)) {
                    vs.window.showErrorMessage("Unable to update references; edits contain ambigious positions.");
                    this.logger.error(`Unable to apply MOVE_FILE edits due to ambigious edits:\n\n${JSON.stringify(editResult.change, undefined, 4)}`);
                    return;
                }
                for (const edit of editResult.change.edits) {
                    for (const e of edit.edits) {
                        const uri = vs.Uri.file(edit.file);
                        const document = yield vs.workspace.openTextDocument(uri);
                        changes.replace(vs.Uri.file(edit.file), new vs.Range(document.positionAt(e.offset), document.positionAt(e.offset + e.length)), e.replacement);
                    }
                }
            }
            if (changes.size === 0)
                return;
            return changes;
        });
    }
    getResourcesToRename(rename) {
        const filesToRename = [];
        if (fs.statSync(rename.oldPath).isFile()) {
            // TODO: if (isAnalyzableAndInWorkspace(rename.oldPath))
            filesToRename.push(rename);
        }
        return filesToRename;
    }
    dispose() {
        for (const command of this.subscriptions)
            command.dispose();
    }
}
exports.RefactorCommands = RefactorCommands;
function getExtractLocalVariableArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const proposedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : "x";
        return { name: proposedName, extractAll: false };
    });
}
function getExtractMethodArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const feedback = f;
        const suggestedName = feedback && feedback.names && feedback.names.length ? feedback.names[0] : undefined;
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the method", value: suggestedName });
        if (!name)
            return;
        return {
            createGetter: false,
            extractAll: false,
            name,
            parameters: feedback && feedback.parameters,
            returnType: feedback && feedback.returnType,
        };
    });
}
function getExtractWidgetArgs(f) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield vs.window.showInputBox({ prompt: "Enter a name for the widget" });
        return name ? { name } : undefined;
    });
}


/***/ }),

/***/ 997:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.markProjectCreationEnded = exports.markProjectCreationStarted = exports.SdkCommands = exports.BaseSdkCommands = exports.commandState = exports.packageNameRegex = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const sdk_manager_1 = __webpack_require__(3570);
const util = __webpack_require__(8779);
const processes_2 = __webpack_require__(5430);
const projects_1 = __webpack_require__(6417);
const channels = __webpack_require__(1026);
exports.packageNameRegex = new RegExp("^[a-z][a-z0-9_]*$");
// TODO: Find a better way/place for this.
exports.commandState = {
    numProjectCreationsInProgress: 0,
    promptToReloadOnVersionChanges: true,
};
class BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.workspace = workspace;
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        // A map of any in-progress commands so we can terminate them if we want to run another.
        this.runningCommands = {};
        this.sdks = workspace.sdks;
    }
    runCommandForWorkspace(handler, placeHolder, args, selection, alwaysShowOutput = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const folderToRunCommandIn = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, placeHolder, selection);
            if (!folderToRunCommandIn)
                return;
            const containingWorkspace = vs.workspace.getWorkspaceFolder(vs.Uri.file(folderToRunCommandIn));
            if (!containingWorkspace) {
                this.logger.error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
                throw new Error(`Failed to get workspace folder for ${folderToRunCommandIn}`);
            }
            const containingWorkspacePath = (0, fs_1.fsPath)(containingWorkspace.uri);
            // Display the relative path from the workspace root to the folder we're running, or if they're
            // the same then the folder name we're running in.
            const shortPath = path.relative(containingWorkspacePath, folderToRunCommandIn)
                || path.basename(folderToRunCommandIn);
            return handler(folderToRunCommandIn, args, shortPath, alwaysShowOutput);
        });
    }
    runFlutter(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runFlutterInFolder.bind(this), `Select the folder to run "flutter ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runFlutterInFolder(folder, args, shortPath, alwaysShowOutput = false, customScript) {
        if (!this.sdks.flutter)
            throw new Error("Flutter SDK not available");
        const execution = (0, utils_1.usingCustomScript)(path.join(this.sdks.flutter, constants_1.flutterPath), args, customScript);
        const allArgs = (0, processes_2.getGlobalFlutterArgs)()
            .concat(config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs)
            .concat(execution.args);
        return this.runCommandInFolder(shortPath, folder, execution.executable, allArgs, alwaysShowOutput);
    }
    runPub(args, selection, alwaysShowOutput = false) {
        return this.runCommandForWorkspace(this.runPubInFolder.bind(this), `Select the folder to run "pub ${args.join(" ")}" in`, args, selection, alwaysShowOutput);
    }
    runPubInFolder(folder, args, shortPath, alwaysShowOutput = false) {
        if (!this.sdks.dart)
            throw new Error("Dart SDK not available");
        args = args.concat(...config_1.config.for(vs.Uri.file(folder)).pubAdditionalArgs);
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return this.runCommandInFolder(shortPath, folder, pubExecution.executable, pubExecution.args, alwaysShowOutput);
    }
    runCommandInFolder(shortPath, folder, binPath, args, alwaysShowOutput) {
        shortPath = shortPath || path.basename(folder);
        const commandName = path.basename(binPath).split(".")[0]; // Trim file extension.
        const channel = channels.getOutputChannel(`${commandName} (${shortPath})`, true);
        if (alwaysShowOutput)
            channel.show();
        // Figure out if there's already one of this command running, in which case we'll chain off the
        // end of it.
        const commandId = `${folder}|${commandName}|${args}`;
        const existingProcess = this.runningCommands[commandId];
        if (existingProcess && !existingProcess.hasStarted) {
            // We already have a queued version of this command so there's no value in queueing another
            // just bail.
            return Promise.resolve(undefined);
        }
        return vs.window.withProgress({
            cancellable: true,
            location: vs.ProgressLocation.Notification,
            title: `${commandName} ${args.join(" ")}`,
        }, (progress, token) => {
            if (existingProcess) {
                progress.report({ message: "terminating previous command..." });
                existingProcess.cancel();
            }
            else {
                channel.clear();
            }
            const process = new ChainedProcess(() => {
                channel.appendLine(`[${shortPath}] ${commandName} ${args.join(" ")}`);
                progress.report({ message: "running..." });
                const proc = (0, processes_2.safeToolSpawn)(folder, binPath, args);
                channels.runProcessInOutputChannel(proc, channel);
                this.logger.info(`(PROC ${proc.pid}) Spawned ${binPath} ${args.join(" ")} in ${folder}`, enums_1.LogCategory.CommandProcesses);
                (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
                // If we complete with a non-zero code, or don't complete within 10s, we should show
                // the output pane.
                const completedWithErrorPromise = new Promise((resolve) => proc.on("close", resolve));
                const timedOutPromise = new Promise((resolve) => setTimeout(() => resolve(true), 10000));
                // tslint:disable-next-line: no-floating-promises
                Promise.race([completedWithErrorPromise, timedOutPromise]).then((showOutput) => {
                    if (showOutput)
                        channel.show(true);
                });
                return proc;
            }, existingProcess);
            this.runningCommands[commandId] = process;
            token.onCancellationRequested(() => process.cancel());
            return process.completed;
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.BaseSdkCommands = BaseSdkCommands;
class SdkCommands extends BaseSdkCommands {
    constructor(logger, context, workspace, dartCapabilities) {
        super(logger, context, workspace, dartCapabilities);
        const dartSdkManager = new sdk_manager_1.DartSdkManager(this.logger, this.workspace.sdks);
        this.disposables.push(vs.commands.registerCommand("dart.changeSdk", () => dartSdkManager.changeSdk()));
        if (workspace.hasAnyFlutterProjects) {
            const flutterSdkManager = new sdk_manager_1.FlutterSdkManager(this.logger, workspace.sdks);
            this.disposables.push(vs.commands.registerCommand("dart.changeFlutterSdk", () => flutterSdkManager.changeSdk()));
        }
        // Monitor version files for SDK upgrades.
        this.setupVersionWatcher();
    }
    setupVersionWatcher() {
        return __awaiter(this, void 0, void 0, function* () {
            // On Windows, the watcher sometimes fires even if the file wasn't modified (could be when
            // accessed), so we need to filter those out. We can't just check the modified time is "recent"
            // because the unzip preserves the modification dates of the SDK. Instead, we'll capture the mtime
            // of the file at start, and then fire only if that time actually changes.
            const versionFile = path.join(this.sdks.dart, "version");
            const getModifiedTimeMs = () => __awaiter(this, void 0, void 0, function* () {
                try {
                    return (yield fs.promises.stat(versionFile)).mtime.getTime();
                }
                catch (error) {
                    this.logger.warn(`Failed to check modification time on version file. ${error}`);
                    return;
                }
            });
            let lastModifiedTime = yield getModifiedTimeMs();
            // If we couldn't get the initial modified time, we can't track this.
            if (!lastModifiedTime)
                return;
            const watcher = fs.watch(versionFile, { persistent: false }, (eventType) => __awaiter(this, void 0, void 0, function* () {
                if (!exports.commandState.promptToReloadOnVersionChanges)
                    return;
                const newModifiedTime = yield getModifiedTimeMs();
                // Bail if we couldn't get a new modified time, or it was the same as the last one.
                if (!newModifiedTime || newModifiedTime === lastModifiedTime)
                    return;
                lastModifiedTime = newModifiedTime;
                // Ensure we don't fire too often as some OSes may generate multiple events.
                exports.commandState.promptToReloadOnVersionChanges = false;
                // Allow it again in 60 seconds.
                setTimeout(() => exports.commandState.promptToReloadOnVersionChanges = true, 60000);
                // Wait a short period before prompting.
                setTimeout(() => util.promptToReloadExtension("Your Dart SDK has been updated. Reload using the new SDK?", undefined, false), 1000);
            }));
            this.disposables.push({ dispose() { watcher.close(); } });
        });
    }
}
exports.SdkCommands = SdkCommands;
function markProjectCreationStarted() {
    exports.commandState.numProjectCreationsInProgress++;
}
exports.markProjectCreationStarted = markProjectCreationStarted;
function markProjectCreationEnded() {
    exports.commandState.numProjectCreationsInProgress--;
}
exports.markProjectCreationEnded = markProjectCreationEnded;
class ChainedProcess {
    constructor(spawn, parent) {
        this.spawn = spawn;
        this.processNumber = ChainedProcess.processNumber++;
        this.completer = new utils_1.PromiseCompleter();
        this.completed = this.completer.promise;
        this.isCancelled = false;
        // We'll either start immediately, or if given a parent process only when it completes.
        if (parent) {
            // tslint:disable-next-line: no-floating-promises
            parent.completed.then(() => this.start());
        }
        else {
            this.start();
        }
    }
    get hasStarted() {
        return this.process !== undefined;
    }
    start() {
        if (this.process)
            throw new Error(`${this.processNumber} Can't start an already started process!`);
        if (this.isCancelled) {
            this.completer.resolve(undefined);
            return;
        }
        this.process = this.spawn();
        this.process.on("close", (code) => this.completer.resolve((0, utils_1.nullToUndefined)(code)));
    }
    cancel() {
        this.isCancelled = true;
    }
}
ChainedProcess.processNumber = 1;


/***/ }),

/***/ 6003:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestCommands = exports.isInImplementationFileThatCanHaveTest = exports.isInTestFileThatHasImplementation = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const test_1 = __webpack_require__(8729);
const debugger_1 = __webpack_require__(2074);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const editors_1 = __webpack_require__(8805);
const utils_3 = __webpack_require__(8779);
const CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION = "dart-code:canGoToTestOrImplementationFile";
// HACK: Used for testing since we can't read contexts?
exports.isInTestFileThatHasImplementation = false;
exports.isInImplementationFileThatCanHaveTest = false;
class TestCommands {
    constructor(logger, testModel, wsContext, vsCodeTestController, flutterCapabilities) {
        this.logger = logger;
        this.testModel = testModel;
        this.wsContext = wsContext;
        this.vsCodeTestController = vsCodeTestController;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("_dart.startDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(false, test, launchTemplate)), vs.commands.registerCommand("_dart.startWithoutDebuggingTestFromOutline", (test, launchTemplate) => this.startTestFromOutline(true, test, launchTemplate)), vs.commands.registerCommand("_dart.startDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPrompts, testRun) => this.runTestsForNode(suiteData, this.getTestNamesForNodes(treeNodes), true, suppressPrompts, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("_dart.startWithoutDebuggingTestsFromVsTestController", (suiteData, treeNodes, suppressPrompts, testRun) => this.runTestsForNode(suiteData, this.getTestNamesForNodes(treeNodes), false, suppressPrompts, treeNodes.length === 1 && treeNodes[0] instanceof test_model_1.TestNode, undefined, testRun)), vs.commands.registerCommand("_dart.runAllTestsWithoutDebugging", (suites, testRun, isRunningAll) => this.runAllTestsWithoutDebugging(suites, testRun, isRunningAll)), vs.commands.registerCommand("dart.goToTests", (resource) => this.goToTestOrImplementationFile(resource), this), vs.commands.registerCommand("dart.goToTestOrImplementationFile", () => this.goToTestOrImplementationFile(), this), vs.window.onDidChangeActiveTextEditor((e) => this.updateEditorContexts(e)));
        // Run for current open editor.
        this.updateEditorContexts(vs.window.activeTextEditor);
    }
    runAllTestsWithoutDebugging(suites, testRun, isRunningAll) {
        return __awaiter(this, void 0, void 0, function* () {
            // To run multiple folders/suites, we can pass the first as `program` and the rest as `args` which
            // will be appended immediately after `program`. However, this only works for things in the same project
            // as the first one that runs will be used for resolving package: URIs etc. We also can't mix and match
            // integration tests with non-integration tests.
            // So, fetch all project folders, then if we have suites in them, group them by that folders (and whether
            // they're integration/non-integration), and otherwise use their 'test'/'integration_test' folders.
            const projectFolders = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            // Sort folders by length descending so that for any given suite, we know the first one that contains
            // it is the closest parent, so we can avoid running the same test multiple times if it's in a nested
            // project.
            (0, array_1.sortBy)(projectFolders, (f) => -1 * f.length);
            function closestProjectFolder(suitePath) {
                return projectFolders.find((f) => (0, fs_1.isWithinPath)(suitePath, f));
            }
            const projectsWithTests = [];
            function addTestItemsForProject(projectFolder, integrationTests) {
                if (!suites)
                    return;
                let testPaths = suites
                    .map((suite) => suite.suiteData.path)
                    .filter((suitePath) => (0, fs_1.isWithinPath)(suitePath, projectFolder))
                    .filter((suitePath) => (0, utils_3.isInsideFolderNamed)(suitePath, "integration_test") === integrationTests)
                    .filter((suitePath) => closestProjectFolder(suitePath) === projectFolder);
                if (testPaths.length) {
                    const projectName = path.basename(projectFolder);
                    const testType = integrationTests ? "Integration Tests" : "Tests";
                    const name = `${projectName} ${testType}`;
                    // To avoid making a huge list of suite names that may trigger
                    // "The command line is too long" on Windows, if we know we're running them
                    // _all_ we can simplify the list of test names to just the top-level folders
                    // that contain each.
                    if (isRunningAll)
                        testPaths = (0, utils_1.uniq)(testPaths.map((suitePath) => path.relative(projectFolder, suitePath).split(path.sep)[0]));
                    projectsWithTests.push({ projectFolder, name, tests: testPaths });
                }
            }
            for (const projectFolder of projectFolders) {
                addTestItemsForProject(projectFolder, false);
                addTestItemsForProject(projectFolder, true);
            }
            if (projectsWithTests.length === 0) {
                vs.window.showErrorMessage("Unable to find any test folders");
                return;
            }
            yield Promise.all(projectsWithTests.map((projectWithTests) => this.runTests({
                debug: false,
                launchTemplate: {
                    args: projectWithTests.tests.slice(1),
                    cwd: projectWithTests.projectFolder,
                    name: projectWithTests.name,
                },
                programPath: projectWithTests.tests[0],
                shouldRunSkippedTests: false,
                suppressPrompts: (suites === null || suites === void 0 ? void 0 : suites.length) !== 1,
                testNames: undefined,
                testRun,
                token: undefined,
                useLaunchJsonTestTemplate: true,
            })));
        });
    }
    runTestsForNode(suiteData, testNames, debug, suppressPrompts, runSkippedTests, token, testRun) {
        return __awaiter(this, void 0, void 0, function* () {
            const programPath = (0, fs_1.fsPath)(suiteData.path);
            const canRunSkippedTest = this.flutterCapabilities.supportsRunSkippedTests || !(0, utils_3.isInsideFlutterProject)(vs.Uri.file(suiteData.path));
            const shouldRunSkippedTests = runSkippedTests && canRunSkippedTest;
            return this.runTests({
                debug,
                launchTemplate: undefined,
                programPath,
                shouldRunSkippedTests,
                suppressPrompts,
                testNames,
                testRun,
                token,
                useLaunchJsonTestTemplate: true,
            });
        });
    }
    runTests({ programPath, debug, testNames, shouldRunSkippedTests, suppressPrompts, launchTemplate, testRun, token, useLaunchJsonTestTemplate }) {
        if (useLaunchJsonTestTemplate) {
            // Get the default Run/Debug template for running/debugging tests and use that as a base.
            const template = (0, debugger_1.getLaunchConfigDefaultTemplate)(vs.Uri.file(programPath), debug);
            if (template)
                launchTemplate = Object.assign({}, template, launchTemplate);
        }
        const subs = [];
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let testsName = path.basename(programPath);
            // Handle when running whole test folder.
            if (testsName === "test")
                testsName = path.basename(path.dirname(programPath));
            const launchConfiguration = Object.assign(Object.assign({ suppressPrompts }, (0, test_1.getLaunchConfig)(!debug, programPath, testNames, shouldRunSkippedTests, launchTemplate)), { name: (_a = launchTemplate === null || launchTemplate === void 0 ? void 0 : launchTemplate.name) !== null && _a !== void 0 ? _a : `${path.basename(programPath)} tests` });
            // Ensure we have a unique ID for this session so we can track when it completes.
            const dartCodeDebugSessionID = (0, utils_3.ensureDebugLaunchUniqueId)(launchConfiguration);
            // If we were given a test to use by VS Code, use it. Otherwise we'll lazily create one at the
            // other end.
            if (testRun)
                (_b = this.vsCodeTestController) === null || _b === void 0 ? void 0 : _b.registerTestRun(dartCodeDebugSessionID, testRun, false);
            if (token) {
                subs.push(vs.debug.onDidStartDebugSession((e) => {
                    if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                        subs.push(token.onCancellationRequested(() => e.customRequest("disconnect")));
                }));
            }
            subs.push(vs.debug.onDidTerminateDebugSession((e) => {
                if (e.configuration.dartCodeDebugSessionID === dartCodeDebugSessionID)
                    resolve(true);
            }));
            const didStart = yield vs.debug.startDebugging(vs.workspace.getWorkspaceFolder(vs.Uri.file(programPath)), launchConfiguration);
            if (!didStart) {
                // Failures to start will trigger their own messages (from debug_config_provider) so we
                // should not reject() here, as VS Code will show an additional (less helpful) error
                // message.
                resolve(false);
            }
        })).finally(() => {
            (0, utils_1.disposeAll)(subs);
        });
    }
    getTestNamesForNodes(nodes) {
        if (nodes.find((node) => node instanceof test_model_1.SuiteNode))
            return undefined;
        return nodes
            .filter((treeNode) => treeNode.name)
            .map((treeNode) => ({ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode }));
    }
    getTestNames(treeNode, onlyOfStatus) {
        // If we're getting all tests, we can just use the test name/group name (or undefined for suite) directly.
        if (onlyOfStatus === undefined) {
            if ((treeNode instanceof test_model_1.TestNode || treeNode instanceof test_model_1.GroupNode) && treeNode.name !== undefined)
                return [{ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode }];
            return undefined;
        }
        // Otherwise, collect all descendant tests that are of the specified type.
        let names = [];
        if (treeNode instanceof test_model_1.SuiteNode || treeNode instanceof test_model_1.GroupNode) {
            for (const child of treeNode.children) {
                const childNames = this.getTestNames(child, onlyOfStatus);
                if (childNames)
                    names = names.concat(childNames);
            }
        }
        else if (treeNode instanceof test_model_1.TestNode && treeNode.name !== undefined) {
            if (treeNode.status === onlyOfStatus)
                names.push({ name: treeNode.name, isGroup: treeNode instanceof test_model_1.GroupNode });
        }
        return names;
    }
    startTestFromOutline(noDebug, test, launchTemplate) {
        const canRunSkippedTest = !test.isGroup && (this.flutterCapabilities.supportsRunSkippedTests || !(0, utils_3.isInsideFlutterProject)(vs.Uri.file(test.file)));
        const shouldRunSkippedTests = canRunSkippedTest; // These are the same when running directly, since we always run skipped.
        return this.runTests({
            debug: !noDebug,
            launchTemplate,
            programPath: test.file,
            shouldRunSkippedTests,
            suppressPrompts: false,
            testNames: [{ name: test.fullName, isGroup: test.isGroup }],
            testRun: undefined,
            token: undefined,
        });
    }
    goToTestOrImplementationFile(resource) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const doc = resource
                ? yield vs.workspace.openTextDocument(resource)
                : (_a = (0, editors_1.getActiveRealFileEditor)()) === null || _a === void 0 ? void 0 : _a.document;
            if (doc && (0, editors_1.isDartDocument)(doc)) {
                const filePath = (0, fs_1.fsPath)(doc.uri);
                const isTest = (0, utils_3.isTestFile)(filePath);
                const otherFile = isTest
                    ? this.getImplementationFileForTest(filePath)
                    : this.getTestFileForImplementation(filePath);
                if (!otherFile || (isTest && !fs.existsSync(otherFile)))
                    return;
                let selectionOffset;
                let selectionLength;
                // Offer to create test files.
                if (!fs.existsSync(otherFile)) {
                    if (isTest)
                        return;
                    const relativePath = vs.workspace.asRelativePath(otherFile, false);
                    const yesAction = (0, test_1.createTestFileAction)(relativePath);
                    const response = yield vs.window.showInformationMessage(`Would you like to create a test file at ${relativePath}?`, yesAction, constants_1.noAction);
                    if (response !== yesAction)
                        return;
                    (0, fs_1.mkDirRecursive)(path.dirname(otherFile));
                    const testFileInfo = (0, test_1.defaultTestFileContents)(this.wsContext.hasAnyFlutterProjects, (0, utils_1.escapeDartString)((0, utils_1.generateTestNameFromFileName)(relativePath)));
                    fs.writeFileSync(otherFile, testFileInfo.contents);
                    selectionOffset = testFileInfo.selectionOffset;
                    selectionLength = testFileInfo.selectionLength;
                }
                const document = yield vs.workspace.openTextDocument(otherFile);
                const editor = yield vs.window.showTextDocument(document);
                if (selectionOffset && selectionLength)
                    editor.selection = new vs.Selection(document.positionAt(selectionOffset), document.positionAt(selectionOffset + selectionLength));
            }
        });
    }
    updateEditorContexts(e) {
        exports.isInTestFileThatHasImplementation = false;
        exports.isInImplementationFileThatCanHaveTest = false;
        if (e && e.document && (0, editors_1.isDartDocument)(e.document)) {
            const filePath = (0, fs_1.fsPath)(e.document.uri);
            if ((0, utils_3.isTestFile)(filePath)) {
                // Implementation files must exist.
                const implementationFilePath = this.getImplementationFileForTest(filePath);
                exports.isInTestFileThatHasImplementation = !!implementationFilePath && fs.existsSync(implementationFilePath);
            }
            else {
                exports.isInImplementationFileThatCanHaveTest = !!this.getTestFileForImplementation(filePath);
            }
        }
        vs.commands.executeCommand("setContext", CAN_JUMP_BETWEEN_TEST_IMPLEMENTATION, exports.isInTestFileThatHasImplementation || exports.isInImplementationFileThatCanHaveTest);
    }
    getImplementationFileForTest(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace test folder with lib.
        const testFolderIndex = pathSegments.lastIndexOf("test");
        if (testFolderIndex !== -1)
            pathSegments[testFolderIndex] = "lib";
        // Remove _test from the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/_test\.dart/, ".dart");
        return pathSegments.join(path.sep);
    }
    getTestFileForImplementation(filePath) {
        const pathSegments = filePath.split(path.sep);
        // Replace lib folder with test.
        const libFolderIndex = pathSegments.lastIndexOf("lib");
        if (libFolderIndex === -1)
            return undefined;
        pathSegments[libFolderIndex] = "test";
        // Add _test to the filename.
        pathSegments[pathSegments.length - 1] = pathSegments[pathSegments.length - 1].replace(/\.dart/, "_test.dart");
        return pathSegments.join(path.sep);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestCommands = TestCommands;


/***/ }),

/***/ 4593:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
class TypeHierarchyCommand {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.showTypeHierarchy", this.showTypeHierarchy, this));
    }
    showTypeHierarchy() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const document = editor.document;
            const originalSelection = editor.selection;
            const response = yield this.analyzer.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset: document.offsetAt(editor.selection.active),
            });
            const items = response.hierarchyItems;
            if (!items) {
                vs.window.showInformationMessage("Type hierarchy not available.");
                return;
            }
            const options = {
                onDidSelectItem: (item) => this.openLocation(item, true),
                placeHolder: name(items, 0),
            };
            // TODO: How / where to show implements?
            const tree = [];
            const startItem = items[0];
            tree.push(startItem);
            addParents(items, tree, startItem);
            addChildren(items, tree, startItem);
            const result = yield vs.window.showQuickPick(tree.map((item) => itemToPick(item, items)), options);
            if (result && result.location) {
                yield this.openLocation(result);
            }
            else {
                // Move the use back to where they were.
                const ed = yield vs.window.showTextDocument(document);
                ed.revealRange(editor.selection, vs.TextEditorRevealType.InCenterIfOutsideViewport);
                ed.selection = originalSelection;
            }
        });
    }
    openLocation(result, asPreview = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!result.location) {
                this.logger.warn(`Unable to open item with no location`);
                return;
            }
            const location = result.location;
            const document = yield vs.workspace.openTextDocument(location.file);
            const editor = yield vs.window.showTextDocument(document, {
                preserveFocus: asPreview,
                preview: asPreview,
            });
            const range = (0, utils_2.toRangeOnLine)(location);
            (0, utils_2.showCode)(editor, range, range, range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TypeHierarchyCommand = TypeHierarchyCommand;
function addParents(items, tree, item) {
    if (item.superclass) {
        const parent = items[item.superclass];
        if (parent.classElement.name !== "Object") {
            tree.unshift(parent);
            addParents(items, tree, parent);
        }
    }
}
function addChildren(items, tree, item) {
    // Handle direct children.
    for (const index of item.subclasses) {
        const child = items[index];
        tree.push(child);
    }
    // Handle grandchildren.
    for (const index of item.subclasses) {
        const child = items[index];
        if (child.subclasses.length > 0)
            addChildren(items, tree, child);
    }
}
function itemToPick(item, items) {
    let desc = "";
    // extends
    if (item.superclass !== undefined && name(items, item.superclass) !== "Object")
        desc += `extends ${name(items, item.superclass)}`;
    // implements
    if (item.interfaces.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `implements ${item.interfaces.map((i) => name(items, i)).join(", ")}`;
    }
    // with
    if (item.mixins.length > 0) {
        if (desc.length > 0)
            desc += ", ";
        desc += `with ${item.mixins.map((i) => name(items, i)).join(", ")}`;
    }
    const result = {
        description: desc,
        label: item.classElement.name,
        location: item.classElement.location,
    };
    return result;
}
function name(items, index) {
    return items[index].classElement.name;
}


/***/ }),

/***/ 4165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.config = exports.ResourceConfig = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
class Config {
    constructor() {
        vscode_1.workspace.onDidChangeConfiguration((e) => this.reloadConfig());
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    reloadConfig() {
        this.config = vscode_1.workspace.getConfiguration("dart");
        (0, processes_1.setupToolEnv)(this.env);
    }
    getConfig(key, defaultValue) {
        const value = this.config.get(key, defaultValue);
        return (0, utils_1.nullToUndefined)(value);
    }
    getWorkspaceConfig(key) {
        const c = this.config.inspect(key);
        if (c && c.workspaceValue)
            return c.workspaceValue;
        if (c && c.workspaceFolderValue) {
            return c.workspaceFolderValue;
        }
        return undefined;
    }
    setConfig(key, value, target) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.config.update(key, value, target);
        });
    }
    get additionalAnalyzerFileExtensions() { return this.getConfig("additionalAnalyzerFileExtensions", []); }
    get allowAnalytics() { return this.getConfig("allowAnalytics", true); }
    get allowTestsOutsideTestFolder() { return this.getConfig("allowTestsOutsideTestFolder", false); }
    get analysisServerFolding() { return this.getConfig("analysisServerFolding", true); }
    get analyzeAngularTemplates() { return this.getConfig("analyzeAngularTemplates", true); }
    get analyzerAdditionalArgs() { return this.getConfig("analyzerAdditionalArgs", []); }
    get analyzerDiagnosticsPort() { return this.getConfig("analyzerDiagnosticsPort", null); }
    get analyzerInstrumentationLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get analyzerSshHost() { return this.getConfig("analyzerSshHost", null); }
    get analyzerVmServicePort() { return this.getConfig("analyzerVmServicePort", null); }
    get autoImportCompletions() { return this.getConfig("autoImportCompletions", true); }
    get automaticCommentSlashes() { return this.getConfig("automaticCommentSlashes", "tripleSlash"); }
    get buildRunnerAdditionalArgs() { return this.getConfig("buildRunnerAdditionalArgs", []); }
    get checkForSdkUpdates() { return this.getConfig("checkForSdkUpdates", true); }
    get cliConsole() { return this.getConfig("cliConsole", "debugConsole"); }
    get closingLabels() { return this.getConfig("closingLabels", true); }
    get customDartDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customDartDapPath", null)); }
    get customFlutterDapPath() { return (0, utils_2.resolvePaths)(this.getConfig("customFlutterDapPath", null)); }
    get customDevTools() { return this.getConfig("customDevTools", null); }
    get dapLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null))); }
    get dartTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null))); }
    get daemonPort() { return this.getConfig("daemonPort", null); }
    get debugExtensionBackendProtocol() { return this.getConfig("debugExtensionBackendProtocol", "ws"); }
    get debugExternalPackageLibraries() { return this.getConfig("debugExternalPackageLibraries", false); }
    get debugSdkLibraries() { return this.getConfig("debugSdkLibraries", false); }
    get devToolsBrowser() { return this.getConfig("devToolsBrowser", "chrome"); }
    get devToolsLocation() { return this.getConfig("devToolsLocation", "beside"); }
    get devToolsLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null))); }
    get devToolsPort() { return this.getConfig("devToolsPort", null); }
    get devToolsReuseWindows() { return this.getConfig("devToolsReuseWindows", true); }
    get devToolsTheme() { return this.getConfig("devToolsTheme", "dark"); }
    get enableSdkFormatter() { return this.getConfig("enableSdkFormatter", true); }
    get enableServerSnippets() { return this.getConfig("enableServerSnippets", true); }
    get enableSnippets() { return this.getConfig("enableSnippets", true); }
    get env() { return this.getConfig("env", {}); }
    get evaluateToStringInDebugViews() { return this.getConfig("evaluateToStringInDebugViews", true); }
    get extensionLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null))); }
    get flutterAdbConnectOnChromeOs() { return this.getConfig("flutterAdbConnectOnChromeOs", false); }
    get flutterCreateAndroidLanguage() { return this.getConfig("flutterCreateAndroidLanguage", "kotlin"); }
    get flutterCreateIOSLanguage() { return this.getConfig("flutterCreateIOSLanguage", "swift"); }
    get flutterCreateOffline() { return this.getConfig("flutterCreateOffline", false); }
    get flutterCreateOrganization() { return this.getConfig("flutterCreateOrganization", null); }
    get flutterCreatePlatforms() { return this.getConfig("flutterCreatePlatforms", undefined); }
    get flutterCustomEmulators() { return this.getConfig("flutterCustomEmulators", []); }
    get flutterDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterGutterIcons() { return this.getConfig("flutterGutterIcons", true); }
    get flutterGenerateLocalizationsOnSave() { return this.getConfig("flutterGenerateLocalizationsOnSave", "never"); }
    get flutterHotReloadOnSave() {
        const value = this.getConfig("flutterHotReloadOnSave", "manual");
        // Convert the legacy values to new values, if required.
        if (value === true)
            return "manual";
        else if (value === false)
            return "never";
        else if (value === "always")
            return "all";
        else
            return value;
    }
    get flutterOutline() { return this.getConfig("flutterOutline", true); }
    get flutterRunLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterSelectDeviceWhenConnected() { return this.getConfig("flutterSelectDeviceWhenConnected", true); }
    get flutterShowEmulators() { return this.getConfig("flutterShowEmulators", "local"); }
    get flutterShowWebServerDevice() { return this.getConfig("flutterShowWebServerDevice", "remote"); }
    get flutterTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null))); }
    get flutterWebRenderer() { return this.getConfig("flutterWebRenderer", "auto"); }
    get hotReloadOnSave() {
        const value = this.getConfig("hotReloadOnSave", "never");
        if (value === "always")
            return "all";
        else
            return value;
    }
    get hotReloadProgress() { return this.getConfig("hotReloadProgress", "notification"); }
    get lspSnippetTextEdits() { return this.getConfig("lspSnippetTextEdits", true); }
    get maxCompletionItems() { return this.getConfig("maxCompletionItems", 100000); }
    get maxLogLineLength() { return this.getConfig("maxLogLineLength", 2000); }
    get normalizeFileCasing() { return this.getConfig("normalizeFileCasing", false); }
    get notifyAnalyzerErrors() { return this.getConfig("notifyAnalyzerErrors", true); }
    get offline() { return this.getConfig("offline", false); }
    get onlyAnalyzeProjectsWithOpenFiles() { return this.getConfig("onlyAnalyzeProjectsWithOpenFiles", false); }
    get openDevTools() { return this.getConfig("openDevTools", "never"); }
    get openTestView() { return this.getConfig("openTestView", ["testRunStart"]); }
    get previewCommitCharacters() { return this.getConfig("previewCommitCharacters", false); }
    get previewFlutterUiGuides() { return this.getConfig("previewFlutterUiGuides", false); }
    get previewFlutterUiGuidesCustomTracking() { return this.getConfig("previewFlutterUiGuidesCustomTracking", false); }
    get previewHotReloadOnSaveWatcher() { return this.getConfig("previewHotReloadOnSaveWatcher", false); }
    get previewSdkDaps() { return this.getConfig("previewSdkDaps", null); }
    get projectSearchDepth() { return this.getConfig("projectSearchDepth", 3); }
    get promptToRunIfErrors() { return this.getConfig("promptToRunIfErrors", true); }
    get renameFilesWithClasses() { return this.getConfig("renameFilesWithClasses", "never"); }
    get runPubGetOnNestedProjects() { return this.getConfig("runPubGetOnNestedProjects", "none"); }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get shareDevToolsWithFlutter() { return this.getConfig("shareDevToolsWithFlutter", true); }
    get showDartPadSampleCodeLens() { return this.getConfig("showDartPadSampleCodeLens", true); }
    get showDevToolsDebugToolBarButtons() { return this.getConfig("showDevToolsDebugToolBarButtons", true); }
    get showIgnoreQuickFixes() { return this.getConfig("showIgnoreQuickFixes", true); }
    get showInspectorNotificationsForWidgetErrors() { return this.getConfig("showInspectorNotificationsForWidgetErrors", true); }
    get showMainCodeLens() { return this.getConfig("showMainCodeLens", true); }
    get showSkippedTests() { return this.getConfig("showSkippedTests", true); }
    get showTestCodeLens() { return this.getConfig("showTestCodeLens", true); }
    get showTodos() { return this.getConfig("showTodos", true); }
    get updateDevTools() { return this.getConfig("updateDevTools", true); }
    get updateImportsOnRename() { return this.getConfig("updateImportsOnRename", true); }
    get useLegacyAnalyzerProtocol() { return this.getConfig("useLegacyAnalyzerProtocol", false); }
    get vmServiceLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null))); }
    get warnWhenEditingFilesInPubCache() { return this.getConfig("warnWhenEditingFilesInPubCache", true); }
    get warnWhenEditingFilesOutsideWorkspace() { return this.getConfig("warnWhenEditingFilesOutsideWorkspace", true); }
    get webDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null))); }
    // Helpers
    get useDevToolsDarkTheme() { return this.devToolsTheme === "dark"; }
    get openTestViewOnFailure() { return this.openTestView.indexOf("testFailure") !== -1; }
    get openTestViewOnStart() { return this.openTestView.indexOf("testRunStart") !== -1; }
    get workspaceSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("sdkPath")); }
    get workspaceFlutterSdkPath() { return (0, utils_2.resolvePaths)(this.getWorkspaceConfig("flutterSdkPath")); }
    // Options that can be set programatically.
    setCheckForSdkUpdates(value) { return this.setConfig("checkForSdkUpdates", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateOrganization(value) { return this.setConfig("flutterCreateOrganization", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateAndroidLanguage(value) { return this.setConfig("flutterCreateAndroidLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreateIOSLanguage(value) { return this.setConfig("flutterCreateIOSLanguage", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterCreatePlatforms(value) { return this.setConfig("flutterCreatePlatforms", value, vscode_1.ConfigurationTarget.Global); }
    setFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setGlobalDartSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugSdkLibraries(value) { return this.setConfig("debugSdkLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalDebugExternalPackageLibraries(value) { return this.setConfig("debugExternalPackageLibraries", value, vscode_1.ConfigurationTarget.Global); }
    setGlobalFlutterSdkPath(value) { return this.setConfig("flutterSdkPath", value, vscode_1.ConfigurationTarget.Global); }
    setOffline(value) { return this.setConfig("offline", value, vscode_1.ConfigurationTarget.Global); }
    setOpenDevTools(value) { return this.setConfig("openDevTools", value, vscode_1.ConfigurationTarget.Global); }
    setShowInspectorNotificationsForWidgetErrors(value) { return this.setConfig("showInspectorNotificationsForWidgetErrors", value, vscode_1.ConfigurationTarget.Global); }
    setSdkPath(value) { return this.setConfig("sdkPath", value, vscode_1.ConfigurationTarget.Workspace); }
    setWarnWhenEditingFilesOutsideWorkspace(value) { return this.setConfig("warnWhenEditingFilesOutsideWorkspace", value, vscode_1.ConfigurationTarget.Global); }
    setWarnWhenEditingFilesInPubCache(value) { return this.setConfig("warnWhenEditingFilesInPubCache", value, vscode_1.ConfigurationTarget.Global); }
    for(uri) {
        return new ResourceConfig(uri);
    }
}
class ResourceConfig {
    constructor(uri) {
        this.uri = uri;
        this.config = vscode_1.workspace.getConfiguration("dart", this.uri);
    }
    getConfig(key, defaultValue) {
        return (0, utils_1.nullToUndefined)(this.config.get(key, defaultValue));
    }
    get analysisExcludedFolders() { return this.getConfig("analysisExcludedFolders", []); }
    get analyzerInstrumentationLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerInstrumentationLogFile", null))); }
    get analyzerLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("analyzerLogFile", null))); }
    get analyzerPath() { return (0, utils_2.resolvePaths)(this.getConfig("analyzerPath", null)); }
    get cliAdditionalArgs() { return this.getConfig("cliAdditionalArgs", []); }
    get completeFunctionCalls() { return this.getConfig("completeFunctionCalls", true); }
    get daemonPort() { return this.getConfig("daemonPort", null); }
    get dapLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dapLogFile", null))); }
    get dartTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("dartTestLogFile", null))); }
    get devToolsLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("devToolsLogFile", null))); }
    get doNotFormat() { return this.getConfig("doNotFormat", []); }
    get enableCompletionCommitCharacters() { return this.getConfig("enableCompletionCommitCharacters", false); }
    get evaluateGettersInDebugViews() { return this.getConfig("evaluateGettersInDebugViews", true); }
    get extensionLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("extensionLogFile", null))); }
    get flutterAdditionalArgs() { return this.getConfig("flutterAdditionalArgs", []); }
    get flutterAttachAdditionalArgs() { return this.getConfig("flutterAttachAdditionalArgs", []); }
    get flutterDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterDaemonLogFile", null))); }
    get flutterRunAdditionalArgs() { return this.getConfig("flutterRunAdditionalArgs", []); }
    get flutterRunLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterRunLogFile", null))); }
    get flutterScreenshotPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterScreenshotPath", null)); }
    get flutterSdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("flutterSdkPath", null)); }
    get flutterSdkPaths() { return this.getConfig("flutterSdkPaths", []).map(utils_2.resolvePaths); }
    get flutterTestAdditionalArgs() { return this.getConfig("flutterTestAdditionalArgs", []); }
    get flutterTestLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("flutterTestLogFile", null))); }
    get flutterTrackWidgetCreation() { return this.getConfig("flutterTrackWidgetCreation", true); }
    get insertArgumentPlaceholders() { return this.getConfig("insertArgumentPlaceholders", true); }
    get lineLength() { return this.getConfig("lineLength", 80); }
    get promptToGetPackages() { return this.getConfig("promptToGetPackages", true); }
    get pubAdditionalArgs() { return this.getConfig("pubAdditionalArgs", []); }
    get runPubGetOnPubspecChanges() {
        let value = this.getConfig("runPubGetOnPubspecChanges", "always");
        if (value === true)
            value = "always";
        if (value === false)
            value = "never";
        return value;
    }
    get sdkPath() { return (0, utils_2.resolvePaths)(this.getConfig("sdkPath", null)); }
    get sdkPaths() { return this.getConfig("sdkPaths", []).map(utils_2.resolvePaths); }
    get showDartDeveloperLogs() { return this.getConfig("showDartDeveloperLogs", true); }
    get suppressTestTimeouts() { return this.getConfig("suppressTestTimeouts", "never"); }
    get testAdditionalArgs() { return this.getConfig("testAdditionalArgs", []); }
    get vmAdditionalArgs() { return this.getConfig("vmAdditionalArgs", []); }
    get vmServiceLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("vmServiceLogFile", null))); }
    get webDaemonLogFile() { return (0, utils_2.createFolderForFile)((0, utils_2.resolvePaths)(this.getConfig("webDaemonLogFile", null))); }
}
exports.ResourceConfig = ResourceConfig;
exports.config = new Config();


/***/ }),

/***/ 4530:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTaskProvider = exports.BaseTaskProvider = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const project_1 = __webpack_require__(3886);
const util = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
const projects_1 = __webpack_require__(6417);
const buildRunnerProblemMatcher = "$dart-build_runner";
const buildRunnerBuildOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Build, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const buildRunnerTestOptions = { problemMatchers: [buildRunnerProblemMatcher], isBackground: true, group: vs.TaskGroup.Test, runtimeArgs: () => config_1.config.buildRunnerAdditionalArgs };
const flutterBuildOptions = { isBackground: true, group: vs.TaskGroup.Build };
const taskOptions = [
    // test must come first so it matches before the next catch-all one
    [["pub", "run", "build_runner", "test"], buildRunnerTestOptions],
    [["pub", "run", "build_runner"], buildRunnerBuildOptions],
    [["build"], flutterBuildOptions],
];
class BaseTaskProvider {
    constructor(logger, context, sdks) {
        this.logger = logger;
        this.context = context;
        this.sdks = sdks;
    }
    /// Tasks that will either be run by Dart or Flutter depending on the project type.
    createSharedTasks(workspaceFolder, projectFolder) {
        const promises = [];
        promises.push(this.createPubTask(workspaceFolder, projectFolder, ["get"]));
        promises.push(this.createPubTask(workspaceFolder, projectFolder, ["upgrade"]));
        if ((0, fs_1.referencesBuildRunner)((0, fs_1.fsPath)(projectFolder))) {
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "watch"]));
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "build"]));
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "serve"]));
            promises.push(this.createPubTask(workspaceFolder, projectFolder, ["run", "build_runner", "test"]));
        }
        return promises;
    }
    resolveTask(task, token) {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            const scope = task.scope;
            const workspaceFolderPath = "uri" in scope ? (0, fs_1.fsPath)(scope.uri) : undefined;
            const definitionCwd = task.definition.cwd;
            const cwd = workspaceFolderPath && definitionCwd ? path.join(workspaceFolderPath, definitionCwd) : (_a = task.definition.cwd) !== null && _a !== void 0 ? _a : workspaceFolderPath;
            const definition = task.definition;
            // Pub commands should be run through Flutter if a Flutter project.
            if (definition.command === "pub" && (0, fs_1.isFlutterProjectFolder)(cwd)) {
                definition.command = "flutter";
                definition.args = ["pub", ...((_b = definition.args) !== null && _b !== void 0 ? _b : [])];
            }
            const options = this.getOptions(definition);
            if (options === null || options === void 0 ? void 0 : options.runtimeArgs) {
                definition.args = ((_c = definition.args) !== null && _c !== void 0 ? _c : []).concat((_d = (yield (options === null || options === void 0 ? void 0 : options.runtimeArgs()))) !== null && _d !== void 0 ? _d : []);
            }
            this.injectArgs(definition);
            // We *must* return a new Task here, otherwise the task cannot be customised
            // in task.json.
            // https://github.com/microsoft/vscode/issues/58836#issuecomment-696620105
            const newTask = new vs.Task(definition, 
            // This should never be undefined, but the type allows it but the constructor
            // arg does not.
            task.scope || vs.TaskScope.Workspace, task.name, task.source, yield this.createTaskExecution(this.sdks, definition, cwd), undefined);
            newTask.detail = task.detail;
            newTask.problemMatchers = (_e = (newTask.problemMatchers && newTask.problemMatchers.length ? newTask.problemMatchers : options === null || options === void 0 ? void 0 : options.problemMatchers)) !== null && _e !== void 0 ? _e : [];
            newTask.group = (_f = task.group) !== null && _f !== void 0 ? _f : options === null || options === void 0 ? void 0 : options.group;
            newTask.isBackground = task.isBackground || ((_g = options === null || options === void 0 ? void 0 : options.isBackground) !== null && _g !== void 0 ? _g : false);
            return newTask;
        });
    }
    injectArgs(_) {
    }
    getOptions(def) {
        var _a;
        let taskCommand = [def.command, ...((_a = def.args) !== null && _a !== void 0 ? _a : [])];
        // Strip ""dart" or flutter" from the front for easier matching.
        if (taskCommand[0] === "flutter" || taskCommand[0] === "dart")
            taskCommand = taskCommand.slice(1);
        for (const knownOption of taskOptions) {
            const [command, options] = knownOption;
            if ((0, array_1.arrayStartsWith)(taskCommand, command))
                return options;
        }
    }
    createTaskStub(workspaceFolder, projectFolder, command, args) {
        const workspaceFolderPath = (0, fs_1.fsPath)(workspaceFolder.uri);
        const projectPath = (0, fs_1.fsPath)(projectFolder);
        const relativePath = path.relative(workspaceFolderPath, projectPath);
        const task = new vs.Task({ type: this.type, cwd: relativePath, command, args }, workspaceFolder, [command, ...args].join(" "), this.type, undefined, undefined);
        task.detail = relativePath;
        return task;
    }
    createTask(workspaceFolder, projectFolder, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const task = this.createTaskStub(workspaceFolder, projectFolder, command, args);
            return this.resolveTask(task);
        });
    }
    runProjectTask(uri, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const projectRoot = uri ? (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(uri)) : undefined;
            const projectRootUri = projectRoot ? vs.Uri.file(projectRoot) : undefined;
            return this.runTask(projectRootUri, command, args);
        });
    }
    runTask(uri, command, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let projectFolder = uri;
            let workspaceFolder = uri ? vs.workspace.getWorkspaceFolder(uri) : undefined;
            if (!workspaceFolder) {
                const folderPath = yield (0, projects_1.getFolderToRunCommandIn)(this.logger, "Select which project to run the command for");
                if (!folderPath)
                    return;
                projectFolder = vs.Uri.file(folderPath);
                workspaceFolder = vs.workspace.getWorkspaceFolder(projectFolder);
            }
            if (!workspaceFolder)
                return;
            const task = yield this.createTask(workspaceFolder, projectFolder, command, args);
            return vs.tasks.executeTask(task);
        });
    }
    createTaskExecution(sdks, definition, cwd) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!definition.command)
                return;
            const sdk = definition.command === "flutter" && sdks.flutter ? sdks.flutter : sdks.dart;
            const executable = (0, constants_1.getExecutableName)(definition.command);
            const program = path.join(sdk, "bin", executable);
            let args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
            if (definition.runtimeArgs) {
                const runtimeArgs = yield definition.runtimeArgs();
                if (runtimeArgs)
                    args = args.concat(runtimeArgs);
            }
            return new vs.ProcessExecution(program, args || [], { cwd, env: (0, processes_1.getToolEnv)() });
        });
    }
}
exports.BaseTaskProvider = BaseTaskProvider;
class DartTaskProvider extends BaseTaskProvider {
    constructor(logger, context, sdks, dartCapabilities) {
        super(logger, context, sdks);
        this.dartCapabilities = dartCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("dart.task.dartdoc", (uri) => this.runTask(uri, this.dartDocCommand, this.dartDocArguments)));
    }
    get dartDocCommand() { return this.dartCapabilities.supportsDartDoc ? "dart" : "dartdoc"; }
    get dartDocArguments() { return this.dartCapabilities.supportsDartDoc ? ["doc", "."] : ["."]; }
    get type() { return DartTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const projectFolders = yield (0, utils_1.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            let promises = [];
            projectFolders.forEach((folder) => {
                const folderUri = vs.Uri.file(folder);
                const workspaceFolder = vs.workspace.getWorkspaceFolder(folderUri);
                const isFlutter = (0, fs_1.isFlutterProjectFolder)(folder);
                if (!isFlutter)
                    promises = promises.concat(this.createSharedTasks(workspaceFolder, folderUri));
                promises.push(this.createTask(workspaceFolder, folderUri, this.dartDocCommand, this.dartDocArguments));
                // For testing...
                // tasks.push(this.createTask(folder, "--version"));
            });
            const tasks = (yield Promise.all(promises));
            return tasks;
        });
    }
    createPubTask(workspaceFolder, projectFolder, args) {
        if (this.dartCapabilities.supportsDartRunForPub && args && args.length && args[0] === "run")
            return this.createTask(workspaceFolder, projectFolder, "dart", [...args]);
        else if (this.dartCapabilities.supportsDartPub)
            return this.createTask(workspaceFolder, projectFolder, "dart", ["pub", ...args]);
        else
            return this.createTask(workspaceFolder, projectFolder, "pub", args);
    }
}
exports.DartTaskProvider = DartTaskProvider;
DartTaskProvider.type = "dart"; // also referenced in package.json


/***/ }),

/***/ 3424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HotReloadOnSaveHandler = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
class HotReloadOnSaveHandler {
    constructor(debugCommands, flutterCapabilities) {
        this.debugCommands = debugCommands;
        this.flutterCapabilities = flutterCapabilities;
        this.disposables = [];
        // And whether any saved file was dirty to support `..ifDirty` settings.
        this.isSavingDirtyFile = false;
        // Non-FS-watcher version (onDidSave).
        this.disposables.push(vscode_1.workspace.onWillSaveTextDocument((e) => {
            if (!this.isReloadableFile(e.document))
                return;
            this.lastSaveReason = e.reason;
            this.isSavingDirtyFile = this.isSavingDirtyFile || e.document.isDirty;
        }));
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            // Bail if we're using fs-watcher instead. We still wire this
            // handler up so we don't need to reload for this setting change.
            if (config_1.config.previewHotReloadOnSaveWatcher)
                return;
            this.triggerReload(td);
        }));
        // FS-watcher version.
        // TODO: Make this support everything that shouldHotReloadFor() does.
        const watcher = vscode_1.workspace.createFileSystemWatcher("**/*.dart");
        this.disposables.push(watcher);
        watcher.onDidChange(this.handleFileSystemChange, this);
        watcher.onDidCreate(this.handleFileSystemChange, this);
    }
    handleFileSystemChange(uri) {
        // Bail if we're not using fs-watcher instead. We still wire this
        // handler up so we don't need to reload for this setting change.
        if (!config_1.config.previewHotReloadOnSaveWatcher)
            return;
        this.triggerReload({ uri });
    }
    triggerReload(file) {
        const isAutoSave = this.lastSaveReason === vscode_1.TextDocumentSaveReason.FocusOut ||
            this.lastSaveReason === vscode_1.TextDocumentSaveReason.AfterDelay;
        // Never do anything for files inside .dart_tool folders.
        if (!this.isReloadableFile(file))
            return;
        const isDirty = this.isSavingDirtyFile;
        this.isSavingDirtyFile = false;
        // Don't do if we have errors for the saved file.
        const errors = vscode_1.languages.getDiagnostics(file.uri);
        const hasErrors = errors && !!errors.find((d) => d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Error);
        if (hasErrors)
            return;
        this.reloadDart({ isAutoSave, isDirty });
        this.reloadFlutter({ isAutoSave, isDirty });
    }
    isReloadableFile(file) {
        // Never do anything for files inside .dart_tool folders.
        if ((0, fs_1.fsPath)(file.uri).indexOf(`${path.sep}.dart_tool${path.sep}`) !== -1)
            return false;
        // Bail out if we're in an external file, or not Dart.
        if (!(0, utils_2.isWithinWorkspace)((0, fs_1.fsPath)(file.uri)) || !(0, utils_2.shouldHotReloadFor)(file))
            return false;
        return true;
    }
    reloadDart({ isAutoSave, isDirty }) {
        const configSetting = config_1.config.hotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "dart.hotReload";
        const args = {
            onlyDart: true,
            reason: constants_1.restartReasonSave,
        };
        // Debounce to avoid reloading multiple times during multi-file-save (Save All).
        // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
        if (this.dartHotReloadDelayTimer) {
            clearTimeout(this.dartHotReloadDelayTimer);
        }
        this.dartHotReloadDelayTimer = setTimeout(() => {
            this.dartHotReloadDelayTimer = undefined;
            vscode_1.commands.executeCommand(commandToRun, args);
        }, 200);
    }
    reloadFlutter({ isAutoSave, isDirty }) {
        const configSetting = config_1.config.flutterHotReloadOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "dart.hotReload";
        const args = {
            debounce: this.flutterCapabilities.supportsRestartDebounce,
            onlyFlutter: true,
            reason: constants_1.restartReasonSave,
        };
        if (this.flutterCapabilities.supportsRestartDebounce) {
            vscode_1.commands.executeCommand(commandToRun, args);
        }
        else {
            // Debounce to avoid reloading multiple times during multi-file-save (Save All).
            // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
            if (this.flutterHotReloadDelayTimer) {
                clearTimeout(this.flutterHotReloadDelayTimer);
            }
            this.flutterHotReloadDelayTimer = setTimeout(() => {
                this.flutterHotReloadDelayTimer = undefined;
                vscode_1.commands.executeCommand(commandToRun, args);
            }, 200);
        }
    }
    dispose() {
        if (this.dartHotReloadDelayTimer)
            clearTimeout(this.dartHotReloadDelayTimer);
        if (this.flutterHotReloadDelayTimer)
            clearTimeout(this.flutterHotReloadDelayTimer);
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.HotReloadOnSaveHandler = HotReloadOnSaveHandler;


/***/ }),

/***/ 1326:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClosingLabelsDecorations = exports.validLastCharacters = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(8779);
exports.validLastCharacters = [")", "]"];
class ClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        this.subscriptions.push(this.analyzer.registerForAnalysisClosingLabels((n) => {
            if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.closingLabels = n;
                this.update();
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor)
            this.setTrackingFile(vs.window.activeTextEditor);
    }
    update() {
        if (!this.closingLabels || !this.activeEditor || this.closingLabels.file !== (0, fs_1.fsPath)(this.activeEditor.document.uri))
            return;
        const decorations = [];
        for (const r of this.closingLabels.labels) {
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = this.activeEditor.document.positionAt(r.offset + r.length);
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = this.activeEditor.document.getText(finalCharacterRange);
            if (exports.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = this.activeEditor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(this.activeEditor.document.positionAt(r.offset), endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.activeEditor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    setTrackingFile(editor) {
        var _a;
        if (!editor || !(0, utils_2.isAnalyzable)(editor.document))
            return;
        if (editor !== this.activeEditor)
            (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        if (editor) {
            this.activeEditor = editor;
            this.closingLabels = undefined;
            this.analyzer.forceNotificationsFor((0, fs_1.fsPath)(editor.document.uri));
        }
        else {
            this.activeEditor = undefined;
            this.closingLabels = undefined;
        }
    }
    dispose() {
        var _a;
        (_a = this.activeEditor) === null || _a === void 0 ? void 0 : _a.setDecorations(this.decorationType, []);
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.ClosingLabelsDecorations = ClosingLabelsDecorations;


/***/ }),

/***/ 1739:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterColorDecorations = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const color_range_computer_1 = __webpack_require__(1197);
const utils_2 = __webpack_require__(8779);
class FlutterColorDecorations {
    constructor(logger, imageStoragePath) {
        this.logger = logger;
        this.imageStoragePath = imageStoragePath;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.computer = new color_range_computer_1.ColorRangeComputer();
        this.subscriptions.push(vs.workspace.onDidChangeTextDocument((e) => {
            if (this.activeEditor && e.document === this.activeEditor.document) {
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                this.updateTimeout = setTimeout(() => this.update(), 1000);
            }
        }));
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        }
    }
    update() {
        if (!this.activeEditor)
            return;
        const results = this.computer.compute(this.activeEditor.document);
        // Each color needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const colorHex of Object.keys(results)) {
            const filePath = this.createImageFile(colorHex);
            if (filePath && !this.decorationTypes[colorHex])
                this.decorationTypes[colorHex] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.file(filePath),
                    gutterIconSize: "50%",
                });
        }
        for (const colorHex of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[colorHex], results[colorHex] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_2.isAnalyzable)(editor.document)) {
            this.activeEditor = editor;
        }
        else
            this.activeEditor = undefined;
    }
    createImageFile(hex) {
        // Add a version number to the folder in case we need to change these
        // and invalidate the old ones.
        const imageFolder = path.join(this.imageStoragePath, "v1");
        (0, fs_1.mkDirRecursive)(imageFolder);
        const file = path.join(imageFolder, `${hex}.svg`);
        if (fs.existsSync(file))
            return file;
        try {
            const hex6 = hex.substr(2);
            const opacity = parseInt(hex.substr(0, 2), 16) / 255;
            const imageContents = svgContents
                .replace("{HEX-6}", hex6)
                .replace("{OPACITY}", opacity.toString());
            fs.writeFileSync(file, imageContents);
            return file;
        }
        catch (e) {
            this.logger.warn(e);
        }
    }
    dispose() {
        if (this.activeEditor) {
            for (const colorHex of Object.keys(this.decorationTypes))
                this.activeEditor.setDecorations(this.decorationTypes[colorHex], []);
        }
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterColorDecorations = FlutterColorDecorations;
const svgContents = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
	<rect fill="#{HEX-6}" x="0" y="0" width="16" height="16" fill-opacity="{OPACITY}" />
</svg>
`;


/***/ }),

/***/ 4478:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorations = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const extension_utils_1 = __webpack_require__(6143);
const utils_2 = __webpack_require__(8779);
class FlutterIconDecorations {
    constructor(logger) {
        this.logger = logger;
        this.subscriptions = [];
        this.decorationTypes = {};
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => {
            this.setTrackingFile(e);
            this.update();
        }));
        setImmediate(() => {
            this.setTrackingFile(vs.window.activeTextEditor);
            this.update();
        });
    }
    render(results) {
        if (!this.activeEditor)
            return;
        // Each icon type needs to be its own decoration, so here we update our main list
        // with any new ones we hadn't previously created.
        for (const iconName of Object.keys(results)) {
            if (!this.decorationTypes[iconName])
                this.decorationTypes[iconName] = vs.window.createTextEditorDecorationType({
                    gutterIconPath: vs.Uri.parse(extension_utils_1.docsIconPathFormat.replace("$1", iconName)),
                    gutterIconSize: "75%",
                });
        }
        for (const iconName of Object.keys(this.decorationTypes)) {
            this.activeEditor.setDecorations(this.decorationTypes[iconName], results[iconName] || []);
        }
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_2.isAnalyzable)(editor.document))
            this.activeEditor = editor;
        else
            this.activeEditor = undefined;
    }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterIconDecorations = FlutterIconDecorations;


/***/ }),

/***/ 91:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsDas = void 0;
const fs_1 = __webpack_require__(300);
const icon_range_computer_1 = __webpack_require__(7731);
const flutter_icon_decorations_1 = __webpack_require__(4478);
class FlutterIconDecorationsDas extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputer(logger);
        this.subscriptions.push(this.analyzer.client.registerForFlutterOutline((n) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === n.file) {
                this.update(n.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(this.activeEditor.document, outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsDas = FlutterIconDecorationsDas;


/***/ }),

/***/ 789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterIconDecorationsLsp = void 0;
const vs = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const icon_range_computer_1 = __webpack_require__(7731);
const flutter_icon_decorations_1 = __webpack_require__(4478);
class FlutterIconDecorationsLsp extends flutter_icon_decorations_1.FlutterIconDecorations {
    constructor(logger, analyzer) {
        super(logger);
        this.analyzer = analyzer;
        this.computer = new icon_range_computer_1.IconRangeComputerLsp(logger);
        this.subscriptions.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => __awaiter(this, void 0, void 0, function* () {
            if (this.activeEditor && (0, fs_1.fsPath)(this.activeEditor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri))) {
                this.update(op.outline);
            }
        })));
    }
    update(outline) {
        if (!this.activeEditor)
            return;
        if (!outline)
            outline = this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri);
        if (!outline)
            return;
        const results = this.computer.compute(outline);
        this.render(results);
    }
}
exports.FlutterIconDecorationsLsp = FlutterIconDecorationsLsp;


/***/ }),

/***/ 8681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WidgetGuide = exports.FlutterUiGuideDecorations = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const trackers_1 = __webpack_require__(4191);
const config_1 = __webpack_require__(4165);
const nonBreakingSpace = "\xa0";
const verticalLine = "│";
const horizontalLine = "─";
const bottomCorner = "└";
const middleCorner = "├";
class FlutterUiGuideDecorations {
    constructor() {
        this.disposables = [];
        this.borderDecoration = vs.window.createTextEditorDecorationType({
            rangeBehavior: vs.DecorationRangeBehavior.OpenOpen,
        });
        // Update any editor that becomes active.
        this.disposables.push(vs.window.onDidChangeActiveTextEditor((e) => this.buildForTextEditor(e)));
        if (config_1.config.previewFlutterUiGuidesCustomTracking) {
            this.tracker = new WidgetGuideTracker();
            this.disposables.push(this.tracker);
            // Subscribe to updates from the tracker so we can update on keypress without
            // waiting for new Outlines.
            this.tracker.onGuidesChanged(([doc, guides]) => this.buildFromUpdatedGuides(doc, guides));
        }
        // Update the current visible editor when we were registered.
        setImmediate(() => this.buildForTextEditor(vs.window.activeTextEditor));
    }
    buildFromUpdatedGuides(doc, guides) {
        if (vs.window.activeTextEditor && vs.window.activeTextEditor.document === doc)
            this.renderGuides(vs.window.activeTextEditor, guides);
    }
    renderGuides(editor, guides) {
        const color = new vs.ThemeColor("dart.flutterUiGuides");
        const guidesByLine = {};
        for (const guide of guides) {
            for (let line = guide.start.line; line <= guide.end.line; line++) {
                guidesByLine[line] = guidesByLine[line] || [];
                guidesByLine[line].push(guide);
            }
        }
        const decorations = this.buildDecorations(editor.document, editor.options.tabSize, guidesByLine, color);
        editor.setDecorations(this.borderDecoration, decorations);
    }
    buildDecorations(doc, tabSize, guidesByLine, color) {
        const decorations = [];
        for (const line of Object.keys(guidesByLine).map((k) => parseInt(k, 10))) {
            const lineInfo = doc.lineAt(line);
            const firstGuideChar = Math.min(...guidesByLine[line].map((g) => Math.min(g.start.character, g.end.character)));
            const lastGuideChar = Math.max(...guidesByLine[line].map((g) => Math.max(g.start.character, g.end.character)));
            const lastLineCharacter = lineInfo.range.end.character;
            const anchorPoint = Math.max(lastLineCharacter < firstGuideChar ? 0 : firstGuideChar, 0);
            const decorationString = new Array(lastGuideChar).fill(nonBreakingSpace);
            for (const guide of guidesByLine[line]) {
                if (line !== guide.end.line) {
                    // Only put a vertical line in if we haven't already o
                    if (decorationString[guide.start.character] === nonBreakingSpace)
                        decorationString[guide.start.character] = verticalLine;
                    else if (decorationString[guide.start.character] === bottomCorner)
                        decorationString[guide.start.character] = middleCorner;
                }
                else {
                    for (let c = guide.start.character; c <= guide.end.character; c++) {
                        if (c === guide.start.character) {
                            decorationString[c] = bottomCorner;
                        }
                        else {
                            decorationString[c] = horizontalLine;
                        }
                    }
                }
            }
            // For any characters that have users text in them, we should not
            // render any guides.
            decorationString.fill(nonBreakingSpace, lineInfo.firstNonWhitespaceCharacterIndex, lineInfo.range.end.character);
            decorationString.splice(0, anchorPoint);
            // For any tabs in the document string, we need to multiply up the characters
            // by the tab width, since everything up to this point is based on the text line
            // character indexes, but rendering needs to obey tab size.
            const tabAdjustedDecorationString = [];
            for (let i = 0; i < decorationString.length; i++) {
                tabAdjustedDecorationString.push(decorationString[i]);
                if (lineInfo.text[anchorPoint + i] === "\t") {
                    const padCharacter = decorationString[i] === horizontalLine || decorationString[i] === bottomCorner || decorationString[i] === middleCorner
                        ? horizontalLine
                        : nonBreakingSpace;
                    for (let c = 0; c < tabSize - 1; c++)
                        tabAdjustedDecorationString.push(padCharacter);
                }
            }
            decorations.push({
                range: new vs.Range(new vs.Position(line, anchorPoint), new vs.Position(line, anchorPoint)),
                renderOptions: {
                    before: {
                        color,
                        contentText: tabAdjustedDecorationString.join(""),
                        fontStyle: "normal",
                        margin: "0 1px 0 -1px",
                        width: "0",
                    },
                },
            });
        }
        return decorations;
    }
    firstNonWhitespace(document, lineNumber) {
        return new vs.Position(lineNumber, document.lineAt(lineNumber).firstNonWhitespaceCharacterIndex);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.FlutterUiGuideDecorations = FlutterUiGuideDecorations;
class WidgetGuide {
    constructor(start, end) {
        this.start = start;
        this.end = end;
    }
}
exports.WidgetGuide = WidgetGuide;
class WidgetGuideTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new trackers_1.DocumentPositionTracker();
        this.guideMap = new Map();
        this.onGuidesChangedEmitter = new vs.EventEmitter();
        this.onGuidesChanged = this.onGuidesChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onPositionsChanged(([doc, positions]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newGuides = [];
            for (const guide of this.guideMap.keys()) {
                const data = this.guideMap.get(guide);
                const currentStartPos = data[0];
                const currentEndPos = data[1];
                const newStartPos = positions.get(currentStartPos);
                const newEndPos = positions.get(currentEndPos);
                if (newStartPos && newEndPos)
                    newGuides.push(new WidgetGuide(newStartPos, newEndPos));
            }
            this.onGuidesChangedEmitter.fire([doc, newGuides]);
        });
    }
    clear() {
        this.guideMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, guides) {
        // Stash all guides as tuples containing their positions.
        this.guideMap.clear();
        for (const guide of guides)
            this.guideMap.set(guide, [guide.start, guide.end]);
        // Extract a flat list of positions to track.
        const positions = (0, utils_1.flatMap)([...this.guideMap.values()], (g) => [g[0], g[1]]);
        this.tracker.trackDoc(document, positions);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}


/***/ }),

/***/ 7900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsDas = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const flutter_ui_guides_decorations_1 = __webpack_require__(8681);
class FlutterUiGuideDecorationsDas extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.client.registerForFlutterOutline((on) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === on.file)
                this.buildFromOutline(editor, on.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        if (editor.document.getText().length !== outline.length)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = document.positionAt(node.offset).line;
            const childLines = node.children && node.children
                .map((c) => document.positionAt(c.offset).line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsDas = FlutterUiGuideDecorationsDas;


/***/ }),

/***/ 1397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterUiGuideDecorationsLsp = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const flutter_ui_guides_decorations_1 = __webpack_require__(8681);
class FlutterUiGuideDecorationsLsp extends flutter_ui_guides_decorations_1.FlutterUiGuideDecorations {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        // Whenever we get a new Flutter Outline, if it's for the active document,
        // update that too.
        this.disposables.push(this.analyzer.fileTracker.onFlutterOutline.listen((op) => {
            const editor = vs.window.activeTextEditor;
            if (editor && editor.document && (0, fs_1.fsPath)(editor.document.uri) === (0, fs_1.fsPath)(vs.Uri.parse(op.uri)))
                this.buildFromOutline(editor, op.outline);
        }));
    }
    buildForTextEditor(editor) {
        if (editor && editor.document)
            this.buildFromOutline(editor, this.analyzer.fileTracker.getFlutterOutlineFor(editor.document.uri));
    }
    buildFromOutline(editor, outline) {
        if (this.tracker)
            this.tracker.clear();
        if (!editor || !editor.document || !outline)
            return;
        // Check that the outline we got looks like it still matches the document.
        // If the lengths are different, just bail without doing anything since
        // there have probably been new edits and we'll get a new outline soon.
        const outlineLength = editor.document.offsetAt((0, utils_2.lspToPosition)(outline.range.end));
        if (editor.document.getText().length !== outlineLength)
            return;
        const guides = this.extractGuides(editor.document, outline);
        if (this.tracker)
            this.tracker.trackDoc(editor.document, guides);
        this.renderGuides(editor, guides);
    }
    extractGuides(document, node) {
        let guides = [];
        if (node.kind === "NEW_INSTANCE") {
            const parentLine = node.codeRange.start.line;
            const childLines = node.children && node.children
                .map((c) => c.codeRange.start.line)
                .filter((cl) => cl > parentLine);
            if (childLines) {
                const startPos = this
                    .firstNonWhitespace(document, parentLine);
                childLines.forEach((childLine, i) => {
                    const firstCodeChar = this.firstNonWhitespace(document, childLine);
                    guides.push(new flutter_ui_guides_decorations_1.WidgetGuide(startPos, firstCodeChar));
                });
            }
        }
        // Recurse down the tree to include childrens (and they'll include their
        // childrens, etc.).
        if (node.children)
            guides = guides.concat((0, utils_1.flatMap)(node.children, (c) => this.extractGuides(document, c)));
        return guides;
    }
}
exports.FlutterUiGuideDecorationsLsp = FlutterUiGuideDecorationsLsp;


/***/ }),

/***/ 8805:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getActiveRealFileEditor = exports.getActiveDartEditor = exports.isDartDocument = void 0;
const vs = __webpack_require__(9496);
function isDartDocument(document) {
    return document && document.languageId === "dart";
}
exports.isDartDocument = isDartDocument;
function getActiveDartEditor() {
    const editor = vs.window.activeTextEditor;
    if (!editor || editor.document.languageId !== "dart")
        return undefined;
    return editor;
}
exports.getActiveDartEditor = getActiveDartEditor;
/// Gets the "active" file:// TextEditor, excluding any output: panes that
/// might be in the list.
function getActiveRealFileEditor() {
    let editor = vs.window.activeTextEditor;
    // It's possible the "active editor" is actually an Output pane, so
    // try falling back to a single visible (file-scheme) editor if there is one.
    if ((editor === null || editor === void 0 ? void 0 : editor.document.uri.scheme) !== "file") {
        const fileEditors = vs.window.visibleTextEditors.filter((e) => e.document.uri.scheme === "file");
        if (fileEditors.length === 1) {
            console.log(`Falling back from ${editor === null || editor === void 0 ? void 0 : editor.document.uri} to ${fileEditors[0].document.uri}`);
            editor = fileEditors[0];
        }
    }
    return (editor === null || editor === void 0 ? void 0 : editor.document.uri.scheme) === "file"
        ? editor
        : undefined;
}
exports.getActiveRealFileEditor = getActiveRealFileEditor;


/***/ }),

/***/ 1824:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExperiments = void 0;
const fs_1 = __webpack_require__(300);
// Used for testing. DO NOT COMMIT AS TRUE.
const clearAllExperiments = false;
function getExperiments(logger, workspaceContext, context) {
    return {
        // example: new ExampleExperiment(logger, workspaceContext, context),
        sdkDaps: new SdkDapExperiment(logger, workspaceContext, context),
    };
}
exports.getExperiments = getExperiments;
// class ExampleExperiment extends Experiment {
// 	constructor(logger: Logger, workspaceContext: WorkspaceContext, context: Context) {
// 		super(logger, workspaceContext, context, "example", 10);
// 	}
// }
class Experiment {
    constructor(logger, workspaceContext, context, id, currentPercent) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.context = context;
        this.id = id;
        this.currentPercent = currentPercent;
        // If this is the first time we've seen this experiment, generate a random number
        // from 1-100.
        const contextKey = `experiment-${id}`;
        const contextHasActivatedKey = `${contextKey}-hasActivated`;
        if (clearAllExperiments) {
            context.update(contextKey, undefined);
            context.update(contextHasActivatedKey, undefined);
        }
        this.randomNumber = context.get(contextKey);
        if (!this.randomNumber) {
            this.randomNumber = (0, fs_1.getRandomInt)(1, 100);
            context.update(contextKey, this.randomNumber);
            logger.info(`Generated random number ${this.randomNumber} for new experiment '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        else {
            logger.info(`Experiment random number is ${this.randomNumber} for experiment '${id}'. Experiment is enabled for <= ${this.currentPercent}`);
        }
        if (this.applies) {
            const isFirst = !context.get(contextHasActivatedKey);
            context.update(contextHasActivatedKey, true);
            logger.info(`Experiment '${id}' is activating (${isFirst ? "first time" : "not first time"})`);
            this.activate(isFirst)
                // Activate is allowed to return false if it skipped activating (eg. not relevant) so
                // first activation can re-run in future.
                .then((v) => {
                if (v === false) {
                    logger.info(`Experiment '${id}' aborted. Clearing hasActivated flag`);
                    context.update(contextHasActivatedKey, undefined);
                }
            });
        }
        else {
            logger.info(`Experiment '${id}' does not apply and will not be activated`);
        }
    }
    get applies() { return this.randomNumber <= this.currentPercent; }
    /// Activates the experiment. If returns false, resets the hasActivated flag so it
    /// is not considered to have run.
    activate(isFirstActivation) {
        return __awaiter(this, void 0, void 0, function* () { return; });
    }
}
class SdkDapExperiment extends Experiment {
    constructor(logger, workspaceContext, context) {
        super(logger, workspaceContext, context, "sdkDaps", 10);
    }
    get applies() { return super.applies; }
}


/***/ }),

/***/ 1892:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = exports.ringLog = exports.SERVICE_CONTEXT_PREFIX = exports.SERVICE_EXTENSION_CONTEXT_PREFIX = exports.FLUTTER_SUPPORTS_ATTACH = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const dart_1 = __webpack_require__(7355);
const flutter_1 = __webpack_require__(4790);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fetch_1 = __webpack_require__(2183);
const logging_1 = __webpack_require__(8323);
const api_1 = __webpack_require__(8316);
const symbols_1 = __webpack_require__(9055);
const coordinator_1 = __webpack_require__(6171);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const constants_2 = __webpack_require__(6249);
const device_manager_1 = __webpack_require__(6711);
const extension_utils_1 = __webpack_require__(6143);
const uri_handler_1 = __webpack_require__(5652);
const utils_2 = __webpack_require__(7220);
const workspace_1 = __webpack_require__(6105);
const analyzer_das_1 = __webpack_require__(2061);
const analyzer_lsp_1 = __webpack_require__(9165);
const analyzer_status_reporter_1 = __webpack_require__(2975);
const file_change_handler_1 = __webpack_require__(7246);
const file_change_warnings_1 = __webpack_require__(4775);
const analytics_1 = __webpack_require__(3189);
const api_2 = __webpack_require__(8237);
const flutter_dartpad_samples_1 = __webpack_require__(7525);
const flutter_dartpad_samples_lsp_1 = __webpack_require__(6212);
const main_code_lens_provider_1 = __webpack_require__(7927);
const main_code_lens_provider_lsp_1 = __webpack_require__(5543);
const test_code_lens_provider_1 = __webpack_require__(6993);
const test_code_lens_provider_lsp_1 = __webpack_require__(3005);
const add_dependency_1 = __webpack_require__(4954);
const analyzer_1 = __webpack_require__(8932);
const channels_1 = __webpack_require__(1026);
const dart_2 = __webpack_require__(5836);
const debug_1 = __webpack_require__(4635);
const edit_1 = __webpack_require__(7244);
const edit_das_1 = __webpack_require__(7511);
const edit_lsp_1 = __webpack_require__(6039);
const flutter_2 = __webpack_require__(2364);
const flutter_outline_1 = __webpack_require__(9021);
const go_to_super_1 = __webpack_require__(1471);
const logging_2 = __webpack_require__(9475);
const open_in_other_editors_1 = __webpack_require__(7809);
const packages_1 = __webpack_require__(8128);
const refactor_1 = __webpack_require__(883);
const sdk_1 = __webpack_require__(997);
const test_1 = __webpack_require__(6003);
const type_hierarchy_1 = __webpack_require__(4593);
const config_1 = __webpack_require__(4165);
const dart_task_provider_1 = __webpack_require__(4530);
const hot_reload_save_handler_1 = __webpack_require__(3424);
const closing_labels_decorations_1 = __webpack_require__(1326);
const flutter_color_decorations_1 = __webpack_require__(1739);
const flutter_icon_decorations_das_1 = __webpack_require__(91);
const flutter_icon_decorations_lsp_1 = __webpack_require__(789);
const flutter_ui_guides_decorations_das_1 = __webpack_require__(7900);
const flutter_ui_guides_decorations_lsp_1 = __webpack_require__(1397);
const experiments_1 = __webpack_require__(1824);
const daemon_message_handler_1 = __webpack_require__(5086);
const flutter_daemon_1 = __webpack_require__(5887);
const flutter_outline_view_1 = __webpack_require__(4942);
const flutter_task_provider_1 = __webpack_require__(9476);
const generate_localizations_on_save_handler_1 = __webpack_require__(4014);
const analyzer_status_reporter_2 = __webpack_require__(7428);
const closing_labels_decorations_2 = __webpack_require__(3088);
const go_to_super_2 = __webpack_require__(9982);
const test_discoverer_1 = __webpack_require__(3747);
const add_dependency_code_action_provider_1 = __webpack_require__(1983);
const assist_code_action_provider_1 = __webpack_require__(9679);
const dart_completion_item_provider_1 = __webpack_require__(6974);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
const dart_document_symbol_provider_1 = __webpack_require__(6663);
const dart_folding_provider_1 = __webpack_require__(3299);
const dart_formatting_edit_provider_1 = __webpack_require__(7099);
const dart_highlighting_provider_1 = __webpack_require__(9917);
const dart_hover_provider_1 = __webpack_require__(988);
const dart_implementation_provider_1 = __webpack_require__(9715);
const dart_language_configuration_1 = __webpack_require__(1122);
const dart_reference_provider_1 = __webpack_require__(8517);
const dart_rename_provider_1 = __webpack_require__(6252);
const dart_signature_help_provider_1 = __webpack_require__(4258);
const dart_workspace_symbol_provider_1 = __webpack_require__(5188);
const debug_adapter_descriptor_factory_1 = __webpack_require__(8109);
const debug_adapter_logger_factory_1 = __webpack_require__(4319);
const debug_config_provider_1 = __webpack_require__(233);
const fix_code_action_provider_1 = __webpack_require__(5587);
const legacy_dart_workspace_symbol_provider_1 = __webpack_require__(23);
const ranking_code_action_provider_1 = __webpack_require__(7702);
const refactor_code_action_provider_1 = __webpack_require__(3797);
const snippet_completion_item_provider_1 = __webpack_require__(2252);
const source_code_action_provider_1 = __webpack_require__(4508);
const global_1 = __webpack_require__(334);
const status_bar_version_tracker_1 = __webpack_require__(9032);
const update_check_1 = __webpack_require__(8949);
const utils_3 = __webpack_require__(8461);
const file_uri_link_provider_1 = __webpack_require__(4371);
const package_uri_link_provider_1 = __webpack_require__(3760);
const vs_test_controller_1 = __webpack_require__(2601);
const user_prompts_1 = __webpack_require__(4741);
const util = __webpack_require__(8779);
const utils_4 = __webpack_require__(8779);
const log_1 = __webpack_require__(8202);
const processes_1 = __webpack_require__(5430);
const packages_view_1 = __webpack_require__(5663);
const PROJECT_LOADED = "dart-code:anyProjectLoaded";
const DART_PROJECT_LOADED = "dart-code:anyStandardDartProjectLoaded";
const FLUTTER_PROJECT_LOADED = "dart-code:anyFlutterProjectLoaded";
const WEB_PROJECT_LOADED = "dart-code:WebProjectLoaded";
exports.FLUTTER_SUPPORTS_ATTACH = "dart-code:flutterSupportsAttach";
const DART_PLATFORM_NAME = "dart-code:dartPlatformName";
exports.SERVICE_EXTENSION_CONTEXT_PREFIX = "dart-code:serviceExtension.";
exports.SERVICE_CONTEXT_PREFIX = "dart-code:service.";
let analyzer;
let flutterDaemon;
let deviceManager;
const dartCapabilities = dart_1.DartCapabilities.empty;
const flutterCapabilities = flutter_1.FlutterCapabilities.empty;
let analysisRoots = [];
let analytics;
let showTodos;
let previousSettings;
let analyzerShutdown;
let experiments;
const loggers = [];
let ringLogger;
const logger = new logging_1.EmittingLogger();
// Keep a running in-memory buffer of last 200 log events we can give to the
// user when something crashed even if they don't have disk-logging enabled.
exports.ringLog = new logging_1.RingLog(200);
function activate(context, isRestart = false) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        // Ring logger is only set up once and presist over silent restarts.
        if (!ringLogger)
            ringLogger = logger.onLog((message) => exports.ringLog.log(message.toLine(500)));
        if (extension_utils_1.isDevExtension)
            context.subscriptions.push((0, logging_1.logToConsole)(logger));
        vs.commands.executeCommand("setContext", constants_1.IS_RUNNING_LOCALLY_CONTEXT, utils_2.isRunningLocally);
        buildLogHeaders();
        setupLog((0, log_1.getExtensionLogPath)(), enums_1.LogCategory.General);
        const extContext = workspace_1.Context.for(context);
        const webClient = new fetch_1.WebClient(extension_utils_1.extensionVersion);
        util.logTime("Code called activate");
        // Wire up a reload command that will re-initialise everything.
        context.subscriptions.push(vs.commands.registerCommand("_dart.reloadExtension", () => __awaiter(this, void 0, void 0, function* () {
            logger.info("Performing silent extension reload...");
            yield deactivate(true);
            (0, utils_1.disposeAll)(context.subscriptions);
            yield activate(context, true);
            logger.info("Done!");
        })));
        showTodos = config_1.config.showTodos;
        previousSettings = getSettingsThatRequireRestart();
        const extensionStartTime = new Date();
        util.logTime();
        const sdkUtils = new utils_3.SdkUtils(logger);
        const workspaceContextUnverified = yield sdkUtils.scanWorkspace();
        util.logTime("initWorkspace");
        // Set up log files.
        setupLog(config_1.config.analyzerLogFile, enums_1.LogCategory.Analyzer);
        setupLog(config_1.config.flutterDaemonLogFile, enums_1.LogCategory.FlutterDaemon);
        setupLog(config_1.config.dapLogFile, enums_1.LogCategory.DAP);
        setupLog(config_1.config.devToolsLogFile, enums_1.LogCategory.DevTools);
        analytics = new analytics_1.Analytics(logger, workspaceContextUnverified);
        if (!workspaceContextUnverified.sdks.dart || (workspaceContextUnverified.hasAnyFlutterProjects && !workspaceContextUnverified.sdks.flutter)) {
            // Don't set anything else up; we can't work like this!
            return sdkUtils.handleMissingSdks(context, analytics, workspaceContextUnverified);
        }
        const workspaceContext = workspaceContextUnverified;
        const sdks = workspaceContext.sdks;
        const writableConfig = workspaceContext.config;
        // TODO: Move these capabilities into WorkspaceContext.
        if (sdks.dartVersion) {
            dartCapabilities.version = sdks.dartVersion;
            analytics.sdkVersion = sdks.dartVersion;
            // tslint:disable-next-line: no-floating-promises
            (0, update_check_1.checkForStandardDartSdkUpdates)(logger, workspaceContext);
        }
        if (sdks.flutterVersion) {
            flutterCapabilities.version = sdks.flutterVersion;
            analytics.flutterSdkVersion = sdks.flutterVersion;
            // If we're going to pass the DevTools URL to Flutter, we need to eagerly start it
            // so it's already running.
            if (workspaceContext.hasAnyFlutterProjects && config_1.config.shareDevToolsWithFlutter && flutterCapabilities.supportsDevToolsServerAddress) {
                writableConfig.startDevToolsServerEagerly = true;
            }
        }
        try {
            if (!experiments)
                experiments = (0, experiments_1.getExperiments)(logger, workspaceContext, extContext);
        }
        catch (e) {
            logger.error(e);
        }
        const isVirtualWorkspace = vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.every((f) => f.uri.scheme !== "file");
        function shouldUseLsp() {
            // Never use LSP if the LSP client would reject the current VS Code version or the Dart SDK doesn't support it.
            if (!vscode_1.vsCodeVersion.supportsLatestLspClient || !dartCapabilities.canDefaultLsp)
                return false;
            // If DART_CODE_FORCE_LSP is set to true/false it always overrides.
            if (process.env.DART_CODE_FORCE_LSP === "true")
                return true;
            if (process.env.DART_CODE_FORCE_LSP === "false")
                return false;
            // In virtual workspaces, we always use LSP because it will have non-file resources
            // and we only handle them properly in LSP.
            if (isVirtualWorkspace)
                return true;
            return !config_1.config.useLegacyAnalyzerProtocol;
        }
        const isUsingLsp = shouldUseLsp();
        writableConfig.useLegacyProtocol = !isUsingLsp;
        vs.commands.executeCommand("setContext", constants_1.IS_LSP_CONTEXT, isUsingLsp);
        // Build log headers now we know analyzer type.
        buildLogHeaders(logger, workspaceContextUnverified);
        // Show the SDK version in the status bar.
        if (sdks.dartVersion)
            context.subscriptions.push(new status_bar_version_tracker_1.StatusBarVersionTracker(workspaceContext, isUsingLsp));
        if (isVirtualWorkspace && !dartCapabilities.supportsNonFileSchemeWorkspaces) {
            vs.window.showWarningMessage("Please upgrade to the latest Dart/Flutter SDK to prevent errors in workspaces with virtual folders");
        }
        vs.commands.executeCommand("setContext", constants_1.PUB_OUTDATED_SUPPORTED_CONTEXT, dartCapabilities.supportsPubOutdated);
        // Fire up Flutter daemon if required.
        if (workspaceContext.hasAnyFlutterProjects && sdks.flutter) {
            let runIfNoDevices;
            let hasRunNoDevicesMessage = false;
            let portFromLocalExtension;
            if (workspaceContext.config.forceFlutterWorkspace && workspaceContext.config.restartMacDaemonMessage) {
                runIfNoDevices = () => {
                    if (!hasRunNoDevicesMessage) {
                        const instruction = workspaceContext.config.restartMacDaemonMessage;
                        (0, utils_4.promptToReloadExtension)(`${instruction} (Settings currently expect port: ${config_1.config.daemonPort}.)`, `Reopen this workspace`);
                        hasRunNoDevicesMessage = true;
                    }
                };
            }
            if (workspaceContext.config.forceFlutterWorkspace && !utils_2.isRunningLocally) {
                let resultFromLocalExtension = null;
                const command = vs.commands.executeCommand("flutter-local-device-exposer.startDaemon", { script: (_a = workspaceContext.config.flutterToolsScript) === null || _a === void 0 ? void 0 : _a.script, command: "expose_devices", workingDirectory: workspaceContext.config.flutterSdkHome });
                try {
                    resultFromLocalExtension = yield (0, utils_1.withTimeout)(command, `The local extension to expose devices timed out. ${(_b = workspaceContext.config.localDeviceCommandAdviceMessage) !== null && _b !== void 0 ? _b : ""}`, 10);
                }
                catch (e) {
                    // Command won't be available if dartlocaldevice isn't installed.
                    logger.error(e);
                }
                if (resultFromLocalExtension !== null) {
                    const resultMessage = resultFromLocalExtension.toString();
                    const results = resultMessage.match(/Device daemon is available on remote port: (\d+)/i);
                    if (results !== null && (results === null || results === void 0 ? void 0 : results.length) > 1) {
                        portFromLocalExtension = parseInt(results[1]);
                    }
                    else if (resultMessage !== null) {
                        const displayError = `The local extension to expose devices failed: ${resultMessage}. ${(_c = workspaceContext.config.localDeviceCommandAdviceMessage) !== null && _c !== void 0 ? _c : ""}`;
                        vs.window.showErrorMessage(displayError);
                    }
                }
            }
            flutterDaemon = new flutter_daemon_1.FlutterDaemon(logger, workspaceContext, flutterCapabilities, runIfNoDevices, portFromLocalExtension);
            deviceManager = new device_manager_1.FlutterDeviceManager(logger, flutterDaemon, config_1.config, workspaceContext, runIfNoDevices, portFromLocalExtension);
            context.subscriptions.push(deviceManager);
            context.subscriptions.push(flutterDaemon);
            (0, daemon_message_handler_1.setUpDaemonMessageHandler)(logger, context, flutterDaemon);
            context.subscriptions.push(vs.commands.registerCommand("flutter.selectDevice", deviceManager.showDevicePicker, deviceManager));
            context.subscriptions.push(vs.commands.registerCommand("flutter.launchEmulator", deviceManager.promptForAndLaunchEmulator, deviceManager));
        }
        if (workspaceContext.config.forceFlutterWorkspace && utils_2.isRunningLocally && constants_1.isMac && workspaceContext.config.localMacWarningMessage) {
            vs.window.showInformationMessage(workspaceContext.config.localMacWarningMessage.toString());
        }
        const pubApi = new api_1.PubApi(webClient);
        const pubGlobal = new global_1.PubGlobal(logger, dartCapabilities, extContext, sdks, pubApi);
        const sdkCommands = new sdk_1.SdkCommands(logger, extContext, workspaceContext, dartCapabilities);
        const dartCommands = new dart_2.DartCommands(logger, extContext, workspaceContext, sdkUtils, pubGlobal, dartCapabilities);
        const flutterCommands = new flutter_2.FlutterCommands(logger, extContext, workspaceContext, sdkUtils, dartCapabilities, flutterCapabilities, deviceManager);
        const packageCommands = new packages_1.PackageCommands(logger, extContext, workspaceContext, dartCapabilities);
        const addDependencyCommand = new add_dependency_1.AddDependencyCommand(logger, extContext, workspaceContext, dartCapabilities, pubApi);
        context.subscriptions.push(sdkCommands);
        context.subscriptions.push(dartCommands);
        context.subscriptions.push(flutterCommands);
        context.subscriptions.push(packageCommands);
        context.subscriptions.push(addDependencyCommand);
        const debugCommands = new debug_1.DebugCommands(logger, extContext, workspaceContext, dartCapabilities, flutterCapabilities, analytics, pubGlobal, flutterDaemon);
        context.subscriptions.push(debugCommands);
        // Handle new projects before creating the analyer to avoid a few issues with
        // showing errors while packages are fetched, plus issues like
        // https://github.com/Dart-Code/Dart-Code/issues/2793 which occur if the analyzer
        // is created too early.
        if (!isRestart)
            yield (0, user_prompts_1.handleNewProjects)(logger, extContext);
        // Fire up the analyzer process.
        const analyzerStartTime = new Date();
        analyzer = isUsingLsp
            ? new analyzer_lsp_1.LspAnalyzer(logger, sdks, dartCapabilities, workspaceContext)
            : new analyzer_das_1.DasAnalyzer(logger, analytics, sdks, dartCapabilities, workspaceContext);
        const lspAnalyzer = isUsingLsp ? analyzer : undefined;
        const dasAnalyzer = isUsingLsp ? undefined : analyzer;
        const dasClient = dasAnalyzer ? dasAnalyzer.client : undefined;
        const lspClient = dasClient ? undefined : analyzer.client;
        context.subscriptions.push(analyzer);
        // tslint:disable-next-line: no-floating-promises
        analyzer.onReady.then(() => {
            const analyzerEndTime = new Date();
            analytics.logAnalyzerStartupTime(analyzerEndTime.getTime() - analyzerStartTime.getTime());
            const analyzerVmServicePort = analyzer.vmServicePort;
            if (analyzerVmServicePort) {
                vs.window.showInformationMessage("The Dart Analysis server is running with the debugger accessible. Unset the dart.analyzerVmServicePort setting when no longer required.");
            }
        });
        // Log analysis server first analysis completion time when it completes.
        let analysisStartTime;
        const analysisCompleteEvents = analyzer.onAnalysisStatusChange.listen((status) => {
            // Analysis started for the first time.
            if (status.isAnalyzing && !analysisStartTime)
                analysisStartTime = new Date();
            // Analysis ends for the first time.
            if (!status.isAnalyzing && analysisStartTime) {
                const analysisEndTime = new Date();
                analytics.logAnalyzerFirstAnalysisTime(analysisEndTime.getTime() - analysisStartTime.getTime());
                analysisCompleteEvents.dispose();
            }
        });
        // Set up providers.
        // TODO: Do we need to push all these to subscriptions?!
        if (lspClient)
            context.subscriptions.push(new closing_labels_decorations_2.LspClosingLabelsDecorations(lspClient));
        const completionItemProvider = isUsingLsp || !dasClient ? undefined : new dart_completion_item_provider_1.DartCompletionItemProvider(logger, dasClient);
        const referenceProvider = isUsingLsp || !dasClient || !dasAnalyzer ? undefined : new dart_reference_provider_1.DartReferenceProvider(dasClient, dasAnalyzer.fileTracker);
        const activeFileFilters = [constants_2.DART_MODE];
        // Analyze Angular2 templates, requires the angular_analyzer_plugin.
        if (config_1.config.analyzeAngularTemplates) {
            activeFileFilters.push(constants_2.HTML_MODE);
        }
        // Analyze files supported by plugins.
        for (const ext of (0, utils_1.uniq)(config_1.config.additionalAnalyzerFileExtensions)) {
            // We can't check that these don't overlap with the existing language filters
            // because vs.languages.match() won't take an extension, only a TextDocument.
            // So we'll just manually exclude file names we know for sure overlap with them.
            if (ext === "dart" || (config_1.config.analyzeAngularTemplates && (ext === "htm" || ext === "html")))
                continue;
            activeFileFilters.push({ scheme: "file", pattern: `**/*.${ext}` });
        }
        // This is registered with VS Code further down, so it's metadata can be collected from all
        // registered providers.
        const rankingCodeActionProvider = new ranking_code_action_provider_1.RankingCodeActionProvider();
        rankingCodeActionProvider.registerProvider(new add_dependency_code_action_provider_1.AddDependencyCodeActionProvider(constants_2.DART_MODE));
        const triggerCharacters = ".(${'\"/\\".split("");
        if (!isUsingLsp && dasClient) {
            context.subscriptions.push(vs.languages.registerHoverProvider(activeFileFilters, new dart_hover_provider_1.DartHoverProvider(logger, dasClient)));
            const formattingEditProvider = new dart_formatting_edit_provider_1.DartFormattingEditProvider(logger, dasClient, extContext);
            context.subscriptions.push(formattingEditProvider);
            formattingEditProvider.registerDocumentFormatter(activeFileFilters);
            // Only for Dart.
            formattingEditProvider.registerTypingFormatter(constants_2.DART_MODE, "}", ";");
        }
        if (completionItemProvider)
            context.subscriptions.push(vs.languages.registerCompletionItemProvider(activeFileFilters, completionItemProvider, ...triggerCharacters));
        if (referenceProvider) {
            context.subscriptions.push(vs.languages.registerDefinitionProvider(activeFileFilters, referenceProvider));
            context.subscriptions.push(vs.languages.registerReferenceProvider(activeFileFilters, referenceProvider));
        }
        let renameProvider;
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            context.subscriptions.push(vs.languages.registerDocumentHighlightProvider(activeFileFilters, new dart_highlighting_provider_1.DartDocumentHighlightProvider(dasAnalyzer.fileTracker)));
            rankingCodeActionProvider.registerProvider(new assist_code_action_provider_1.AssistCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new fix_code_action_provider_1.FixCodeActionProvider(logger, activeFileFilters, dasClient));
            rankingCodeActionProvider.registerProvider(new refactor_code_action_provider_1.RefactorCodeActionProvider(activeFileFilters, dasClient));
            renameProvider = new dart_rename_provider_1.DartRenameProvider(dasClient);
            context.subscriptions.push(vs.languages.registerRenameProvider(activeFileFilters, renameProvider));
            // Dart only.
            context.subscriptions.push(vs.languages.registerCodeActionsProvider(constants_2.DART_MODE, new source_code_action_provider_1.SourceCodeActionProvider(), source_code_action_provider_1.SourceCodeActionProvider.metadata));
            context.subscriptions.push(vs.languages.registerImplementationProvider(constants_2.DART_MODE, new dart_implementation_provider_1.DartImplementationProvider(dasAnalyzer)));
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_1.MainCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_1.TestCodeLensProvider(logger, dasAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_1.FlutterDartPadSamplesCodeLensProvider(logger, dasAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
        }
        if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.showMainCodeLens) {
                const codeLensProvider = new main_code_lens_provider_lsp_1.LspMainCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showTestCodeLens) {
                const codeLensProvider = new test_code_lens_provider_lsp_1.LspTestCodeLensProvider(logger, lspAnalyzer);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
            if (config_1.config.showDartPadSampleCodeLens && sdks.flutter) {
                const codeLensProvider = new flutter_dartpad_samples_lsp_1.LspFlutterDartPadSamplesCodeLensProvider(logger, lspAnalyzer, sdks);
                context.subscriptions.push(codeLensProvider);
                context.subscriptions.push(vs.languages.registerCodeLensProvider(constants_2.DART_MODE, codeLensProvider));
            }
        }
        // Register the ranking provider from VS Code now that it has all of its delegates.
        context.subscriptions.push(vs.languages.registerCodeActionsProvider(activeFileFilters, rankingCodeActionProvider, rankingCodeActionProvider.metadata));
        // Task handlers.
        context.subscriptions.push(vs.tasks.registerTaskProvider(dart_task_provider_1.DartTaskProvider.type, new dart_task_provider_1.DartTaskProvider(logger, context, sdks, dartCapabilities)));
        context.subscriptions.push(vs.tasks.registerTaskProvider(flutter_task_provider_1.FlutterTaskProvider.type, new flutter_task_provider_1.FlutterTaskProvider(logger, context, sdks, flutterCapabilities)));
        // Snippets are language-specific
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(constants_2.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider(isUsingLsp, dartCapabilities, "snippets/dart.json", () => true)));
        context.subscriptions.push(vs.languages.registerCompletionItemProvider(constants_2.DART_MODE, new snippet_completion_item_provider_1.SnippetCompletionItemProvider(isUsingLsp, dartCapabilities, "snippets/flutter.json", (uri) => util.isInsideFlutterProject(uri))));
        context.subscriptions.push(vs.languages.setLanguageConfiguration(constants_2.DART_MODE.language, new dart_language_configuration_1.DartLanguageConfiguration()));
        // TODO: Push the differences into the Analyzer classes so we can have one reporter.
        if (lspClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_2.LspAnalyzerStatusReporter(analyzer);
        if (dasClient)
            // tslint:disable-next-line: no-unused-expression
            new analyzer_status_reporter_1.AnalyzerStatusReporter(logger, dasClient, workspaceContext, analytics);
        context.subscriptions.push(new file_change_warnings_1.FileChangeWarnings());
        // Set up diagnostics.
        if (!isUsingLsp && dasClient) {
            const diagnostics = vs.languages.createDiagnosticCollection("dart");
            context.subscriptions.push(diagnostics);
            const diagnosticsProvider = new dart_diagnostic_provider_1.DartDiagnosticProvider(dasClient, diagnostics);
            // TODO: Currently calculating analysis roots requires the version to check if
            // we need the package workaround. In future if we stop supporting server < 1.20.1 we
            // can unwrap this call so that it'll start sooner.
            const serverConnected = dasClient.registerForServerConnected((sc) => {
                serverConnected.dispose();
                if (vs.workspace.workspaceFolders)
                    recalculateDasAnalysisRoots();
                // Set up a handler to warn the user if they open a Dart file and we
                // never set up the analyzer
                let hasWarnedAboutLooseDartFiles = false;
                const handleOpenFile = (d) => {
                    if (!hasWarnedAboutLooseDartFiles && d.languageId === "dart" && d.uri.scheme === "file" && analysisRoots.length === 0) {
                        hasWarnedAboutLooseDartFiles = true;
                        vs.window.showWarningMessage("For full Dart language support, please open a folder containing your Dart files instead of individual loose files");
                    }
                };
                context.subscriptions.push(vs.workspace.onDidOpenTextDocument((d) => handleOpenFile(d)));
                // Fire for editors already visible at the time this code runs.
                vs.window.visibleTextEditors.forEach((e) => handleOpenFile(e.document));
            });
            // Hook editor changes to send updated contents to analyzer.
            context.subscriptions.push(new file_change_handler_1.FileChangeHandler(dasClient));
        }
        util.logTime("All other stuff before debugger..");
        const testModel = new test_model_1.TestModel(config_1.config, util.isPathInsideFlutterProject);
        const testCoordinator = new coordinator_1.TestSessionCoordinator(logger, testModel, lspAnalyzer === null || lspAnalyzer === void 0 ? void 0 : lspAnalyzer.fileTracker);
        context.subscriptions.push(testCoordinator, vs.debug.onDidReceiveDebugSessionCustomEvent((e) => testCoordinator.handleDebugSessionCustomEvent(e.session.id, e.session.configuration.dartCodeDebugSessionID, e.event, e.body)), vs.debug.onDidTerminateDebugSession((session) => testCoordinator.handleDebugSessionEnd(session.id, session.configuration.dartCodeDebugSessionID)), vs.workspace.onDidChangeConfiguration((e) => testModel.handleConfigChange()));
        const testDiscoverer = lspAnalyzer ? new test_discoverer_1.TestDiscoverer(logger, lspAnalyzer.fileTracker, testModel) : undefined;
        if (testDiscoverer)
            context.subscriptions.push(testDiscoverer);
        const vsCodeTestController = ((_d = vs.tests) === null || _d === void 0 ? void 0 : _d.createTestController) !== undefined // Feature-detect for Theia
            ? new vs_test_controller_1.VsCodeTestController(logger, testModel, testDiscoverer)
            : undefined;
        if (vsCodeTestController)
            context.subscriptions.push(vsCodeTestController);
        const analyzerCommands = new analyzer_1.AnalyzerCommands(context, logger, analyzer, analytics);
        // Set up debug stuff.
        const debugProvider = new debug_config_provider_1.DebugConfigProvider(logger, workspaceContext, analytics, pubGlobal, testModel, flutterDaemon, deviceManager, debugCommands, dartCapabilities, flutterCapabilities);
        context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", debugProvider));
        const debugLogger = new debug_adapter_logger_factory_1.DartDebugAdapterLoggerFactory(logger);
        context.subscriptions.push(vs.debug.registerDebugAdapterTrackerFactory("dart", debugLogger));
        const debugAdapterDescriptorFactory = new debug_adapter_descriptor_factory_1.DartDebugAdapterDescriptorFactory(analytics, sdks, logger, extContext, dartCapabilities, flutterCapabilities, workspaceContext, experiments);
        context.subscriptions.push(vs.debug.registerDebugAdapterDescriptorFactory("dart", debugAdapterDescriptorFactory));
        // Also the providers for the initial configs.
        if (vs.DebugConfigurationProviderTriggerKind) { // Temporary workaround for GitPod/Theia not having this enum.
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.InitialLaunchJsonDebugConfigProvider(logger), vs.DebugConfigurationProviderTriggerKind.Initial));
            context.subscriptions.push(vs.debug.registerDebugConfigurationProvider("dart", new debug_config_provider_1.DynamicDebugConfigProvider(logger, deviceManager), vs.DebugConfigurationProviderTriggerKind.Dynamic));
        }
        if (config_1.config.flutterGutterIcons) {
            const colorDecorations = new flutter_color_decorations_1.FlutterColorDecorations(logger, path.join(context.globalStoragePath, "flutterColors"));
            context.subscriptions.push(colorDecorations);
            // If the server registers for colors and we see a request go out, then we should
            // remove our own handler.
            if (lspAnalyzer)
                lspAnalyzer.onDocumentColorsRequested.then(() => colorDecorations.dispose());
        }
        if (!isUsingLsp && dasClient && dasAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_das_1.FlutterUiGuideDecorationsDas(dasAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_das_1.FlutterIconDecorationsDas(logger, dasAnalyzer));
            // Setup that requires server version/capabilities.
            const connectedSetup = dasClient.registerForServerConnected((sc) => __awaiter(this, void 0, void 0, function* () {
                connectedSetup.dispose();
                context.subscriptions.push(new refactor_1.RefactorCommands(logger, context, dasClient));
                if (dasClient.capabilities.supportsClosingLabels && config_1.config.closingLabels) {
                    context.subscriptions.push(new closing_labels_decorations_1.ClosingLabelsDecorations(dasClient));
                }
                if (dasClient.capabilities.supportsGetDeclerations) {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new dart_workspace_symbol_provider_1.DartWorkspaceSymbolProvider(logger, dasClient)));
                }
                else {
                    context.subscriptions.push(vs.languages.registerWorkspaceSymbolProvider(new legacy_dart_workspace_symbol_provider_1.LegacyDartWorkspaceSymbolProvider(logger, dasClient)));
                }
                if (dasClient.capabilities.supportsCustomFolding && config_1.config.analysisServerFolding)
                    context.subscriptions.push(vs.languages.registerFoldingRangeProvider(activeFileFilters, new dart_folding_provider_1.DartFoldingProvider(dasAnalyzer)));
                if (dasClient.capabilities.supportsGetSignature)
                    context.subscriptions.push(vs.languages.registerSignatureHelpProvider(constants_2.DART_MODE, new dart_signature_help_provider_1.DartSignatureHelpProvider(dasClient)));
                const documentSymbolProvider = new dart_document_symbol_provider_1.DartDocumentSymbolProvider(logger, dasAnalyzer.fileTracker);
                activeFileFilters.forEach((filter) => {
                    context.subscriptions.push(vs.languages.registerDocumentSymbolProvider(filter, documentSymbolProvider));
                });
                // Set up completions for unimported items.
                if (dasClient.capabilities.supportsAvailableSuggestions && config_1.config.autoImportCompletions) {
                    yield dasClient.completionSetSubscriptions({
                        subscriptions: ["AVAILABLE_SUGGESTION_SETS"],
                    });
                }
            }));
        }
        else if (isUsingLsp && lspClient && lspAnalyzer) {
            if (config_1.config.previewFlutterUiGuides)
                context.subscriptions.push(new flutter_ui_guides_decorations_lsp_1.FlutterUiGuideDecorationsLsp(lspAnalyzer));
            if (config_1.config.flutterGutterIcons)
                context.subscriptions.push(new flutter_icon_decorations_lsp_1.FlutterIconDecorationsLsp(logger, lspAnalyzer));
        }
        // Handle config changes so we can reanalyze if necessary.
        context.subscriptions.push(vs.workspace.onDidChangeConfiguration(() => handleConfigurationChange(sdks)));
        // Wire up handling of On-Save handlers.
        context.subscriptions.push(new hot_reload_save_handler_1.HotReloadOnSaveHandler(debugCommands, flutterCapabilities));
        if (workspaceContext.hasAnyFlutterProjects && sdks.flutter) {
            context.subscriptions.push(new generate_localizations_on_save_handler_1.GenerateLocalizationsOnSaveHandler());
        }
        // Register URI handler.
        context.subscriptions.push(vs.window.registerUriHandler(new uri_handler_1.DartUriHandler(flutterCapabilities)));
        context.subscriptions.push(new logging_2.LoggingCommands(logger, context.logPath));
        context.subscriptions.push(new open_in_other_editors_1.OpenInOtherEditorCommands(logger, sdks));
        context.subscriptions.push(new test_1.TestCommands(logger, testModel, workspaceContext, vsCodeTestController, flutterCapabilities));
        if (lspClient && lspAnalyzer) {
            // TODO: LSP equivs of the others...
            // Refactors
            // TypeHierarchyCommand
            context.subscriptions.push(new go_to_super_2.LspGoToSuperCommand(lspAnalyzer));
        }
        // Set up commands for Dart editors.
        context.subscriptions.push(new edit_1.EditCommands());
        if (dasClient && dasAnalyzer) {
            context.subscriptions.push(new edit_das_1.DasEditCommands(logger, context, dasClient));
            context.subscriptions.push(new type_hierarchy_1.TypeHierarchyCommand(logger, dasClient));
            context.subscriptions.push(new go_to_super_1.GoToSuperCommand(dasAnalyzer));
        }
        else if (lspClient && lspAnalyzer) {
            context.subscriptions.push(new edit_lsp_1.LspEditCommands(lspAnalyzer));
        }
        const packageLinkProvider = new package_uri_link_provider_1.DartPackageUriLinkProvider(logger, workspaceContext);
        const fileLinkProvider = new file_uri_link_provider_1.DartFileUriLinkProvider();
        if (vs.window.registerTerminalLinkProvider) { // Workaround for GitPod/Theia not having this.
            context.subscriptions.push(vs.window.registerTerminalLinkProvider(packageLinkProvider));
            context.subscriptions.push(vs.window.registerTerminalLinkProvider(fileLinkProvider));
        }
        if (vs.languages.registerDocumentLinkProvider) {
            vs.languages.registerDocumentLinkProvider({ scheme: "vscode-test-data" }, packageLinkProvider);
            vs.languages.registerDocumentLinkProvider({ scheme: "vscode-test-data" }, fileLinkProvider);
        }
        // Register our view providers.
        const dartPackagesProvider = new packages_view_1.DartPackagesProvider(logger, workspaceContext, dartCapabilities);
        context.subscriptions.push(dartPackagesProvider);
        const packagesTreeView = vs.window.createTreeView("dartDependencyTree", { treeDataProvider: dartPackagesProvider });
        context.subscriptions.push(packagesTreeView);
        let flutterOutlineTreeProvider;
        if (config_1.config.flutterOutline) {
            // TODO: Extract this out - it's become messy since TreeView was added in.
            flutterOutlineTreeProvider = dasAnalyzer ? new flutter_outline_view_1.DasFlutterOutlineProvider(dasAnalyzer) : new flutter_outline_view_1.LspFlutterOutlineProvider(lspAnalyzer);
            const tree = vs.window.createTreeView("dartFlutterOutline", { treeDataProvider: flutterOutlineTreeProvider, showCollapseAll: true });
            tree.onDidChangeSelection((e) => __awaiter(this, void 0, void 0, function* () {
                // TODO: This should be in a tree, not the data provider.
                yield flutterOutlineTreeProvider.setContexts(e.selection);
            }));
            context.subscriptions.push(vs.window.onDidChangeTextEditorSelection((e) => {
                if (e.selections && e.selections.length) {
                    const node = flutterOutlineTreeProvider.getNodeAt(e.textEditor.document.uri, e.selections[0].start);
                    if (node && tree.visible)
                        tree.reveal(node, { select: true, focus: false, expand: true });
                }
            }));
            context.subscriptions.push(tree);
            context.subscriptions.push(flutterOutlineTreeProvider);
            // TODO: This doesn't work for LSP!!!
            const flutterOutlineCommands = new flutter_outline_1.FlutterOutlineCommands(tree, context);
        }
        context.subscriptions.push(vs.commands.registerCommand("dart.package.openFile", (filePath) => {
            if (!filePath)
                return;
            vs.workspace.openTextDocument(filePath).then((document) => {
                vs.window.showTextDocument(document, { preview: true });
            }, (error) => logger.error(error));
        }));
        // Warn the user if they've opened a folder with mismatched casing.
        if (vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length) {
            for (const wf of vs.workspace.workspaceFolders) {
                if ((0, utils_2.warnIfPathCaseMismatch)(logger, (0, fs_1.fsPath)(wf.uri), "the open workspace folder", "re-open the folder using the File Open dialog"))
                    break;
            }
        }
        // Prompt user for any special config we might want to set.
        if (!isRestart)
            // tslint:disable-next-line: no-floating-promises
            (0, user_prompts_1.showUserPrompts)(logger, extContext, webClient, analytics, workspaceContext);
        // Turn on all the commands.
        setCommandVisiblity(true, workspaceContext);
        vs.commands.executeCommand("setContext", DART_PLATFORM_NAME, constants_1.dartPlatformName);
        // Prompt for pub get/upgrade if required
        function checkForPackages() {
            // Don't prompt for package updates in the Fuchsia tree/Dart SDK repo.
            if (workspaceContext.config.disableAutomaticPackageGet)
                return;
            // tslint:disable-next-line: no-floating-promises
            packageCommands.fetchPackagesOrPrompt(undefined, { alwaysPrompt: true, upgradeOnSdkChange: true });
        }
        checkForPackages();
        // Begin activating dependant packages.
        if (workspaceContext.shouldLoadFlutterExtension) {
            const flutterExtension = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
            if (flutterExtension) {
                logger.info(`Activating Flutter extension for ${workspaceContext.workspaceTypeDescription} project...`);
                // Do NOT await this.. the Flutter extension needs to wait for the Dart extension to finish activating
                // so that it can call its exported API, therefore we'll deadlock if we wait for the Flutter extension
                // to finish activating.
                flutterExtension.activate()
                    // Then rebuild log because it includes whether we activated Flutter.
                    .then(() => buildLogHeaders(logger, workspaceContextUnverified));
            }
        }
        // Log how long all this startup took.
        const extensionEndTime = new Date();
        if (isRestart) {
            analytics.logExtensionRestart(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        else {
            analytics.logExtensionStartup(extensionEndTime.getTime() - extensionStartTime.getTime());
        }
        // Handle changes to the workspace.
        // Set the roots, handling project changes that might affect SDKs.
        context.subscriptions.push(vs.workspace.onDidChangeWorkspaceFolders((f) => __awaiter(this, void 0, void 0, function* () {
            // First check if something changed that will affect our SDK, in which case
            // we'll perform a silent restart so that we do new SDK searches.
            const newWorkspaceContext = yield sdkUtils.scanWorkspace();
            if (newWorkspaceContext.hasAnyFlutterProjects !== workspaceContext.hasAnyFlutterProjects
                || newWorkspaceContext.hasProjectsInFuchsiaTree !== workspaceContext.hasProjectsInFuchsiaTree) {
                // tslint:disable-next-line: no-floating-promises
                util.promptToReloadExtension();
                return;
            }
            workspaceContext.events.onPackageMapChange.fire();
            if (!isUsingLsp)
                recalculateDasAnalysisRoots();
            checkForPackages();
        })));
        context.subscriptions.push((0, utils_2.createWatcher)("**/.packages", workspaceContext.events.onPackageMapChange));
        context.subscriptions.push((0, utils_2.createWatcher)("**/.dart_tool/package_config.json", workspaceContext.events.onPackageMapChange));
        workspaceContext.events.onPackageMapChange.fire();
        return Object.assign(Object.assign({}, new api_2.DartExtensionApi()), { [symbols_1.internalApiSymbol]: {
                addDependencyCommand,
                analyzer,
                analyzerCapabilities: dasClient && dasClient.capabilities,
                cancelAllAnalysisRequests: () => dasClient && dasClient.cancelAllRequests(),
                completionItemProvider,
                context: extContext,
                currentAnalysis: () => analyzer.onCurrentAnalysisComplete,
                daemonCapabilities: flutterDaemon ? flutterDaemon.capabilities : flutter_1.DaemonCapabilities.empty,
                dartCapabilities,
                debugAdapterDescriptorFactory,
                debugCommands,
                debugLogger,
                debugProvider,
                debugSessions: debug_1.debugSessions,
                deviceManager,
                envUtils: utils_2.envUtils,
                fileTracker: dasAnalyzer ? dasAnalyzer.fileTracker : (lspAnalyzer ? lspAnalyzer.fileTracker : undefined),
                flutterCapabilities,
                flutterOutlineTreeProvider,
                get isInImplementationFileThatCanHaveTest() { return test_1.isInImplementationFileThatCanHaveTest; },
                get isInTestFileThatHasImplementation() { return test_1.isInTestFileThatHasImplementation; },
                getLogHeader: log_1.getLogHeader,
                getOutputChannel: channels_1.getOutputChannel,
                initialAnalysis: analyzer.onInitialAnalysis,
                interactiveRefactors: lspAnalyzer === null || lspAnalyzer === void 0 ? void 0 : lspAnalyzer.refactors,
                isLsp: isUsingLsp,
                logger,
                nextAnalysis: () => analyzer.onNextAnalysisComplete,
                packagesTreeProvider: dartPackagesProvider,
                pubGlobal,
                renameProvider,
                safeToolSpawn: processes_1.safeToolSpawn,
                testController: vsCodeTestController,
                testCoordinator,
                testDiscoverer,
                testModel,
                webClient,
                workspaceContext,
            } });
    });
}
exports.activate = activate;
function setupLog(logFile, category) {
    if (logFile)
        loggers.push((0, logging_1.captureLogs)(logger, logFile, (0, log_1.getLogHeader)(), config_1.config.maxLogLineLength, [category]));
}
function buildLogHeaders(logger, workspaceContext) {
    (0, log_1.clearLogHeader)();
    (0, log_1.addToLogHeader)(() => `!! PLEASE REVIEW THIS LOG FOR SENSITIVE INFORMATION BEFORE SHARING !!`);
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `Dart Code extension: ${extension_utils_1.extensionVersion}`);
    (0, log_1.addToLogHeader)(() => {
        const ext = vs.extensions.getExtension(constants_1.flutterExtensionIdentifier);
        return `Flutter extension: ${ext.packageJSON.version} (${ext.isActive ? "" : "not "}activated)`;
    });
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `App: ${vs.env.appName}`);
    if (vs.env.remoteName)
        (0, log_1.addToLogHeader)(() => `Remote: ${vs.env.remoteName}`);
    (0, log_1.addToLogHeader)(() => `Version: ${vs.version}`);
    (0, log_1.addToLogHeader)(() => `Platform: ${constants_1.platformDisplayName}`);
    if (workspaceContext) {
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Workspace type: ${workspaceContext.workspaceTypeDescription}`);
        (0, log_1.addToLogHeader)(() => `Analyzer type: ${workspaceContext.config.useLegacyProtocol ? "DAS" : "LSP"}`);
        (0, log_1.addToLogHeader)(() => `Multi-root?: ${vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length > 1}`);
        const sdks = workspaceContext.sdks;
        (0, log_1.addToLogHeader)(() => ``);
        (0, log_1.addToLogHeader)(() => `Dart SDK:\n    Loc: ${sdks.dart}\n    Ver: ${sdks.dartVersion}`);
        (0, log_1.addToLogHeader)(() => `Flutter SDK:\n    Loc: ${sdks.flutter}\n    Ver: ${sdks.flutterVersion}`);
    }
    (0, log_1.addToLogHeader)(() => ``);
    (0, log_1.addToLogHeader)(() => `HTTP_PROXY: ${process.env.HTTP_PROXY}`);
    (0, log_1.addToLogHeader)(() => `NO_PROXY: ${process.env.NO_PROXY}`);
    // Any time the log headers are rebuilt, we should re-log them.
    logger === null || logger === void 0 ? void 0 : logger.info((0, log_1.getLogHeader)());
}
function recalculateDasAnalysisRoots() {
    const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
    analysisRoots = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
    // Sometimes people open their home directories as the workspace root and
    // have all sorts of performance issues because of PubCache and AppData folders
    // so we will exclude them if the user has opened a parent folder (opening a
    // child of these directly will still work).
    const excludeFolders = [];
    if (constants_1.isWin) {
        const addExcludeIfRequired = (folder) => {
            if (!folder || !path.isAbsolute(folder))
                return;
            const containingRoot = analysisRoots.find((root) => (0, fs_1.isWithinPath)(folder, root));
            if (containingRoot) {
                logger.info(`Excluding folder ${folder} from analysis roots as it is a child of analysis root ${containingRoot} and may cause performance issues.`);
                excludeFolders.push(folder);
            }
        };
        addExcludeIfRequired(process.env.PUB_CACHE);
        addExcludeIfRequired(process.env.APPDATA);
        addExcludeIfRequired(process.env.LOCALAPPDATA);
    }
    // For each workspace, handle excluded folders.
    workspaceFolders.forEach((f) => {
        for (const folder of util.getExcludedFolders(f))
            excludeFolders.push(folder);
    });
    // tslint:disable-next-line: no-floating-promises
    analyzer.client.analysisSetAnalysisRoots({
        excluded: excludeFolders,
        included: analysisRoots,
    });
}
function handleConfigurationChange(sdks) {
    // TODOs
    const newShowTodoSetting = config_1.config.showTodos;
    const todoSettingChanged = showTodos !== newShowTodoSetting;
    showTodos = newShowTodoSetting;
    // SDK
    const newSettings = getSettingsThatRequireRestart();
    const settingsChanged = previousSettings !== newSettings;
    previousSettings = newSettings;
    if (todoSettingChanged && analyzer instanceof analyzer_das_1.DasAnalyzer) {
        // tslint:disable-next-line: no-floating-promises
        analyzer.client.analysisReanalyze();
    }
    if (settingsChanged) {
        // Delay the restart slightly, because the config change may be transmitted to the LSP server
        // and shutting the server down too quickly results in that trying to write to a closed
        // stream.
        setTimeout(util.promptToReloadExtension, 50);
    }
}
function getSettingsThatRequireRestart() {
    var _a, _b;
    // The return value here is used to detect when any config option changes that requires a project reload.
    // It doesn't matter how these are combined; it just gets called on every config change and compared.
    // Usually these are options that affect the analyzer and need a reload, but config options used at
    // activation time will also need to be included.
    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
    return "CONF-"
        + config_1.config.sdkPath
        + ((_a = config_1.config.sdkPaths) === null || _a === void 0 ? void 0 : _a.length)
        + config_1.config.analyzerPath
        + config_1.config.analyzerDiagnosticsPort
        + config_1.config.analyzerVmServicePort
        + config_1.config.analyzerInstrumentationLogFile
        + config_1.config.extensionLogFile
        + config_1.config.analyzerAdditionalArgs
        + config_1.config.flutterSdkPath
        + ((_b = config_1.config.flutterSdkPaths) === null || _b === void 0 ? void 0 : _b.length)
        + config_1.config.flutterSelectDeviceWhenConnected
        + config_1.config.closingLabels
        + config_1.config.analyzeAngularTemplates
        + config_1.config.analysisServerFolding
        + config_1.config.showMainCodeLens
        + config_1.config.showTestCodeLens
        + config_1.config.updateImportsOnRename
        + config_1.config.flutterOutline
        + config_1.config.flutterAdbConnectOnChromeOs;
}
function deactivate(isRestart = false) {
    return __awaiter(this, void 0, void 0, function* () {
        setCommandVisiblity(false);
        analyzer === null || analyzer === void 0 ? void 0 : analyzer.dispose();
        yield (flutterDaemon === null || flutterDaemon === void 0 ? void 0 : flutterDaemon.shutdown());
        if (loggers) {
            yield Promise.all(loggers.map((logger) => logger.dispose()));
            loggers.length = 0;
        }
        vs.commands.executeCommand("setContext", exports.FLUTTER_SUPPORTS_ATTACH, false);
        if (!isRestart) {
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, false);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, false);
            yield analytics.logExtensionShutdown();
            ringLogger === null || ringLogger === void 0 ? void 0 : ringLogger.dispose();
            logger.dispose();
        }
    });
}
exports.deactivate = deactivate;
function setCommandVisiblity(enable, workspaceContext) {
    vs.commands.executeCommand("setContext", PROJECT_LOADED, enable);
    vs.commands.executeCommand("setContext", DART_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyStandardDartProjects);
    vs.commands.executeCommand("setContext", FLUTTER_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyFlutterProjects);
    vs.commands.executeCommand("setContext", WEB_PROJECT_LOADED, enable && workspaceContext && workspaceContext.hasAnyWebProjects);
}


/***/ }),

/***/ 5086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setUpDaemonMessageHandler = void 0;
const vscode_1 = __webpack_require__(9496);
const channels_1 = __webpack_require__(1026);
function setUpDaemonMessageHandler(logger, context, daemon) {
    const channel = (0, channels_1.getOutputChannel)("flutter daemon", true);
    context.subscriptions.push(daemon.registerForDaemonLog((l) => {
        // Don't show, as we get errors from this just when disconnected devices!
        // channel.show(true);
        channel.appendLine(`${l.error ? "[ERR] " : ""}${l.log}`);
    }));
    context.subscriptions.push(daemon.registerForDaemonShowMessage((l) => {
        const title = l.title.trim().endsWith(".") ? l.title.trim() : `${l.title.trim()}.`;
        const message = `${title} ${l.message}`.trim();
        switch (l.level) {
            case "info":
                vscode_1.window.showInformationMessage(message);
                break;
            case "warning":
                vscode_1.window.showWarningMessage(message);
                break;
            case "error":
                vscode_1.window.showErrorMessage(message);
                break;
            default:
                logger.warn(`Unexpected daemon.showMessage type: ${l.level}`);
        }
    }));
}
exports.setUpDaemonMessageHandler = setUpDaemonMessageHandler;


/***/ }),

/***/ 5887:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDaemon = void 0;
const child_process = __webpack_require__(2081);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const flutter_1 = __webpack_require__(4790);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const stdio_service_1 = __webpack_require__(3058);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const utils_3 = __webpack_require__(8779);
const misc_1 = __webpack_require__(9106);
const processes_1 = __webpack_require__(5430);
class FlutterDaemon extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, flutterCapabilities, runIfNoDevices, portFromLocalExtension) {
        var _a;
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.FlutterDaemon), config_1.config.maxLogLineLength, true, true);
        this.workspaceContext = workspaceContext;
        this.runIfNoDevices = runIfNoDevices;
        this.hasStarted = false;
        this.hasShownTerminationError = false;
        this.isShuttingDown = false;
        this.daemonStartedCompleter = new utils_1.PromiseCompleter();
        this.capabilities = flutter_1.DaemonCapabilities.empty;
        this.hasShownStartupError = false;
        // Subscription lists.
        this.daemonConnectedSubscriptions = [];
        this.deviceAddedSubscriptions = [];
        this.deviceRemovedSubscriptions = [];
        this.daemonLogMessageSubscriptions = [];
        this.daemonLogSubscriptions = [];
        this.daemonShowMessageSubscriptions = [];
        const folder = workspaceContext.sdks.flutter;
        this.registerForDaemonConnected((e) => {
            this.additionalPidsToTerminate.push(e.pid);
            this.capabilities.version = e.version;
            vs.commands.executeCommand("setContext", extension_1.FLUTTER_SUPPORTS_ATTACH, this.capabilities.canFlutterAttach);
            this.deviceEnable();
        });
        const daemonArgs = [];
        const showWebServer = config_1.config.flutterShowWebServerDevice === "always" || !utils_2.isRunningLocally;
        if (showWebServer && flutterCapabilities.supportsShowWebServerDevice)
            daemonArgs.push("--show-web-server-device");
        if (constants_1.isDartCodeTestRun)
            daemonArgs.push("--show-test-device");
        if (portFromLocalExtension) {
            this.createNcProcess(portFromLocalExtension);
            this.startPing();
        }
        else if (workspaceContext.config.forceFlutterWorkspace && config_1.config.daemonPort) {
            this.createNcProcess(config_1.config.daemonPort);
            this.startPing(workspaceContext.config.restartMacDaemonMessage);
        }
        else {
            const execution = (0, utils_1.usingCustomScript)(path.join(workspaceContext.sdks.flutter, constants_1.flutterPath), ["daemon"].concat(daemonArgs), (_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.flutterDaemonScript);
            const flutterAdditionalArgs = config_1.config.for(vs.Uri.file(folder)).flutterAdditionalArgs;
            const args = (0, processes_1.getGlobalFlutterArgs)().concat(flutterAdditionalArgs).concat(execution.args);
            this.createProcess(folder, execution.executable, args, { toolEnv: (0, processes_1.getToolEnv)() });
        }
        if (constants_1.isChromeOS && config_1.config.flutterAdbConnectOnChromeOs) {
            logger.info("Running ADB Connect on Chrome OS");
            const adbConnectProc = (0, processes_1.safeToolSpawn)(undefined, "adb", ["connect", "100.115.92.2:5555"]);
            (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, adbConnectProc);
        }
    }
    startPing(customMessage) {
        const message = customMessage !== null && customMessage !== void 0 ? customMessage : "The daemon connection was lost. Reload the extension to restart the daemon.";
        this.pingIntervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield (0, utils_1.withTimeout)(this.daemonVersion(), "The daemon connection was lost", 10);
            }
            catch (e) {
                clearInterval(this.pingIntervalId);
                this.logger.error(e);
                this.hasShownTerminationError = true;
                (0, utils_3.promptToReloadExtension)(message);
            }
        }), 60 * 1000);
    }
    // This is for the case where a user has started a flutter daemon process on their local machine where devices are available, and
    // has forwarded this port to the remote machine where the Dart extension is running. Netcat is used to access the local devices,
    // instead of starting another daemon process on the remote machine.
    createNcProcess(port) {
        this.process = child_process.spawn("nc", ["localhost", port.toString()]);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => {
            vs.window.showErrorMessage(`Remote daemon startup had an error: ${error}. Check the instructions for using dart.daemonPort`);
            this.handleError(error);
        });
    }
    handleExit(code, signal) {
        if (code && !this.hasShownTerminationError && !this.isShuttingDown) {
            if (this.runIfNoDevices) {
                this.runIfNoDevices();
            }
            else {
                this.hasShownTerminationError = true;
                const message = this.hasStarted ? "has terminated" : "failed to start";
                // tslint:disable-next-line: no-floating-promises
                (0, utils_3.promptToReloadExtension)(`The Flutter Daemon ${message}.`, undefined, true);
            }
        }
        super.handleExit(code, signal);
    }
    dispose() {
        this.isShuttingDown = true;
        if (this.pingIntervalId) {
            clearInterval(this.pingIntervalId);
        }
        super.dispose();
    }
    sendMessage(json) {
        try {
            super.sendMessage(json);
        }
        catch (e) {
            if (!this.hasShownTerminationError && !this.isShuttingDown) {
                this.hasShownTerminationError = true;
                // tslint:disable-next-line: no-floating-promises
                (0, utils_3.promptToReloadExtension)("The Flutter Daemon has terminated.", undefined, true);
                throw e;
            }
        }
    }
    shouldHandleMessage(message) {
        // Everything in flutter is wrapped in [] so we can tell what to handle.
        if (message.startsWith("[{") && message.endsWith("}]")) {
            // When we get the first message to handle, complete the status notifications.
            if (!this.hasStarted) {
                this.hasStarted = true;
                this.daemonStartedCompleter.resolve();
            }
            return true;
        }
        return false;
    }
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            let upgradeMessage;
            const matches = FlutterDaemon.outOfDateWarning.exec(message);
            if (matches && matches.length === 2)
                upgradeMessage = `Your installation of Flutter is ${matches[1]} days old.`;
            else if (message.indexOf(FlutterDaemon.newVersionMessage) !== -1)
                upgradeMessage = "A new version of Flutter is available";
            if (upgradeMessage) {
                if (yield vs.window.showWarningMessage(upgradeMessage, "Upgrade Flutter"))
                    vs.commands.executeCommand("flutter.upgrade");
                return;
            }
            if (!this.hasShownStartupError && message.startsWith("Flutter requires")) {
                this.logger.error(message, enums_1.LogCategory.FlutterDaemon);
                vs.window.showErrorMessage(message);
                this.hasShownStartupError = true;
                return;
            }
            // Show as progress message, this is likely "Building flutter tool" or "downloading Dart SDK" messages.
            if ((message.startsWith("Building ") || message.startsWith("Downloading ") || message.startsWith("Starting ") || message.startsWith("Running "))
                && !message.startsWith("Starting device daemon") // Don't show this one as it happens for normal startups too.
            ) {
                if (!this.hasStarted) {
                    if (this.startupReporter) {
                        this.startupReporter.report({ message });
                    }
                    else {
                        vs.window.withProgress({
                            location: vscode_1.ProgressLocation.Notification,
                            title: "Flutter Setup",
                        }, (progressReporter) => {
                            this.startupReporter = progressReporter;
                            this.startupReporter.report({ message });
                            return this.daemonStartedCompleter.promise;
                        });
                    }
                }
            }
        });
    }
    enablePlatformGlobally(platformType) {
        return __awaiter(this, void 0, void 0, function* () {
            const flutterSdkPath = this.workspaceContext.sdks.flutter;
            const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
            const args = ["config", `--enable-${platformType}`];
            yield (0, processes_1.runToolProcess)(this.logger, flutterSdkPath, binPath, args);
        });
    }
    checkIfPlatformGloballyDisabled(platformType) {
        return __awaiter(this, void 0, void 0, function* () {
            const flutterSdkPath = this.workspaceContext.sdks.flutter;
            const value = yield (0, misc_1.getFlutterConfigValue)(this.logger, flutterSdkPath, flutterSdkPath, `enable-${platformType}`);
            // Only consider it disabled if it's specifically false (if it's not present, don't assume).
            return value === false;
        });
    }
    // TODO: Can we code-gen all this like the analysis server?
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.event) {
                case "daemon.connected":
                    yield this.notify(this.daemonConnectedSubscriptions, evt.params);
                    break;
                case "device.added":
                    yield this.notify(this.deviceAddedSubscriptions, evt.params);
                    break;
                case "device.removed":
                    yield this.notify(this.deviceRemovedSubscriptions, evt.params);
                    break;
                case "daemon.logMessage":
                    yield this.notify(this.daemonLogMessageSubscriptions, evt.params);
                    break;
                case "daemon.log":
                    yield this.notify(this.daemonLogSubscriptions, evt.params);
                    break;
                case "daemon.showMessage":
                    yield this.notify(this.daemonShowMessageSubscriptions, evt.params);
                    break;
            }
        });
    }
    // Request methods.
    daemonVersion() {
        return this.sendRequest("daemon.version");
    }
    deviceEnable() {
        return this.sendRequest("device.enable");
    }
    getEmulators() {
        return this.sendRequest("emulator.getEmulators");
    }
    launchEmulator(emulatorId, coldBoot) {
        return this.sendRequest("emulator.launch", { emulatorId, coldBoot });
    }
    createEmulator(name) {
        return this.sendRequest("emulator.create", { name });
    }
    getSupportedPlatforms(projectRoot) {
        return this.sendRequest("daemon.getSupportedPlatforms", { projectRoot });
    }
    serveDevTools() {
        return this.sendRequest("devtools.serve");
    }
    shutdown() {
        return this.hasStarted && !this.hasShownTerminationError ? this.sendRequest("daemon.shutdown") : new Promise((resolve) => resolve());
    }
    // Subscription methods.
    registerForDaemonConnected(subscriber) {
        return this.subscribe(this.daemonConnectedSubscriptions, subscriber);
    }
    registerForDeviceAdded(subscriber) {
        return this.subscribe(this.deviceAddedSubscriptions, subscriber);
    }
    registerForDeviceRemoved(subscriber) {
        return this.subscribe(this.deviceRemovedSubscriptions, subscriber);
    }
    registerForDaemonLogMessage(subscriber) {
        return this.subscribe(this.daemonLogMessageSubscriptions, subscriber);
    }
    registerForDaemonLog(subscriber) {
        return this.subscribe(this.daemonLogSubscriptions, subscriber);
    }
    registerForDaemonShowMessage(subscriber) {
        return this.subscribe(this.daemonShowMessageSubscriptions, subscriber);
    }
}
exports.FlutterDaemon = FlutterDaemon;
FlutterDaemon.outOfDateWarning = new RegExp("WARNING: .* Flutter is (\\d+) days old");
FlutterDaemon.newVersionMessage = "A new version of Flutter is available";


/***/ }),

/***/ 4942:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterWidgetItem = exports.LspFlutterOutlineProvider = exports.DasFlutterOutlineProvider = exports.FlutterOutlineProvider = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
const mappings_1 = __webpack_require__(3978);
const utils_2 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
const flutter_outline_1 = __webpack_require__(9021);
const utils_3 = __webpack_require__(8779);
const DART_SHOW_FLUTTER_OUTLINE = "dart-code:showFlutterOutline";
const WIDGET_SELECTED_CONTEXT = "dart-code:isSelectedWidget";
const WIDGET_SUPPORTS_CONTEXT_PREFIX = "dart-code:widgetSupports:";
class FlutterOutlineProvider {
    constructor() {
        this.subscriptions = [];
        this.treeNodesByLine = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
    }
    setTrackingFile(editor) {
        if (editor && (0, utils_3.isAnalyzable)(editor.document)) {
            this.activeEditor = editor;
            // tslint:disable-next-line: no-floating-promises
            this.loadExistingOutline();
        }
        else if (editor && editor.document.uri.scheme === "file") {
            // HACK: We can't currently reliably tell when editors are changed that are only real
            // text editors (debug window is considered an editor) so we should only hide the tree
            // when we know a file that is not ours is selected.
            // https://github.com/Microsoft/vscode/issues/45188
            this.activeEditor = undefined;
            FlutterOutlineProvider.hideTree();
        }
        else {
            // HACK: If there are no valid open editors, hide the tree.
            // The timeout is because the open editors disappear briefly during a closing
            // of one preview and opening of another :(
            // https://github.com/Microsoft/vscode/issues/45188.
            setTimeout(() => {
                if (!vs.window.visibleTextEditors.filter((e) => (0, utils_3.isAnalyzable)(e.document)).length) {
                    FlutterOutlineProvider.hideTree();
                }
            }, 100);
        }
    }
    setContexts(selection) {
        return __awaiter(this, void 0, void 0, function* () {
            // Unmark the old node as being selected.
            if (this.lastSelectedWidget) {
                this.lastSelectedWidget.contextValue = undefined;
                this.refresh(this.lastSelectedWidget);
            }
            // Clear all contexts that enabled refactors.
            for (const refactor of flutter_outline_1.flutterOutlineCommands) {
                vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + refactor, false);
            }
            // Set up the new contexts for our node and mark is as current.
            if (this.activeEditor && selection && selection.length === 1 && isWidget(selection[0].outline)) {
                const fixes = (yield getFixes(this.activeEditor, selection[0].outline))
                    .filter((f) => f instanceof vs.CodeAction)
                    .filter((ca) => ca.kind && ca.kind.value && flutter_outline_1.flutterOutlineCommands.indexOf(ca.kind.value) !== -1);
                // Stash the fixes, as we may need to call them later.
                selection[0].fixes = fixes;
                for (const fix of fixes)
                    vs.commands.executeCommand("setContext", WIDGET_SUPPORTS_CONTEXT_PREFIX + (fix.kind ? fix.kind.value : "NOKIND"), true);
                // Used so we can show context menu if you right-click the selected one.
                // We can't support arbitrary context menus, because we can't get the fixes up-front (see
                // https://github.com/dart-lang/sdk/issues/32462) so we fetch when you select an item
                // and then just support it if it's selected.
                selection[0].contextValue = WIDGET_SELECTED_CONTEXT;
                this.lastSelectedWidget = selection[0];
                this.refresh(selection[0]);
            }
        });
    }
    getNodeAt(uri, pos) {
        if (!this.activeEditor || !this.flutterOutline || (0, fs_1.fsPath)(this.activeEditor.document.uri) !== (0, fs_1.fsPath)(uri) || !this.treeNodesByLine[pos.line])
            return;
        const nodes = this.treeNodesByLine[pos.line];
        // We want the last node that started before the position (eg. most specific).
        let currentBest;
        for (const item of nodes) {
            const range = "range" in item.outline
                ? (0, utils_2.lspToRange)(item.outline.range)
                : (0, utils_2.toRange)(this.activeEditor.document, item.outline.offset, item.outline.length);
            if (range.contains(pos))
                currentBest = item;
        }
        if (currentBest === this.rootNode)
            return undefined; // Root node isn't actually in the tree.
        return currentBest;
    }
    refresh(item) {
        this.onDidChangeTreeDataEmitter.fire(item);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (element)
            return element.children;
        if (this.rootNode)
            return this.rootNode.children;
        return [];
    }
    getParent(element) {
        return element.parent;
    }
    static setTreeVisible(visible) {
        vs.commands.executeCommand("setContext", DART_SHOW_FLUTTER_OUTLINE, visible);
    }
    static showTree() { this.setTreeVisible(true); }
    static hideTree() { this.setTreeVisible(false); }
    dispose() {
        this.activeEditor = undefined;
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.FlutterOutlineProvider = FlutterOutlineProvider;
class DasFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.client.registerForServerConnected((c) => {
            if (analyzer.client.capabilities.supportsFlutterOutline) {
                this.analyzer.client.registerForFlutterOutline((n) => {
                    if (this.activeEditor && n.file === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                        this.flutterOutline = n.outline;
                        this.treeNodesByLine = [];
                        // Delay this so if we're getting lots of updates we don't flicker.
                        if (this.updateTimeout)
                            clearTimeout(this.updateTimeout);
                        if (!this.rootNode)
                            // tslint:disable-next-line: no-floating-promises
                            this.update();
                        else
                            this.updateTimeout = setTimeout(() => this.update(), 200);
                    }
                });
                this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
                if (vs.window.activeTextEditor) {
                    this.setTrackingFile(vs.window.activeTextEditor);
                }
            }
        });
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
            if (this.activeEditor)
                this.analyzer.client.forceNotificationsFor((0, fs_1.fsPath)(this.activeEditor.document.uri));
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, element, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, element, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = editor.document.positionAt(element.offset).line;
                const endLine = editor.document.positionAt(element.offset + element.length).line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (element.children)
                    node.children = (yield Promise.all(element.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.DasFlutterOutlineProvider = DasFlutterOutlineProvider;
class LspFlutterOutlineProvider extends FlutterOutlineProvider {
    constructor(analyzer) {
        super();
        this.analyzer = analyzer;
        this.analyzer.fileTracker.onFlutterOutline.listen((n) => {
            if (this.activeEditor && (0, fs_1.fsPath)(vs.Uri.parse(n.uri)) === (0, fs_1.fsPath)(this.activeEditor.document.uri)) {
                this.flutterOutline = n.outline;
                this.treeNodesByLine = [];
                // Delay this so if we're getting lots of updates we don't flicker.
                if (this.updateTimeout)
                    clearTimeout(this.updateTimeout);
                if (!this.rootNode)
                    // tslint:disable-next-line: no-floating-promises
                    this.update();
                else
                    this.updateTimeout = setTimeout(() => this.update(), 200);
            }
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor((e) => this.setTrackingFile(e)));
        if (vs.window.activeTextEditor) {
            this.setTrackingFile(vs.window.activeTextEditor);
        }
    }
    loadExistingOutline() {
        return __awaiter(this, void 0, void 0, function* () {
            this.flutterOutline = this.activeEditor ? this.analyzer.fileTracker.getFlutterOutlineFor(this.activeEditor.document.uri) : undefined;
            if (this.flutterOutline)
                yield this.update();
            else {
                this.rootNode = undefined;
                this.refresh(); // Force update (to nothing) while requests are in-flight.
            }
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            // Build the tree from our outline
            if (this.flutterOutline) {
                this.rootNode = yield this.createTreeNode(undefined, this.flutterOutline, this.activeEditor);
                FlutterOutlineProvider.showTree();
            }
            else {
                this.rootNode = undefined;
                FlutterOutlineProvider.hideTree();
            }
            this.refresh();
        });
    }
    createTreeNode(parent, outline, editor) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure we're still active editor before trying to use.
            if (editor && editor.document && !editor.document.isClosed && this.activeEditor === editor) {
                const node = new FlutterWidgetItem(parent, outline, editor);
                // Add this node to a lookup by line so we can quickly find it as the user moves around the doc.
                const startLine = outline.range.start.line;
                const endLine = outline.range.end.line;
                for (let line = startLine; line <= endLine; line++) {
                    if (!this.treeNodesByLine[line]) {
                        this.treeNodesByLine[line] = [];
                    }
                    this.treeNodesByLine[line].push(node);
                }
                if (outline.children)
                    node.children = (yield Promise.all(outline.children.map((c) => this.createTreeNode(node, c, editor)))).filter((n) => n).map((n) => n);
                return node;
            }
            return undefined;
        });
    }
}
exports.LspFlutterOutlineProvider = LspFlutterOutlineProvider;
function isWidget(outline) {
    return outline.kind !== "DART_ELEMENT";
}
function getFixes(editor, outline) {
    return __awaiter(this, void 0, void 0, function* () {
        const pos = "range" in outline
            ? (0, utils_2.lspToPosition)(outline.range.start)
            : editor.document.positionAt(outline.offset);
        const range = new vs.Range(pos, pos);
        const fixes = yield vs.commands.executeCommand("vscode.executeCodeActionProvider", editor.document.uri, range);
        return fixes || [];
    });
}
class FlutterWidgetItem extends vs.TreeItem {
    constructor(parent, outline, editor) {
        super(FlutterWidgetItem.getLabel(outline), (outline.children && outline.children.length)
            ? vs.TreeItemCollapsibleState.Expanded
            : vs.TreeItemCollapsibleState.None);
        this.parent = parent;
        this.outline = outline;
        this.children = [];
        this.fixes = [];
        this.description = FlutterWidgetItem.getDescription(outline);
        if (isWidget(outline)) {
            this.iconPath = vs.Uri.file(path.join(extension_utils_1.extensionPath, "media/icons/flutter_widget.svg"));
        }
        else if (outline.dartElement) {
            const icon = (0, mappings_1.getIconForSymbolKind)((0, analyzer_das_1.getSymbolKindForElementKind)(logging_1.nullLogger, outline.dartElement.kind));
            this.iconPath = {
                dark: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-dark.svg`)),
                light: vs.Uri.file(path.join(extension_utils_1.extensionPath, `media/icons/vscode_symbols/${icon}-light.svg`)),
            };
        }
        const displayRange = "range" in outline
            ? outline.range
            : new vs.Range(editor.document.positionAt(outline.offset), editor.document.positionAt(outline.offset + outline.length));
        const highlightRange = "codeRange" in outline
            ? outline.codeRange
            : new vs.Range(editor.document.positionAt(outline.codeOffset), editor.document.positionAt(outline.codeOffset + outline.codeLength));
        const selectionPos = "range" in outline
            ? outline.dartElement && outline.dartElement.range
                ? (0, utils_2.lspToPosition)(outline.dartElement.range.start)
                : (0, utils_2.lspToPosition)(outline.range.start)
            : outline.dartElement && outline.dartElement.location && outline.dartElement.location.offset
                ? editor.document.positionAt(outline.dartElement.location.offset)
                : editor.document.positionAt(outline.offset);
        this.command = {
            arguments: [
                editor,
                // Code to fit on screen
                displayRange,
                // Code to highlight
                highlightRange,
                // Selection (we just want to move cursor, so it's 0-length)
                new vs.Range(selectionPos, selectionPos),
            ],
            command: "_dart.showCode",
            title: "",
        };
        this.tooltip = (0, utils_2.treeLabel)(this);
        if (outline.attributes && outline.attributes.length) {
            this.tooltip += "\n  " + outline.attributes.map((a) => `${a.name}: ${a.label}`).join("\n   ");
        }
    }
    static getLabel(outline) {
        let label = "";
        if (outline.dartElement) {
            label += " " + outline.dartElement.name;
            if (outline.dartElement.typeParameters)
                label += outline.dartElement.typeParameters;
        }
        if (outline.variableName)
            label += " " + outline.variableName;
        if (outline.className)
            label += " " + outline.className;
        if (outline.label)
            label += " " + outline.label;
        return label.trim();
    }
    static getDescription(outline) {
        var _a, _b;
        let label = "";
        if (outline.dartElement) {
            if (outline.dartElement.parameters)
                label += outline.dartElement.parameters;
            if (outline.dartElement.returnType)
                label += " → " + outline.dartElement.returnType;
        }
        // Prefer an attribute named "data", but otherwise try some others
        // in order that appear useful.
        const attributeToShow = ((_a = outline.attributes) === null || _a === void 0 ? void 0 : _a.find((a) => a.name === "data"))
            || ((_b = outline.attributes) === null || _b === void 0 ? void 0 : _b.find((a) => a.name === "icon" || a.name === "value"));
        if (attributeToShow)
            label += " " + attributeToShow.label;
        return label.trim();
    }
}
exports.FlutterWidgetItem = FlutterWidgetItem;


/***/ }),

/***/ 9476:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterTaskProvider = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(5820);
const utils_2 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_3 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const dart_task_provider_1 = __webpack_require__(4530);
const util = __webpack_require__(8779);
class FlutterTaskProvider extends dart_task_provider_1.BaseTaskProvider {
    constructor(logger, context, sdks, flutterCapabilities) {
        super(logger, context, sdks);
        this.flutterCapabilities = flutterCapabilities;
        context.subscriptions.push(vs.commands.registerCommand("flutter.task.genl10n", (uri) => this.runProjectTask(uri, "flutter", ["gen-l10n"])));
    }
    get type() { return FlutterTaskProvider.type; }
    provideTasks(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const projectFolders = yield (0, utils_3.getAllProjectFolders)(this.logger, util.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
            let promises = [];
            projectFolders.forEach((folder) => {
                const folderUri = vs.Uri.file(folder);
                const workspaceFolder = vs.workspace.getWorkspaceFolder(folderUri);
                const isFlutter = (0, fs_1.isFlutterProjectFolder)(folder);
                if (isFlutter) {
                    promises = promises.concat(this.createSharedTasks(workspaceFolder, folderUri));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "aar"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "apk"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "appbundle"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "bundle"]));
                    if (constants_1.isMac) {
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ios"]));
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ios-framework"]));
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "ipa"]));
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "macos"]));
                    }
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "web"]));
                    if (constants_1.isWin) {
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "windows"]));
                        promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["build", "winuwp"]));
                    }
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["install"]));
                    promises.push(this.createTask(workspaceFolder, folderUri, "flutter", ["gen-l10n"]));
                }
            });
            const tasks = (yield Promise.all(promises)).filter(utils_2.notUndefined);
            return tasks;
        });
    }
    createPubTask(workspaceFolder, projectFolder, args) {
        return this.createTask(workspaceFolder, projectFolder, "flutter", ["pub", ...args]);
    }
    injectArgs(definition) {
        var _a;
        definition.args = (_a = definition.args) !== null && _a !== void 0 ? _a : [];
        if (definition.command === "flutter") {
            // Inject web-renderer if required.
            const isWebBuild = (0, array_1.arrayStartsWith)(definition.args, ["build", "web"]);
            if (isWebBuild && !definition.args.includes("--web-renderer")) {
                const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                if (renderer) {
                    definition.args.push("--web-renderer");
                    definition.args.push(renderer);
                }
            }
        }
    }
}
exports.FlutterTaskProvider = FlutterTaskProvider;
FlutterTaskProvider.type = "flutter"; // also referenced in package.json


/***/ }),

/***/ 4014:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateLocalizationsOnSaveHandler = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const utils_2 = __webpack_require__(8779);
class GenerateLocalizationsOnSaveHandler {
    constructor() {
        this.disposables = [];
        // And whether any saved file was dirty to support `..ifDirty` settings.
        this.isSavingDirtyFile = false;
        this.disposables.push(vscode_1.workspace.onWillSaveTextDocument((e) => {
            if (!this.isGeneratableFile(e.document))
                return;
            this.lastSaveReason = e.reason;
            this.isSavingDirtyFile = this.isSavingDirtyFile || e.document.isDirty;
        }));
        this.disposables.push(vscode_1.workspace.onDidSaveTextDocument((td) => {
            this.triggerGeneration(td);
        }));
    }
    triggerGeneration(file) {
        const isAutoSave = this.lastSaveReason === vscode_1.TextDocumentSaveReason.FocusOut ||
            this.lastSaveReason === vscode_1.TextDocumentSaveReason.AfterDelay;
        // Never do anything for files inside .dart_tool folders.
        if (!this.isGeneratableFile(file))
            return;
        const isDirty = this.isSavingDirtyFile;
        this.isSavingDirtyFile = false;
        const configSetting = config_1.config.flutterGenerateLocalizationsOnSave;
        if (configSetting === "never" || (isAutoSave && (configSetting === "manual" || configSetting === "manualIfDirty")))
            return;
        if (!isDirty && (configSetting === "manualIfDirty" || configSetting === "allIfDirty"))
            return;
        const commandToRun = "flutter.task.genl10n";
        const args = [file.uri];
        // Debounce to avoid reloading multiple times during multi-file-save (Save All).
        // Hopefully we can improve in future: https://github.com/microsoft/vscode/issues/86087
        if (this.debounceDelayTimer) {
            clearTimeout(this.debounceDelayTimer);
        }
        this.debounceDelayTimer = setTimeout(() => {
            this.debounceDelayTimer = undefined;
            vscode_1.commands.executeCommand(commandToRun, args);
        }, 200);
    }
    isGeneratableFile(file) {
        // Never do anything for files inside .dart_tool folders.
        if ((0, fs_1.fsPath)(file.uri).indexOf(`${path.sep}.dart_tool${path.sep}`) !== -1)
            return false;
        // Bail out if we're in an external file, or not Dart.
        if (!(0, utils_2.isWithinWorkspace)((0, fs_1.fsPath)(file.uri)) || !this.isArbDocument(file))
            return false;
        if (!(0, utils_2.isInsideFlutterProject)(file.uri))
            return false;
        return true;
    }
    isArbDocument(file) {
        if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
            return false;
        const extName = path.extname((0, fs_1.fsPath)(file.uri));
        const extension = extName ? extName.substr(1) : undefined;
        return extension === "arb";
    }
    dispose() {
        if (this.debounceDelayTimer)
            clearTimeout(this.debounceDelayTimer);
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.GenerateLocalizationsOnSaveHandler = GenerateLocalizationsOnSaveHandler;


/***/ }),

/***/ 7253:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VmServiceExtensions = exports.timeDilationSlow = exports.timeDilationNormal = exports.IS_INSPECTING_WIDGET_CONTEXT = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const utils_2 = __webpack_require__(8779);
exports.IS_INSPECTING_WIDGET_CONTEXT = "dart-code:flutter.isInspectingWidget";
const keyTimeDilation = "timeDilation";
const keyEnabled = "enabled";
const keyValue = "value";
/// Service extension values must be wrapped in objects when sent to the VM, eg:
///
///     { timeDilation: x.x }
///     { enabled: true }
///
/// This map tracks the name of the key for a given extension.
const toggleExtensionStateKeys = {
    [enums_1.VmServiceExtension.PlatformOverride]: keyValue,
    [enums_1.VmServiceExtension.DebugBanner]: keyEnabled,
    [enums_1.VmServiceExtension.DebugPaint]: keyEnabled,
    [enums_1.VmServiceExtension.PaintBaselines]: keyEnabled,
    [enums_1.VmServiceExtension.InspectorSelectMode]: keyEnabled,
    [enums_1.VmServiceExtension.BrightnessOverride]: keyValue,
    [enums_1.VmServiceExtension.RepaintRainbow]: keyEnabled,
    [enums_1.VmServiceExtension.PerformanceOverlay]: keyEnabled,
    [enums_1.VmServiceExtension.SlowAnimations]: keyTimeDilation,
};
exports.timeDilationNormal = 1.0;
exports.timeDilationSlow = 5.0;
/// Manages state for (mostly Flutter) VM service extensions.
class VmServiceExtensions {
    constructor(logger, debugCommands, workspaceContext) {
        this.logger = logger;
        this.debugCommands = debugCommands;
        this.workspaceContext = workspaceContext;
        this.registeredServices = {};
        this.loadedServiceExtensions = [];
        this.loadedServiceExtensionIsolateIds = new Map();
        /// Extension values owned by us. If someone else updates a value, we should
        /// remove it from here.
        this.currentExtensionValues = {};
        this.debugCommands.onWillHotRestart(() => this.markAllServiceExtensionsUnloaded());
    }
    /// Handles an event from the Debugger, such as extension services being loaded and values updated.
    handleDebugEvent(session, e) {
        return __awaiter(this, void 0, void 0, function* () {
            if (e.event === "dart.serviceExtensionAdded") {
                this.handleServiceExtensionLoaded(session, e.body.extensionRPC, e.body.isolateId);
                try {
                    if (e.body.extensionRPC === enums_1.VmServiceExtension.InspectorSetPubRootDirectories) {
                        // TODO(helin24): Check if all of the places that call `getAllProjectFolders` need similar settings; we could potentially simplify the arguments.
                        const projectFolders = yield (0, utils_1.getAllProjectFolders)(this.logger, utils_2.getExcludedFolders, { requirePubspec: !this.workspaceContext.config.forceFlutterWorkspace, searchDepth: config_1.config.projectSearchDepth, onlyWorkspaceRoots: this.workspaceContext.config.forceFlutterWorkspace });
                        const params = {
                            // TODO: Is this OK???
                            isolateId: e.body.isolateId,
                        };
                        let argNum = 0;
                        for (const projectFolder of projectFolders) {
                            params[`arg${argNum++}`] = this.formatPathForPubRootDirectories(projectFolder);
                        }
                        yield this.callServiceExtension(e.session, enums_1.VmServiceExtension.InspectorSetPubRootDirectories, params);
                    }
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            else if (e.event === "dart.serviceRegistered") {
                this.handleServiceRegistered(e.body.service, e.body.method);
            }
            else if (e.event === "flutter.serviceExtensionStateChanged") {
                this.handleRemoteValueUpdate(e.body.extension, e.body.value);
            }
        });
    }
    formatPathForPubRootDirectories(path) {
        if (constants_1.isWin) {
            return path && `file:///${path.replace(/\\/g, "/")}`;
        }
        // TODO(helin24): Use DDS for this translation.
        const search = "/google3/";
        if (this.workspaceContext.config.forceFlutterWorkspace && path.startsWith("/google") && path.includes(search)) {
            const idx = path.indexOf(search);
            const remainingPath = path.substring(idx + search.length);
            return `google3:///${remainingPath}`;
        }
        return path;
    }
    overridePlatform() {
        return __awaiter(this, void 0, void 0, function* () {
            const selection = yield vs.window.showQuickPick([
                { label: "Android", platform: "android" },
                { label: "iOS", platform: "iOS" },
                { label: "macOS", platform: "macOS" },
                { label: "Windows", platform: "windows" },
                { label: "Linux", platform: "linux" },
            ]);
            if (!selection)
                return;
            // Pass the same value for both options as we will always set it.
            return this.toggle(enums_1.VmServiceExtension.PlatformOverride, selection.platform, selection.platform);
        });
    }
    /// Toggles between two values. Always picks the value1 if the current value
    /// is not already value1 (eg. if it's neither of those, it'll pick val1).
    toggle(id, val1 = true, val2 = false) {
        return __awaiter(this, void 0, void 0, function* () {
            /// Helper that toggles for one session.
            const toggleForSession = (session) => __awaiter(this, void 0, void 0, function* () {
                const newValue = val1 === val2
                    ? val1
                    : (yield this.getCurrentServiceExtensionValue(session.session, id)) !== val1
                        ? val1
                        : val2;
                this.currentExtensionValues[id] = newValue;
                yield this.sendExtensionValue(session.session, id, newValue);
            });
            yield Promise.all(debug_1.debugSessions.map((session) => toggleForSession(session).catch((e) => this.logger.error(e))));
        });
    }
    getCurrentServiceExtensionValue(session, method) {
        return __awaiter(this, void 0, void 0, function* () {
            const responseBody = yield this.callServiceExtension(session, method);
            return this.extractServiceValue(responseBody[toggleExtensionStateKeys[method]]);
        });
    }
    sendExtensionValue(session, method, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = { [toggleExtensionStateKeys[method]]: value };
            yield this.callServiceExtension(session, method, params);
        });
    }
    callServiceExtension(session, method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(params === null || params === void 0 ? void 0 : params.isolateId)) {
                params = params || {};
                params.isolateId = this.loadedServiceExtensionIsolateIds.get(method);
            }
            return yield session.customRequest("callService", { method, params });
        });
    }
    syncContextStates(id, value) {
        if (id === enums_1.VmServiceExtension.InspectorSelectMode) {
            /// Keep the context in sync so that the "Cancel Inspect Widget" command is enabled/disabled.
            vs.commands.executeCommand("setContext", exports.IS_INSPECTING_WIDGET_CONTEXT, !!value);
            this.debugCommands.isInspectingWidget = !!value;
        }
    }
    /// Handles updates that come from the VM (eg. were updated by another tool).
    handleRemoteValueUpdate(id, value) {
        this.syncContextStates(id, value);
        // Don't try to process service extension we don't know about.
        if (this.currentExtensionValues[id] === undefined)
            return;
        value = this.extractServiceValue(value);
        // If someone else updated it to something different to the value we're
        // overriding, then remove our override.
        if (this.currentExtensionValues[id] !== value)
            delete this.currentExtensionValues[id];
    }
    extractServiceValue(value) {
        // HACK: Everything comes through as strings, but we need bools/ints and sometimes strings,
        // so attempt to parse it, but keep the original string in the case of failure.
        if (typeof value === "string") {
            try {
                value = JSON.parse(value);
            }
            catch (_a) {
            }
        }
        return value;
    }
    /// Resets all local state to defaults - used when terminating the last debug session (or
    // starting the first) to ensure debug toggles don't "persist" across sessions.
    resetToDefaults() {
        this.currentExtensionValues = {};
    }
    /// Tracks registered services and updates contexts to enable VS Code commands.
    handleServiceRegistered(service, method) {
        this.registeredServices[service] = method;
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${service}`, true);
    }
    /// Tracks loaded service extensions and updates contexts to enable VS Code commands.
    handleServiceExtensionLoaded(session, extensionRPC, isolateId) {
        session.loadedServiceExtensions.push(extensionRPC);
        this.loadedServiceExtensions.push(extensionRPC);
        if (isolateId)
            this.loadedServiceExtensionIsolateIds.set(extensionRPC, isolateId);
        vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${extensionRPC}`, true);
        // If this extension is one we have an override value for, then this must be the extension loading
        // for a new isolate (perhaps after a restart), so send its value.
        // Only ever send values for enabled and known extensions.
        const isTogglableService = toggleExtensionStateKeys[extensionRPC] !== undefined;
        const value = this.currentExtensionValues[extensionRPC];
        const hasValue = value !== undefined;
        if (isTogglableService && hasValue)
            this.sendExtensionValue(session.session, extensionRPC, value).catch((e) => this.logger.error(e));
    }
    /// Marks all services as not-loaded (happens after session ends).
    markAllServicesUnloaded() {
        for (const id of Object.keys(this.registeredServices)) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.registeredServices = {};
    }
    /// Marks all service extensions as not-loaded (happens after session ends or after hot restart).
    markAllServiceExtensionsUnloaded() {
        for (const id of this.loadedServiceExtensions) {
            vs.commands.executeCommand("setContext", `${extension_1.SERVICE_EXTENSION_CONTEXT_PREFIX}${id}`, undefined);
        }
        this.loadedServiceExtensions.length = 0;
        this.loadedServiceExtensionIsolateIds.clear();
    }
    // TODO: These services should be per-session!
    serviceIsRegistered(service) {
        return !!this.registeredServices[service];
    }
    getServiceMethodName(service) {
        return this.registeredServices[service];
    }
    serviceExtensionIsLoaded(id) {
        return !!this.loadedServiceExtensions.find((loadedID) => loadedID === id);
    }
}
exports.VmServiceExtensions = VmServiceExtensions;


/***/ }),

/***/ 7428:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspAnalyzerStatusReporter = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
// TODO: Remove this class once Flutter Stable has an LSP server that uses $/progress.
class LspAnalyzerStatusReporter {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.analysisInProgress = false;
        analyzer.onAnalysisStatusChange.listen((params) => this.handleServerStatus(params));
    }
    handleServerStatus(params) {
        if (params.suppressProgress) {
            return;
        }
        this.analysisInProgress = params.isAnalyzing;
        if (this.analysisInProgress) {
            // Debounce short analysis times.
            setTimeout(() => {
                // When the timeout fires, we need to check analysisInProgress again in case
                // analysis has already finished.
                if (this.analysisInProgress && !this.analyzingPromise) {
                    vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, title: "Analyzing…" }, () => {
                        if (!this.analyzingPromise) // Re-check, since we don't know how long before this callback is called.
                            this.analyzingPromise = new utils_1.PromiseCompleter();
                        return this.analyzingPromise.promise;
                    });
                }
            }, 100);
        }
        else {
            if (this.analyzingPromise) {
                this.analyzingPromise.resolve();
                this.analyzingPromise = undefined;
            }
        }
    }
}
exports.LspAnalyzerStatusReporter = LspAnalyzerStatusReporter;


/***/ }),

/***/ 3088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClosingLabelsDecorations = void 0;
const vs = __webpack_require__(9496);
const custom_protocol_1 = __webpack_require__(556);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const closing_labels_decorations_1 = __webpack_require__(1326);
class LspClosingLabelsDecorations {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.subscriptions = [];
        this.closingLabels = {};
        this.editors = {};
        this.decorationType = vs.window.createTextEditorDecorationType({
            after: {
                color: new vs.ThemeColor("dart.closingLabels"),
                margin: "2px",
            },
            rangeBehavior: vs.DecorationRangeBehavior.ClosedOpen,
        });
        // tslint:disable-next-line: no-floating-promises
        analyzer.start().then(() => {
            this.analyzer.onNotification(custom_protocol_1.PublishClosingLabelsNotification.type, (n) => {
                const filePath = (0, fs_1.fsPath)(vs.Uri.parse(n.uri));
                this.closingLabels[filePath] = n;
                // Fire an update if it was for the active document.
                if (vs.window.activeTextEditor
                    && vs.window.activeTextEditor.document
                    && filePath === (0, fs_1.fsPath)(vs.window.activeTextEditor.document.uri)) {
                    // Delay this so if we're getting lots of updates we don't flicker.
                    if (this.updateTimeout)
                        clearTimeout(this.updateTimeout);
                    this.updateTimeout = setTimeout(() => this.update(), 500);
                }
            });
        });
        this.subscriptions.push(vs.window.onDidChangeActiveTextEditor(() => this.update()));
        this.subscriptions.push(vs.workspace.onDidCloseTextDocument((td) => {
            const filePath = (0, fs_1.fsPath)(td.uri);
            delete this.closingLabels[filePath];
        }));
        if (vs.window.activeTextEditor)
            this.update();
    }
    update() {
        const editor = vs.window.activeTextEditor;
        if (!editor || !editor.document)
            return;
        const filePath = (0, fs_1.fsPath)(editor.document.uri);
        if (!this.closingLabels[filePath])
            return;
        const decorations = [];
        for (const r of this.closingLabels[filePath].labels) {
            const labelRange = this.analyzer.protocol2CodeConverter.asRange(r.range);
            // Ensure the label we got looks like a sensible range, otherwise the outline info
            // might be stale (eg. we sent two updates, and the outline from in between them just
            // arrived). In this case, we'll just bail and do nothing, assuming a future update will
            // have the correct info.
            const finalCharacterPosition = labelRange.end;
            if (finalCharacterPosition.character < 1)
                return;
            const finalCharacterRange = new vs.Range(finalCharacterPosition.translate({ characterDelta: -1 }), finalCharacterPosition);
            const finalCharacterText = editor.document.getText(finalCharacterRange);
            if (closing_labels_decorations_1.validLastCharacters.indexOf(finalCharacterText) === -1)
                return;
            // Get the end of the line where we'll show the labels.
            const endOfLine = editor.document.lineAt(finalCharacterPosition).range.end;
            const existingDecorationForLine = decorations[endOfLine.line];
            if (existingDecorationForLine) {
                existingDecorationForLine.renderOptions.after.contentText = " // " + r.label + " " + existingDecorationForLine.renderOptions.after.contentText;
            }
            else {
                const dec = {
                    range: new vs.Range(labelRange.start, endOfLine),
                    renderOptions: { after: { contentText: " // " + r.label } },
                };
                decorations[endOfLine.line] = dec;
            }
        }
        this.editors[filePath] = editor;
        editor.setDecorations(this.decorationType, Object.keys(decorations).map((k) => parseInt(k, 10)).map((k) => decorations[k]));
    }
    dispose() {
        for (const editor of Object.values(this.editors)) {
            try {
                editor.setDecorations(this.decorationType, []);
            }
            catch (_a) {
                // It's possible the editor was closed, but there
                // doesn't seem to be a way to tell.
            }
        }
        (0, utils_1.disposeAll)(this.subscriptions);
    }
}
exports.LspClosingLabelsDecorations = LspClosingLabelsDecorations;


/***/ }),

/***/ 9982:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspGoToSuperCommand = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const editors = __webpack_require__(8805);
class LspGoToSuperCommand {
    constructor(analyzer) {
        this.analyzer = analyzer;
        this.disposables = [];
        this.disposables.push(vs.commands.registerCommand("dart.goToSuper", this.goToSuper, this));
    }
    goToSuper() {
        return __awaiter(this, void 0, void 0, function* () {
            const editor = editors.getActiveDartEditor();
            if (!editor) {
                vs.window.showWarningMessage("No active Dart editor.");
                return;
            }
            const location = yield this.analyzer.getSuper({
                position: this.analyzer.client.code2ProtocolConverter.asPosition(editor.selection.start),
                textDocument: this.analyzer.client.code2ProtocolConverter.asVersionedTextDocumentIdentifier(editor.document),
            });
            if (!location)
                return;
            const codeLocation = this.analyzer.client.protocol2CodeConverter.asLocation(location);
            const elementDocument = yield vs.workspace.openTextDocument(codeLocation.uri);
            const elementEditor = yield vs.window.showTextDocument(elementDocument);
            (0, utils_2.showCode)(elementEditor, codeLocation.range, codeLocation.range, codeLocation.range);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.LspGoToSuperCommand = LspGoToSuperCommand;


/***/ }),

/***/ 3747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// TODO: Move this to Shared (and remove dependencies on extension/)
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestDiscoverer = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const outline_lsp_1 = __webpack_require__(4215);
const test_1 = __webpack_require__(8729);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_3 = __webpack_require__(8779);
class TestDiscoverer {
    constructor(logger, fileTracker, model) {
        this.logger = logger;
        this.fileTracker = fileTracker;
        this.model = model;
        this.disposables = [];
        this.debounceTimers = {};
        this.debounceDuration = 1500;
        this.hasSetupFileHandlers = false;
        this.disposables.push(fileTracker.onOutline.listen((o) => this.handleOutline(o)));
    }
    /// Performs suite discovery if it has not already finished. If discovery
    /// is started (or already in progress), waits for it to complete.
    ensureSuitesDiscovered() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.testDiscoveryPerformed)
                this.testDiscoveryPerformed = this.performSuiteDiscovery();
            // Wait for discovery to complete, however it started.
            yield this.testDiscoveryPerformed;
        });
    }
    /// Immediately performs suite discovery. Use [ensureSuitesDiscovered] if you want
    /// to just ensure discovery has run at least once.
    ///
    /// Also sets up handlers so creating/renaming/deleting files updates the
    /// discovered suite list correctly.
    performSuiteDiscovery() {
        return __awaiter(this, void 0, void 0, function* () {
            // Set up events for create/rename/delete so we keep the suites updated
            // once we have discovered them.
            if (!this.hasSetupFileHandlers) {
                this.hasSetupFileHandlers = true;
                this.disposables.push(vs.workspace.onDidCreateFiles((e) => {
                    e.files.forEach((file) => {
                        const filePath = (0, fs_1.fsPath)(file);
                        if ((0, utils_3.isTestFile)(filePath))
                            this.model.suiteDiscovered(undefined, filePath);
                    });
                }), vs.workspace.onDidRenameFiles((e) => __awaiter(this, void 0, void 0, function* () {
                    e.files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
                        this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file.oldUri));
                        this.discoverTestSuites((0, fs_1.fsPath)(file.newUri));
                    }));
                })), vs.workspace.onDidDeleteFiles((e) => __awaiter(this, void 0, void 0, function* () {
                    e.files.forEach((file) => __awaiter(this, void 0, void 0, function* () {
                        this.model.clearSuiteOrDirectory((0, fs_1.fsPath)(file));
                    }));
                })));
            }
            yield vs.window.withProgress({
                location: vs.ProgressLocation.Window,
                title: "Discovering Tests…",
            }, () => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve) => setTimeout(resolve, 1000));
                try {
                    const projectFolders = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
                    yield Promise.all(projectFolders.map((folder) => this.discoverTestSuites(folder)));
                }
                catch (e) {
                    this.logger.error(`Failed to discover tests: ${e}`);
                }
            }));
        });
    }
    discoverTestSuites(fileOrDirectory, isDirectory, level = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (level > 100)
                return; // Ensure we don't traverse too far or follow any cycles.
            if ((0, utils_3.isTestFile)(fileOrDirectory)) {
                this.model.suiteDiscovered(undefined, fileOrDirectory);
            }
            else if (isDirectory !== false) { // undefined or true are allowed
                try {
                    const children = yield vs.workspace.fs.readDirectory(vs.Uri.file(fileOrDirectory));
                    const childPromises = children
                        .map((item) => ({ name: item[0], type: item[1] }))
                        .filter((item) => !item.name.startsWith("."))
                        .map((item) => this.discoverTestSuites(path.join(fileOrDirectory, item.name), item.type === vs.FileType.Directory, level + 1));
                    yield Promise.all(childPromises);
                }
                catch (e) {
                    if (e.code !== "FileNotADirectory")
                        this.logger.error(`Failed to discover tests: ${e}`);
                }
            }
        });
    }
    discoverTestsForSuite(node) {
        return __awaiter(this, void 0, void 0, function* () {
            const doc = yield vs.workspace.openTextDocument(node.suiteData.path);
            yield this.fileTracker.waitForOutline(doc, undefined);
        });
    }
    /// Forces an update for a file based on the last Outline data (if any).
    ///
    /// Used by tests to ensure discovery results are available if the test tree state has
    /// been cleared between test runs.
    forceUpdate(uri) {
        const outline = this.fileTracker.getOutlineFor(uri);
        if (outline)
            this.rebuildFromOutline((0, fs_1.fsPath)(uri), outline);
    }
    handleOutline(outline) {
        const suitePath = (0, fs_1.forceWindowsDriveLetterToUppercase)((0, utils_1.uriToFilePath)(outline.uri));
        const existingTimeout = this.debounceTimers[suitePath];
        if (existingTimeout)
            clearTimeout(existingTimeout);
        // If this is the first outline for a file (eg. we've never had a timeout)
        // we should skip the debounce so things are initially more responsive.
        const debounceDuration = existingTimeout ? this.debounceDuration : 0;
        this.debounceTimers[suitePath] = setTimeout(() => this.rebuildFromOutline(suitePath, outline.outline), debounceDuration);
    }
    rebuildFromOutline(suitePath, outline) {
        if ((0, utils_3.isTestFile)(suitePath)) {
            // Force creation of a node if it's not already there.
            const [suite, _] = this.model.getOrCreateSuite(suitePath);
            // Generate a unique ID for these IDs to be owned by so that they can be looked
            // up independent of any other ongoing runs.
            const dartCodeDebugSessionID = `discovery-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}`;
            // Mark everything in the suite as potentially-deleted so that we can detect anything
            // that was not present in the new list to remove it afterwards.
            this.model.markAllAsPotentiallyDeleted(suite, test_model_1.TestSource.Outline);
            const visitor = new TestDiscoveryVisitor(this.logger, this.model, dartCodeDebugSessionID, suitePath);
            visitor.visit(outline);
            this.model.removeAllPotentiallyDeletedNodes(suite);
            this.model.rebuildSuiteNode(suite);
            this.model.updateNode();
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestDiscoverer = TestDiscoverer;
class TestDiscoveryVisitor extends outline_lsp_1.LspOutlineVisitor {
    constructor(logger, model, dartCodeDebugSessionID, suitePath) {
        super(logger);
        this.model = model;
        this.dartCodeDebugSessionID = dartCodeDebugSessionID;
        this.suitePath = suitePath;
        this.stack = [];
        this.id = 1;
    }
    visitUnitTestTest(outline) {
        this.handleItem(outline, false, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.handleItem(outline, true, super.visitUnitTestGroup);
    }
    handleItem(outline, isGroup, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const parent = this.stack.length > 0 ? this.stack[this.stack.length - 1] : undefined;
        const fullName = (parent === null || parent === void 0 ? void 0 : parent.name)
            ? `${parent.name} ${name}`
            : name;
        const thisID = this.id++;
        if (isGroup)
            this.model.groupDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent === null || parent === void 0 ? void 0 : parent.id, undefined, range);
        else
            this.model.testDiscovered(this.dartCodeDebugSessionID, this.suitePath, test_model_1.TestSource.Outline, thisID, fullName, parent === null || parent === void 0 ? void 0 : parent.id, undefined, range, undefined);
        if (isGroup)
            this.stack.push({ id: thisID, name: fullName });
        try {
            base.bind(this)(outline);
        }
        finally {
            if (isGroup)
                this.stack.pop();
        }
    }
}


/***/ }),

/***/ 3886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.locateBestProjectRoot = exports.UPGRADE_TO_WORKSPACE_FOLDERS = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
exports.UPGRADE_TO_WORKSPACE_FOLDERS = "Mark Projects as Workspace Folders";
function locateBestProjectRoot(folder) {
    var _a;
    if (!folder || (!(0, utils_1.isWithinWorkspace)(folder) && ((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length)))
        return undefined;
    let dir = folder;
    while (dir !== path.dirname(dir)) {
        if ((0, fs_1.hasPubspec)(dir) || (0, fs_1.hasPackageMapFile)(dir))
            return dir;
        dir = path.dirname(dir);
    }
    return undefined;
}
exports.locateBestProjectRoot = locateBestProjectRoot;


/***/ }),

/***/ 1983:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddDependencyCodeActionProvider = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const project_1 = __webpack_require__(3886);
const utils_2 = __webpack_require__(8779);
const applicableErrorCodes = ["uri_does_not_exist", "conditional_uri_does_not_exist"];
const packageUriSourceCodePattern = new RegExp(`r?['"]+package:(.*)\\/`);
class AddDependencyCodeActionProvider {
    constructor(selector) {
        this.selector = selector;
        this.rank = 90;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!context || !context.diagnostics || !context.diagnostics.length)
            return;
        const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(document.uri));
        if (!projectRoot)
            return;
        let diagnosticsWithPackageNames = context.diagnostics
            .filter((d) => d.range.intersection(range) && d.source === "dart")
            .map((diagnostic) => ({ diagnostic, packageName: this.extractPackageNameForUriNotFoundDiagnostic(document, diagnostic) }))
            .filter((d) => d.packageName);
        if (!diagnosticsWithPackageNames.length)
            return;
        const pubspec = path.join(projectRoot, "pubspec.yaml");
        const pubspecContent = fs.existsSync(pubspec) ? fs.readFileSync(pubspec).toString() : undefined;
        if (!pubspecContent)
            return;
        // Next, filter out any already in pubspec, as that suggests the URI is incorrect
        // for another reason (and we wouldn't want to try to add something that exists).
        diagnosticsWithPackageNames = diagnosticsWithPackageNames
            .filter((obj) => obj.packageName && !pubspecContent.includes(`  ${obj.packageName}`));
        if (!diagnosticsWithPackageNames.length)
            return;
        return (0, utils_1.flatMap)(diagnosticsWithPackageNames, (item) => this.createActions(document, item.diagnostic, item.packageName));
    }
    /// Checks if the diagnostic is a uri_does_not_exist and the URI is a package:
    /// URI and returns the package name.
    extractPackageNameForUriNotFoundDiagnostic(document, diag) {
        const code = diag.code;
        if (!code)
            return;
        const errorCode = typeof code === "string" || typeof code === "number"
            ? code.toString()
            : ("value" in code)
                ? code.value.toString()
                : undefined;
        if (!errorCode)
            return;
        if (!applicableErrorCodes.includes(errorCode))
            return;
        // Finally, ensure the URI is a package: URI and something that exists in the pub cache list
        // we have.
        const uriSourceCode = document.getText(diag.range);
        const match = packageUriSourceCodePattern.exec(uriSourceCode);
        if (!match)
            return;
        return match[1];
    }
    createActions(document, diagnostic, packageName) {
        const createAction = (isDevDependency) => {
            const dependencyTypeName = isDevDependency ? "dev_dependencies" : "dependencies";
            const title = `Add '${packageName}' to ${dependencyTypeName}`;
            const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
            action.command = {
                arguments: [
                    document.uri,
                    { packageNames: packageName },
                    isDevDependency,
                ],
                command: "_dart.addDependency",
                title,
            };
            return action;
        };
        const actions = [createAction(false)];
        // When outside of lib, dev_dependency is an option too.
        if (!document.uri.path.includes("/lib/"))
            actions.push(createAction(true));
        return actions;
    }
}
exports.AddDependencyCodeActionProvider = AddDependencyCodeActionProvider;


/***/ }),

/***/ 9679:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
const ranking_code_action_provider_1 = __webpack_require__(7702);
class AssistCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 10;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const assists = yield this.analyzer.editGetAssists({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                const allAssists = assists.assists.map((assist) => this.convertResult(document, assist));
                return context.only
                    ? allAssists.filter((ca) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(ca.kind); })
                    : allAssists;
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    convertResult(document, change) {
        const title = change.message;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.Refactor);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        return action;
    }
}
exports.AssistCodeActionProvider = AssistCodeActionProvider;


/***/ }),

/***/ 6974:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCompletionItemProvider = void 0;
/* eslint-disable no-underscore-dangle */
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const extension_utils_1 = __webpack_require__(6143);
const edit_das_1 = __webpack_require__(7511);
const config_1 = __webpack_require__(4165);
// TODO: This code has become messy with the SuggestionSet changes. It could do with some refactoring
// (such as creating a mapping from CompletionSuggestion -> x and SuggestionSet -> x, and then x -> CompletionItem).
class DartCompletionItemProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.disposables = [];
        this.cachedCompletions = {};
        this.existingImports = {};
        this.disposables.push(analyzer.registerForCompletionAvailableSuggestions((n) => this.storeCompletionSuggestions(n)));
        this.disposables.push(analyzer.registerForCompletionExistingImports((n) => this.storeExistingImports(n)));
    }
    provideCompletionItems(document, position, token, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const line = document.lineAt(position.line).text.slice(0, position.character);
            const nextCharacter = document.getText(new vscode_1.Range(position, position.translate({ characterDelta: 200 }))).trim().substr(0, 1);
            const conf = config_1.config.for(document.uri);
            const enableCommitCharacters = conf.enableCompletionCommitCharacters;
            const insertArgumentPlaceholders = !enableCommitCharacters && conf.insertArgumentPlaceholders && this.shouldAllowArgPlaceholders(line);
            if (!this.shouldAllowCompletion(line, context))
                return;
            const offset = document.offsetAt(position);
            const resp = yield this.analyzer.completionGetSuggestionsResults({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
            });
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const includedResults = resp.results.map((r) => this.convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp, r));
            const cachedResults = yield this.getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, document.offsetAt(position), resp);
            yield promises_1.resolvedPromise;
            if (token && token.isCancellationRequested) {
                return undefined;
            }
            const allResults = [...includedResults, ...cachedResults];
            return new vscode_1.CompletionList(allResults);
        });
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Filter out auto triggered completions on certain characters based on the previous
        // characters (eg. to allow completion on " if it's part of an import).
        if (context.triggerKind === vscode_1.CompletionTriggerKind.TriggerCharacter) {
            switch (context.triggerCharacter) {
                case "{":
                    return line.endsWith("${");
                case "'":
                    return line.endsWith("import '") || line.endsWith("export '");
                case "\"":
                    return line.endsWith("import \"") || line.endsWith("export \"");
                case "/":
                case "\\":
                    return line.startsWith("import \"") || line.startsWith("export \"")
                        || line.startsWith("import '") || line.startsWith("export '");
            }
        }
        // Otherwise, allow through.
        return true;
    }
    shouldAllowArgPlaceholders(line) {
        line = line.trim();
        // Disallow args on imports/exports since they're likely show/hide and
        // we only want the function name. This doesn't catch all cases (for ex.
        // where a show/hide is split across multiple lines) but it's better than
        // nothing. We'd need more semantic info to handle this better, and probably
        // this will go away if commit characters is fixed properly.
        if (line.startsWith("import \"") || line.startsWith("export \"")
            || line.startsWith("import '") || line.startsWith("export '")) {
            return false;
        }
        return true;
    }
    storeCompletionSuggestions(notification) {
        if (notification.changedLibraries) {
            for (const completionSet of notification.changedLibraries) {
                this.cachedCompletions[completionSet.id] = completionSet;
            }
        }
        if (notification.removedLibraries) {
            for (const completionSetID of notification.removedLibraries) {
                delete this.cachedCompletions[completionSetID];
            }
        }
    }
    storeExistingImports(notification) {
        const existingImports = notification.imports;
        // Map with key "elementName/elementDeclaringLibraryUri"
        // Value is a set of imported URIs that import that element.
        const alreadyImportedSymbols = {};
        for (const existingImport of existingImports.imports) {
            for (const importedElement of existingImport.elements) {
                // This is the symbol name and declaring library. That is, the
                // library that declares the symbol, not the one that was imported.
                // This wil be the same for an element that is re-exported by other
                // libraries, so we can avoid showing the exact duplicate.
                const elementName = existingImports.elements.strings[existingImports.elements.names[importedElement]];
                const elementDeclaringLibraryUri = existingImports.elements.strings[existingImports.elements.uris[importedElement]];
                const importedUri = existingImports.elements.strings[existingImport.uri];
                const key = `${elementName}/${elementDeclaringLibraryUri}`;
                if (!alreadyImportedSymbols[key])
                    alreadyImportedSymbols[key] = {};
                alreadyImportedSymbols[key][importedUri] = true;
            }
        }
        this.existingImports[notification.file] = alreadyImportedSymbols;
    }
    resolveCompletionItem(item, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!item.suggestion) {
                if (!item.documentation && item._documentation) {
                    item.documentation = item._documentation;
                }
                return item;
            }
            const res = yield this.analyzer.completionGetSuggestionDetails({
                file: item.filePath,
                id: item.suggestionSetID,
                label: item.suggestion.label,
                offset: item.offset,
            });
            if (token && token.isCancellationRequested) {
                return;
            }
            // Rebuild the completion using the additional resolved info.
            return this.createCompletionItemFromSuggestion(item.document, item.offset, item.nextCharacter, item.enableCommitCharacters, item.insertArgumentPlaceholders, item.replacementOffset, item.replacementLength, item.autoImportUri, item.relevance, item.suggestion, res);
        });
    }
    createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, replacementOffset, replacementLength, displayUri, relevance, suggestion, resolvedResult) {
        const completionItem = this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            autoImportUri: displayUri,
            completionText: (resolvedResult && resolvedResult.completion) || suggestion.label,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.label,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: false,
            kind: undefined,
            parameterNames: suggestion.parameterNames,
            parameterType: undefined,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance,
            replacementLength,
            replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.element ? suggestion.element.returnType : undefined,
            selectionLength: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? 0 : undefined,
            selectionOffset: resolvedResult && resolvedResult.change && resolvedResult.change.selection ? resolvedResult.change.selection.offset : undefined,
        });
        // Additional edits for the imports.
        if (resolvedResult && resolvedResult.change && resolvedResult.change.edits && resolvedResult.change.edits.length) {
            this.appendAdditionalEdits(completionItem, document, resolvedResult.change);
            if (displayUri)
                completionItem.detail = `Auto import from '${displayUri}'` + (completionItem.detail ? `\n\n${completionItem.detail}` : "");
        }
        // Copy the lazy docs over.
        if (resolvedResult && !completionItem.documentation && completionItem._documentation) {
            completionItem.documentation = completionItem._documentation;
        }
        return completionItem;
    }
    getCachedResults(document, token, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, offset, resp) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!resp.includedSuggestionSets || !resp.includedElementKinds)
                return [];
            const existingImports = resp.libraryFile ? this.existingImports[resp.libraryFile] : undefined;
            // Create a fast lookup for which kinds to include.
            const elementKinds = {};
            resp.includedElementKinds.forEach((k) => elementKinds[k] = true);
            // Create a fast lookup for relevance boosts based on tag string.
            const tagBoosts = {};
            if (resp.includedSuggestionRelevanceTags)
                resp.includedSuggestionRelevanceTags.forEach((r) => tagBoosts[r.tag] = r.relevanceBoost);
            const filePath = (0, fs_1.fsPath)(document.uri);
            const suggestionSetResults = [];
            // Keep track of suggestion sets we've seen to avoid included them twice.
            // See https://github.com/dart-lang/sdk/issues/37211.
            const usedSuggestionSets = {};
            // Keep track of items items we've included so we don't show dupes if
            // there are multiple libraries importing the same thing.
            const includedItems = {};
            for (const includedSuggestionSet of resp.includedSuggestionSets) {
                if (usedSuggestionSets[includedSuggestionSet.id])
                    continue;
                // Mark that we've done this one so we don't do it again.
                usedSuggestionSets[includedSuggestionSet.id] = true;
                // Because this work is expensive, we periodically (per suggestion
                // set) yield and check whether cancellation is pending and if so
                // stop and bail out to avoid doing redundant work.
                yield promises_1.resolvedPromise;
                if (token && token.isCancellationRequested) {
                    return [];
                }
                const suggestionSet = this.cachedCompletions[includedSuggestionSet.id];
                if (!suggestionSet) {
                    this.logger.warn(`Suggestion set ${includedSuggestionSet.id} was not available and therefore not included in the completion results`);
                    return [];
                }
                const unresolvedItems = suggestionSet.items
                    .filter((r) => elementKinds[r.element.kind])
                    .filter((suggestion) => {
                    // Check existing imports to ensure we don't already import
                    // this element (note: this exact element from its declaring
                    // library, not just something with the same name). If we do
                    // we'll want to skip it.
                    // Trim back to the . to handle enum values
                    // https://github.com/Dart-Code/Dart-Code/issues/1835
                    const key = `${suggestion.label.split(".")[0]}/${suggestion.declaringLibraryUri}`;
                    const importingUris = existingImports && existingImports[key];
                    // If there are no URIs already importing this, then include it
                    // as an auto-import.
                    if (!importingUris)
                        return true;
                    // Otherwise, it is imported but if it's not by this file, then skip it.
                    if (!importingUris[suggestionSet.uri])
                        return false;
                    // Finally, we're importing a file that has this item, so include
                    // it only if it has not already been included by another imported file.
                    // Unlike the above, we include the Kind here so that things with similar labels
                    // like Constructors+Class are still included.
                    const fullItemKey = `${suggestion.label}/${suggestion.element.kind}/${suggestion.declaringLibraryUri}`;
                    const itemHasAlreadyBeenIncluded = includedItems[fullItemKey];
                    includedItems[fullItemKey] = true;
                    return !itemHasAlreadyBeenIncluded;
                })
                    .map((suggestion) => {
                    // Calculate the relevance for this item.
                    let relevanceBoost = 0;
                    if (suggestion.relevanceTags)
                        suggestion.relevanceTags.forEach((t) => relevanceBoost = Math.max(relevanceBoost, tagBoosts[t] || 0));
                    const completionItem = this.createCompletionItemFromSuggestion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, resp.replacementOffset, resp.replacementLength, undefined, includedSuggestionSet.relevance + relevanceBoost, suggestion, undefined);
                    // Attach additional info that resolve will need.
                    const delayedCompletionItem = Object.assign({ autoImportUri: includedSuggestionSet.displayUri || suggestionSet.uri, document,
                        enableCommitCharacters,
                        filePath,
                        insertArgumentPlaceholders,
                        nextCharacter,
                        offset, relevance: includedSuggestionSet.relevance + relevanceBoost, replacementLength: resp.replacementLength, replacementOffset: resp.replacementOffset, suggestion, suggestionSetID: includedSuggestionSet.id }, completionItem);
                    return delayedCompletionItem;
                });
                suggestionSetResults.push(unresolvedItems);
            }
            return [].concat(...suggestionSetResults);
        });
    }
    convertResult(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, notification, suggestion) {
        return this.makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, {
            completionText: suggestion.completion,
            defaultArgumentListString: suggestion.defaultArgumentListString,
            defaultArgumentListTextRanges: suggestion.defaultArgumentListTextRanges,
            displayText: suggestion.displayText,
            docComplete: suggestion.docComplete,
            elementKind: suggestion.element ? suggestion.element.kind : undefined,
            isDeprecated: suggestion.isDeprecated,
            kind: suggestion.kind,
            parameterNames: suggestion.parameterNames,
            parameterType: suggestion.parameterType,
            parameters: suggestion.element ? suggestion.element.parameters : undefined,
            relevance: suggestion.relevance,
            replacementLength: notification.replacementLength,
            replacementOffset: notification.replacementOffset,
            requiredParameterCount: suggestion.requiredParameterCount,
            returnType: suggestion.returnType || (suggestion.element ? suggestion.element.returnType : undefined),
            selectionLength: suggestion.selectionLength,
            selectionOffset: suggestion.selectionOffset,
        });
    }
    makeCompletion(document, offset, nextCharacter, enableCommitCharacters, insertArgumentPlaceholders, suggestion) {
        const completionItemKind = suggestion.elementKind ? this.getElementKind(suggestion.elementKind) : undefined;
        let label = suggestion.displayText || suggestion.completionText;
        let detail;
        const completionText = new vscode_1.SnippetString();
        let triggerCompletion = false;
        const nextCharacterIsOpenParen = nextCharacter === "(";
        // If element has parameters (METHOD/CONSTRUCTOR/FUNCTION), show its parameters.
        if (suggestion.parameters && completionItemKind !== vscode_1.CompletionItemKind.Property && suggestion.kind !== "OVERRIDE"
            // Don't ever show if there is already a paren! (#969).
            && label.indexOf("(") === -1) {
            label += suggestion.parameters.length === 2 ? "()" : "(…)";
            detail = suggestion.parameters;
            const hasParams = (suggestion.parameterNames && suggestion.parameterNames.length > 0)
                || (insertArgumentPlaceholders && !!suggestion.defaultArgumentListString);
            // Add placeholders for params to the completion.
            if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("(");
                if (suggestion.defaultArgumentListString) {
                    for (const arg of this.extractTabstopDataForNamedArgs(suggestion.defaultArgumentListString, suggestion.defaultArgumentListTextRanges || [])) {
                        const text = suggestion.defaultArgumentListString.substring(arg.start, arg.end);
                        if (arg.tabStop)
                            completionText.appendPlaceholder(text);
                        else
                            completionText.appendText(text);
                    }
                }
                else
                    completionText.appendTabstop(); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && hasParams && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                const args = suggestion.parameterNames.slice(0, suggestion.requiredParameterCount);
                completionText.appendText("(");
                if (args.length) {
                    completionText.appendPlaceholder(args[0]);
                    for (const arg of args.slice(1)) {
                        completionText.appendText(", ");
                        completionText.appendPlaceholder(arg);
                    }
                }
                else
                    completionText.appendTabstop(0); // Put a tap stop between parens since there are optional args.
                completionText.appendText(")");
            }
            else if (insertArgumentPlaceholders && !nextCharacterIsOpenParen) {
                completionText.appendText(suggestion.completionText);
                completionText.appendText("()");
            }
            else {
                completionText.appendText(suggestion.completionText);
            }
        }
        else if (suggestion.selectionOffset) {
            const before = suggestion.completionText.slice(0, suggestion.selectionOffset);
            const selection = suggestion.completionText.slice(suggestion.selectionOffset, suggestion.selectionOffset + (suggestion.selectionLength || 0));
            // If we have a selection offset (eg. a place to put the cursor) but not any text to pre-select then
            // pop open the completion to help the user type the value.
            // Only do this if it ends with a space (argument completion), see #730.
            if (!selection && suggestion.completionText.slice(suggestion.selectionOffset - 1, suggestion.selectionOffset) === " ")
                triggerCompletion = true;
            const after = suggestion.completionText.slice(suggestion.selectionOffset + (suggestion.selectionLength || 0));
            completionText.appendText(before);
            if (selection)
                completionText.appendPlaceholder(selection);
            else
                completionText.appendTabstop(0);
            completionText.appendText(after);
        }
        else {
            completionText.appendText(suggestion.completionText);
        }
        // If we're a property, work out the type.
        if (completionItemKind === vscode_1.CompletionItemKind.Property) {
            // Setters appear as methods with one arg (and cause getters to not appear),
            // so treat them both the same and just display with the properties type.
            detail = suggestion.elementKind === "GETTER"
                ? suggestion.returnType
                // See https://github.com/dart-lang/sdk/issues/27747
                : suggestion.parameters ? suggestion.parameters.substring(1, suggestion.parameters.lastIndexOf(" ")) : "";
            // Otherwise, get return type from method.
        }
        else if (suggestion.returnType) {
            detail =
                detail
                    ? detail + " → " + suggestion.returnType
                    : suggestion.returnType;
        }
        else if (suggestion.parameterType) {
            detail = suggestion.parameterType;
        }
        // If we have trailing commas (flutter) they look weird in the list, so trim the off (for display label only).
        if (label.endsWith(","))
            label = label.substr(0, label.length - 1).trim();
        // If we didnt have a CompletionItemKind from our element, base it on the CompletionSuggestionKind.
        // This covers things like Keywords that don't have elements.
        const kind = completionItemKind || (suggestion.kind ? this.getSuggestionKind(suggestion.kind, label) : undefined);
        const docs = (0, extension_utils_1.cleanDartdoc)(suggestion.docComplete);
        const completion = new vscode_1.CompletionItem(label, kind);
        completion.filterText = label.split("(")[0]; // Don't ever include anything after a ( in filtering.
        if (suggestion.isDeprecated)
            completion.tags = [vs.CompletionItemTag.Deprecated];
        completion.detail = detail;
        completion._documentation = docs ? (0, extension_utils_1.createMarkdownString)(docs) : undefined;
        completion.insertText = completionText;
        completion.keepWhitespace = true;
        completion.range = {
            inserting: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(Math.min(offset, suggestion.replacementOffset + suggestion.replacementLength))),
            replacing: new vscode_1.Range(document.positionAt(suggestion.replacementOffset), document.positionAt(suggestion.replacementOffset + suggestion.replacementLength)),
        };
        if (enableCommitCharacters)
            completion.commitCharacters = this.getCommitCharacters(suggestion.kind);
        const triggerCompletionsFor = ["import '';"];
        if (triggerCompletionsFor.indexOf(label) !== -1)
            triggerCompletion = true;
        // Handle folders in imports better.
        if (suggestion.kind === "IMPORT" && label.endsWith("/"))
            triggerCompletion = true;
        if (triggerCompletion) {
            completion.command = {
                command: "editor.action.triggerSuggest",
                title: "Suggest",
            };
        }
        // Relevance is a number, highest being best. Code sorts by text, so subtract from a large number so that
        // a text sort will result in the correct order.
        // 555 -> 999455
        //  10 -> 999990
        //   1 -> 999999
        completion.sortText = (1000000 - suggestion.relevance).toString();
        return completion;
    }
    /// Argument info comes through as a stringle string like "a: null, b: null"
    /// and an array of ints that are offset/length pairs. [3,4,12,4] means
    /// characters 3-7 and 12 - 16 are tabstops.
    ///
    /// To process this more easily, we first convert this into an array like:
    ///
    /// ```
    /// [
    ///   { start: 0, end: 3, tabStop: false },
    ///   { start: 3, end: 7, tabStop: true },
    ///   { start: 7, end: 12, tabStop: false },
    ///   { start: 12, end: 16, tabStop: true },
    /// ]
    /// ```
    extractTabstopDataForNamedArgs(argListString, argListTextRanges) {
        const ranges = [];
        let currentIndex = 0;
        // For each range, push anything that comes before it, and it.
        for (const range of this.extractOffsetLengthPairs(argListTextRanges)) {
            ranges.push({ start: currentIndex, end: range[0], tabStop: false });
            ranges.push({ start: range[0], end: range[1], tabStop: true });
            currentIndex = range[1];
        }
        // Then push anything left at the end.
        if (currentIndex < argListString.length)
            ranges.push({ start: currentIndex, end: argListString.length, tabStop: false });
        return ranges;
    }
    extractOffsetLengthPairs(numberPairs) {
        const pairs = [];
        for (let i = 0; i < numberPairs.length - 1; i += 2) {
            pairs.push([numberPairs[i], numberPairs[i] + numberPairs[i + 1]]);
        }
        return pairs;
    }
    getSuggestionKind(kind, label) {
        switch (kind) {
            case "ARGUMENT_LIST":
                return vscode_1.CompletionItemKind.Variable;
            case "IMPORT":
                return label.startsWith("dart:")
                    ? vscode_1.CompletionItemKind.Module
                    : path.extname(label.toLowerCase()) === ".dart"
                        ? vscode_1.CompletionItemKind.File
                        : vscode_1.CompletionItemKind.Folder;
            case "IDENTIFIER":
                return vscode_1.CompletionItemKind.Variable;
            case "INVOCATION":
                return vscode_1.CompletionItemKind.Method;
            case "KEYWORD":
                return vscode_1.CompletionItemKind.Keyword;
            case "NAMED_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "OPTIONAL_ARGUMENT":
                return vscode_1.CompletionItemKind.Variable;
            case "PARAMETER":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getElementKind(kind) {
        switch (kind) {
            case "CLASS":
            case "CLASS_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Class;
            case "COMPILATION_UNIT":
                return vscode_1.CompletionItemKind.Module;
            case "CONSTRUCTOR":
            case "CONSTRUCTOR_INVOCATION":
                return vscode_1.CompletionItemKind.Constructor;
            case "ENUM":
                return vscode_1.CompletionItemKind.Enum;
            case "ENUM_CONSTANT":
                return vscode_1.CompletionItemKind.EnumMember;
            case "FIELD":
                return vscode_1.CompletionItemKind.Field;
            case "FILE":
                return vscode_1.CompletionItemKind.File;
            case "FUNCTION":
            case "FUNCTION_TYPE_ALIAS":
                return vscode_1.CompletionItemKind.Function;
            case "GETTER":
                return vscode_1.CompletionItemKind.Property;
            case "LABEL":
            case "LIBRARY":
                return vscode_1.CompletionItemKind.Module;
            case "LOCAL_VARIABLE":
                return vscode_1.CompletionItemKind.Variable;
            case "METHOD":
                return vscode_1.CompletionItemKind.Method;
            case "PARAMETER":
            case "PREFIX":
                return vscode_1.CompletionItemKind.Variable;
            case "SETTER":
                return vscode_1.CompletionItemKind.Property;
            case "TOP_LEVEL_VARIABLE":
            case "TYPE_PARAMETER":
                return vscode_1.CompletionItemKind.Variable;
            case "UNIT_TEST_GROUP":
                return vscode_1.CompletionItemKind.Module;
            case "UNIT_TEST_TEST":
                return vscode_1.CompletionItemKind.Method;
            case "UNKNOWN":
                return vscode_1.CompletionItemKind.Value;
        }
        return undefined;
    }
    getCommitCharacters(kind) {
        switch (kind) {
            case "IDENTIFIER":
            case "INVOCATION":
                return [".", ",", "(", "["];
        }
        return undefined;
    }
    appendAdditionalEdits(completionItem, document, change) {
        if (!change)
            return undefined;
        // VS Code expects offsets to be based on the original document, but the analysis server provides
        // them assuming all previous edits have already been made. This means if the server provides us a
        // set of edits where any edits offset is *equal to or greater than* a previous edit, it will do the wrong thing.
        // If this happens; we will fall back to sequential edits and write a warning.
        const hasProblematicEdits = (0, edit_das_1.hasOverlappingEdits)(change);
        if (hasProblematicEdits) {
            this.logger.error("Unable to insert imports because of overlapping edits from the server.");
            vs.window.showErrorMessage(`Unable to insert imports because of overlapping edits from the server`);
            return undefined;
        }
        const filePath = (0, fs_1.fsPath)(document.uri);
        const thisFilesEdits = change.edits.filter((e) => e.file === filePath);
        const otherFilesEdits = change.edits.filter((e) => e.file !== filePath);
        if (thisFilesEdits.length) {
            completionItem.additionalTextEdits = (0, utils_1.flatMap)(thisFilesEdits, (edit) => edit.edits.map((edit) => {
                const range = new vs.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length));
                return new vs.TextEdit(range, edit.replacement);
            }));
        }
        if (otherFilesEdits.length) {
            const filteredSourceChange = {
                edits: otherFilesEdits,
                id: change.id,
                linkedEditGroups: [],
                message: change.message,
                selection: change.selection,
            };
            completionItem.command = {
                arguments: [document, filteredSourceChange],
                command: "_dart.applySourceChange",
                title: "Automatically add imports",
            };
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartCompletionItemProvider = DartCompletionItemProvider;


/***/ }),

/***/ 5453:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDiagnostic = exports.DartDiagnosticProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
// TODO: This is not a provider?
class DartDiagnosticProvider {
    constructor(analyzer, diagnostics) {
        this.analyzer = analyzer;
        this.diagnostics = diagnostics;
        this.analyzer.registerForAnalysisErrors((es) => this.handleErrors(es));
        // Fired when files are deleted
        this.analyzer.registerForAnalysisFlushResults((es) => this.flushResults(es));
    }
    handleErrors(notification) {
        const notificationJson = JSON.stringify(notification);
        // As a workaround for https://github.com/Dart-Code/Dart-Code/issues/1678, if
        // the errors we got are exactly the same as the previous set, do not give
        // them to VS Code. This avoids a potential loop of refreshing the error view
        // which triggers a request for Code Actions, which could result in analysis
        // of the file (which triggers errors to be sent, which triggers a refresh
        // of the error view... etc.!).
        if (this.lastErrorJson === notificationJson) {
            // TODO: Come up with a better fix than this!
            // log("Skipping error notification as it was the same as the previous one");
            return;
        }
        let errors = notification.errors;
        if (!config_1.config.showTodos)
            errors = errors.filter((error) => error.type !== "TODO");
        this.diagnostics.set(vscode_1.Uri.file(notification.file), errors.map((e) => DartDiagnosticProvider.createDiagnostic(e)));
        this.lastErrorJson = notificationJson;
    }
    static createDiagnostic(error) {
        const diag = new DartDiagnostic((0, utils_1.toRangeOnLine)(error.location), error.message, DartDiagnosticProvider.getSeverity(error.severity, error.type), error.type);
        diag.code = error.url ? { value: error.code, target: vscode_1.Uri.parse(error.url) } : error.code;
        diag.source = "dart";
        diag.tags = DartDiagnosticProvider.getTags(error);
        if (error.correction)
            diag.message += `\n${error.correction}`;
        if (error.contextMessages && error.contextMessages.length)
            diag.relatedInformation = error.contextMessages.map(DartDiagnosticProvider.createRelatedInformation);
        return diag;
    }
    static createRelatedInformation(related) {
        return new vscode_1.DiagnosticRelatedInformation(new vscode_1.Location(vscode_1.Uri.file(related.location.file), (0, utils_1.toRangeOnLine)(related.location)), related.message);
    }
    static getSeverity(severity, type) {
        switch (severity) {
            case "ERROR":
                return vscode_1.DiagnosticSeverity.Error;
            case "WARNING":
                return vscode_1.DiagnosticSeverity.Warning;
            case "INFO":
                switch (type) {
                    case "TODO":
                        return vscode_1.DiagnosticSeverity.Information; // https://github.com/Microsoft/vscode/issues/48376
                    default:
                        return vscode_1.DiagnosticSeverity.Information;
                }
            default:
                throw new Error(`Unknown severity type: ${severity}`);
        }
    }
    static getTags(error) {
        const tags = [];
        if (error.code === "dead_code" || error.code === "unused_local_variable" || error.code === "unused_import")
            tags.push(vscode_1.DiagnosticTag.Unnecessary);
        if (error.code === "deprecated_member_use" || error.code === "deprecated_member_use_from_same_package")
            tags.push(vscode_1.DiagnosticTag.Deprecated);
        return tags;
    }
    flushResults(notification) {
        this.lastErrorJson = undefined;
        const entries = notification.files.map((file) => [vscode_1.Uri.file(file), undefined]);
        this.diagnostics.set(entries);
    }
}
exports.DartDiagnosticProvider = DartDiagnosticProvider;
class DartDiagnostic extends vscode_1.Diagnostic {
    constructor(range, message, severity, type) {
        super(range, message, severity);
        this.type = type;
    }
}
exports.DartDiagnostic = DartDiagnostic;


/***/ }),

/***/ 6663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentSymbolProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const promises_1 = __webpack_require__(776);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
class DartDocumentSymbolProvider {
    constructor(logger, fileTracker) {
        this.logger = logger;
        this.fileTracker = fileTracker;
    }
    provideDocumentSymbols(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outline = yield (0, promises_1.waitFor)(() => this.fileTracker.getOutlineFor(document.uri), 500, 60000, token);
            if (token.isCancellationRequested || !outline || !outline.children || !outline.children.length)
                return;
            return outline.children.map((r) => this.convertResult(document, r));
        });
    }
    convertResult(document, outline) {
        const name = outline.element.name
            ? outline.element.name
            : (outline.element.kind === "EXTENSION" ? "<unnamed extension>" : "<unnamed>");
        const location = outline.element.location || outline;
        const symbol = new vscode_1.DocumentSymbol(name, this.getDetail(outline.element), (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, outline.element.kind), this.getCodeOffset(document, outline), (0, utils_1.toRange)(document, location.offset, location.length));
        // eslint-disable-next-line no-bitwise
        if (outline.element.flags & 0x20)
            symbol.tags = [vscode_1.SymbolTag.Deprecated];
        if (outline.children && outline.children.length) {
            symbol.children = outline.children.filter(this.shouldShow).map((r) => this.convertResult(document, r));
        }
        return symbol;
    }
    shouldShow(outline) {
        // Don't show these (#656).
        if (outline.element.kind === "CONSTRUCTOR_INVOCATION" || outline.element.kind === "FUNCTION_INVOCATION")
            return false;
        return true;
    }
    getDetail(element) {
        let label = "";
        if (element.parameters)
            label += element.parameters;
        if (element.returnType)
            label += " → " + element.returnType;
        return label.trim();
    }
    getCodeOffset(document, outline) {
        return (0, utils_1.toRange)(document, outline.codeOffset || outline.offset, outline.codeLength || outline.length);
    }
}
exports.DartDocumentSymbolProvider = DartDocumentSymbolProvider;


/***/ }),

/***/ 3299:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFoldingProvider = void 0;
const vscode_1 = __webpack_require__(9496);
class DartFoldingProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideFoldingRanges(document, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait for any current analysis to complete (eg. if we've just opened a project it
            // may take a while to get the results).
            yield this.analyzer.client.currentAnalysis;
            if (token && token.isCancellationRequested)
                return;
            // Wait up to another few seconds after analysis completed (it might be that we opened a new
            // file and there was no analysis, in which case we're just waiting for the server to process
            // the newly added subscription and send results).
            let foldingRegions;
            for (let i = 0; i < 5; i++) {
                foldingRegions = this.analyzer.fileTracker.getFoldingRegionsFor(document.uri);
                if (foldingRegions)
                    break;
                yield new Promise((resolve) => setTimeout(resolve, i * 1000).unref());
                if (token && token.isCancellationRequested)
                    return;
            }
            if (token.isCancellationRequested || !foldingRegions)
                return;
            return foldingRegions.map((f) => new vscode_1.FoldingRange(document.positionAt(f.offset).line, document.positionAt(f.offset + f.length).line, this.getKind(f.kind)));
        });
    }
    getKind(kind) {
        switch (kind) {
            case "FILE_HEADER":
            case "DOCUMENTATION_COMMENT":
                return vscode_1.FoldingRangeKind.Comment;
            case "DIRECTIVES":
                return vscode_1.FoldingRangeKind.Imports;
        }
    }
}
exports.DartFoldingProvider = DartFoldingProvider;


/***/ }),

/***/ 7099:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFormattingEditProvider = void 0;
const minimatch = __webpack_require__(1171);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
class DartFormattingEditProvider {
    constructor(logger, analyzer, context) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.context = context;
        this.registeredFormatters = [];
        this.formatterRegisterFuncs = [];
        vscode_1.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration("dart.enableSdkFormatter")) {
                if (config_1.config.enableSdkFormatter)
                    this.registerAllFormatters();
                else
                    this.unregisterAllFormatters();
            }
        });
    }
    registerDocumentFormatter(filter) {
        this.registerFormatter(() => vscode_1.languages.registerDocumentFormattingEditProvider(filter, this));
    }
    registerTypingFormatter(filter, firstTriggerCharacter, ...moreTriggerCharacters) {
        this.registerFormatter(() => vscode_1.languages.registerOnTypeFormattingEditProvider(filter, this, firstTriggerCharacter, ...moreTriggerCharacters));
    }
    registerFormatter(reg) {
        const registerAndTrack = () => this.registeredFormatters.push(reg());
        // Register the formatter immediately if enabled.
        if (config_1.config.enableSdkFormatter)
            registerAndTrack();
        // Add it to our list so we can re-register later..
        this.formatterRegisterFuncs.push(registerAndTrack);
    }
    registerAllFormatters() {
        for (const formatterReg of this.formatterRegisterFuncs) {
            formatterReg();
        }
    }
    unregisterAllFormatters() {
        (0, utils_1.disposeAll)(this.registeredFormatters);
    }
    provideDocumentFormattingEdits(document, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, true); // await is important for catch to work.
            }
            catch (_a) {
                if (!this.context.hasWarnedAboutFormatterSyntaxLimitation) {
                    this.context.hasWarnedAboutFormatterSyntaxLimitation = true;
                    vscode_1.window.showInformationMessage("The Dart formatter will not run if the file has syntax errors");
                }
                return undefined;
            }
        });
    }
    provideOnTypeFormattingEdits(document, position, ch, options, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.doFormat(document, false);
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    doFormat(document, doLogError = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.shouldFormat(document))
                return undefined;
            try {
                const resp = yield this.analyzer.editFormat({
                    file: (0, fs_1.fsPath)(document.uri),
                    lineLength: config_1.config.for(document.uri).lineLength,
                    selectionLength: 0,
                    selectionOffset: 0,
                });
                if (resp.edits.length === 0)
                    return undefined;
                else
                    return resp.edits.map((e) => this.convertData(document, e));
            }
            catch (e) {
                if (doLogError)
                    this.logger.error(e);
                throw e;
            }
        });
    }
    shouldFormat(document) {
        if (!document || !document.uri || document.uri.scheme !== "file")
            return false;
        const resourceConf = config_1.config.for(document.uri);
        const path = (0, fs_1.fsPath)(document.uri);
        return undefined === resourceConf.doNotFormat.find((p) => minimatch(path, p, { dot: true }));
    }
    convertData(document, edit) {
        return new vscode_1.TextEdit(new vscode_1.Range(document.positionAt(edit.offset), document.positionAt(edit.offset + edit.length)), edit.replacement);
    }
    dispose() {
        this.unregisterAllFormatters();
    }
}
exports.DartFormattingEditProvider = DartFormattingEditProvider;


/***/ }),

/***/ 9917:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDocumentHighlightProvider = void 0;
const vscode_1 = __webpack_require__(9496);
class DartDocumentHighlightProvider {
    constructor(fileTracker) {
        this.fileTracker = fileTracker;
    }
    provideDocumentHighlights(document, position, token) {
        const offset = document.offsetAt(position);
        const occurrences = this.fileTracker.getOccurrencesFor(document.uri);
        if (!occurrences)
            return;
        for (const occurrence of occurrences) {
            // If an occurence spans our position, then we don't need to look at any others.
            if (occurrence.offsets.find((o) => o <= offset && o + occurrence.length >= offset)) {
                return occurrence.offsets.map((o) => new vscode_1.DocumentHighlight(new vscode_1.Range(document.positionAt(o), document.positionAt(o + occurrence.length))));
            }
        }
    }
}
exports.DartDocumentHighlightProvider = DartDocumentHighlightProvider;


/***/ }),

/***/ 988:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartHoverProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
class DartHoverProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideHover(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetHover({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token.isCancellationRequested || resp.hovers.length === 0)
                    return;
                const hover = resp.hovers[0];
                const data = this.getHoverData(document.uri, hover);
                if (!data)
                    return;
                const range = new vscode_1.Range(document.positionAt(hover.offset), document.positionAt(hover.offset + hover.length));
                return new vscode_1.Hover([{ language: "dart", value: data.displayString }, data.documentation || undefined], range.isSingleLine ? range : undefined);
            }
            catch (e) {
                this.logger.error(e);
            }
        });
    }
    getHoverData(documentUri, hover) {
        if (!hover.elementDescription)
            return undefined;
        // Import prefix tooltips are not useful currently.
        // https://github.com/dart-lang/sdk/issues/32735
        if (hover.elementKind === "import prefix")
            return undefined;
        const elementDescription = hover.elementDescription;
        const dartdoc = hover.dartdoc;
        const propagatedType = hover.propagatedType;
        let displayString = "";
        if (elementDescription)
            displayString += (hover.isDeprecated ? "(deprecated) " : "") + `${elementDescription}\n`;
        if (propagatedType)
            displayString += `propogated type: ${propagatedType.trim()}`;
        let documentation = (0, extension_utils_1.cleanDartdoc)(dartdoc);
        const containingLibraryName = hover.containingLibraryName;
        if (containingLibraryName)
            documentation = `*${containingLibraryName}*\n\n` + documentation;
        return {
            displayString: displayString.trim(),
            documentation: documentation.trim(),
        };
    }
}
exports.DartHoverProvider = DartHoverProvider;


/***/ }),

/***/ 9715:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartImplementationProvider = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const outline_1 = __webpack_require__(7104);
class DartImplementationProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideImplementation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Try to use the Outline data to snap our location to a node.
            // For example in:
            //
            //     void b();
            //
            // The search.getTypeHierarchy call will only work over "b" but by using outline we
            // can support the whole "void b();".
            const outlineNode = (0, outline_1.findNearestOutlineNode)(this.analyzer.fileTracker, document, position, true);
            const offset = outlineNode && outlineNode.element && outlineNode.element.location
                ? outlineNode.element.location.offset
                : document.offsetAt(position);
            const hierarchy = yield this.analyzer.client.searchGetTypeHierarchy({
                file: (0, fs_1.fsPath)(document.uri),
                offset,
            });
            if (token.isCancellationRequested || !hierarchy || !hierarchy.hierarchyItems || !hierarchy.hierarchyItems.length || hierarchy.hierarchyItems.length === 1)
                return;
            // Find the element we started with, since we only want implementations (not super classes).
            const currentItem = hierarchy.hierarchyItems.find((h) => {
                const elm = h.memberElement || h.classElement;
                return elm.location && elm.location.offset <= offset && elm.location.offset + elm.location.length >= offset;
            })
                // If we didn't find the element when we might have been at a call site, so we'll have to start
                // at the root.
                || hierarchy.hierarchyItems[0];
            const isClass = !currentItem.memberElement;
            function getDescendants(item) {
                return [
                    ...item.subclasses.map((i) => hierarchy.hierarchyItems[i]),
                    ...(0, utils_1.flatMap)(item.subclasses, (i) => getDescendants(hierarchy.hierarchyItems[i])),
                ];
            }
            const descendants = getDescendants(currentItem)
                .map((d) => isClass ? d.classElement : d.memberElement)
                .filter(utils_1.notUndefined);
            const locations = [];
            for (const element of descendants) {
                if (!element.location)
                    continue;
                const range = (0, utils_2.toRange)(yield vs.workspace.openTextDocument(element.location.file), element.location.offset, element.location.length);
                locations.push(new vs.Location(vs.Uri.file(element.location.file), range));
            }
            return locations;
        });
    }
}
exports.DartImplementationProvider = DartImplementationProvider;


/***/ }),

/***/ 1122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartLanguageConfiguration = void 0;
const vscode_1 = __webpack_require__(9496);
const config_1 = __webpack_require__(4165);
class DartLanguageConfiguration {
    constructor() {
        this.doubleSlashRules = [
            {
                // Double-slash with space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
                beforeText: /^\s*\/\/ /,
            },
            {
                // Double-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                beforeText: /^\s*\/\//,
            },
        ];
        // When double-slash is disabled, we still want to be able to add newlines
        // in existing comments and have them include the comment markers.
        this.betweenDoubleSlashRules = [
            {
                // Double-slash with space when there's already an existing space after
                // so we don't need to insert one.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                afterText: / .*$/,
                beforeText: /^\s*\/\//,
            },
            {
                // Double-slash with space when there's not already an existing space after.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "// " },
                afterText: /[^ ]+$/,
                beforeText: /^\s*\/\/ /,
            },
            {
                // Double-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "//" },
                afterText: /.+$/,
                beforeText: /^\s*\/\//,
            },
        ];
        this.tripleSlashRules = [
            {
                // Triple-slash with space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "/// " },
                beforeText: /^\s*\/\/\/ /,
            },
            {
                // Triple-slash without space.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "///" },
                beforeText: /^\s*\/\/\//,
            },
        ];
        this.slashStarRules = [
            {
                // When between "/** | */" this puts a " * " in but also pushes the "*/" down to next line.
                action: { indentAction: vscode_1.IndentAction.IndentOutdent, appendText: " * " },
                afterText: /^\s*\*\/$/,
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // When after "/**" will put a " * " in (like above, but where there's no "*/" to push down).
                action: { indentAction: vscode_1.IndentAction.None, appendText: " * " },
                beforeText: /^\s*\/\*\*(?!\/)([^\*]|\*(?!\/))*$/,
            },
            {
                // Continue " * " when on a line already start with this.
                action: { indentAction: vscode_1.IndentAction.None, appendText: "* " },
                beforeText: /^(\t|(\ \ ))*\ \*(\ ([^\*]|\*(?!\/))*)?$/,
            },
            {
                // After "*/" we need to remove the indent.
                action: { indentAction: vscode_1.IndentAction.None, removeText: 1 },
                beforeText: /^(\t|(\ \ ))*\ \*\/\s*$/,
            },
        ];
        this.tripleQuoteRules = [
            {
                // Remove all indent after starting a multiline string.
                action: { indentAction: vscode_1.IndentAction.None, removeText: 80 },
                beforeText: /('''|""")$/,
            },
        ];
    }
    get onEnterRules() {
        let rules = [];
        if (config_1.config.automaticCommentSlashes !== "none")
            rules = rules.concat(this.tripleSlashRules);
        if (config_1.config.automaticCommentSlashes === "all")
            rules = rules.concat(this.doubleSlashRules);
        else
            rules = rules.concat(this.betweenDoubleSlashRules);
        rules = rules.concat(this.slashStarRules);
        rules = rules.concat(this.tripleQuoteRules);
        return rules;
    }
}
exports.DartLanguageConfiguration = DartLanguageConfiguration;


/***/ }),

/***/ 8517:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartReferenceProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
class DartReferenceProvider {
    constructor(analyzer, fileTracker) {
        this.analyzer = analyzer;
        this.fileTracker = fileTracker;
    }
    provideReferences(document, position, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we want to include the decleration, kick off a request for that.
            const definitions = context.includeDeclaration
                ? yield this.provideDefinition(document, position, token)
                : undefined;
            const resp = yield this.analyzer.searchFindElementReferencesResults({
                file: (0, fs_1.fsPath)(document.uri),
                includePotential: true,
                offset: document.offsetAt(position),
            });
            if (token && token.isCancellationRequested)
                return;
            const locations = resp.results.map((result) => new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_2.toRangeOnLine)(result.location)));
            return definitions
                ? locations.concat(definitions.map((dl) => new vscode_1.Location(dl.targetUri, dl.targetRange)))
                : locations;
        });
    }
    provideDefinition(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            let resp1 = this.fileTracker.getNavigationTargets((0, fs_1.fsPath)(document.uri), document.offsetAt(position));
            if (!resp1) {
                resp1 = yield this.analyzer.analysisGetNavigation({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: 0,
                    offset: document.offsetAt(position),
                });
            }
            if (!resp1)
                return undefined;
            const resp = resp1;
            if (token && token.isCancellationRequested)
                return;
            const definitions = (0, utils_1.flatMap)(resp.regions, (region) => region.targets.map((targetIndex) => {
                const target = resp.targets[targetIndex];
                // HACK: We sometimes get a startColumn of 0 (should be 1-based). Just treat this as 1 for now.
                //     See https://github.com/Dart-Code/Dart-Code/issues/200
                if (target.startColumn === 0)
                    target.startColumn = 1;
                return {
                    originSelectionRange: (0, utils_2.toRange)(document, region.offset, region.length),
                    targetRange: (0, utils_2.toRangeOnLine)(target),
                    targetUri: vscode_1.Uri.file(resp.files[target.fileIndex]),
                };
            }));
            // For some locations (for example on the "var" keyword ), we'll get multiple results
            // where some of them are the location we invoked at, or the name of the variable. If
            // there are any results that are on a different line/different file to where we were
            // invoked, return only those. If the only results are on the same line of the same
            // file then just return them all.
            const definitionsOnOtherLines = definitions
                .filter((d) => (0, fs_1.fsPath)(d.targetUri) !== (0, fs_1.fsPath)(document.uri)
                || d.targetRange.start.line !== position.line);
            return definitionsOnOtherLines.length ? definitionsOnOtherLines : definitions;
        });
    }
}
exports.DartReferenceProvider = DartReferenceProvider;


/***/ }),

/***/ 6252:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartRenameProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const channels = __webpack_require__(1026);
class DartRenameProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideRenameEdits(document, position, newName, token) {
        return this.doRename(document, position, newName, token);
    }
    prepareRename(document, position, token) {
        return this.getLocation(document, position, token);
    }
    doRename(document, position, newName, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const outputChannel = channels.getOutputChannel("Refactorings");
            outputChannel.appendLine("");
            const resp = yield this.analyzer.editGetRefactoring({
                file: (0, fs_1.fsPath)(document.uri),
                kind: "RENAME",
                length: 1,
                offset: document.offsetAt(position),
                options: {
                    newName,
                },
                validateOnly: false,
            });
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            const workspaceEdit = new vscode_1.WorkspaceEdit();
            if (resp.change && resp.change.message)
                outputChannel.appendLine(`[INFO] ${resp.change.message}…`);
            this.handleProblem(resp.initialProblems
                .concat(resp.optionsProblems)
                .concat(resp.finalProblems), outputChannel);
            const promises = [];
            if (resp.change) {
                resp.change.edits.forEach((changeEdit) => {
                    changeEdit.edits.forEach((fileEdit) => {
                        const uri = vscode_1.Uri.file(changeEdit.file);
                        const promise = vscode_1.workspace.openTextDocument(uri);
                        promises.push(promise.then((document) => workspaceEdit.replace(uri, new vscode_1.Range(document.positionAt(fileEdit.offset), document.positionAt(fileEdit.offset + fileEdit.length)), fileEdit.replacement)));
                    });
                });
            }
            // TODO: This class is inconsistent with other refactors (which are silent when they work, for ex).
            // We should review what we can extract share (though note that this method must return the edit whereas
            // the other refactors apply them).
            // Wait all openTextDocument to finish
            yield Promise.all(promises);
            if (token && token.isCancellationRequested) {
                outputChannel.appendLine("[INFO] Rename cancelled.");
                return;
            }
            outputChannel.appendLine("[INFO] Rename successful.");
            return workspaceEdit;
        });
    }
    handleProblem(problems, outputChannel) {
        // Log all in output channel.
        problems.forEach((problem) => outputChannel.appendLine(`[${problem.severity}] ${problem.message}`));
        const errors = problems
            .filter((p) => p.severity !== "INFO" && p.severity !== "WARNING")
            .sort((p1, p2) => p2.severity.localeCompare(p1.severity));
        if (errors.length !== 0) {
            outputChannel.appendLine("[INFO] Rename aborted.");
            throw errors[0].message;
        }
    }
    getLocation(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const resp = yield this.analyzer.editGetRefactoring({
                file: (0, fs_1.fsPath)(document.uri),
                kind: "RENAME",
                length: 0,
                offset: document.offsetAt(position),
                validateOnly: true,
            });
            if (token && token.isCancellationRequested)
                return;
            if (!resp.feedback)
                throw new Error("You cannot rename this element.");
            const feedback = resp.feedback;
            // The dart server returns -1 when the old name doesn't exist (for ex. renaming an unprefixed import to add a prefix)
            // so we use a zero-character range at the requested position in this case.
            const range = feedback.offset === -1
                ? new vscode_1.Range(position, position)
                : (0, utils_1.toRange)(document, feedback.offset, feedback.length);
            if (feedback) {
                return {
                    placeholder: feedback.oldName,
                    range,
                };
            }
            else {
                const fatalProblems = resp.initialProblems
                    .concat(resp.optionsProblems)
                    .concat(resp.finalProblems)
                    .filter((p) => p.severity === "FATAL");
                if (fatalProblems && fatalProblems.length) {
                    throw new Error(fatalProblems[0].message);
                }
                else {
                    throw new Error("This rename is not supported.");
                }
            }
        });
    }
}
exports.DartRenameProvider = DartRenameProvider;


/***/ }),

/***/ 4258:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartSignatureHelpProvider = void 0;
const vs = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
class DartSignatureHelpProvider {
    constructor(analyzer) {
        this.analyzer = analyzer;
    }
    provideSignatureHelp(document, position, token) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const resp = yield this.analyzer.analysisGetSignature({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(position),
                });
                if (token && token.isCancellationRequested)
                    return undefined;
                const sig = new vs.SignatureInformation(this.getSignatureLabel(resp), (0, extension_utils_1.createMarkdownString)((0, extension_utils_1.cleanDartdoc)(resp.dartdoc)));
                sig.parameters = resp.parameters.map((p) => new vs.ParameterInformation(this.getLabel(p)));
                const sigs = new vs.SignatureHelp();
                sigs.signatures = [sig];
                sigs.activeSignature = 0;
                // TODO: This isn't implemented in the server yet.
                sigs.activeParameter = -1; // resp.selectedParameterIndex;
                return sigs;
            }
            catch (_a) {
                return undefined;
            }
        });
    }
    getSignatureLabel(resp) {
        const req = resp.parameters.filter((p) => p.kind === "REQUIRED" || p.kind === "REQUIRED_POSITIONAL");
        const opt = resp.parameters.filter((p) => p.kind === "OPTIONAL" || p.kind === "OPTIONAL_POSITIONAL");
        const named = resp.parameters.filter((p) => p.kind === "NAMED" || p.kind === "OPTIONAL_NAMED" || p.kind === "REQUIRED_NAMED");
        const params = [];
        if (req.length)
            params.push(req.map(this.getLabel).join(", "));
        if (opt.length)
            params.push("[" + opt.map(this.getLabel).join(", ") + "]");
        if (named.length)
            params.push("{" + named.map(this.getLabel).join(", ") + "}");
        return `${resp.name}(${params.join(", ")})`;
    }
    getLabel(p) {
        const def = p.defaultValue
            ? ` = ${p.defaultValue}`
            : "";
        const prefix = p.kind === "REQUIRED_NAMED" ? "required " : "";
        return `${prefix}${p.type} ${p.name}${def}`;
    }
}
exports.DartSignatureHelpProvider = DartSignatureHelpProvider;


/***/ }),

/***/ 5188:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartWorkspaceSymbolProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
class DartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
        this.badChars = new RegExp("[^0-9a-z\-]", "gi");
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            // Turn query into a case-insensitive fuzzy search.
            const pattern = ".*" + query.replace(this.badChars, "").split("").map((c) => `[${c.toUpperCase()}${c.toLowerCase()}]`).join(".*") + ".*";
            const results = yield this.analyzer.searchGetElementDeclarations({ pattern, maxResults: 500 });
            if (token && token.isCancellationRequested)
                return;
            return results.declarations.map((d) => this.convertWorkspaceResult(d, results.files[d.fileIndex]));
        });
    }
    resolveWorkspaceSymbol(symbol, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(symbol instanceof PartialSymbolInformation))
                return undefined;
            const document = yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(symbol.locationData.file));
            symbol.location = new vscode_1.Location(document.uri, (0, utils_1.toRange)(document, symbol.locationData.offset, symbol.locationData.length));
            return symbol;
        });
    }
    convertWorkspaceResult(result, file) {
        const nameSuffix = result.parameters ? (result.parameters === "()" ? "()" : "(…)") : "";
        const symbol = new PartialSymbolInformation(result.name + nameSuffix, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.kind), result.className || "", 
        // HACK: Work around the incorrect typing in VS Code with !
        // https://github.com/microsoft/vscode/issues/69558
        new vscode_1.Location(vscode_1.Uri.file(file), undefined), {
            file,
            length: result.codeLength,
            // Fall back to offset when the server gives us a bad codeOffset
            // https://github.com/dart-lang/sdk/issues/39192.
            offset: result.codeOffset || result.offset,
        });
        return symbol;
    }
}
exports.DartWorkspaceSymbolProvider = DartWorkspaceSymbolProvider;
class PartialSymbolInformation extends vscode_1.SymbolInformation {
    constructor(name, kind, containerName, location, locationData) {
        super(name, kind, containerName, location);
        this.locationData = locationData;
    }
}


/***/ }),

/***/ 8109:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterDescriptorFactory = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const debug_1 = __webpack_require__(2335);
const config_1 = __webpack_require__(4165);
const processes_1 = __webpack_require__(5430);
class DartDebugAdapterDescriptorFactory {
    constructor(analytics, sdks, logger, extensionContext, dartCapabilities, flutterCapabilities, workspaceContext, experiments) {
        this.analytics = analytics;
        this.sdks = sdks;
        this.logger = logger;
        this.extensionContext = extensionContext;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.workspaceContext = workspaceContext;
        this.experiments = experiments;
    }
    createDebugAdapterDescriptor(session, executable) {
        return this.descriptorForType(session.configuration.debuggerType, !!session.configuration.noDebug);
    }
    descriptorForType(debuggerType, noDebug) {
        var _a, _b;
        const debuggerName = (0, debug_1.getDebugAdapterName)(debuggerType);
        this.logger.info(`Using ${debuggerName} debugger for ${enums_1.DebuggerType[debuggerType]}`);
        const isDartOrDartTest = debuggerType === enums_1.DebuggerType.Dart || debuggerType === enums_1.DebuggerType.DartTest;
        const isFlutterOrFlutterTest = debuggerType === enums_1.DebuggerType.Flutter || debuggerType === enums_1.DebuggerType.FlutterTest;
        const isDartTestOrFlutterTest = debuggerType === enums_1.DebuggerType.DartTest || debuggerType === enums_1.DebuggerType.FlutterTest;
        const isDartTest = debuggerType === enums_1.DebuggerType.DartTest;
        const isFlutterTest = debuggerType === enums_1.DebuggerType.FlutterTest;
        let isSdkDapSupported = false;
        let canDefaultToSdkDap = false;
        let isPreReleaseSdk = false;
        if (isDartOrDartTest) {
            isSdkDapSupported = this.dartCapabilities.supportsSdkDap;
            canDefaultToSdkDap = this.dartCapabilities.canDefaultSdkDaps;
            isPreReleaseSdk = this.dartCapabilities.version.includes("-");
        }
        else if (isFlutterOrFlutterTest) {
            isSdkDapSupported = this.flutterCapabilities.supportsSdkDap;
            canDefaultToSdkDap = this.flutterCapabilities.canDefaultSdkDaps;
            isPreReleaseSdk = this.flutterCapabilities.version.includes("-");
        }
        const forceSdkDap = process.env.DART_CODE_FORCE_SDK_DAP === "true"
            ? true
            : process.env.DART_CODE_FORCE_SDK_DAP === "false"
                ? false
                : undefined;
        let useSdkDap;
        let sdkDapReason;
        if (forceSdkDap !== undefined) {
            useSdkDap = forceSdkDap;
            sdkDapReason = "DART_CODE_FORCE_SDK_DAP env variable";
        }
        else {
            if (!isSdkDapSupported) {
                useSdkDap = false;
                sdkDapReason = "not supported for SDK";
            }
            else if (this.workspaceContext.config.forceFlutterWorkspace) {
                useSdkDap = true;
                sdkDapReason = "workspaceContext.config.forceFlutterWorkspace";
            }
            else if (config_1.config.previewSdkDaps !== undefined) {
                useSdkDap = config_1.config.previewSdkDaps;
                sdkDapReason = "config.previewSdkDaps";
            }
            else if (canDefaultToSdkDap && isPreReleaseSdk) {
                useSdkDap = true;
                sdkDapReason = "canDefaultToSdkDap and using pre-release SDK";
            }
            else {
                useSdkDap = this.experiments.sdkDaps.applies;
                sdkDapReason = "sdkDaps experiment";
                if (useSdkDap && !canDefaultToSdkDap) {
                    useSdkDap = false;
                    sdkDapReason = "sdkDaps experiment overriden by canDefaultSdkDaps";
                }
            }
        }
        this.logger.info(`SDK DAP setting is ${useSdkDap}, set by ${sdkDapReason}`);
        const analytics = this.analytics;
        function logDebuggerStart(sdkDap) {
            analytics.logDebuggerStart(enums_1.DebuggerType[debuggerType], noDebug ? "Run" : "Debug", sdkDap);
        }
        const executableOptions = {
            env: (0, processes_1.getToolEnv)(),
        };
        if (config_1.config.customDartDapPath && isDartOrDartTest) {
            const args = [config_1.config.customDartDapPath, "debug_adapter"];
            if (isDartTest)
                args.push("--test");
            this.logger.info(`Running custom Dart debugger using Dart VM with args ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args, executableOptions);
        }
        else if (config_1.config.customFlutterDapPath && isFlutterOrFlutterTest) {
            const args = [config_1.config.customFlutterDapPath, "debug_adapter"];
            if (isFlutterTest)
                args.push("--test");
            if (isFlutterTest && this.flutterCapabilities.requiresDdsDisabledForSdkDapTestRuns)
                args.push("--no-dds");
            this.logger.info(`Running custom Flutter debugger using Dart VM with args ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            return new vscode_1.DebugAdapterExecutable(path.join(this.sdks.dart, constants_1.dartVMPath), args, executableOptions);
        }
        else if (useSdkDap) {
            const executable = isDartOrDartTest
                ? path.join(this.sdks.dart, constants_1.dartVMPath)
                : (_b = (_a = this.workspaceContext.config.flutterToolsScript) === null || _a === void 0 ? void 0 : _a.script) !== null && _b !== void 0 ? _b : (this.sdks.flutter ? path.join(this.sdks.flutter, constants_1.flutterPath) : constants_1.executableNames.flutter);
            const args = ["debug_adapter"];
            if (isDartTestOrFlutterTest)
                args.push("--test");
            if (isFlutterTest && this.flutterCapabilities.requiresDdsDisabledForSdkDapTestRuns)
                args.push("--no-dds");
            if (this.workspaceContext.config.flutterSdkHome)
                executableOptions.cwd = this.workspaceContext.config.flutterSdkHome;
            this.logger.info(`Running SDK DAP Dart VM in ${executableOptions.cwd}: ${executable} ${args.join("    ")} and options ${JSON.stringify(executableOptions)}`);
            logDebuggerStart(true);
            return new vscode_1.DebugAdapterExecutable(executable, args, executableOptions);
        }
        if (process.env.DART_CODE_USE_DEBUG_SERVERS) {
            const port = (0, debug_1.getDebugAdapterPort)(debuggerName);
            this.logger.info(`Running debugger in server mode on port ${port} because DART_CODE_USE_DEBUG_SERVERS is set`);
            return new vscode_1.DebugAdapterServer(port);
        }
        const args = [this.extensionContext.asAbsolutePath(constants_1.debugAdapterPath), debuggerName];
        this.logger.info(`Running debugger via node with ${args.join("    ")}`);
        logDebuggerStart(false);
        return new vscode_1.DebugAdapterExecutable("node", args);
    }
}
exports.DartDebugAdapterDescriptorFactory = DartDebugAdapterDescriptorFactory;


/***/ }),

/***/ 4319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartDebugAdapterLoggerFactory = void 0;
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
class DartDebugAdapterLoggerFactory {
    constructor(logger) {
        this.logger = new logging_1.CategoryLogger(logger, enums_1.LogCategory.DAP);
    }
    createDebugAdapterTracker(session) {
        return new DartDebugAdapterLogger(this.logger, session);
    }
}
exports.DartDebugAdapterLoggerFactory = DartDebugAdapterLoggerFactory;
class DartDebugAdapterLogger {
    constructor(logger, session) {
        this.logger = logger;
        this.session = session;
    }
    onWillStartSession() {
        this.logger.info(`Starting debug session ${this.session.id}`);
    }
    onWillReceiveMessage(message) {
        this.logger.info(`<== ${JSON.stringify(message)}`);
    }
    onDidSendMessage(message) {
        this.logger.info(`==> ${JSON.stringify(message)}`);
    }
    onWillStopSession() {
        this.logger.info(`Stopping debug session ${this.session.id}`);
    }
    onError(error) {
        // We log this as info, as this isn't the place to handle errors and it seems to fire
        // whenever a debug session stops because the process stream goes away.
        this.logger.info(`Debug session ${this.session.id} errored: ${JSON.stringify(error)}`);
    }
    onExit(code, signal) {
        this.logger.info(`Debug session ${this.session.id} exit: code: ${code}, signal: ${signal}`);
    }
}


/***/ }),

/***/ 233:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynamicDebugConfigProvider = exports.InitialLaunchJsonDebugConfigProvider = exports.DebugConfigProvider = void 0;
/* eslint-disable @typescript-eslint/tslint/config */
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(5820);
const version_1 = __webpack_require__(1883);
const utils_2 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_3 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const logging_1 = __webpack_require__(9475);
const config_1 = __webpack_require__(4165);
const editors_1 = __webpack_require__(8805);
const project_1 = __webpack_require__(3886);
const webdev_1 = __webpack_require__(708);
const utils_4 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
class DebugConfigProvider {
    constructor(logger, wsContext, analytics, pubGlobal, testModel, daemon, deviceManager, debugCommands, dartCapabilities, flutterCapabilities) {
        this.logger = logger;
        this.wsContext = wsContext;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.testModel = testModel;
        this.daemon = daemon;
        this.deviceManager = deviceManager;
        this.debugCommands = debugCommands;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.cachedTestCapabilities = {};
    }
    resolveDebugConfiguration(folder, debugConfig, token) {
        (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
        debugConfig.type = debugConfig.type || "dart";
        debugConfig.request = debugConfig.request || "launch";
        return debugConfig;
    }
    warnOnUnresolvedVariables(property, input) {
        if (!input)
            return false;
        const v = this.getUnresolvedVariable(input);
        if (v) {
            this.logger.error(`Launch config property '${property}' has unresolvable variable ${v}`);
            vscode_1.window.showErrorMessage(`Launch config property '${property}' has unresolvable variable ${v}`);
            return true;
        }
        return false;
    }
    /** Gets the first unresolved variable from the given string. */
    getUnresolvedVariable(input) {
        if (!input)
            return undefined;
        const matches = /\${\w+}/.exec(input);
        return matches ? matches[0] : undefined;
    }
    resolveDebugConfigurationWithSubstitutedVariables(folder, debugConfig, token) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (0, utils_4.ensureDebugLaunchUniqueId)(debugConfig);
            const isAttachRequest = debugConfig.request === "attach";
            const logger = this.logger;
            const editor = (0, editors_1.getActiveRealFileEditor)();
            const openFile = editor
                ? (0, fs_1.fsPath)(editor.document.uri)
                : undefined;
            logger.info(`Starting debug session...`);
            if (folder)
                logger.info(`    workspace: ${(0, fs_1.fsPath)(folder.uri)}`);
            if (debugConfig.program)
                logger.info(`    program  : ${debugConfig.program}`);
            if (debugConfig.cwd)
                logger.info(`    cwd      : ${debugConfig.cwd}`);
            if (this.warnOnUnresolvedVariables("program", debugConfig.program) || this.warnOnUnresolvedVariables("cwd", debugConfig.cwd)) {
                // Warning is shown from inside warnOnUnresolvedVariables.
                return null; // null means open launch.json.
            }
            this.configureProgramAndCwd(debugConfig, folder, openFile);
            // If we still don't have an entry point, the user will have to provide it.
            if (!isAttachRequest && !debugConfig.program) {
                this.logger.warn("No program was set in launch config");
                const exampleEntryPoint = this.wsContext.hasAnyFlutterProjects ? "lib/main.dart" : "bin/main.dart";
                vscode_1.window.showInformationMessage(`Set the 'program' value in your launch config (eg '${exampleEntryPoint}') then launch again`);
                return null; // null means open launch.json.
            }
            const debugType = this.selectDebuggerType(debugConfig, logger);
            const isFlutter = debugType === enums_1.DebuggerType.Flutter || debugType === enums_1.DebuggerType.FlutterTest;
            const isTest = (0, utils_4.isTestFileOrFolder)(debugConfig.program);
            const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
            const argsHaveTestNameFilter = (0, utils_4.hasTestNameFilter)(debugConfig.toolArgs, debugConfig.args);
            // Handle detecting a Flutter app, but the extension has loaded in Dart-only mode.
            if (isFlutter && !this.wsContext.hasAnyFlutterProjects) {
                this.logger.warn("Tried to launch Flutter project in non-Flutter workspace");
                vscode_1.window.showErrorMessage(`Unable to launch Flutter project in a Dart-only workspace. Please open a folder closer to your Flutter project root or increase the value of the "dart.projectSearchDepth" setting.`);
                return undefined; // undefined means abort
            }
            // Handle test_driver tests that can be pointed at an existing running instrumented app.
            if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "test_driver") && !((_a = debugConfig.env) === null || _a === void 0 ? void 0 : _a.VM_SERVICE_URL)) {
                const runningInstrumentedApps = debug_1.debugSessions.filter((s) => s.loadedServiceExtensions.indexOf(enums_1.VmServiceExtension.Driver) !== -1);
                if (runningInstrumentedApps.length === 0) {
                    return this.errorWithoutOpeningLaunchConfig("Could not find a running Flutter app that was instrumented with enableFlutterDriverExtension. Run your instrumented app before running driver tests.");
                }
                else if (runningInstrumentedApps.length > 1) {
                    return this.errorWithoutOpeningLaunchConfig("More than one Flutter app instrumented with enableFlutterDriverExtension is running. Please run only one app before running driver tests.");
                }
                else {
                    const app = runningInstrumentedApps[0];
                    // This shouldn't really be possible as we wouldn't find an instrumented app without having its VM Service connection.
                    if (!app.vmServiceUri)
                        return this.errorWithoutOpeningLaunchConfig("The Flutter app instrumented with enableFlutterDriverExtension is not fully initialised yet.");
                    // Restart the app for clean state before the test run.
                    yield app.session.customRequest("hotRestart");
                    debugConfig.env = debugConfig.env || {};
                    debugConfig.env.VM_SERVICE_URL = app.vmServiceUri;
                }
            }
            if (debugType === enums_1.DebuggerType.WebTest) {
                // TODO: IMPORTANT! When removing this if statement, add WebTest to
                // the call to TestResultsProvider.flagSuiteStart below!
                logger.error("Tests in web projects are not currently supported");
                vscode_1.window.showErrorMessage("Tests in web projects are not currently supported");
                return undefined; // undefined means silent (don't open launch.json).
            }
            if (debugType === enums_1.DebuggerType.FlutterTest && (0, utils_4.isTestFolder)(debugConfig.program) && !debugConfig.noDebug) {
                // When running `flutter test (folder)`, multiple debug sessions are created - one for each file. This is
                // different to how `pub run test (folder)` works (one debug session, which each file in an isolate). The
                // debugger does not currently support multiple VM service sessions so we have to downgrade this to noDebug.
                logger.warn("Setting noDebug=true for Flutter test run because it's a folder");
                debugConfig.noDebug = true;
            }
            // If we're attaching to Dart, ensure we get a VM service URI.
            if (isAttachRequest && !debugConfig.vmServiceInfoFile) {
                // For attaching, the VM service address must be specified. If it's not provided already, prompt for it.
                if (!isFlutter) { // TEMP Condition because there's no point asking yet as the user doesn't know how to get this..
                    debugConfig.vmServiceUri = yield this.getFullVmServiceUri(debugConfig.vmServiceUri || debugConfig.observatoryUri);
                }
                if (!debugConfig.vmServiceUri && !isFlutter) {
                    logger.warn("No VM service URI/port was provided");
                    vscode_1.window.showInformationMessage("You must provide a VM service URI/port to attach a debugger");
                    return undefined; // undefined means silent (don't open launch.json).
                }
            }
            if (token && token.isCancellationRequested)
                return;
            // Ensure we have a device if required.
            let deviceToLaunchOn = ((_b = this.deviceManager) === null || _b === void 0 ? void 0 : _b.getDevice(debugConfig.deviceId)) || ((_c = this.deviceManager) === null || _c === void 0 ? void 0 : _c.currentDevice);
            const requiresDevice = (debugType === enums_1.DebuggerType.Flutter && !isAttachRequest)
                || (enums_1.DebuggerType.FlutterTest && isIntegrationTest && this.flutterCapabilities.supportsRunningIntegrationTests);
            if (requiresDevice) {
                if (this.deviceManager && this.daemon && debugConfig.deviceId !== "flutter-tester") {
                    let supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                        ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                        : undefined;
                    if (!debugConfig.suppressPrompts) {
                        // If the current device is not valid, prompt the user.
                        if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn))
                            deviceToLaunchOn = yield this.deviceManager.showDevicePicker(supportedPlatforms);
                        // Refresh the supported platforms, as the we may have enabled new platforms during
                        // the call to showDevicePicker.
                        supportedPlatforms = this.daemon.capabilities.providesPlatformTypes && debugConfig.cwd
                            ? (yield this.daemon.getSupportedPlatforms(debugConfig.cwd)).platforms
                            : undefined;
                    }
                    // If we still don't have a valid device, show an error.
                    if (!this.deviceManager.isSupported(supportedPlatforms, deviceToLaunchOn)) {
                        if (!debugConfig.suppressPrompts) {
                            if (deviceToLaunchOn) {
                                logger.warn(`Unable to launch because ${deviceToLaunchOn.id} is not valid for this project (${deviceToLaunchOn.platformType} is not allowed according to [${supportedPlatforms === null || supportedPlatforms === void 0 ? void 0 : supportedPlatforms.join(", ")}])`);
                                vscode_1.window.showInformationMessage("Cannot launch without a valid device for this project");
                            }
                            else {
                                logger.warn("Unable to launch due to no active device");
                                vscode_1.window.showInformationMessage("Cannot launch without an active device");
                            }
                        }
                        return undefined; // undefined means silent (don't open launch.json).
                    }
                }
            }
            if (token && token.isCancellationRequested)
                return;
            // Ensure we have any require dependencies.
            if (!(yield this.installDependencies(debugType, this.pubGlobal))) {
                return undefined;
            }
            if (token && token.isCancellationRequested)
                return;
            // TODO: This cast feels nasty?
            yield this.setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttachRequest, isTest, deviceToLaunchOn, this.deviceManager);
            // Debugger always uses uppercase drive letters to ensure our paths have them regardless of where they came from.
            debugConfig.program = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.program);
            debugConfig.cwd = (0, fs_1.forceWindowsDriveLetterToUppercase)(debugConfig.cwd);
            // If we're launching (not attaching) then check there are no errors before we launch.
            if (!isAttachRequest && debugConfig.cwd && config_1.config.promptToRunIfErrors && !debugConfig.suppressPrompts) {
                if (yield this.checkIfProjectHasErrors(debugConfig))
                    return undefined; // undefined means silent (don't open launch.json).
            }
            if (token && token.isCancellationRequested)
                return;
            const didWarnAboutCwd = debugConfig.cwd && path.isAbsolute(debugConfig.cwd)
                ? (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.cwd, "the launch script working directory", "check the 'cwd' field in your launch configuration file (.vscode/launch.json)")
                : false;
            if (!didWarnAboutCwd && debugConfig.program && path.isAbsolute(debugConfig.program))
                (0, utils_3.warnIfPathCaseMismatch)(logger, debugConfig.program, "the launch script", "check the 'program' field in your launch configuration file (.vscode/launch.json)");
            if (debugType === enums_1.DebuggerType.FlutterTest /* || debugType === DebuggerType.WebTest */ || debugType === enums_1.DebuggerType.DartTest) {
                const suitePaths = (0, utils_4.isTestFolder)(debugConfig.program)
                    ? Object.values(this.testModel.suites)
                        .map((suite) => suite.path)
                        .filter((p) => p.startsWith(debugConfig.program))
                    : [debugConfig.program];
                for (const suitePath of suitePaths)
                    this.testModel.flagSuiteStart(suitePath, !argsHaveTestNameFilter);
            }
            debugConfig.debuggerType = debugType;
            logger.info(`Debug session starting...\n    ${JSON.stringify(debugConfig, undefined, 4).replace(/\n/g, "\n    ")}`);
            // Stash the config to support the "rerun last debug session" command.
            debug_1.LastDebugSession.workspaceFolder = folder;
            debug_1.LastDebugSession.debugConfig = Object.assign({}, debugConfig);
            vs.commands.executeCommand("setContext", constants_1.HAS_LAST_DEBUG_CONFIG, true);
            // Stash the config to support the "rerun last test(s)" command.
            if (isTest) {
                debug_1.LastTestDebugSession.workspaceFolder = folder;
                debug_1.LastTestDebugSession.debugConfig = Object.assign({}, debugConfig);
                vs.commands.executeCommand("setContext", constants_1.HAS_LAST_TEST_DEBUG_CONFIG, true);
            }
            return debugConfig;
        });
    }
    checkIfProjectHasErrors(debugConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger;
            logger.info("Checking for errors before launching");
            const isDartError = (d) => d.source === "dart" && d.severity === vs.DiagnosticSeverity.Error;
            const dartErrors = vs.languages
                .getDiagnostics()
                .filter((file) => file[1].find(isDartError));
            // Check if any are inside our CWD.
            const firstRelevantDiagnostic = dartErrors.find((fd) => {
                const file = (0, fs_1.fsPath)(fd[0]);
                return (0, fs_1.isWithinPath)(file, debugConfig.cwd)
                    // Ignore errors in test folder unless it's the file we're running.
                    && ((!(0, utils_4.isInsideFolderNamed)(file, "test") && !(0, utils_4.isInsideFolderNamed)(file, "integration_test")) || file === debugConfig.program);
            });
            if (firstRelevantDiagnostic) {
                logger.warn("Project has errors, prompting user");
                const firstRelevantError = firstRelevantDiagnostic[1].find(isDartError);
                const range = firstRelevantError.range;
                logger.warn(`    ${(0, fs_1.fsPath)(firstRelevantDiagnostic[0])}:${range.start.line}:${range.start.character}`);
                logger.warn(`    ${firstRelevantError.message.split("\n")[0].trim()}`);
                const action = yield vscode_1.window.showErrorMessage("Build errors exist in your project.", { modal: true }, constants_1.debugAnywayAction, constants_1.showErrorsAction);
                if (action === constants_1.debugAnywayAction) {
                    logger.info("Debugging anyway!");
                    // Do nothing, we'll just carry on.
                }
                else {
                    logger.info("Aborting!");
                    if (action === constants_1.showErrorsAction)
                        vs.commands.executeCommand("workbench.action.showErrorsWarnings");
                    return true;
                }
            }
            return false;
        });
    }
    selectDebuggerType(debugConfig, logger) {
        const isTest = (0, utils_4.isTestFileOrFolder)(debugConfig.program);
        const isIntegrationTest = debugConfig.program && (0, utils_4.isInsideFolderNamed)(debugConfig.program, "integration_test");
        // TODO: Remove argsHaveTestNameFilter now that "flutter test" supports running tests on device (integration tests).
        const argsHaveTestNameFilter = (0, utils_4.hasTestNameFilter)(debugConfig.toolArgs, debugConfig.args);
        let debugType = enums_1.DebuggerType.Dart;
        if (debugConfig.cwd
            // TODO: This isInsideFolderNamed often fails when we found a better project root above.
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "bin")
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "tool")
            && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, ".dart_tool")) {
            // Check if we're a Flutter or Web project.
            if ((0, fs_1.isFlutterProjectFolder)(debugConfig.cwd) || this.wsContext.config.forceFlutterDebug) {
                debugType = enums_1.DebuggerType.Flutter;
            }
            else if ((0, utils_4.isInsideFolderNamed)(debugConfig.program, "web") && !(0, utils_4.isInsideFolderNamed)(debugConfig.program, "test"))
                debugType = enums_1.DebuggerType.Web;
            else
                logger.info(`Project (${debugConfig.program}) not recognised as Flutter or Web, will use Dart debugger`);
        }
        logger.info(`Detected launch project as ${enums_1.DebuggerType[debugType]}`);
        if (isTest)
            logger.info(`Detected launch project as a Test project`);
        const canPubRunTest = isTest && debugConfig.cwd && (0, utils_4.projectShouldUsePubForTests)(debugConfig.cwd, this.wsContext.config);
        if (isTest && !canPubRunTest)
            logger.info(`Project does not appear to support 'pub run test', will use VM directly`);
        if (isTest) {
            switch (debugType) {
                case enums_1.DebuggerType.Dart:
                    if (canPubRunTest)
                        debugType = enums_1.DebuggerType.DartTest;
                    break;
                case enums_1.DebuggerType.Flutter:
                    if (isIntegrationTest) {
                        // Integration tests always use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice && argsHaveTestNameFilter) {
                        // Non-integration tests set to run on device but have a test name filter will also have
                        // to run with "flutter test".
                        vs.window.showWarningMessage("Running with 'flutter test' as 'runTestsOnDevice' is not supported for individual tests.");
                        logger.info(`runTestsOnDevice is set but args have test filter so will still use Flutter`);
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    else if (debugConfig.runTestsOnDevice) {
                        // Anything else (eg. Non-integration tests without a test name filter) is allowed to
                        // run on a device if specified.
                        logger.info(`runTestsOnDevice is set, so will use Flutter instead of FlutterTest`);
                    }
                    else {
                        // Otherwise, default is to use "flutter test".
                        debugType = enums_1.DebuggerType.FlutterTest;
                    }
                    break;
                case enums_1.DebuggerType.Web:
                    debugType = enums_1.DebuggerType.WebTest;
                    break;
                default:
                    logger.info("Unknown debugType, unable to switch to test debugger");
            }
        }
        logger.info(`Using ${enums_1.DebuggerType[debugType]} debug adapter for this session`);
        return debugType;
    }
    configureProgramAndCwd(debugConfig, folder, openFile) {
        var _a;
        const logger = this.logger;
        const isAttachRequest = debugConfig.request === "attach";
        // Try to infer a default working directory:
        //
        //   1. Provided by the user
        //   2. Inferred from the likely entry point (`program ?? openFile`)
        //   3. From the active workspace folder for this launch configuration (only if no explicit entry point)
        //   4. A common ancestor from the workspace folders
        //
        // The default may be overwritten further down if we locate a project root
        // while walking up the tree from the `program`.
        let defaultCwd = debugConfig.cwd;
        if (!defaultCwd) {
            const likelyEntryPoint = (_a = debugConfig.program) !== null && _a !== void 0 ? _a : openFile;
            if (likelyEntryPoint && path.isAbsolute(likelyEntryPoint)) {
                // If we have an explicit program, always use that to try and get a cwd.
                folder = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(likelyEntryPoint));
                if (folder) {
                    defaultCwd = (0, fs_1.fsPath)(folder.uri);
                    logger.info(`Setting cwd based on likely entry point: ${defaultCwd}`);
                }
            }
            else if (folder) {
                // Otherwise, if we had no entry point but did have an active workspace folder, use that.
                defaultCwd = (0, fs_1.fsPath)(folder.uri);
                logger.info(`Setting cwd based on active workspace folder: ${defaultCwd}`);
            }
            // If none of those searches found a good cwd, try to infer one from our active workspace
            // folders.
            if (!defaultCwd && vs.workspace.workspaceFolders && vs.workspace.workspaceFolders.length >= 1) {
                if (vs.workspace.workspaceFolders.length === 1) {
                    folder = vs.workspace.workspaceFolders[0];
                    defaultCwd = (0, fs_1.fsPath)(folder.uri);
                    logger.info(`Setting folder/defaultCwd based single open folder: ${defaultCwd}`);
                }
                else {
                    const workspaceFolderPaths = vs.workspace.workspaceFolders.map((wf) => (0, fs_1.fsPath)(wf.uri));
                    defaultCwd = (0, fs_1.findCommonAncestorFolder)(workspaceFolderPaths);
                }
                if (defaultCwd)
                    logger.info(`Setting defaultCwd based on common ancestor of open folders: ${defaultCwd}`);
                else
                    logger.info(`Unable to infer defaultCwd from open workspace (no common ancestor)`);
            }
        }
        // Convert any relative paths to absolute paths (if possible).
        if (defaultCwd && !path.isAbsolute(defaultCwd) && folder) {
            debugConfig.cwd = path.join((0, fs_1.fsPath)(folder.uri), defaultCwd);
            this.logger.info(`Converted defaultCwd to absolute path: ${defaultCwd}`);
        }
        if (debugConfig.cwd && !path.isAbsolute(debugConfig.cwd) && folder) {
            debugConfig.cwd = path.join((0, fs_1.fsPath)(folder.uri), debugConfig.cwd);
            this.logger.info(`Converted cwd to absolute path: ${debugConfig.cwd}`);
        }
        if (debugConfig.program && !path.isAbsolute(debugConfig.program) && (debugConfig.cwd || folder)) {
            debugConfig.program = path.join(debugConfig.cwd || (0, fs_1.fsPath)(folder.uri), debugConfig.program);
            this.logger.info(`Converted program to absolute path: ${debugConfig.program}`);
        }
        if (!isAttachRequest) {
            // If there's no program set, try to guess one.
            if (!debugConfig.program) {
                const preferredFolder = debugConfig.cwd
                    ? debugConfig.cwd
                    : defaultCwd;
                // If we have a folder specified, we should only consider open files if it's inside it.
                const preferredFile = !preferredFolder || (!!openFile && (0, fs_1.isWithinPath)(openFile, preferredFolder)) ? openFile : undefined;
                debugConfig.program = debugConfig.program || this.guessBestEntryPoint(preferredFile, preferredFolder);
            }
        }
        // If we don't have a cwd then find the best one from the project root.
        if (!debugConfig.cwd && defaultCwd) {
            debugConfig.cwd = defaultCwd;
            this.logger.info(`Using workspace as cwd: ${debugConfig.cwd}`);
            // If we have an entry point, see if we can make this more specific by finding a project root.
            if (debugConfig.program) {
                const bestProjectRoot = (0, project_1.locateBestProjectRoot)(debugConfig.program);
                if (bestProjectRoot && (0, fs_1.isWithinPath)(bestProjectRoot, defaultCwd)) {
                    debugConfig.cwd = bestProjectRoot;
                    this.logger.info(`Found better project root to use as cwd: ${debugConfig.cwd}`);
                }
            }
        }
        // Ensure we have a full path.
        if (debugConfig.program && debugConfig.cwd && !path.isAbsolute(debugConfig.program))
            debugConfig.program = path.join(debugConfig.cwd, debugConfig.program);
        if (debugConfig.program && path.isAbsolute(debugConfig.program) && !fs.existsSync(debugConfig.program) && !this.wsContext.config.omitTargetFlag) {
            this.logger.warn(`Launch config references non-existant file ${debugConfig.program}`);
            vscode_1.window.showWarningMessage(`Your launch config references a program that does not exist. If you have problems launching, check the "program" field in your ".vscode/launch.json" file.`);
        }
    }
    errorWithoutOpeningLaunchConfig(message) {
        this.logger.error(message);
        vscode_1.window.showErrorMessage(message);
        return undefined; // undefined means silent (don't open launch.json).
    }
    installDependencies(debugType, pubGlobal) {
        return debugType === enums_1.DebuggerType.Web
            ? new webdev_1.WebDev(pubGlobal).installIfRequired()
            : true;
    }
    guessBestEntryPoint(openFile, folder) {
        var _a;
        // For certain open files, assume the user wants to run them.
        if ((0, utils_4.isValidEntryFile)(openFile)) {
            this.logger.info(`Using open file as entry point: ${openFile}`);
            return openFile;
        }
        // Use the open file as a clue to find the best project root, then search from there.
        const projectRoot = (openFile && (0, project_1.locateBestProjectRoot)(openFile)) || folder;
        if (projectRoot) {
            const commonLaunchPaths = [
                path.join(projectRoot, "lib", "main.dart"),
                path.join(projectRoot, "bin", "main.dart"),
            ];
            for (const launchPath of commonLaunchPaths) {
                if (fs.existsSync(launchPath)) {
                    this.logger.info(`Using found common entry point: ${launchPath}`);
                    return launchPath;
                }
            }
            // If we don't have a bin folder, or a lib/main.dart, or a web folder, then
            // see if we have an example and try that.
            if (!fs.existsSync(path.join(projectRoot, "bin"))
                && !fs.existsSync(path.join(projectRoot, "web"))
                && fs.existsSync(path.join(projectRoot, "example")))
                return this.guessBestEntryPoint(undefined, path.join(projectRoot, "example"));
        }
        // Finally, if we don't have any workspace folder open, assume the user just wants to
        // run this file.
        if (!((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length))
            return openFile;
    }
    getFullVmServiceUri(vmServiceUriOrPort) {
        return __awaiter(this, void 0, void 0, function* () {
            vmServiceUriOrPort = vmServiceUriOrPort || (yield vs.commands.executeCommand("dart.promptForVmService"));
            vmServiceUriOrPort = vmServiceUriOrPort && vmServiceUriOrPort.trim();
            // If the input is just a number, treat is as a localhost port.
            if (vmServiceUriOrPort && /^[0-9]+$/.exec(vmServiceUriOrPort)) {
                vmServiceUriOrPort = `http://127.0.0.1:${vmServiceUriOrPort}`;
            }
            return vmServiceUriOrPort;
        });
    }
    setupDebugConfig(folder, debugConfig, debugType, isFlutter, isAttach, isTest, device, deviceManager) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const conf = config_1.config.for(folder && folder.uri);
            // Attach any properties that weren't explicitly set.
            if (!debugConfig.name) {
                if (isFlutter && debugConfig.deviceId) {
                    debugConfig.name = `Flutter (${debugConfig.deviceId})`;
                }
                else if (isFlutter && device) {
                    debugConfig.name = `Flutter (${deviceManager ? deviceManager.labelForDevice(device) : device.name})`;
                }
                else if (isFlutter) {
                    debugConfig.name = "Flutter";
                }
                else {
                    debugConfig.name = "Dart";
                }
            }
            // Some properties depend on the device, so infer that first if required.
            if (isFlutter && !debugConfig.deviceId && device) {
                debugConfig.deviceId = device.id;
                debugConfig.deviceName = `${deviceManager ? deviceManager.labelForDevice(device) : device.name} (${device.platform})`;
            }
            debugConfig.toolEnv = (0, processes_1.getToolEnv)();
            debugConfig.sendLogsToClient = true;
            debugConfig.sendCustomProgressEvents = true;
            debugConfig.cwd = debugConfig.cwd || (folder && (0, fs_1.fsPath)(folder.uri));
            debugConfig.additionalProjectPaths = debugConfig.additionalProjectPaths || ((_a = vs.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.map((wf) => (0, fs_1.fsPath)(wf.uri)));
            debugConfig.args = debugConfig.args || [];
            debugConfig.vmAdditionalArgs = debugConfig.vmAdditionalArgs || conf.vmAdditionalArgs;
            debugConfig.toolArgs = yield this.buildToolArgs(debugType, debugConfig, conf, deviceManager === null || deviceManager === void 0 ? void 0 : deviceManager.daemonPortOverride);
            debugConfig.vmServicePort = (_b = debugConfig.vmServicePort) !== null && _b !== void 0 ? _b : 0;
            debugConfig.dartSdkPath = this.wsContext.sdks.dart;
            debugConfig.vmServiceLogFile = this.insertSessionName(debugConfig, debugConfig.vmServiceLogFile || conf.vmServiceLogFile);
            debugConfig.webDaemonLogFile = this.insertSessionName(debugConfig, debugConfig.webDaemonLogFile || conf.webDaemonLogFile);
            debugConfig.maxLogLineLength = debugConfig.maxLogLineLength || config_1.config.maxLogLineLength;
            debugConfig.dartTestLogFile = this.insertSessionName(debugConfig, debugConfig.dartTestLogFile || conf.dartTestLogFile);
            debugConfig.debugSdkLibraries = debugConfig.debugSdkLibraries !== undefined && debugConfig.debugSdkLibraries !== null
                ? debugConfig.debugSdkLibraries
                : !!config_1.config.debugSdkLibraries;
            debugConfig.debugExternalPackageLibraries = debugConfig.debugExternalPackageLibraries !== undefined && debugConfig.debugExternalPackageLibraries !== null
                ? debugConfig.debugExternalPackageLibraries
                : config_1.config.debugExternalPackageLibraries;
            debugConfig.showDartDeveloperLogs = conf.showDartDeveloperLogs;
            debugConfig.evaluateGettersInDebugViews = debugConfig.evaluateGettersInDebugViews || conf.evaluateGettersInDebugViews;
            debugConfig.evaluateToStringInDebugViews = debugConfig.evaluateToStringInDebugViews || config_1.config.evaluateToStringInDebugViews;
            debugConfig.daemonPort = config_1.config.daemonPort;
            if (!isFlutter && !isAttach && !isTest && debugConfig.console === undefined && config_1.config.cliConsole !== undefined)
                debugConfig.console = config_1.config.cliConsole;
            else if (isFlutter && (debugConfig.console === "terminal" || debugConfig.console === "externalTerminal"))
                vs.window.showWarningMessage(`Flutter projects do not support "terminal" or "externalTerminal" for the "console" setting of a launch configuration. This setting will be ignored.`);
            if (isFlutter && this.wsContext.sdks.flutter) {
                debugConfig.flutterSdkPath = this.wsContext.sdks.flutter;
                debugConfig.omitTargetFlag = this.wsContext.config.omitTargetFlag;
                debugConfig.useInspectorNotificationsForWidgetErrors = config_1.config.showInspectorNotificationsForWidgetErrors;
                if (!debugConfig.customTool) {
                    const customScript = isAttach ? this.wsContext.config.flutterToolsScript : isTest
                        ? this.wsContext.config.flutterTestScript
                        : this.wsContext.config.flutterRunScript;
                    debugConfig.customTool = customScript === null || customScript === void 0 ? void 0 : customScript.script;
                    debugConfig.customToolReplacesArgs = customScript === null || customScript === void 0 ? void 0 : customScript.replacesArgs;
                }
                debugConfig.flutterRunLogFile = this.insertSessionName(debugConfig, debugConfig.flutterRunLogFile || conf.flutterRunLogFile);
                debugConfig.flutterTestLogFile = this.insertSessionName(debugConfig, debugConfig.flutterTestLogFile || conf.flutterTestLogFile);
                debugConfig.showMemoryUsage =
                    debugConfig.showMemoryUsage || debugConfig.showMemoryUsage === false
                        ? debugConfig.showMemoryUsage
                        : debugConfig.flutterMode === "profile";
            }
        });
    }
    /// Builds arguments to be passed to tools (Dart VM or Flutter tool) for a given launch config.
    ///
    /// Arguments included here are usually based on convenience flags that are supported in launch.json, and are
    /// just mapped to standard arguments in an array.
    ///
    /// All arguments built here should be things that user the recognises based on the app they are trying to launch
    /// or settings they have configured. It should not include things that are specifically required by the debugger
    /// (for example, enabling the VM Service or starting paused). Those items should be handled inside the Debug Adapter.
    buildToolArgs(debugType, debugConfig, conf, portFromLocalExtension) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let args = [];
            args = args.concat((_a = debugConfig.toolArgs) !== null && _a !== void 0 ? _a : []);
            switch (debugType) {
                case enums_1.DebuggerType.Dart:
                    args = args.concat(yield this.buildDartToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.DartTest:
                    args = args.concat(yield this.buildDartTestToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.Flutter:
                    args = args.concat(yield this.buildFlutterToolArgs(debugConfig, conf));
                    break;
                case enums_1.DebuggerType.FlutterTest:
                    args = args.concat(yield this.buildFlutterTestToolArgs(debugConfig, conf));
                    break;
            }
            return args;
        });
    }
    buildDartToolArgs(debugConfig, conf) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            const isDebug = debugConfig.noDebug !== true;
            this.addArgsIfNotExist(args, ...conf.cliAdditionalArgs);
            if (isDebug && debugConfig.enableAsserts !== false) // undefined = on
                this.addArgsIfNotExist(args, "--enable-asserts");
            return args;
        });
    }
    buildDartTestToolArgs(debugConfig, conf) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            this.addArgsIfNotExist(args, ...conf.testAdditionalArgs);
            if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug)) {
                // Check whether package:test supports --ignore-timeouts
                let useIgnoreTimeouts = false;
                if (debugConfig.cwd) {
                    const testCapabilities = (_a = this.cachedTestCapabilities[debugConfig.cwd]) !== null && _a !== void 0 ? _a : yield (0, version_1.getPackageTestCapabilities)(this.logger, this.wsContext.sdks, debugConfig.cwd);
                    this.cachedTestCapabilities[debugConfig.cwd] = testCapabilities;
                    useIgnoreTimeouts = testCapabilities.supportsIgnoreTimeouts;
                }
                if (useIgnoreTimeouts)
                    this.addArgsIfNotExist(args, "--ignore-timeouts");
                else
                    this.addArgsIfNotExist(args, "--timeout", "1d");
            }
            return args;
        });
    }
    buildFlutterToolArgs(debugConfig, conf) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            const isDebug = debugConfig.noDebug !== true;
            const isAttach = debugConfig.request === "attach";
            const isWeb = (0, utils_2.isWebDevice)(debugConfig.deviceId);
            this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
            this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
            if (isAttach)
                this.addArgsIfNotExist(args, ...conf.flutterAttachAdditionalArgs);
            else
                this.addArgsIfNotExist(args, ...conf.flutterRunAdditionalArgs);
            if (debugConfig.deviceId)
                this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
            if (!isAttach) {
                switch (debugConfig.flutterMode) {
                    case "profile":
                    case "release":
                        this.addArgsIfNotExist(args, `--${debugConfig.flutterMode}`);
                        break;
                    default: // Debug mode.
                        if (debugConfig.vmServicePort && isDebug)
                            this.addArgsIfNotExist(args, "--observatory-port", debugConfig.vmServicePort.toString());
                        if (!conf.flutterTrackWidgetCreation && !args.includes("--no-track-widget-creation"))
                            this.addArgsIfNotExist(args, "--no-track-widget-creation");
                }
                if (debugConfig.flutterPlatform && debugConfig.flutterPlatform !== "default")
                    this.addArgsIfNotExist(args, "--target-platform", debugConfig.flutterPlatform);
                if (debugConfig.deviceId === "web-server") {
                    if (this.flutterCapabilities.supportsWsVmService && !args.includes("--web-server-debug-protocol"))
                        this.addArgsIfNotExist(args, "--web-server-debug-protocol", "ws");
                    if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsDebugBackend)
                        this.addArgsIfNotExist(args, "--web-server-debug-backend-protocol", config_1.config.debugExtensionBackendProtocol);
                    if (config_1.config.debugExtensionBackendProtocol && this.flutterCapabilities.supportsWsInjectedClient)
                        this.addArgsIfNotExist(args, "--web-server-debug-injected-client-protocol", config_1.config.debugExtensionBackendProtocol);
                }
                if (this.flutterCapabilities.supportsExposeUrl && !utils_3.isRunningLocally)
                    this.addArgsIfNotExist(args, "--web-allow-expose-url");
                if (isWeb) {
                    const renderer = (0, utils_1.getFutterWebRenderer)(this.flutterCapabilities, config_1.config.flutterWebRenderer);
                    if (renderer)
                        this.addArgsIfNotExist(args, "--web-renderer", renderer);
                }
            }
            const daemonPort = (_b = (_a = this.deviceManager) === null || _a === void 0 ? void 0 : _a.daemonPortOverride) !== null && _b !== void 0 ? _b : conf.daemonPort;
            if (this.wsContext.config.forceFlutterWorkspace && daemonPort) {
                this.addArgsIfNotExist(args, "--daemon-connection-port", daemonPort.toString());
            }
            if (config_1.config.shareDevToolsWithFlutter && this.flutterCapabilities.supportsDevToolsServerAddress && !args.includes("--devtools-server-address")) {
                this.logger.info("Getting DevTools server address to pass to Flutter...");
                try {
                    const devtoolsUrl = yield this.debugCommands.devTools.devtoolsUrl;
                    if (devtoolsUrl)
                        this.addArgsIfNotExist(args, "--devtools-server-address", devtoolsUrl.toString());
                    else if (!constants_1.isDartCodeTestRun) // Suppress warning on test runs as they're fast and can launch before the server starts
                        this.logger.warn("DevTools server unavailable, not sending --devtools-server-address!");
                }
                catch (e) {
                    this.logger.error(`Failed to get DevTools server address ${e}`);
                }
            }
            if ((logging_1.isLogging || constants_1.isDartCodeTestRun) && !args.includes("--verbose"))
                this.addArgsIfNotExist(args, "-v");
            return args;
        });
    }
    buildFlutterTestToolArgs(debugConfig, conf) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = [];
            this.addArgsIfNotExist(args, ...(0, processes_1.getGlobalFlutterArgs)());
            this.addArgsIfNotExist(args, ...conf.flutterAdditionalArgs);
            this.addArgsIfNotExist(args, ...conf.flutterTestAdditionalArgs);
            if (debugConfig.deviceId)
                this.addArgsIfNotExist(args, "-d", debugConfig.deviceId);
            if (conf.suppressTestTimeouts === "always" || (conf.suppressTestTimeouts === "debug" && !debugConfig.noDebug))
                this.addArgsIfNotExist(args, "--timeout", "1d");
            return args;
        });
    }
    addArgsIfNotExist(args, ...toAdd) {
        if (!args.includes(toAdd[0])) {
            toAdd.forEach((s) => args.push(s));
        }
    }
    insertSessionName(args, logPath) {
        return logPath
            ? logPath.replace(/\${name}/, (0, utils_2.filenameSafe)(args.name || "unnamed-session"))
            : logPath;
    }
}
exports.DebugConfigProvider = DebugConfigProvider;
class InitialLaunchJsonDebugConfigProvider {
    constructor(logger) {
        this.logger = logger;
    }
    provideDebugConfigurations(folder, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const projectFolders = folder
                ? yield (0, utils_3.getAllProjectFolders)(this.logger, utils_4.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth, workspaceFolders: [folder] })
                : [];
            const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
            if (projectFolders.length) {
                for (const projectFolder of projectFolders) {
                    const isFlutter = (0, fs_1.isFlutterProjectFolder)(projectFolder);
                    const name = path.basename(projectFolder);
                    // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                    const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                    if (isFlutter) {
                        results.push({
                            name,
                            cwd,
                            request: "launch",
                            type: "dart",
                        });
                        results.push({
                            name: `${name} (profile mode)`,
                            cwd,
                            request: "launch",
                            type: "dart",
                            flutterMode: "profile",
                        });
                        results.push({
                            name: `${name} (release mode)`,
                            cwd,
                            request: "launch",
                            type: "dart",
                            flutterMode: "release",
                        });
                    }
                    else {
                        results.push({
                            name,
                            cwd,
                            request: "launch",
                            type: "dart",
                        });
                    }
                }
            }
            else {
                results.push({
                    name: "Dart & Flutter",
                    request: "launch",
                    type: "dart",
                });
            }
            return results;
        });
    }
}
exports.InitialLaunchJsonDebugConfigProvider = InitialLaunchJsonDebugConfigProvider;
class DynamicDebugConfigProvider {
    constructor(logger, deviceManager) {
        this.logger = logger;
        this.deviceManager = deviceManager;
    }
    provideDebugConfigurations(folder, token) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const results = [];
            const rootFolder = folder ? (0, fs_1.fsPath)(folder.uri) : undefined;
            const projectFolders = folder
                ? yield (0, utils_3.getAllProjectFolders)(this.logger, utils_4.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth, workspaceFolders: [folder] })
                : [];
            for (const projectFolder of projectFolders) {
                const isFlutter = (0, fs_1.isFlutterProjectFolder)(projectFolder);
                const name = path.basename(projectFolder);
                // Compute cwd, using undefined instead of empty if rootFolder === projectFolder
                const cwd = rootFolder ? path.relative(rootFolder, projectFolder) || undefined : undefined;
                const exists = (p) => projectFolder && fs.existsSync(path.join(projectFolder, p));
                if (isFlutter && exists("lib/main.dart") && this.deviceManager) {
                    results.push({
                        name: `Flutter`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                    const devices = yield this.deviceManager.getValidDevicesForProject(projectFolder);
                    for (const device of devices) {
                        const deviceLabel = (_a = this.deviceManager) === null || _a === void 0 ? void 0 : _a.labelForDevice(device);
                        results.push({
                            name: `Flutter (${deviceLabel})`,
                            program: "lib/main.dart",
                            cwd,
                            deviceId: device.id,
                            request: "launch",
                            type: "dart",
                        });
                    }
                    results.push({
                        name: `Flutter (profile mode)`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                        flutterMode: "profile",
                    });
                    results.push({
                        name: `Flutter (release mode)`,
                        program: "lib/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                        flutterMode: "release",
                    });
                }
                if (!isFlutter && exists("web")) {
                    results.push({
                        name: `Dart Web`,
                        program: "web",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("bin/main.dart")) {
                    results.push({
                        name: `Dart`,
                        program: "bin/main.dart",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (exists("test")) {
                    results.push({
                        name: `${isFlutter ? "Flutter" : "Dart"} Tests`,
                        program: "test",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
                if (isFlutter && exists("integration_test")) {
                    results.push({
                        name: `${isFlutter ? "Flutter" : "Dart"} Integration Tests`,
                        program: "integration_test",
                        cwd,
                        request: "launch",
                        type: "dart",
                    });
                }
            }
            return results;
        });
    }
}
exports.DynamicDebugConfigProvider = DynamicDebugConfigProvider;


/***/ }),

/***/ 5587:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(8779);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
const ranking_code_action_provider_1 = __webpack_require__(7702);
class FixCodeActionProvider {
    constructor(logger, selector, analyzer) {
        this.logger = logger;
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 1;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // quickfix (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
                return undefined;
            try {
                const pos = "active" in range ? range.active : range.start;
                const result = yield this.analyzer.editGetFixes({
                    file: (0, fs_1.fsPath)(document.uri),
                    offset: document.offsetAt(pos),
                });
                if (token && token.isCancellationRequested)
                    return;
                // Because fixes may be the same for multiple errors, we'll de-dupe them based on their edit.
                const allActions = {};
                for (const errorFix of result.fixes) {
                    for (const fix of errorFix.fixes) {
                        allActions[JSON.stringify(fix.edits)] = this.convertResult(document, fix, errorFix.error);
                    }
                }
                const allFixes = Object.keys(allActions).map((a) => allActions[a]);
                return context.only
                    ? allFixes.filter((f) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(f.kind); })
                    : allFixes;
            }
            catch (e) {
                this.logger.error(e);
                throw e;
            }
        });
    }
    convertResult(document, change, error) {
        const title = change.message;
        const diagnostics = error ? [dart_diagnostic_provider_1.DartDiagnosticProvider.createDiagnostic(error)] : undefined;
        const kind = (0, ranking_code_action_provider_1.getKindFor)(change.id, vscode_1.CodeActionKind.QuickFix);
        const action = new vscode_1.CodeAction(title, kind);
        action.command = {
            arguments: [document, change],
            command: "_dart.applySourceChange",
            title,
        };
        action.diagnostics = diagnostics;
        return action;
    }
}
exports.FixCodeActionProvider = FixCodeActionProvider;


/***/ }),

/***/ 2862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IgnoreLintCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const config_1 = __webpack_require__(4165);
const utils_1 = __webpack_require__(8779);
const dart_diagnostic_provider_1 = __webpack_require__(5453);
class IgnoreLintCodeActionProvider {
    constructor(selector) {
        this.selector = selector;
        this.rank = 100;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.QuickFix],
        };
    }
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_1.isAnalyzableAndInWorkspace)(document))
            return;
        // If we were only asked for specific action types and that doesn't include
        // quickfix (which is all we supply), bail out.
        if (context && context.only && !vscode_1.CodeActionKind.QuickFix.contains(context.only))
            return;
        if (!config_1.config.showIgnoreQuickFixes || !context || !context.diagnostics || !context.diagnostics.length)
            return;
        const lintErrors = context.diagnostics.filter((d) => d.range.intersection(range)
            && (
            // Non-LSP:
            (d instanceof dart_diagnostic_provider_1.DartDiagnostic && (d.type === "LINT" || d.type === "HINT")
                // LSP:
                || (d.source === "dart" && d.severity === vscode_1.DiagnosticSeverity.Information))));
        if (!lintErrors.length)
            return;
        return lintErrors.map((diagnostic) => this.convertResult(document, diagnostic));
    }
    convertResult(document, diagnostic) {
        const type = diagnostic instanceof dart_diagnostic_provider_1.DartDiagnostic ? `${diagnostic.type.toLowerCase()} ` : "";
        const dCode = diagnostic.code || "";
        const code = typeof dCode === "string" ? dCode : dCode.value;
        const edit = new vscode_1.WorkspaceEdit();
        const line = document.lineAt(diagnostic.range.start.line);
        edit.insert(document.uri, line.range.start, `${" ".repeat(line.firstNonWhitespaceCharacterIndex)}// ignore: ${code}\n`);
        const title = `Ignore ${type}'${code}' for this line`;
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.QuickFix);
        action.edit = edit;
        return action;
    }
}
exports.IgnoreLintCodeActionProvider = IgnoreLintCodeActionProvider;


/***/ }),

/***/ 23:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LegacyDartWorkspaceSymbolProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const analyzer_das_1 = __webpack_require__(2061);
const utils_2 = __webpack_require__(8779);
class LegacyDartWorkspaceSymbolProvider {
    constructor(logger, analyzer) {
        this.logger = logger;
        this.analyzer = analyzer;
    }
    provideWorkspaceSymbols(query, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (query.length === 0)
                return undefined;
            query = this.sanitizeUserQuery(query);
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const results = yield Promise.all([
                this.analyzer.searchFindTopLevelDeclarationsResults({ pattern }),
                this.analyzer.searchFindMemberDeclarationsResults({ name: pattern }),
            ]);
            return this.combineResults(results);
        });
    }
    combineResults(results) {
        return results[0].results.concat(results[1].results)
            .filter((r) => this.shouldIncludeResult(r))
            .map((r) => this.convertResult(r));
    }
    searchTopLevelSymbols(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindTopLevelDeclarationsResults({ pattern });
            return resp.results;
        });
    }
    searchMemberDeclarations(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const pattern = this.makeCaseInsensitiveFuzzyRegex(query);
            const resp = yield this.analyzer.searchFindMemberDeclarationsResults({ name: pattern });
            return resp.results;
        });
    }
    sanitizeUserQuery(query) {
        let chars = Array.from(query);
        // Filter out special chars that will break regex.
        // searchFindTopLevelDeclarations supports regex, but we build the pattern with the output of this.
        // searchMemberDeclarations is not intended to support regex but does.
        chars = chars.filter((c) => "[](){}\\|./<>?+".indexOf(c) === -1);
        return chars.join("");
    }
    makeCaseInsensitiveFuzzyRegex(query) {
        let chars = Array.from(query);
        chars = chars.map((c) => {
            if (c.toUpperCase() === c.toLowerCase())
                return c;
            return `[${c.toUpperCase()}${c.toLowerCase()}]`;
        });
        const pattern = chars.join(".*");
        return `.*${pattern}.*`;
    }
    shouldIncludeResult(result) {
        // Must be either:
        //   1. Public (not start with an underscore).
        //   2. In our project.
        const isPrivate = result.path[0].name.startsWith("_") || result.path[1].name.startsWith("_");
        return (0, utils_2.isWithinWorkspace)(result.location.file) || !isPrivate;
    }
    convertResult(result) {
        // Rewrite the filename for best display.
        const containerName = this.createDisplayPath(result.location.file);
        // Remove the library and compilation unit parent elements; concatenate names.
        let elementPathDescription = result.path
            .slice(0, result.path.length - 2)
            .reverse()
            .map((e) => e.name)
            .join(".");
        // For properties, show if get/set.
        if (result.path[0].kind === "SETTER")
            elementPathDescription += " set";
        if (result.path[0].kind === "GETTER")
            elementPathDescription += " get";
        const parameters = result.path[0].parameters && result.path[0].kind !== "SETTER"
            ? result.path[0].parameters
            : "";
        return new vscode_1.SymbolInformation(elementPathDescription + parameters, (0, analyzer_das_1.getSymbolKindForElementKind)(this.logger, result.path[0].kind), containerName || "", new vscode_1.Location(vscode_1.Uri.file(result.location.file), (0, utils_1.toRangeOnLine)(result.location)));
    }
    createDisplayPath(inputPath) {
        if (!inputPath)
            return undefined;
        // HACK: The AS returns paths to the PUB_CACHE folder, which Code can't
        // convert to relative paths (so they look terrible). If the file exists in
        // workspace.rootPath we rewrite the path to there which gives us a nice
        // relative path.
        // Currently I only do this for "hosted\pub.dartlang.org" as I'm not sure of the
        // rules for these paths!
        const pubCachePath = "hosted" + path.sep + "pub.dartlang.org";
        const pubCachePathIndex = inputPath.indexOf(pubCachePath);
        if (pubCachePathIndex > -1) {
            const relativePath = inputPath.substring(pubCachePathIndex + pubCachePath.length + 1);
            // Packages in pubcache are versioned so trim the "-x.x.x" off the end of the foldername.
            const pathComponents = relativePath.split(path.sep);
            pathComponents[0] = pathComponents[0].split("-")[0];
            // Symlink goes into the lib folder, so strip that out of the path.
            if (pathComponents[1] === "lib")
                pathComponents.splice(1, 1);
            // Return 'package:foo/bar.dart'.
            inputPath = `package:${pathComponents[0]}/${pathComponents.slice(1).join("/")}`;
        }
        else {
            const root = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(inputPath));
            inputPath = root && path.relative((0, fs_1.fsPath)(root.uri), inputPath);
        }
        return inputPath;
    }
}
exports.LegacyDartWorkspaceSymbolProvider = LegacyDartWorkspaceSymbolProvider;


/***/ }),

/***/ 7702:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getKindFor = exports.RankingCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
class RankingCodeActionProvider {
    constructor() {
        this.codeActionProviders = [];
    }
    registerProvider(provider) {
        this.codeActionProviders.push(provider);
        (0, array_1.sortBy)(this.codeActionProviders, (p) => p.rank);
    }
    get metadata() {
        const allKinds = (0, utils_1.flatMap)(this.codeActionProviders, (p) => p.metadata.providedCodeActionKinds || []);
        return { providedCodeActionKinds: (0, utils_1.uniq)(allKinds) };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sort the providers, because then their results will be sorted (flatMap doesn't change the order, and
            // Promise.all preserves order).
            const applicableProviders = this.codeActionProviders.filter((p) => vscode_1.languages.match(p.selector, document));
            const promises = applicableProviders.map((p) => p.provideCodeActions(document, range, context, token));
            const allResults = yield Promise.all(promises);
            const flatResults = (0, utils_1.flatMap)(allResults, (x) => x || []);
            return flatResults;
        });
    }
}
exports.RankingCodeActionProvider = RankingCodeActionProvider;
function getKindFor(id, base) {
    if (!id)
        return base;
    const newID = id
        .replace("dart.assist.", "")
        .replace("dart.fix.", "")
        .replace("analysisOptions.assist.", "")
        .replace("analysisOptions.fix.", "");
    return base.append(newID);
}
exports.getKindFor = getKindFor;


/***/ }),

/***/ 3797:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefactorCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(8779);
const supportedRefactors = {
    CONVERT_METHOD_TO_GETTER: "Convert Method to Getter",
    EXTRACT_LOCAL_VARIABLE: "Extract Local Variable",
    EXTRACT_METHOD: "Extract Method",
    EXTRACT_WIDGET: "Extract Widget",
};
class RefactorCodeActionProvider {
    constructor(selector, analyzer) {
        this.selector = selector;
        this.analyzer = analyzer;
        this.rank = 50;
        this.metadata = {
            providedCodeActionKinds: [vscode_1.CodeActionKind.Refactor],
        };
    }
    provideCodeActions(document, range, context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
                return undefined;
            // If we were only asked for specific action types and that doesn't include
            // refactor (which is all we supply), bail out.
            if (context && context.only && !vscode_1.CodeActionKind.Refactor.contains(context.only))
                return undefined;
            try {
                const startOffset = document.offsetAt(range.start);
                const endOffset = document.offsetAt(range.end);
                const result = yield this.analyzer.editGetAvailableRefactorings({
                    file: (0, fs_1.fsPath)(document.uri),
                    length: endOffset - startOffset,
                    offset: startOffset,
                });
                if (token && token.isCancellationRequested)
                    return;
                const allRefactors = result.kinds.map((k) => this.getSupportedRefactorForKind(document, range, k)).filter(utils_1.notUndefined);
                return context.only
                    ? allRefactors.filter((r) => { var _a; return (_a = context.only) === null || _a === void 0 ? void 0 : _a.contains(r.kind); })
                    : allRefactors;
            }
            catch (e) {
                // TODO: Swap this back to logError/throw when https://github.com/dart-lang/sdk/issues/33471 is fixed.
                return [];
                // logError(e);
                // reject();
            }
        });
    }
    getSupportedRefactorForKind(document, range, k) {
        if (!supportedRefactors[k])
            return;
        const title = supportedRefactors[k];
        const action = new vscode_1.CodeAction(title, vscode_1.CodeActionKind.Refactor);
        action.command = {
            arguments: [document, range, k],
            command: "_dart.performRefactor",
            title,
        };
        return action;
    }
}
exports.RefactorCodeActionProvider = RefactorCodeActionProvider;


/***/ }),

/***/ 2252:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SnippetCompletionItemProvider = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const extension_utils_1 = __webpack_require__(6143);
const config_1 = __webpack_require__(4165);
class SnippetCompletionItemProvider {
    constructor(isLsp, dartCapabilities, filename, shouldRender) {
        this.isLsp = isLsp;
        this.dartCapabilities = dartCapabilities;
        this.completions = new vscode_1.CompletionList();
        this.shouldRender = shouldRender;
        const snippets = (0, extension_utils_1.readJson)(path.join(extension_utils_1.extensionPath, filename));
        for (const snippetType of Object.keys(snippets)) {
            for (const snippetName of Object.keys(snippets[snippetType])) {
                const snippet = snippets[snippetType][snippetName];
                const completionItem = new vscode_1.CompletionItem(snippetName, vscode_1.CompletionItemKind.Snippet);
                completionItem.filterText = snippet.prefix;
                completionItem.insertText = new vscode_1.SnippetString(Array.isArray(snippet.body)
                    ? snippet.body.join("\n")
                    : snippet.body);
                completionItem.detail = snippet.description;
                completionItem.documentation = (0, extension_utils_1.createMarkdownString)("").appendCodeblock(completionItem.insertText.value);
                completionItem.sortText = "zzzzzzzzzzzzzzzzzzzzzz";
                this.completions.items.push(completionItem);
            }
        }
    }
    provideCompletionItems(document, position, token, context) {
        if (!config_1.config.enableSnippets)
            return;
        if (config_1.config.enableServerSnippets && this.dartCapabilities.supportsServerSnippets && this.isLsp)
            return;
        const line = document.lineAt(position.line).text.slice(0, position.character);
        if (!this.shouldAllowCompletion(line, context))
            return;
        if (!this.shouldRender(document.uri))
            return;
        return this.completions;
    }
    shouldAllowCompletion(line, context) {
        line = line.trim();
        // Don't provide completions after comment markers. This isn't perfect since it'll
        // suppress them for ex if // appears inside strings, but it's a reasonable
        // approximation given we don't have a reliable way to tell that.
        if (line.indexOf("//") !== -1)
            return false;
        // Otherwise, allow through.
        return true;
    }
}
exports.SnippetCompletionItemProvider = SnippetCompletionItemProvider;


/***/ }),

/***/ 4508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceCodeActionProvider = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(7220);
const utils_2 = __webpack_require__(8779);
class SourceCodeActionProvider {
    provideCodeActions(document, range, context, token) {
        if (!(0, utils_2.isAnalyzableAndInWorkspace)(document))
            return undefined;
        const actions = [];
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(vscode_1.CodeActionKind.SourceOrganizeImports)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "_dart.organizeImports",
                    title: "Organize Imports",
                },
                kind: vscode_1.CodeActionKind.SourceOrganizeImports,
                title: "Organize Imports",
            });
        }
        if (!context
            || !context.only
            || context.only.contains(vscode_1.CodeActionKind.Source)
            || context.only.contains(utils_1.SourceSortMembersCodeActionKind)) {
            actions.push({
                command: {
                    arguments: [document],
                    command: "dart.sortMembers",
                    title: "Sort Members",
                },
                kind: utils_1.SourceSortMembersCodeActionKind,
                title: "Sort Members",
            });
        }
        return actions;
    }
}
exports.SourceCodeActionProvider = SourceCodeActionProvider;
SourceCodeActionProvider.metadata = {
    providedCodeActionKinds: [vscode_1.CodeActionKind.Source, vscode_1.CodeActionKind.SourceOrganizeImports, utils_1.SourceSortMembersCodeActionKind],
};


/***/ }),

/***/ 334:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubGlobal = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const processes_2 = __webpack_require__(5430);
class PubGlobal {
    constructor(logger, dartCapabilities, context, sdks, pubApi) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.context = context;
        this.sdks = sdks;
        this.pubApi = pubApi;
    }
    installIfRequired(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const packageID = options.packageID;
            const packageName = (_a = options.packageName) !== null && _a !== void 0 ? _a : packageID;
            const moreInfoLink = (_b = options.moreInfoLink) !== null && _b !== void 0 ? _b : constants_1.pubGlobalDocsUrl;
            const requiredVersion = options.requiredVersion;
            const silent = !!options.silent;
            const skipOptionalUpdates = !!options.skipOptionalUpdates;
            let updateSilently = !!options.updateSilently;
            let installedVersion = yield this.getInstalledVersion(packageName, packageID);
            const versionStatus = yield this.checkVersionStatus(packageID, installedVersion, requiredVersion);
            // If we have the latest version, or the update is not mandatory (UpdateRequired) and we were told to skip optional updates
            // just bail and use the current version.
            if (versionStatus === enums_1.VersionStatus.Valid || (skipOptionalUpdates && versionStatus === enums_1.VersionStatus.UpdateAvailable))
                return installedVersion;
            if (silent)
                updateSilently = true;
            const activateForMe = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activate ${packageName}` : `Update ${packageName}`;
            const message = versionStatus === enums_1.VersionStatus.NotInstalled
                ? `${packageName} needs to be installed with 'pub global activate ${packageID}' to use this feature.`
                : (versionStatus === enums_1.VersionStatus.UpdateRequired
                    ? `${packageName} needs to be updated with 'pub global activate ${packageID}' to use this feature.`
                    : `A new version of ${packageName} is available and can be installed with 'pub global activate ${packageID}'.`);
            let action = 
            // If we need an update and we're allowed to auto-update, to the same as if the user
            // clicked the activate button, otherwise prompt them.
            updateSilently && ((versionStatus === enums_1.VersionStatus.UpdateRequired || versionStatus === enums_1.VersionStatus.UpdateAvailable) || silent)
                ? activateForMe
                : yield vs.window.showWarningMessage(message, activateForMe, constants_1.moreInfoAction);
            if (action === constants_1.moreInfoAction) {
                yield utils_2.envUtils.openInBrowser(moreInfoLink);
                return undefined;
            }
            else if (action === activateForMe) {
                const actionName = versionStatus === enums_1.VersionStatus.NotInstalled ? `Activating ${packageName}` : `Updating ${packageName}`;
                const args = ["global", "activate", packageID];
                try {
                    if (silent)
                        yield this.runCommand(packageName, args);
                    else
                        yield this.runCommandWithProgress(packageName, `${actionName}...`, args);
                    installedVersion = yield this.getInstalledVersion(packageName, packageID);
                    const newVersionStatus = yield this.checkVersionStatus(packageID, installedVersion);
                    if (newVersionStatus !== enums_1.VersionStatus.Valid) {
                        this.logger.warn(`After installing ${packageID}, version status was ${enums_1.VersionStatus[newVersionStatus]} and not Valid!`);
                    }
                    return installedVersion;
                }
                catch (e) {
                    this.logger.error(e);
                    if (!silent) {
                        action = yield vs.window.showErrorMessage(`${actionName} failed. Please try running 'pub global activate ${packageID}' manually.`, constants_1.moreInfoAction);
                        if (action === constants_1.moreInfoAction) {
                            yield utils_2.envUtils.openInBrowser(moreInfoLink);
                        }
                    }
                    return undefined;
                }
            }
            return undefined;
        });
    }
    backgroundActivate(packageName, packageID, silent) {
        return __awaiter(this, void 0, void 0, function* () {
            const actionName = `Activating ${packageName}`;
            const args = ["global", "activate", packageID];
            if (silent)
                yield this.runCommand(packageName, args);
            else
                yield this.runCommandWithProgress(packageName, `${actionName}...`, args);
        });
    }
    uninstall(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = ["global", "deactivate", packageID];
            yield this.runCommand(packageID, args);
        });
    }
    checkVersionStatus(packageID, installedVersion, requiredVersion) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!installedVersion) {
                this.logger.info(`${packageID} has no installed version, returning NotInstalled`);
                return enums_1.VersionStatus.NotInstalled;
            }
            // If we need a specific version, check it here.
            if (requiredVersion && !(0, utils_1.pubVersionIsAtLeast)(installedVersion, requiredVersion)) {
                this.logger.info(`${packageID} version ${installedVersion} is not at least ${requiredVersion} so returning UpdateRequired`);
                return enums_1.VersionStatus.UpdateRequired;
            }
            // If we haven't checked in the last 24 hours, check if there's an update available.
            const lastChecked = this.context.getPackageLastCheckedForUpdates(packageID);
            if (!lastChecked || lastChecked <= Date.now() - constants_1.noRepeatPromptThreshold) {
                this.context.setPackageLastCheckedForUpdates(packageID, Date.now());
                try {
                    const pubPackage = yield this.pubApi.getPackage(packageID);
                    if (!(0, utils_1.pubVersionIsAtLeast)(installedVersion, pubPackage.latest.version)) {
                        if (pubPackage.latest.retracted) {
                            this.logger.info(`${packageID} version ${installedVersion} is is retracted, so even though it's newer than ${pubPackage.latest.version}, returning Valid to avoid potentially installing repeatedly`);
                            return enums_1.VersionStatus.Valid;
                        }
                        else {
                            this.logger.info(`${packageID} version ${installedVersion} is not at least ${pubPackage.latest.version} so returning UpdateAvailable`);
                            return enums_1.VersionStatus.UpdateAvailable;
                        }
                    }
                }
                catch (e) {
                    // If we fail to call the API to check for a new version, then we can run
                    // with what we have.
                    this.logger.warn(`Failed to check for new version of ${packageID}: ${e}`, enums_1.LogCategory.CommandProcesses);
                    return enums_1.VersionStatus.Valid;
                }
            }
            // Otherwise, we're installed and have a new enough version.
            this.logger.info(`${packageID} version ${installedVersion} appears to be latest so returning Valid`);
            return enums_1.VersionStatus.Valid;
        });
    }
    getInstalledVersion(packageName, packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield this.runCommand(packageName, ["global", "list"]);
            const versionMatch = new RegExp(`^${packageID} (\\d+\\.\\d+\\.\\d+[\\w.\\-+]*)(?: |$)`, "m");
            const match = versionMatch.exec(output);
            const installedVersion = match ? match[1] : undefined;
            return installedVersion;
        });
    }
    runCommandWithProgress(packageName, title, args, customScript) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(packageName, args));
    }
    runCommand(packageName, args) {
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return new Promise((resolve, reject) => {
            this.logger.info(`Spawning ${pubExecution.executable} with args ${JSON.stringify(pubExecution.args)}`);
            const proc = (0, processes_2.safeToolSpawn)(undefined, pubExecution.executable, pubExecution.args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`${packageName} exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.PubGlobal = PubGlobal;


/***/ }),

/***/ 5958:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stagehand = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const utils_1 = __webpack_require__(3438);
const processes_2 = __webpack_require__(5430);
const packageName = "Stagehand";
const packageID = "stagehand";
class Stagehand {
    constructor(logger, dartCapabilities, sdks, pubGlobal) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.sdks = sdks;
        this.pubGlobal = pubGlobal;
    }
    installIfRequired() {
        return this.pubGlobal.installIfRequired({ packageName, packageID, moreInfoLink: constants_1.stagehandInstallationInstructionsUrl, requiredVersion: "3.3.0" });
    }
    getTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getTemplateJson();
            return JSON.parse(json);
        });
    }
    getTemplateJson() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.cleanPubOutput)(yield this.runCommandWithProgress("Fetching Stagehand templates...", ["global", "run", "stagehand", "--machine"]));
        });
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const pubExecution = (0, processes_1.getPubExecutionInfo)(this.dartCapabilities, this.sdks.dart, args);
        return new Promise((resolve, reject) => {
            const proc = (0, processes_2.safeToolSpawn)(undefined, pubExecution.executable, pubExecution.args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`Stagehand exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.Stagehand = Stagehand;


/***/ }),

/***/ 708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDev = void 0;
const packageName = "webdev";
const packageID = "webdev";
class WebDev {
    constructor(pubGlobal) {
        this.pubGlobal = pubGlobal;
    }
    installIfRequired() {
        return this.pubGlobal.installIfRequired({ packageName, packageID, moreInfoLink: undefined, requiredVersion: "2.5.4" });
    }
}
exports.WebDev = WebDev;


/***/ }),

/***/ 3285:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCreate = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(3438);
const processes_1 = __webpack_require__(5430);
class DartCreate {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    installIfRequired() {
        return __awaiter(this, void 0, void 0, function* () { return "0.0.0"; });
    }
    getTemplates() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getTemplateJson();
            return JSON.parse(json);
        });
    }
    getTemplateJson() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, utils_1.cleanPubOutput)(yield this.runCommandWithProgress("Fetching project templates...", ["create", "--list-templates"]));
        });
    }
    runCommandWithProgress(title, args) {
        return vs.window.withProgress({
            location: vs.ProgressLocation.Notification,
            title,
        }, () => this.runCommand(args));
    }
    runCommand(args) {
        const dartSdkPath = this.sdks.dart;
        const dartBinPath = path.join(dartSdkPath, constants_1.dartVMPath);
        return new Promise((resolve, reject) => {
            const proc = (0, processes_1.safeToolSpawn)(undefined, dartBinPath, args);
            (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, proc);
            const stdout = [];
            const stderr = [];
            proc.stdout.on("data", (data) => stdout.push(data.toString()));
            proc.stderr.on("data", (data) => stderr.push(data.toString()));
            proc.on("close", (code) => {
                if (!code) {
                    resolve(stdout.join(""));
                }
                else {
                    reject(`'dart create' exited with code ${code}.\n\n${stdout.join("")}\n\n${stderr.join("")}`);
                }
            });
        });
    }
}
exports.DartCreate = DartCreate;


/***/ }),

/***/ 8397:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsEmbeddedView = void 0;
const vs = __webpack_require__(9496);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(7220);
const pageScript = `
const vscode = acquireVsCodeApi();
window.addEventListener('message', (event) => {
	const message = event.data;
	const devToolsFrame = document.getElementById('devToolsFrame');
	switch (message.command) {
		case "setUrl":
			const theme = document.body.classList.contains('vscode-light') ? 'light': 'dark';
			const background = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-background');
			const foreground = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-foreground');
			let url = \`\${message.url}&theme=\${theme}&backgroundColor=\${encodeURIComponent(background)}&foregroundColor=\${encodeURIComponent(foreground)}\`;
			const fontSizeWithUnits = getComputedStyle(document.documentElement).getPropertyValue('--vscode-editor-font-size');
			if (fontSizeWithUnits && fontSizeWithUnits.endsWith('px')) {
				url += \`&fontSize=\${encodeURIComponent(parseFloat(fontSizeWithUnits))}\`;
			}
			if (devToolsFrame.src !== url)
				devToolsFrame.src = url;
			break;
		case "keydown":
			// https://github.com/flutter/devtools/issues/2775
			window.dispatchEvent(new KeyboardEvent('keydown', message.data));
			break;
		case "launchUrl":
			vscode.postMessage({command: 'launchUrl', data: message.data});
			break;
	}
});
`;
const scriptNonce = Buffer.from(pageScript).toString("base64");
const frameCss = "position: absolute; top: 0; left: 0; width: 100%; height: 100%";
const cssNonce = Buffer.from(frameCss).toString("base64");
class DevToolsEmbeddedView {
    constructor(session, devToolsUri, page, location) {
        var _a;
        this.session = session;
        this.devToolsUri = devToolsUri;
        this.page = page;
        this.onDisposeEmitter = new events_1.EventEmitter();
        this.onDispose = this.onDisposeEmitter.event;
        const column = location === "active"
            ? vs.ViewColumn.Active
            : ((_a = (0, utils_1.firstNonEditorColumn)()) !== null && _a !== void 0 ? _a : vs.ViewColumn.Beside);
        this.panel = vs.window.createWebviewPanel("dartDevTools", page.title, column, {
            enableScripts: true,
            localResourceRoots: [],
            retainContextWhenHidden: true,
        });
        this.panel.onDidDispose(() => this.dispose(true));
        this.panel.webview.html = `
			<html>
			<head>
			<meta http-equiv="Content-Security-Policy" content="default-src 'self' 'nonce-${scriptNonce}' 'nonce-${cssNonce}' http://${vs.Uri.parse(devToolsUri).authority};">
			<script nonce="${scriptNonce}">${pageScript}</script>
			<style nonce="${cssNonce}">#devToolsFrame { ${frameCss} }</style>
			</head>
			<body><iframe id="devToolsFrame" src="about:blank" frameborder="0"></iframe></body>
			</html>
			`;
        this.messageDisposable = this.panel.webview.onDidReceiveMessage((message) => __awaiter(this, void 0, void 0, function* () {
            if (message.command === "launchUrl") {
                yield utils_1.envUtils.openInBrowser(message.data.url);
            }
        }));
    }
    load(session, uri) {
        this.session = session;
        this.panel.webview.postMessage({ command: "setUrl", url: uri });
        this.panel.reveal();
    }
    dispose(panelDisposed = false) {
        if (!panelDisposed)
            this.panel.dispose();
        this.onDisposeEmitter.fire();
        this.messageDisposable.dispose();
    }
}
exports.DevToolsEmbeddedView = DevToolsEmbeddedView;


/***/ }),

/***/ 34:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DevToolsManager = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const vscode_2 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const stdio_service_1 = __webpack_require__(3058);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const constants_2 = __webpack_require__(6249);
const utils_2 = __webpack_require__(7220);
const debug_1 = __webpack_require__(4635);
const config_1 = __webpack_require__(4165);
const processes_2 = __webpack_require__(5430);
const embedded_view_1 = __webpack_require__(8397);
const devtoolsPackageID = "devtools";
const devtoolsPackageName = "Dart DevTools";
// This starts off undefined, which means we'll read from config.devToolsPort and fall back to undefined (use default).
// Once we get a port we'll update this variable so that if we restart (eg. a silent extension restart due to
// SDK change or similar) we will try to use the same port, so if the user has browser windows open they're
// still valid.
let portToBind;
/// Handles launching DevTools in the browser and managing the underlying service.
class DevToolsManager {
    constructor(logger, workspaceContext, debugCommands, analytics, pubGlobal, dartCapabilities, flutterCapabilities, flutterDaemon) {
        this.logger = logger;
        this.workspaceContext = workspaceContext;
        this.debugCommands = debugCommands;
        this.analytics = analytics;
        this.pubGlobal = pubGlobal;
        this.dartCapabilities = dartCapabilities;
        this.flutterCapabilities = flutterCapabilities;
        this.flutterDaemon = flutterDaemon;
        this.disposables = [];
        this.statusBarItem = vs.languages.createLanguageStatusItem("dart.devTools", constants_2.ANALYSIS_FILTERS);
        this.devToolsEmbeddedViews = {};
        this.statusBarItem.text = "Dart DevTools";
        this.statusBarItem.name = "Dart/Flutter DevTools";
        this.setNotStartedStatusBar();
        this.disposables.push(this.statusBarItem);
        this.handleEagerActivationAndStartup(workspaceContext);
    }
    get devToolsActivation() { return this.devToolsActivationPromise; }
    setNotStartedStatusBar() {
        this.statusBarItem.detail = "Not Started";
        this.statusBarItem.command = {
            command: "dart.openDevTools",
            title: "start & launch",
            tooltip: "Start and Launch DevTools",
        };
    }
    handleEagerActivationAndStartup(workspaceContext) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.startDevToolsServerEagerly) {
                try {
                    if ((_b = workspaceContext.config) === null || _b === void 0 ? void 0 : _b.startDevToolsServerEagerly) {
                        yield this.spawnIfRequired(true);
                    }
                }
                catch (e) {
                    this.logger.error("Failed to background start DevTools");
                    this.logger.error(e);
                    vs.window.showErrorMessage(`Failed to start DevTools: ${e}`);
                }
            }
        });
    }
    preActivate(silent) {
        return __awaiter(this, void 0, void 0, function* () {
            this.devToolsActivationPromise = this.pubGlobal.backgroundActivate(devtoolsPackageName, devtoolsPackageID, silent);
            yield this.devToolsActivationPromise;
        });
    }
    routeIdForPage(page) {
        if (!page)
            return undefined;
        if (page.routeId)
            return page.routeId(this.flutterCapabilities.version);
        return page.id;
    }
    spawnIfRequired(silent = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If we're mid-silent-activation, wait until that's finished.
            yield this.devToolsActivationPromise;
            if (!this.devtoolsUrl) {
                this.setNotStartedStatusBar();
                // Ensure the Pub version of DevTools is installed if we're not launching from the daemon or
                // the version from the Dart SDK.
                if (!this.dartCapabilities.supportsDartDevTools) {
                    const installedVersion = yield this.pubGlobal.installIfRequired({
                        moreInfoLink: undefined,
                        packageID: devtoolsPackageID,
                        packageName: devtoolsPackageName,
                        requiredVersion: "0.9.6",
                        silent,
                        skipOptionalUpdates: !config_1.config.updateDevTools,
                        updateSilently: true,
                    });
                    // If install failed, we can't start.
                    if (!installedVersion) {
                        return undefined;
                    }
                }
                // Ignore silent flag if we're using a custom DevTools, because it could
                // take much longer to start and won't be obvious why launching isn't working.
                const isCustomDevTools = !!((_a = config_1.config.customDevTools) === null || _a === void 0 ? void 0 : _a.script);
                const startingTitle = isCustomDevTools ? "Starting Custom Dart DevTools…" : "Starting Dart DevTools…";
                if (silent && !isCustomDevTools) {
                    this.devtoolsUrl = this.startServer();
                }
                else {
                    this.devtoolsUrl = vs.window.withProgress({
                        location: vs.ProgressLocation.Notification,
                        title: startingTitle,
                    }, () => __awaiter(this, void 0, void 0, function* () { return this.startServer(); }));
                }
            }
            const url = yield this.devtoolsUrl;
            this.statusBarItem.text = "Dart DevTools";
            this.statusBarItem.detail = "Started";
            this.statusBarItem.command = {
                command: "dart.openDevTools",
                title: "launch",
                tooltip: `DevTools is running at ${url}`,
            };
            return url;
        });
    }
    /// Spawns DevTools and returns the full URL to open without a debug session.
    spawnForNoSession() {
        return __awaiter(this, void 0, void 0, function* () {
            this.analytics.logDebuggerOpenDevTools();
            const url = yield this.spawnIfRequired();
            if (!url)
                return;
            try {
                utils_2.envUtils.openInBrowser(url.toString(), this.logger);
            }
            catch (e) {
                this.showError(e);
            }
        });
    }
    /// Spawns DevTools and returns the full URL to open for that session
    ///   eg. http://127.0.0.1:8123/?port=8543
    spawnForSession(session, options) {
        return __awaiter(this, void 0, void 0, function* () {
            this.analytics.logDebuggerOpenDevTools();
            const url = yield this.spawnIfRequired();
            if (!url)
                return;
            if (options.location === undefined)
                options.location = config_1.config.devToolsLocation;
            if (!vscode_2.vsCodeVersion.supportsEmbeddedDevTools)
                options.location = "external";
            if (options.reuseWindows === undefined)
                options.reuseWindows = config_1.config.devToolsReuseWindows;
            // When we're running embedded and were asked to open without a page, we should prompt for a page (plus give an option
            // to open non-embedded view).
            if (options.location !== "external" && !options.page) {
                const choice = options.page === null ? "EXTERNAL" : yield this.promptForDevToolsPage();
                if (!choice) // User cancelled
                    return;
                else if (choice === "EXTERNAL")
                    options.location = "external";
                else
                    options.page = choice.page;
            }
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                    title: "Opening DevTools...",
                }, () => __awaiter(this, void 0, void 0, function* () {
                    const canLaunchDevToolsThroughService = utils_2.isRunningLocally
                        && options.location === "external"
                        && !constants_1.isDartCodeTestRun
                        && config_1.config.devToolsBrowser === "chrome"
                        && (yield (0, promises_1.waitFor)(() => this.debugCommands.vmServices.serviceIsRegistered(enums_1.VmService.LaunchDevTools), 500));
                    yield this.launch(!!canLaunchDevToolsThroughService, session, options);
                }));
                return { url, dispose: () => this.dispose() };
            }
            catch (e) {
                this.showError(e);
            }
        });
    }
    promptForDevToolsPage() {
        return __awaiter(this, void 0, void 0, function* () {
            const choices = [
                ...constants_1.devToolsPages.map((page) => ({
                    label: `Open ${page.title} Page`,
                    page,
                })),
                { label: `Open DevTools in Web Browser`, isExternal: true },
            ];
            const choice = yield vs.window.showQuickPick(choices, { placeHolder: "Which DevTools page?" });
            if (!choice)
                return undefined;
            else if (choice.isExternal)
                return "EXTERNAL";
            else if (choice.page)
                return { page: choice.page };
            else
                return undefined; // Shouldn't get here...
        });
    }
    showError(e) {
        this.logger.error(e);
        vs.window.showErrorMessage(`${e}`);
    }
    /// When a new Debug session starts, we can reconnect any views that are still open
    // in the disconnected state.
    reconnectDisconnectedEmbeddedViews(session) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.devtoolsUrl)
                return;
            for (const pageId of Object.keys(this.devToolsEmbeddedViews)) {
                const page = constants_1.devToolsPages.find((p) => p.id === pageId);
                const panels = this.devToolsEmbeddedViews[pageId];
                if (!panels)
                    continue;
                // If there are disconnected panels for this page, trigger a launch
                // of the page to reuse it.
                const reusablePanel = panels.find((p) => p.session.hasEnded);
                if (reusablePanel) {
                    reusablePanel.session = session;
                    yield this.launch(false, session, { location: "beside", page });
                }
            }
        });
    }
    getDefaultPage() {
        return debug_1.isInFlutterDebugModeDebugSession
            ? constants_1.widgetInspectorPage
            : debug_1.isInFlutterProfileModeDebugSession
                ? constants_1.performancePage
                : constants_1.cpuProfilerPage;
    }
    launch(allowLaunchThroughService, session, options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const url = yield this.devtoolsUrl;
            if (!url) {
                this.showError(`DevTools URL not available`);
                return;
            }
            const queryParams = {
                inspectorRef: options.inspectorRef,
                theme: config_1.config.useDevToolsDarkTheme && options.location === "external" ? "dark" : undefined,
            };
            // Try to launch via service if allowed.
            if (allowLaunchThroughService && (yield this.launchThroughService(session, Object.assign(Object.assign({}, options), { queryParams, page: this.routeIdForPage((_a = options.page) !== null && _a !== void 0 ? _a : this.getDefaultPage()) }))))
                return true;
            // Otherwise, fall back to embedded or launching manually.
            if (options.page)
                queryParams.page = this.routeIdForPage(options.page);
            if (options.location !== "external")
                queryParams.embed = "true";
            const fullUrl = yield this.buildDevToolsUrl(queryParams, session.vmServiceUri, url);
            if (options.location !== "external") {
                const exposedUrl = yield utils_2.envUtils.exposeUrl(fullUrl);
                this.launchInEmbeddedWebView(exposedUrl, session, (_b = options.page) !== null && _b !== void 0 ? _b : constants_1.devToolsPages[0], options.location);
            }
            else {
                yield utils_2.envUtils.openInBrowser(fullUrl, this.logger);
            }
        });
    }
    buildDevToolsUrl(queryParams, vmServiceUri, url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            queryParams.hide = "debugger";
            queryParams.ide = "VSCode";
            // Handle new Path URL DevTools.
            let path = "";
            if (this.dartCapabilities.supportsDartDevToolsPathUrls) {
                path = (_a = queryParams.page) !== null && _a !== void 0 ? _a : "";
                delete queryParams.page;
            }
            const paramsString = Object.keys(queryParams)
                .filter((key) => queryParams[key] !== undefined)
                .map((key) => { var _a; return `${encodeURIComponent(key)}=${encodeURIComponent((_a = queryParams[key]) !== null && _a !== void 0 ? _a : "")}`; })
                .join("&");
            const exposedUrl = yield utils_2.envUtils.exposeUrl(vmServiceUri, this.logger);
            const urlPathSeperator = url.endsWith("/") ? "" : "/";
            return `${url}${urlPathSeperator}${path}?uri=${encodeURIComponent(exposedUrl)}&${paramsString}`;
        });
    }
    launchInEmbeddedWebView(uri, session, page, location) {
        var _a, _b;
        const pageId = page.id;
        if (!this.devToolsEmbeddedViews[pageId]) {
            this.devToolsEmbeddedViews[pageId] = [];
        }
        // Look through any open DevTools frames for this page, to see if any are already our session, or
        // are for a session that has been stopped.
        let frame = (_a = this.devToolsEmbeddedViews[pageId]) === null || _a === void 0 ? void 0 : _a.find((dtev) => dtev.session === session || dtev.session.hasEnded);
        if (!frame) {
            frame = new embedded_view_1.DevToolsEmbeddedView(session, uri, page, location);
            frame.onDispose.listen(() => delete this.devToolsEmbeddedViews[pageId]);
            (_b = this.devToolsEmbeddedViews[pageId]) === null || _b === void 0 ? void 0 : _b.push(frame);
        }
        frame === null || frame === void 0 ? void 0 : frame.load(session, uri);
    }
    launchThroughService(session, params) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield session.session.customRequest("callService", {
                    method: this.debugCommands.vmServices.getServiceMethodName(enums_1.VmService.LaunchDevTools),
                    params,
                });
                return true;
            }
            catch (e) {
                this.logger.error(`DevTools failed to launch Chrome, will launch default browser locally instead: ${e.message}`);
                vs.window.showWarningMessage(`Dart DevTools was unable to launch Chrome so your default browser was launched instead.`, "Show Full Error").then((res) => {
                    var _a;
                    if (res) {
                        const fileName = `bug-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
                        const tempPath = path.join(os.tmpdir(), fileName);
                        fs.writeFileSync(tempPath, `${(_a = e.message) !== null && _a !== void 0 ? _a : e}`);
                        vscode_1.workspace.openTextDocument(tempPath).then((document) => {
                            vscode_1.window.showTextDocument(document);
                        });
                    }
                });
                return false;
            }
        });
    }
    /// Starts the devtools server and returns the URL of the running app.
    startServer(hasReinstalled = false) {
        return new Promise((resolve, reject) => {
            var _a;
            if (this.service) {
                try {
                    this.service.dispose();
                    this.service = undefined;
                    this.devtoolsUrl = undefined;
                }
                catch (e) {
                    this.logger.error(e);
                }
            }
            this.service = new DevToolsService(this.logger, this.workspaceContext, this.dartCapabilities);
            const service = this.service;
            this.disposables.push(service);
            service.registerForServerStarted((n) => {
                // When a new debug session starts, we need to wait for its VM
                // Service, then register it with this server.
                this.disposables.push(this.debugCommands.onDebugSessionVmServiceAvailable((session) => __awaiter(this, void 0, void 0, function* () {
                    if (session.vmServiceUri) {
                        service.vmRegister({ uri: session.vmServiceUri });
                        // Also reconnect any orphaned DevTools views.
                        yield this.reconnectDisconnectedEmbeddedViews(session);
                    }
                })));
                // And send any existing sessions we have.
                for (const session of debug_1.debugSessions) {
                    if (session.vmServiceUri)
                        service.vmRegister({ uri: session.vmServiceUri });
                }
                portToBind = n.port;
                resolve(`http://${n.host}:${n.port}/`);
            });
            (_a = service.process) === null || _a === void 0 ? void 0 : _a.on("close", (code) => __awaiter(this, void 0, void 0, function* () {
                this.devtoolsUrl = undefined;
                this.setNotStartedStatusBar();
                if (code && code !== 0) {
                    // Reset the port to 0 on error in case it was from us trying to reuse the previous port.
                    portToBind = 0;
                    const errorMessage = `${devtoolsPackageName} exited with code ${code}.`;
                    this.logger.error(errorMessage);
                    // If we haven't tried reinstalling, prompt to retry.
                    if (!hasReinstalled) {
                        const resp = yield vs.window.showErrorMessage(`${errorMessage} Would you like to try reactivating DevTools?`, constants_1.reactivateDevToolsAction, constants_1.skipAction);
                        if (resp === constants_1.reactivateDevToolsAction) {
                            try {
                                yield this.preActivate(false);
                                resolve(yield this.startServer(true));
                            }
                            catch (e) {
                                reject(e);
                            }
                            return;
                        }
                    }
                    reject(errorMessage);
                }
            }));
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DevToolsManager = DevToolsManager;
/// Handles running the DevTools process (via pub, or dart).
///
/// This is not used for internal workspaces (see startDevToolsFromDaemon).
class DevToolsService extends stdio_service_1.StdIOService {
    constructor(logger, workspaceContext, dartCapabilities) {
        var _a;
        super(new logging_1.CategoryLogger(logger, enums_1.LogCategory.DevTools), config_1.config.maxLogLineLength);
        this.serverStartedSubscriptions = [];
        const dartVm = path.join(workspaceContext.sdks.dart, constants_1.dartVMPath);
        const devToolsArgs = ["--machine", "--try-ports", "10", "--allow-embedding"];
        const customDevTools = config_1.config.customDevTools;
        const executionInfo = (customDevTools === null || customDevTools === void 0 ? void 0 : customDevTools.script) ?
            {
                args: [customDevTools.script],
                cwd: customDevTools.cwd,
                env: customDevTools.env,
                executable: dartVm,
            }
            : dartCapabilities.supportsDartDevTools
                ? (0, utils_1.usingCustomScript)(dartVm, ["devtools"], (_a = workspaceContext.config) === null || _a === void 0 ? void 0 : _a.flutterDevToolsScript)
                : (0, processes_1.getPubExecutionInfo)(dartCapabilities, workspaceContext.sdks.dart, ["global", "run", "devtools"]);
        const binPath = executionInfo.executable;
        const binArgs = [...executionInfo.args, ...devToolsArgs];
        const binCwd = executionInfo.cwd;
        const binEnv = executionInfo.env;
        // Store the port we'll use for later so we can re-bind to the same port if we restart.
        portToBind = config_1.config.devToolsPort // Always config first
            || portToBind; // Then try the last port we bound this session
        if (portToBind) {
            binArgs.push("--port");
            binArgs.push(portToBind.toString());
        }
        this.registerForServerStarted((n) => this.additionalPidsToTerminate.push(n.pid));
        this.createProcess(binCwd, binPath, binArgs, { toolEnv: (0, processes_2.getToolEnv)(), envOverrides: binEnv });
    }
    shouldHandleMessage(message) {
        return message.startsWith("{") && message.endsWith("}");
    }
    // TODO: Remove this if we fix the DevTools server (and rev min version) to not use method for
    // the server.started event.
    isNotification(msg) { return msg.event || msg.method === "server.started"; }
    handleNotification(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.method || evt.event) {
                case "server.started":
                    yield this.notify(this.serverStartedSubscriptions, evt.params);
                    break;
            }
        });
    }
    registerForServerStarted(subscriber) {
        return this.subscribe(this.serverStartedSubscriptions, subscriber);
    }
    vmRegister(request) {
        return this.sendRequest("vm.register", request);
    }
}


/***/ }),

/***/ 3546:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initializeFlutterSdk = void 0;
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const channels = __webpack_require__(1026);
const extension_1 = __webpack_require__(1892);
const utils_1 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
function initializeFlutterSdk(logger, flutterScript) {
    return __awaiter(this, void 0, void 0, function* () {
        logger.info(`Flutter is not initialized, running 'flutter doctor' to force...`);
        try {
            yield vscode_1.window.withProgress({
                location: vscode_1.ProgressLocation.Notification,
                title: constants_1.initializingFlutterMessage,
            }, (progress, cancellationToken) => __awaiter(this, void 0, void 0, function* () {
                const proc = (0, processes_1.safeToolSpawn)(undefined, flutterScript, ["doctor", "-v"]);
                // Show the output in an output channel so if it gets stuck the user can see it.
                const channel = channels.getOutputChannel(`flutter doctor`);
                channel.show();
                channels.runProcessInOutputChannel(proc, channel);
                cancellationToken.onCancellationRequested((e) => {
                    logger.info(`User canceled!`);
                    proc.kill();
                });
                // Log this to general as it's startup stuff that can't be captured with
                // Capture Logs so log it to the main log file.
                (0, logging_1.logProcess)(logger, enums_1.LogCategory.General, proc);
                return new Promise((resolve, reject) => proc.on("exit", (code) => {
                    if (code) {
                        const ringLogContents = extension_1.ringLog.toString();
                        logger.error(`Failed to initialize Flutter: Process exited with code ${code}.`);
                        vscode_1.window.showErrorMessage(`Failed to initialize Flutter: Process exited with code ${code}.`, constants_1.showLogAction).then((chosenAction) => {
                            if (chosenAction === constants_1.showLogAction)
                                (0, utils_1.openLogContents)(undefined, ringLogContents);
                        });
                        reject();
                    }
                    else {
                        resolve();
                    }
                }));
            }));
            logger.info(`Flutter initialized!`);
        }
        catch (e) {
            logger.warn(`Flutter initialization failed, proceeding without!`);
        }
    });
}
exports.initializeFlutterSdk = initializeFlutterSdk;


/***/ }),

/***/ 8137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlutterSnippets = void 0;
const fs = __webpack_require__(7147);
const https = __webpack_require__(5687);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const processes_1 = __webpack_require__(5430);
function getFlutterSnippets(logger, sdks, capabilities) {
    if (capabilities.supportsFlutterCreateListSamples)
        return getFlutterSnippetsFromSdk(logger, sdks);
    return getFlutterSnippetsFromWeb();
}
exports.getFlutterSnippets = getFlutterSnippets;
function getFlutterSnippetsFromSdk(logger, sdks) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!sdks.flutter)
            throw new Error("Flutter SDK not available");
        const binPath = path.join(sdks.flutter, constants_1.flutterPath);
        const fileName = `flutter-samples-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`;
        const tempPath = path.join(os.tmpdir(), fileName);
        try {
            const res = yield (0, processes_1.runToolProcess)(logger, undefined, binPath, ["create", "--list-samples", tempPath]);
            if (res.exitCode !== 0)
                throw new Error(`Failed to get Flutter samples from SDK (${res.exitCode})\n\n${res.stderr}\n\n${res.stdout}`);
            const json = fs.readFileSync(tempPath, { encoding: "utf8" });
            return JSON.parse(json);
        }
        finally {
            (0, fs_1.tryDeleteFile)(tempPath);
        }
    });
}
function getFlutterSnippetsFromWeb() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "api.flutter.dev",
            method: "GET",
            path: "/snippets/index.json",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Flutter samples ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                const chunks = [];
                resp.on("data", (b) => chunks.push(b.toString()));
                resp.on("end", () => {
                    const json = chunks.join("");
                    resolve(JSON.parse(json));
                });
            }
        });
        req.end();
    });
}


/***/ }),

/***/ 3570:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSdkManager = exports.DartSdkManager = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
class SdkManager {
    constructor(logger, sdks) {
        this.logger = logger;
        this.sdks = sdks;
    }
    changeSdk() {
        if (this.sdkPaths)
            this.searchForSdks(this.sdkPaths).catch((e) => console.error(e));
        else
            vs.window.showWarningMessage("Set `${configName}` to enable fast SDK switching.");
    }
    searchForSdks(sdkPaths) {
        return __awaiter(this, void 0, void 0, function* () {
            let allPaths = [];
            for (const sdkPath of sdkPaths.filter(fs.existsSync)) {
                allPaths.push(sdkPath);
                // Add immediate children to support folders-of-SDKs.
                allPaths = allPaths.concat(yield (0, fs_1.getChildFolders)(this.logger, sdkPath));
            }
            // Add in the current path if it's not there.
            if (this.currentSdk && allPaths.indexOf(this.currentSdk) === -1)
                allPaths.push(this.currentSdk);
            const sdkFolders = allPaths
                // We don't need to check isDirectory, since existsSync() will just return false
                // if we join a filename on the end of another.
                // .filter((f) => fs.statSync(f).isDirectory()) // Only directories.
                .filter((f) => fs.existsSync(path.join(f, this.executablePath))); // Only those that look like SDKs.
            const sdkItems = sdkFolders.map((f) => {
                // Resolve synlinks so we look in correct folder for version file.
                const actualBinary = fs.realpathSync(path.join(f, this.executablePath));
                // Then we need to take the executable name and /bin back off
                const actualFolder = path.dirname(path.dirname(actualBinary));
                const version = (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: actualFolder });
                return {
                    description: f === this.currentSdk && this.configuredSdk ? "Current setting" : "",
                    detail: f,
                    folder: f,
                    label: version ? this.getLabel(version) : "Unknown version",
                    version,
                };
            })
                .sort((a, b) => (0, utils_1.versionIsAtLeast)(a.version || "0.0.0", b.version || "0.0.0") ? 1 : -1);
            if (sdkItems.length === 0)
                return;
            const items = [{
                    description: !this.configuredSdk ? "Current setting" : "",
                    detail: !this.configuredSdk ? `Found at ${this.currentSdk}` : undefined,
                    folder: undefined,
                    label: "Auto-detect SDK location",
                    version: undefined,
                }].concat(sdkItems);
            vs.window.showQuickPick(items, { placeHolder: "Select an SDK to use" })
                .then((sdk) => { if (sdk)
                this.setSdk(sdk.folder); });
        });
    }
}
class DartSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.sdkPaths; }
    get currentSdk() { return this.sdks.dart; }
    get configuredSdk() { return config_1.config.sdkPath; }
    get configName() { return "dart.sdkPaths"; }
    get executablePath() { return constants_1.dartVMPath; }
    getLabel(version) {
        return `Dart SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setSdkPath(folder); }
}
exports.DartSdkManager = DartSdkManager;
class FlutterSdkManager extends SdkManager {
    get sdkPaths() { return config_1.config.flutterSdkPaths; }
    get currentSdk() { return this.sdks.flutter; }
    get configuredSdk() { return config_1.config.flutterSdkPath; }
    get configName() { return "dart.flutterSdkPaths"; }
    get executablePath() { return constants_1.flutterPath; }
    getLabel(version) {
        return `Flutter SDK ${version}`;
    }
    setSdk(folder) { config_1.config.setFlutterSdkPath(folder); }
}
exports.FlutterSdkManager = FlutterSdkManager;


/***/ }),

/***/ 9032:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatusBarVersionTracker = void 0;
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const constants_2 = __webpack_require__(6249);
const config_1 = __webpack_require__(4165);
class StatusBarVersionTracker {
    constructor(workspaceContext, isLsp) {
        this.disposables = [];
        const isFlutter = workspaceContext.hasAnyFlutterProjects;
        const dartIsFromFlutter = workspaceContext.sdks.dartSdkIsFromFlutter;
        const canChangeFlutterSdk = config_1.config.flutterSdkPaths && config_1.config.flutterSdkPaths.length > 0;
        const canChangeDartSdk = !isFlutter && config_1.config.sdkPaths && config_1.config.sdkPaths.length > 0;
        const flutterVersion = this.versionOrLatest(workspaceContext.sdks.flutterVersion);
        let dartVersion = this.versionOrLatest(workspaceContext.sdks.dartVersion);
        if (dartIsFromFlutter)
            dartVersion = `${dartVersion} (Flutter)`;
        if (dartVersion) {
            this.addStatusBarItem("dart.sdkVersion", "Dart", dartVersion, canChangeDartSdk ? "dart.changeSdk" : undefined);
        }
        if (isFlutter && flutterVersion) {
            this.addStatusBarItem("dart.flutterSdkVersion", "Flutter", flutterVersion, canChangeFlutterSdk ? "dart.changeFlutterSdk" : undefined);
        }
    }
    versionOrLatest(version) {
        return version === constants_1.MAX_VERSION ? "latest" : version;
    }
    addStatusBarItem(id, text, detail, command) {
        const statusBarItem = vs.languages.createLanguageStatusItem(id, constants_2.ANALYSIS_FILTERS);
        statusBarItem.text = `${text} SDK`;
        statusBarItem.name = statusBarItem.text;
        statusBarItem.detail = detail;
        if (command)
            statusBarItem.command = {
                command,
                title: "change",
            };
        this.disposables.push(statusBarItem);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.StatusBarVersionTracker = StatusBarVersionTracker;


/***/ }),

/***/ 8949:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkForStandardDartSdkUpdates = void 0;
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_3 = __webpack_require__(8779);
function checkForStandardDartSdkUpdates(logger, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!config_1.config.checkForSdkUpdates || workspaceContext.config.disableSdkUpdateChecks)
            return;
        // Sometimes people use the Dart SDK inside Flutter for non-Flutter projects. Since that SDK is
        // versioned with Flutter, it never makes sense to prompt the user to update the Dart SDK.
        if (workspaceContext.sdks.dartSdkIsFromFlutter)
            return;
        const dartSdkVersion = workspaceContext.sdks.dartVersion;
        try {
            const version = yield (0, utils_3.getLatestSdkVersion)();
            if (!dartSdkVersion || (0, utils_1.versionIsAtLeast)(dartSdkVersion, version))
                return;
            const goToDownloadsAction = "Go to Dart Downloads";
            const dontShowAgainAction = "Disable Update Checks";
            const message = `Version ${version} of the Dart SDK is available (you have ${dartSdkVersion}). Some features of Dart Code may not work correctly with an old SDK.`;
            const action = yield vscode_1.window.showWarningMessage(message, goToDownloadsAction, dontShowAgainAction);
            if (action === goToDownloadsAction)
                yield utils_2.envUtils.openInBrowser(constants_1.DART_DOWNLOAD_URL);
            else if (action === dontShowAgainAction)
                config_1.config.setCheckForSdkUpdates(false);
        }
        catch (e) {
            logger.error(e);
        }
    });
}
exports.checkForStandardDartSdkUpdates = checkForStandardDartSdkUpdates;


/***/ }),

/***/ 8461:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hasDartAnalysisServer = exports.SdkUtils = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const promises_1 = __webpack_require__(776);
const workspace_1 = __webpack_require__(2479);
const utils_2 = __webpack_require__(7220);
const workspace_2 = __webpack_require__(2329);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const utils_3 = __webpack_require__(8779);
const flutter_1 = __webpack_require__(3546);
// TODO: Tidy this class up (it exists mainly to share logger).
class SdkUtils {
    constructor(logger) {
        this.logger = logger;
        this.hasShownActivationFailure = false;
    }
    handleMissingSdks(context, analytics, workspaceContext) {
        // Note: This code only runs if we fail to find the Dart SDK, or fail to find the Flutter SDK
        // and are in a Flutter project. In the case where we fail to find the Flutter SDK but are not
        // in a Flutter project (eg. we ran Flutter Doctor without the extension activated) then
        // this code will not be run as the extension will activate normally, and then the command-handling
        // code for each command will detect the missing Flutter SDK and respond appropriately.
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("dart.createProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, false, "dart.createProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("_dart.flutter.createSampleProject", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "_dart.flutter.createSampleProject");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.doctor", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.doctor");
        }));
        context.subscriptions.push(vscode_1.commands.registerCommand("flutter.upgrade", () => {
            this.showRelevantActivationFailureMessage(analytics, workspaceContext, true, "flutter.upgrade");
        }));
        // Wait a while before showing the error to allow the code above to have run if it will.
        setTimeout(() => {
            // Only show the "startup" message if we didn't already show another message as
            // a result of one of the above commands beinv invoked.
            if (!this.hasShownActivationFailure) {
                if (workspaceContext.hasAnyFlutterProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, true);
                }
                else if (workspaceContext.hasAnyStandardDartProjects) {
                    this.showRelevantActivationFailureMessage(analytics, workspaceContext, false);
                }
                else {
                    this.logger.error("No Dart or Flutter SDK was found. Suppressing prompt because it doesn't appear that a Dart/Flutter project is open.");
                }
            }
        }, 500);
        return;
    }
    showRelevantActivationFailureMessage(analytics, workspaceContext, isFlutter, commandToReRun) {
        if (isFlutter && workspaceContext.sdks.flutter && !workspaceContext.sdks.dart) {
            this.showFluttersDartSdkActivationFailure();
        }
        else if (isFlutter) {
            this.showFlutterActivationFailure(commandToReRun);
        }
        else {
            this.showDartActivationFailure(commandToReRun);
        }
        if (!this.hasShownActivationFailure) {
            analytics.logSdkDetectionFailure();
            this.hasShownActivationFailure = true;
        }
    }
    showFluttersDartSdkActivationFailure() {
        // tslint:disable-next-line: no-floating-promises
        (0, utils_3.promptToReloadExtension)("Could not find Dart in your Flutter SDK. " +
            "Please run 'flutter doctor' in the terminal then reload the project once all issues are resolved.", "Reload", // eslint-disable-line @typescript-eslint/indent
        true);
    }
    showFlutterActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Flutter", (p) => this.findFlutterSdk(p), constants_1.FLUTTER_DOWNLOAD_URL, (p) => config_1.config.setGlobalFlutterSdkPath(p), commandToReRun);
    }
    showDartActivationFailure(commandToReRun) {
        // tslint:disable-next-line: no-floating-promises
        this.showSdkActivationFailure("Dart", (p) => this.findDartSdk(p), constants_1.DART_DOWNLOAD_URL, (p) => config_1.config.setGlobalDartSdkPath(p), commandToReRun);
    }
    showSdkActivationFailure(sdkType, search, downloadUrl, saveSdkPath, commandToReRun) {
        return __awaiter(this, void 0, void 0, function* () {
            const locateAction = "Locate SDK";
            const downloadAction = "Download SDK";
            let displayMessage = `Could not find a ${sdkType} SDK. ` +
                `Please ensure ${sdkType.toLowerCase()} is installed and in your PATH (you may need to restart).`;
            while (true) {
                const ringLogContents = extension_1.ringLog.toString();
                const selectedItem = yield vscode_1.window.showErrorMessage(displayMessage, locateAction, downloadAction, constants_1.showLogAction);
                // TODO: Refactor/reformat/comment this code - it's messy and hard to understand!
                if (selectedItem === locateAction) {
                    const selectedFolders = yield vscode_1.window.showOpenDialog({ canSelectFolders: true, openLabel: `Set ${sdkType} SDK folder` });
                    if (selectedFolders && selectedFolders.length > 0) {
                        const matchingSdkFolder = search(selectedFolders.map((f) => (0, fs_1.fsPath)(f)));
                        if (matchingSdkFolder.sdkPath) {
                            yield saveSdkPath(matchingSdkFolder.sdkPath);
                            yield (0, utils_3.promptToReloadExtension)();
                            if (commandToReRun) {
                                vscode_1.commands.executeCommand(commandToReRun);
                            }
                            break;
                        }
                        else {
                            displayMessage = `That folder does not appear to be a ${sdkType} SDK.`;
                        }
                    }
                }
                else if (selectedItem === downloadAction) {
                    yield utils_2.envUtils.openInBrowser(downloadUrl);
                    break;
                }
                else if (selectedItem === constants_1.showLogAction) {
                    (0, utils_3.openLogContents)(undefined, ringLogContents);
                    break;
                }
                else {
                    break;
                }
            }
        });
    }
    scanWorkspace() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.info("Searching for SDKs...");
            const pathOverride = process.env.DART_PATH_OVERRIDE || "";
            const normalPath = process.env.PATH || "";
            const paths = (pathOverride + path.delimiter + normalPath).split(path.delimiter).filter((p) => p);
            this.logger.info("Environment PATH:");
            for (const p of paths)
                this.logger.info(`    ${p}`);
            // If we are running the analyzer remotely over SSH, we only support an analyzer, since none
            // of the other SDKs will work remotely. Also, there is no need to validate the sdk path,
            // since that file will exist on a remote machine.
            if (config_1.config.analyzerSshHost) {
                return new workspace_2.WorkspaceContext({
                    dart: config_1.config.sdkPath,
                    dartSdkIsFromFlutter: false,
                    flutter: undefined,
                }, {}, false, false, false, false);
            }
            // TODO: This has gotten very messy and needs tidying up...
            let firstFlutterMobileProject;
            let hasAnyFlutterProject = false;
            let hasAnyFlutterMobileProject = false;
            let hasAnyWebProject = false;
            let hasAnyStandardDartProject = false;
            const possibleProjects = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { searchDepth: config_1.config.projectSearchDepth });
            // Scan through them all to figure out what type of projects we have.
            for (const folder of possibleProjects) {
                const hasPubspecFile = (0, fs_1.hasPubspec)(folder);
                const refsFlutter = hasPubspecFile && (0, fs_1.projectReferencesFlutterSdk)(folder);
                const refsWeb = false; // hasPubspecFile && referencesWeb(folder);
                const hasFlutterCreateProjectTriggerFile = fs.existsSync(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
                // Special case to detect the Flutter repo root, so we always consider it a Flutter project and will use the local SDK
                const isFlutterRepo = fs.existsSync(path.join(folder, "bin/flutter")) && fs.existsSync(path.join(folder, "bin/cache/dart-sdk"));
                // Since we just blocked on a lot of sync FS, yield.
                yield promises_1.resolvedPromise;
                const isSomethingFlutter = refsFlutter || hasFlutterCreateProjectTriggerFile || isFlutterRepo;
                if (isSomethingFlutter) {
                    this.logger.info(`Found Flutter project at ${folder}:
			Mobile? ${refsFlutter}
			Web? ${refsWeb}
			Create Trigger? ${hasFlutterCreateProjectTriggerFile}
			Flutter Repo? ${isFlutterRepo}`);
                }
                // Track the first Flutter Project so we can try finding the Flutter SDK from its packages file.
                firstFlutterMobileProject = firstFlutterMobileProject || (isSomethingFlutter ? folder : undefined);
                // Set some flags we'll use to construct the workspace, so we know what things we need to light up.
                hasAnyFlutterProject = hasAnyFlutterProject || isSomethingFlutter;
                hasAnyFlutterMobileProject = hasAnyFlutterMobileProject || refsFlutter || hasFlutterCreateProjectTriggerFile;
                hasAnyWebProject = hasAnyWebProject || refsWeb;
                hasAnyStandardDartProject = hasAnyStandardDartProject || (!isSomethingFlutter && hasPubspecFile);
            }
            // Certain types of workspaces will have special config, so read them here.
            const workspaceConfig = {};
            // Helper that searches for a specific folder/file up the tree and
            // runs some specific processing.
            const workspaceFolders = (0, utils_2.getDartWorkspaceFolders)();
            const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
            const processWorkspaceType = (search, process) => __awaiter(this, void 0, void 0, function* () {
                for (const folder of topLevelFolders) {
                    const root = yield search(this.logger, folder);
                    if (root) {
                        process(this.logger, workspaceConfig, root);
                        return root;
                    }
                }
                return undefined;
            });
            yield processWorkspaceType(findDartSdkRoot, workspace_1.processDartSdkRepository);
            yield processWorkspaceType(findBazelWorkspaceRoot, workspace_1.processBazelWorkspace);
            const fuchsiaRoot = yield processWorkspaceType(findFuchsiaRoot, workspace_1.processFuchsiaWorkspace);
            if (fuchsiaRoot) {
                this.logger.info(`Found Fuchsia root at ${fuchsiaRoot}`);
                if (hasAnyStandardDartProject)
                    this.logger.info(`Found Fuchsia project that is not vanilla Flutter`);
            }
            let flutterSdkPath;
            if (workspaceConfig.forceFlutterWorkspace) {
                hasAnyFlutterProject = true;
                hasAnyFlutterMobileProject = true;
                flutterSdkPath = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterSdkHome;
            }
            else {
                const flutterSdkSearchPaths = [
                    config_1.config.flutterSdkPath,
                    // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                    fuchsiaRoot && path.join(fuchsiaRoot, "lib/flutter"),
                    fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart-pkg/git/flutter"),
                    firstFlutterMobileProject,
                    firstFlutterMobileProject && (0, fs_1.extractFlutterSdkPathFromPackagesFile)(firstFlutterMobileProject),
                    firstFlutterMobileProject && path.join(firstFlutterMobileProject, ".flutter"),
                    firstFlutterMobileProject && path.join(firstFlutterMobileProject, "vendor/flutter"),
                    process.env.FLUTTER_ROOT,
                    constants_1.isLinux ? "~/snap/flutter/common/flutter" : undefined,
                    "~/flutter-sdk",
                    "/google/flutter",
                ].concat(paths).filter(utils_1.notUndefined);
                let flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
                const sdkInitScript = flutterSdkResult.sdkInitScript;
                // Handle the case where the Flutter snap has not been initialised.
                if (!flutterSdkResult.sdkPath && sdkInitScript && flutterSdkResult.candidatePaths.includes(sdkInitScript)) {
                    // Trigger initialization.
                    this.logger.info(`No Flutter SDK found, but ${sdkInitScript} looks like an init script so attempting to initialize...`);
                    yield (0, flutter_1.initializeFlutterSdk)(this.logger, sdkInitScript);
                    // Then search again.
                    this.logger.info(`Snap initialization completed, searching for Flutter SDK again...`);
                    flutterSdkResult = this.findFlutterSdk(flutterSdkSearchPaths);
                }
                flutterSdkPath = flutterSdkResult.sdkPath;
            }
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            // If we're a Flutter workspace but we couldn't get the version, try running Flutter to initialise it first.
            // Do this before searching for the Dart SDK, as it might download the Dart SDK we'd like to find.
            let hasAttemptedFlutterInitialization = false;
            if (hasAnyFlutterProject && flutterSdkPath && !workspaceConfig.skipFlutterInitialization) {
                const flutterVersion = (_a = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersion) !== null && _a !== void 0 ? _a : (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath });
                const flutterNeedsInitializing = !flutterVersion
                    || !fs.existsSync(path.join(flutterSdkPath, "bin/cache/dart-sdk"));
                if (flutterNeedsInitializing) {
                    hasAttemptedFlutterInitialization = true;
                    yield (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
                }
            }
            const dartSdkSearchPaths = [
                // TODO: These could move into processFuchsiaWorkspace and be set on the config?
                fuchsiaRoot && path.join(fuchsiaRoot, "topaz/tools/prebuilt-dart-sdk", `${constants_1.dartPlatformName}-x64`),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks/dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "third_party/dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                fuchsiaRoot && path.join(fuchsiaRoot, "dart/tools/sdks", constants_1.dartPlatformName, "dart-sdk"),
                firstFlutterMobileProject && flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk"),
                config_1.config.sdkPath,
            ].concat(paths)
                // The above array only has the Flutter SDK	in the search path if we KNOW it's a flutter
                // project, however this doesn't cover the activating-to-run-flutter.createProject so
                // we need to always look in the flutter SDK, but only AFTER the users PATH so that
                // we don't prioritise it over any real Dart versions.
                .concat([flutterSdkPath && path.join(flutterSdkPath, "bin/cache/dart-sdk")])
                .concat([workspaceConfig.defaultDartSdk])
                .filter(utils_1.notUndefined);
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            let dartSdkPath = this.findDartSdk(dartSdkSearchPaths).sdkPath;
            // Since we just blocked on a lot of sync FS, yield.
            yield promises_1.resolvedPromise;
            // If we still don't have a Dart SDK, but we do have a Flutter SDK and we did not already try to initialize, then
            // try again here. This could happen if we were not in a Flutter project (so didn't try to initialize before) but
            // still need a Dart SDK (for example, we were activated by running Flutter: New Project in an empty workspace.. we
            // wouldn't trigger the code above).
            if (!hasAttemptedFlutterInitialization && flutterSdkPath && !dartSdkPath) {
                yield (0, flutter_1.initializeFlutterSdk)(this.logger, path.join(flutterSdkPath, constants_1.flutterPath));
                dartSdkPath = this.findDartSdk([path.join(flutterSdkPath, "bin/cache/dart-sdk")]).sdkPath;
            }
            // It's possible we've opened a folder without a pubspec/etc., so before assuming this is a non-Dart project, check
            // for any Dart files in the top few folders.
            if (!hasAnyFlutterProject && !hasAnyStandardDartProject) {
                // Only look in the root and known folders to avoid a potentially slow full workspace search.
                const hasAnyDartFile = !!(yield vscode_1.workspace.findFiles("{*.dart,lib/*.dart,bin/*.dart,tool/*.dart,test/*.dart}", undefined, 1)).length;
                hasAnyStandardDartProject = hasAnyDartFile;
            }
            // Sometimes the extension is activated when there's not a Dart/Flutter project open because the
            // events are not fine-grain enough (for example `activationEvent:onDebugDynamicConfigurations`), so
            // if this seems to be the case, turn off a few things that are likely not relevant for the user.
            if (!hasAnyFlutterProject && !hasAnyStandardDartProject) {
                const wc = workspaceConfig;
                wc.disableAnalytics = true;
                wc.disableStartupPrompts = true;
                wc.disableSdkUpdateChecks = true;
            }
            return new workspace_2.WorkspaceContext({
                dart: dartSdkPath,
                dartSdkIsFromFlutter: !!dartSdkPath && (0, utils_1.isDartSdkFromFlutter)(dartSdkPath),
                dartVersion: (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: dartSdkPath }),
                flutter: flutterSdkPath,
                flutterVersion: (_b = workspaceConfig === null || workspaceConfig === void 0 ? void 0 : workspaceConfig.flutterVersion) !== null && _b !== void 0 ? _b : (0, fs_1.getSdkVersion)(this.logger, { sdkRoot: flutterSdkPath }),
            }, workspaceConfig, hasAnyFlutterMobileProject, hasAnyWebProject, hasAnyStandardDartProject, !!fuchsiaRoot && hasAnyStandardDartProject);
        });
    }
    findDartSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.dart, (p) => this.hasExecutable(p, constants_1.dartVMPath) && (0, exports.hasDartAnalysisServer)(p));
    }
    findFlutterSdk(folders) {
        return this.searchPaths(folders, constants_1.executableNames.flutter, (p) => this.hasExecutable(p, constants_1.flutterPath));
    }
    hasExecutable(folder, executablePath) {
        const fullPath = path.join(folder, executablePath);
        return fs.existsSync(fullPath) && fs.statSync(fullPath).isFile();
    }
    searchPaths(paths, executableFilename, postFilter) {
        this.logger.info(`Searching for ${executableFilename}`);
        let sdkPaths = paths
            .filter((p) => p)
            .map(utils_3.resolvePaths)
            .filter(utils_1.notUndefined);
        // Any that don't end with bin, add it on (as an extra path) since some of our
        // paths may come from places that don't already include it (for ex. the
        // user config.sdkPath).
        const isBinFolder = (f) => ["bin", "sbin"].indexOf(path.basename(f)) !== -1;
        sdkPaths = (0, utils_1.flatMap)(sdkPaths, (p) => isBinFolder(p) ? [p] : [p, path.join(p, "bin")]);
        // TODO: Make the list unique, but preserve the order of the first occurrences. We currently
        // have uniq() and unique(), so also consolidate them.
        this.logger.info(`    Looking for ${executableFilename} in:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Restrict only to the paths that have the executable.
        sdkPaths = sdkPaths.filter((p) => fs.existsSync(path.join(p, executableFilename)));
        this.logger.info(`    Found at:`);
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        // Keep track if we find something that looks like a package manager init script. These are
        // symlinks like `flutter` that resolve to other binaries (like `snap` or `hermit`) and may need
        // to be executed if we don't find a real SDK.
        let sdkInitScript;
        // Convert all the paths to their resolved locations.
        sdkPaths = sdkPaths.map((p) => {
            const fullPath = path.join(p, executableFilename);
            // In order to handle symlinks on the binary (not folder), we need to add the executableName before calling realpath.
            const realExecutableLocation = p && fs.realpathSync(fullPath);
            if (realExecutableLocation.toLowerCase() !== fullPath.toLowerCase())
                this.logger.info(`Following symlink: ${fullPath} ==> ${realExecutableLocation}`);
            // If the symlink resolves to a package manager binary, it's not a real SDK
            // and we should return as-is rather than walk up two levels, as we
            // may want to use the presence of this to trigger initialisation.
            const targetBaseName = path.basename(realExecutableLocation);
            if (targetBaseName !== executableFilename) {
                this.logger.info(`Target ${targetBaseName} is not ${executableFilename}, assuming ${fullPath} is a package manager init script`);
                sdkInitScript = fullPath;
                return fullPath;
            }
            // Then we need to take the executable name and /bin back off
            return path.dirname(path.dirname(realExecutableLocation));
        });
        // Now apply any post-filters.
        this.logger.info("    Candidate paths to be post-filtered:");
        for (const p of sdkPaths)
            this.logger.info(`        ${p}`);
        const sdkPath = sdkPaths.find(postFilter || (() => true));
        if (sdkPath)
            this.logger.info(`    Found at ${sdkPath}`);
        this.logger.info(`    Returning SDK path ${sdkPath} for ${executableFilename}`);
        return {
            candidatePaths: sdkPaths,
            sdkInitScript,
            sdkPath,
        };
    }
}
exports.SdkUtils = SdkUtils;
function findFuchsiaRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".jiri_root");
    });
}
function findBazelWorkspaceRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, "WORKSPACE", true);
    });
}
function findGitRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return findRootContaining(folder, ".git");
    });
}
function findDartSdkRoot(logger, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        const gitRoot = yield findGitRoot(logger, folder);
        if (gitRoot && fs.existsSync(path.join(gitRoot, "README.dart-sdk")) && fs.existsSync(path.join(gitRoot, "DEPS")))
            return gitRoot;
        else
            return undefined;
    });
}
function findRootContaining(folder, childName, expectFile = false) {
    if (folder) {
        // Walk up the directories from the workspace root, and see if there
        // exists a directory which has `childName` file/directory as a child.
        let child = folder;
        while (child) {
            try {
                const stat = fs.statSync(path.join(child, childName));
                if (expectFile ? stat.isFile() : stat.isDirectory()) {
                    return child;
                }
            }
            catch (_a) { }
            const parentDir = path.dirname(child);
            if (child === parentDir)
                break;
            child = parentDir;
        }
    }
    return undefined;
}
const hasDartAnalysisServer = (folder) => fs.existsSync(path.join(folder, constants_1.analyzerSnapshotPath));
exports.hasDartAnalysisServer = hasDartAnalysisServer;


/***/ }),

/***/ 4371:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartFileUriLinkProvider = void 0;
const vs = __webpack_require__(9496);
const fs_1 = __webpack_require__(300);
const terminal_link_provider_utils_1 = __webpack_require__(821);
class DartFileUriLinkProvider {
    provideTerminalLinks(context, token) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getLinks(context.line);
        });
    }
    getLinks(content) {
        return (0, terminal_link_provider_utils_1.findFileUriLinks)(content);
    }
    handleTerminalLink(link) {
        const filePath = (0, fs_1.fsPath)(link.uri);
        vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
    provideDocumentLinks(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const links = yield this.getLinks(document.getText());
            return links.map((link) => {
                const range = new vs.Range(document.positionAt(link.startIndex), document.positionAt(link.startIndex + link.length));
                return new vs.DocumentLink(range, link.uri.with({ fragment: (0, terminal_link_provider_utils_1.formatLineColFragment)(link) }));
            });
        });
    }
}
exports.DartFileUriLinkProvider = DartFileUriLinkProvider;


/***/ }),

/***/ 3760:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartPackageUriLinkProvider = void 0;
const vs = __webpack_require__(9496);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(4586);
const terminal_link_provider_utils_1 = __webpack_require__(821);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_3 = __webpack_require__(8779);
class DartPackageUriLinkProvider {
    constructor(logger, context) {
        this.logger = logger;
        this.context = context;
        context.events.onPackageMapChange.listen(() => {
            this.packageMaps = undefined;
            this.packageMapDiscovery = undefined;
        });
    }
    discoverPackageMaps() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.packageMapDiscovery) {
                return this.packageMapDiscovery;
            }
            this.packageMapDiscovery = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const projectFolders = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
                this.packageMaps = {};
                for (const projectFolder of projectFolders) {
                    this.packageMaps[projectFolder] = package_map_1.PackageMap.loadForProject(this.logger, projectFolder);
                }
                resolve();
            }));
            return this.packageMapDiscovery;
        });
    }
    isKnownPackage(packageName) {
        return !!(this.packageMaps && Object.values(this.packageMaps).find((m) => m.packages[packageName]));
    }
    resolvePackageUri(uri) {
        if (!this.packageMaps)
            return undefined;
        for (const packageMap of Object.values(this.packageMaps)) {
            const filePath = packageMap.resolvePackageUri(uri);
            if (filePath)
                return filePath;
        }
        return undefined;
    }
    provideTerminalLinks(context, token) {
        return this.getLinks(context.line);
    }
    getLinks(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.packageMaps)
                yield this.discoverPackageMaps();
            return (0, terminal_link_provider_utils_1.findPackageUriLinks)(content, (name) => this.isKnownPackage(name));
        });
    }
    handleTerminalLink(link) {
        const filePath = this.resolvePackageUri(link.uri);
        if (!filePath) {
            vs.window.showErrorMessage(`Unable to find root for package ${link.packageName}`);
            return;
        }
        vs.commands.executeCommand("_dart.jumpToLineColInUri", vs.Uri.file(filePath), link.line, link.col);
    }
    provideDocumentLinks(document, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const links = yield this.getLinks(document.getText());
            return links.map((link) => {
                const range = new vs.Range(document.positionAt(link.startIndex), document.positionAt(link.startIndex + link.length));
                const filePath = this.resolvePackageUri(link.uri);
                if (!filePath)
                    return undefined;
                return new vs.DocumentLink(range, vs.Uri.file(filePath).with({ fragment: (0, terminal_link_provider_utils_1.formatLineColFragment)(link) }));
            }).filter(utils_1.notUndefined);
        });
    }
}
exports.DartPackageUriLinkProvider = DartPackageUriLinkProvider;


/***/ }),

/***/ 2601:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VsCodeTestController = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const enums_1 = __webpack_require__(7341);
const test_model_1 = __webpack_require__(1159);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
const terminals_1 = __webpack_require__(6368);
const runnableTestTag = new vs.TestTag("DartRunnableTest");
class VsCodeTestController {
    constructor(logger, model, discoverer) {
        this.logger = logger;
        this.model = model;
        this.discoverer = discoverer;
        this.disposables = [];
        this.itemForNode = new WeakMap();
        this.nodeForItem = new WeakMap();
        this.testRuns = {};
        const controller = vs.tests.createTestController("dart", "Dart & Flutter");
        this.controller = controller;
        this.disposables.push(controller);
        this.disposables.push(model.onDidChangeTreeData.listen((node) => this.onDidChangeTreeData(node)));
        this.disposables.push(vs.debug.onDidTerminateDebugSession((e) => this.handleDebugSessionEnd(e)));
        model.addTestEventListener(this);
        if (discoverer)
            controller.resolveHandler = (item) => this.resolveTestItem(item);
        controller.createRunProfile("Run", vs.TestRunProfileKind.Run, (request, token) => this.runTests(false, request, token), false, runnableTestTag);
        controller.createRunProfile("Debug", vs.TestRunProfileKind.Debug, (request, token) => this.runTests(true, request, token), true, runnableTestTag);
    }
    resolveTestItem(item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.discoverer)
                return;
            if (!item) {
                yield this.discoverer.ensureSuitesDiscovered();
                return;
            }
            const node = this.nodeForItem.get(item);
            if (node instanceof test_model_1.SuiteNode)
                yield this.discoverer.discoverTestsForSuite(node);
        });
    }
    registerTestRun(dartCodeDebugSessionID, run, shouldEndWithSession) {
        this.testRuns[dartCodeDebugSessionID] = { run, shouldEndWithSession };
    }
    handleDebugSessionEnd(e) {
        const run = this.testRuns[e.configuration.dartCodeDebugSessionID];
        if (run === null || run === void 0 ? void 0 : run.shouldEndWithSession)
            run.run.end();
    }
    getLatestData(test) {
        return this.nodeForItem.get(test);
    }
    runTests(debug, request, token) {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.discoverer) === null || _a === void 0 ? void 0 : _a.ensureSuitesDiscovered());
            const testsToRun = new Set();
            const isRunningAll = !((_b = request.include) === null || _b === void 0 ? void 0 : _b.length) && !((_c = request.exclude) === null || _c === void 0 ? void 0 : _c.length);
            ((_d = request.include) !== null && _d !== void 0 ? _d : this.controller.items).forEach((item) => testsToRun.add(item));
            (_e = request.exclude) === null || _e === void 0 ? void 0 : _e.forEach((item) => testsToRun.delete(item));
            // For each item in the set, remove any of its descendants because they will be run by the parent.
            function removeWithDescendants(item) {
                testsToRun.delete(item);
                item.children.forEach((child) => removeWithDescendants(child));
            }
            const all = [...testsToRun];
            all.forEach((item) => item.children.forEach((child) => removeWithDescendants(child)));
            const run = this.controller.createTestRun(request);
            try {
                // As an optimisation, if we're no-debug and running complete files (eg. all included or excluded items are
                // suites), we can run the "fast path" in a single `dart test` invocation.
                if (!debug && [...testsToRun].every((item) => this.nodeForItem.get(item) instanceof test_model_1.SuiteNode)) {
                    yield vs.commands.executeCommand("_dart.runAllTestsWithoutDebugging", [...testsToRun].map((item) => this.nodeForItem.get(item)), run, isRunningAll);
                    return;
                }
                // Group into suites since we need to run each seperately (although we can run
                // multiple tests witthin one suite together).
                const testsBySuite = new Map();
                testsToRun.forEach((test) => {
                    var _a;
                    const node = this.nodeForItem.get(test);
                    if (!node)
                        return;
                    const testNodes = (_a = testsBySuite.get(node.suiteData)) !== null && _a !== void 0 ? _a : [];
                    testsBySuite.set(node.suiteData, testNodes);
                    testNodes.push(node);
                });
                const suppressPrompts = testsBySuite.size > 1;
                for (const suite of testsBySuite.keys()) {
                    const nodes = testsBySuite.get(suite);
                    if (!nodes)
                        continue;
                    const command = debug
                        ? "_dart.startDebuggingTestsFromVsTestController"
                        : "_dart.startWithoutDebuggingTestsFromVsTestController";
                    yield vs.commands.executeCommand(command, suite, nodes, suppressPrompts, run);
                }
            }
            finally {
                run.end();
            }
        });
    }
    /// Replace the whole tree.
    replaceAll() {
        const suiteTestItems = Object.values(this.model.suites)
            .map((suite) => this.createOrUpdateNode(suite.node))
            .filter(utils_1.notUndefined);
        this.controller.items.replace(suiteTestItems);
    }
    onDidChangeTreeData(node) {
        if (node === undefined) {
            this.replaceAll();
            return;
        }
        this.createOrUpdateNode(node);
    }
    /// Creates a node (including its children), or if it already exists, updates it
    /// and its children.
    /// Does not add the item to its parent, so that the calling code can .replace()
    /// all children if required.
    ///
    /// Returns undefined if in the case of an error or a node that should
    /// not be shown in the tree.
    createOrUpdateNode(node) {
        var _a, _b;
        if (!this.shouldShowNode(node))
            return;
        let collection;
        if (node instanceof test_model_1.SuiteNode) {
            collection = this.controller.items;
        }
        else {
            collection = (_a = this.itemForNode.get(node.parent)) === null || _a === void 0 ? void 0 : _a.children;
        }
        if (!collection) {
            this.logger.error(`Failed to find parent (${(_b = node.parent) === null || _b === void 0 ? void 0 : _b.label}) of node (${node.label})`);
            return;
        }
        let existingItem = collection.get(this.idForNode(node));
        // Create new item if required.
        if (!existingItem) {
            const newItem = this.createTestItem(node);
            existingItem = newItem;
        }
        else {
            // Otherwise, update this item to match the latest state.
            this.updateFields(existingItem, node);
        }
        // For new suites without chilren, set canResolveChildren because we can
        // open the file and discover tests from the Outline if the user expands them.
        if (node instanceof test_model_1.SuiteNode && node.children.length === 0)
            existingItem.canResolveChildren = true;
        existingItem.children.replace(node.children.map((c) => this.createOrUpdateNode(c)).filter(utils_1.notUndefined));
        return existingItem;
    }
    shouldShowNode(node) {
        if (config_1.config.showSkippedTests)
            return true;
        if (node instanceof test_model_1.TestNode && node.children.length === 0) {
            // Simple test node.
            // Show only if not skipped.
            return node.status !== enums_1.TestStatus.Skipped;
        }
        else if (node instanceof test_model_1.TestNode) {
            // Dynamic test node with children.
            // Show only if any child not skipped.
            return !!node.children.find((c) => c.status !== enums_1.TestStatus.Skipped);
        }
        else if (node instanceof test_model_1.GroupNode) {
            // Show only if status is not exactly skipped.
            return node.statuses.size !== 1 || !node.statuses.has(enums_1.TestStatus.Skipped);
        }
        else {
            // Otherwise show eg. suites are always shown.
            return true;
        }
    }
    idForNode(node) {
        if (node instanceof test_model_1.SuiteNode)
            return `SUITE:${node.suiteData.path}`;
        if (node instanceof test_model_1.GroupNode)
            return `GROUP:${node.suiteData.path}:${node.name}`;
        if (node instanceof test_model_1.TestNode)
            return `TEST:${node.suiteData.path}:${node.name}`;
        throw new Error(`Tried to create ID for unknown node type! ${node.label}`);
    }
    cleanLabel(label) {
        return label.trim().split("\n").map((l) => l.trim()).join(" ");
    }
    labelForSuite(node) {
        const suitePath = node.suiteData.path;
        const wf = vs.workspace.getWorkspaceFolder(vs.Uri.file(suitePath));
        return wf
            ? path.relative((0, fs_1.fsPath)(wf.uri), node.suiteData.path)
            : path.basename(suitePath);
    }
    createTestItem(node) {
        var _a;
        const id = this.idForNode(node);
        const label = node instanceof test_model_1.SuiteNode
            ? this.labelForSuite(node)
            : this.cleanLabel((_a = node.label) !== null && _a !== void 0 ? _a : "<unnamed>");
        const uri = vs.Uri.file(node.suiteData.path);
        const item = this.controller.createTestItem(id, label, uri);
        this.updateFields(item, node);
        this.nodeForItem.set(item, node);
        this.itemForNode.set(node, item);
        item.children.replace(node.children.map((c) => this.createTestItem(c)));
        return item;
    }
    updateFields(item, node) {
        if (this.isRunnableTest(node))
            item.tags = [runnableTestTag];
        else
            item.tags = [];
        item.description = node.description;
        if ((node instanceof test_model_1.GroupNode || node instanceof test_model_1.TestNode) && node.range) {
            item.range = new vs.Range(new vs.Position(node.range.start.line, node.range.start.character), new vs.Position(node.range.end.line, node.range.end.character));
        }
    }
    isRunnableTest(node) {
        const label = node.label;
        if (!label)
            return false;
        if (label.startsWith("(setUp") || label.startsWith("(tearDown"))
            return label.endsWith(")");
        return true;
    }
    getOrCreateTestRun(sessionID) {
        var _a;
        let run = (_a = this.testRuns[sessionID]) === null || _a === void 0 ? void 0 : _a.run;
        if (!run) {
            run = this.controller.createTestRun(new vs.TestRunRequest(), undefined, true);
            this.registerTestRun(sessionID, run, true);
        }
        return run;
    }
    suiteDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    groupDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testDiscovered(sessionID, node) {
        // const run = this.getOrCreateTestRun(sessionID);
        // const item = this.itemForNode.get(node);
    }
    testStarted(sessionID, node) {
        this.testDiscovered(sessionID, node);
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            run.started(item);
    }
    testOutput(sessionID, node, message) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item)
            this.appendTestOutputLines(run, item, message);
    }
    testErrorOutput(sessionID, node, message, isFailure, stack) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            // TODO: isFailure??
            this.appendTestOutputLines(run, item, message);
            this.appendTestOutputLines(run, item, stack);
        }
    }
    appendTestOutputLines(run, item, message) {
        if (message.trim() === "")
            return;
        run.appendOutput(`${(0, terminals_1.formatForTerminal)(message)}\r\n`, undefined, item);
    }
    testDone(sessionID, node, result) {
        const run = this.getOrCreateTestRun(sessionID);
        const item = this.itemForNode.get(node);
        if (run && item) {
            switch (result) {
                case "skipped":
                    run.skipped(item);
                    break;
                case "success":
                    run.passed(item, node.duration);
                    break;
                default:
                    const outputEvents = node.outputEvents;
                    const lastOutputEvent = outputEvents.length > 0 ? outputEvents[outputEvents.length - 1] : undefined;
                    const errorString = lastOutputEvent ? this.formatNotification(lastOutputEvent) : "Unknown test failure";
                    const testMessage = new vs.TestMessage(errorString);
                    if (result === "failure")
                        run.failed(item, testMessage, node.duration);
                    else
                        run.errored(item, testMessage, node.duration);
                    break;
            }
        }
    }
    suiteDone(sessionID, node) { }
    formatNotification(error) {
        var _a, _b;
        if (!("error" in error))
            return error.message;
        return [
            (_a = error.error) !== null && _a !== void 0 ? _a : "",
            (_b = error.stackTrace) !== null && _b !== void 0 ? _b : "",
        ].join("\n").trim();
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.VsCodeTestController = VsCodeTestController;


/***/ }),

/***/ 4741:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.handleNewProjects = exports.showUserPrompts = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fs_1 = __webpack_require__(300);
const extension_utils_1 = __webpack_require__(6143);
const user_prompts_1 = __webpack_require__(7622);
const utils_1 = __webpack_require__(7220);
const sdk_1 = __webpack_require__(997);
const utils_2 = __webpack_require__(8779);
function showUserPrompts(logger, context, webClient, analytics, workspaceContext) {
    return __awaiter(this, void 0, void 0, function* () {
        if (workspaceContext.config.disableStartupPrompts)
            return;
        function shouldSuppress(key) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            return context.get(stateKey) === true;
        }
        /// Shows a prompt and stores the return value. Prompt should return `true` to mark
        /// this extension as seen-forever and it won't be shown again. Returning anything
        /// else will allow the prompt to appear again next time.
        function showPrompt(key, prompt) {
            const stateKey = `${constants_1.userPromptContextPrefix}${key}`;
            prompt().then((res) => context.update(stateKey, res), error);
        }
        if (workspaceContext.hasAnyFlutterProjects && !extension_utils_1.hasFlutterExtension && !shouldSuppress(constants_1.installFlutterExtensionPromptKey)) {
            // It's possible that we got here when the user installed the Flutter extension, because it causes Dart to install
            // first and activate. So, before showing this prompt we'll wait 30 seconds and then check if we still don't
            // have the Flutter extension, and then show the prompt.
            yield new Promise((resolve) => setTimeout(resolve, 20000));
            if (!(0, extension_utils_1.checkHasFlutterExtension)())
                return showPrompt(constants_1.installFlutterExtensionPromptKey, promptToInstallFlutterExtension);
        }
        // Check the user hasn't installed Flutter in a forbidden location that will cause issues.
        if (workspaceContext.hasAnyFlutterProjects && workspaceContext.sdks.flutter) {
            if (constants_1.isWin) {
                const forbiddenLocations = [
                    process.env.COMMONPROGRAMFILES,
                    process.env["COMMONPROGRAMFILES(x86)"],
                    process.env.CommonProgramW6432,
                    process.env.PROGRAMFILES,
                    process.env.ProgramW6432,
                    process.env["PROGRAMFILES(X86)"],
                ];
                const installedForbiddenLocation = forbiddenLocations.find((fl) => { var _a; return fl && ((_a = workspaceContext.sdks.flutter) === null || _a === void 0 ? void 0 : _a.toLowerCase().startsWith(fl.toLowerCase())); });
                if (installedForbiddenLocation) {
                    logger.error(`Flutter is installed in protected folder: ${installedForbiddenLocation}`);
                    vs.window.showErrorMessage("The Flutter SDK is installed in a protected folder and may not function correctly. Please move the SDK to a location that is user-writable without Administration permissions and restart.");
                }
            }
        }
        const lastSeenVersionNotification = context.lastSeenVersion;
        if (!lastSeenVersionNotification) {
            // If we've not got a stored version, this is the first install, so just
            // stash the current version and don't show anything.
            context.lastSeenVersion = extension_utils_1.extensionVersion;
        }
        else if (!extension_utils_1.isDevExtension && !extension_utils_1.isPreReleaseExtension && lastSeenVersionNotification !== extension_utils_1.extensionVersion) {
            const versionLink = extension_utils_1.extensionVersion.split(".").slice(0, 2).join(".").replace(".", "-");
            // tslint:disable-next-line: no-floating-promises
            promptToShowReleaseNotes(extension_utils_1.extensionVersion, versionLink).then(() => context.lastSeenVersion = extension_utils_1.extensionVersion);
            return;
        }
        if (workspaceContext.hasAnyFlutterProjects) {
            if (yield (0, user_prompts_1.showFlutterSurveyNotificationIfAppropriate)(context, webClient, analytics, utils_1.envUtils.openInBrowser, Date.now(), logger))
                return; // Bail if we showed it, so we won't show any other notifications.
        }
        if (!shouldSuppress(constants_1.useRecommendedSettingsPromptKey)) {
            showPrompt(constants_1.useRecommendedSettingsPromptKey, promptToUseRecommendedSettings);
            return;
        }
        // (though, there are no other notifications right now...)
    });
}
exports.showUserPrompts = showUserPrompts;
function promptToUseRecommendedSettings() {
    return __awaiter(this, void 0, void 0, function* () {
        const action = yield vs.window.showInformationMessage("Would you like to use recommended VS Code settings for Dart & Flutter?", constants_1.yesAction, constants_1.noAction, constants_1.showRecommendedSettingsAction);
        if (action === constants_1.yesAction) {
            yield vs.commands.executeCommand("dart.writeRecommendedSettings");
        }
        else if (action === constants_1.showRecommendedSettingsAction) {
            yield utils_1.envUtils.openInBrowser(constants_1.recommendedSettingsUrl);
        }
        return true;
    });
}
function promptToInstallFlutterExtension() {
    return __awaiter(this, void 0, void 0, function* () {
        const installExtension = "Install Flutter Extension";
        const res = yield vs.window.showInformationMessage("The Flutter extension is required to work with Flutter projects.", installExtension);
        if (res === installExtension) {
            yield vs.window.withProgress({ location: vs.ProgressLocation.Notification }, (progress) => {
                progress.report({ message: "Installing Flutter extension" });
                return new Promise((resolve) => {
                    vs.extensions.onDidChange((e) => resolve());
                    vs.commands.executeCommand("workbench.extensions.installExtension", constants_1.flutterExtensionIdentifier);
                });
            });
            // tslint:disable-next-line: no-floating-promises
            (0, utils_2.promptToReloadExtension)();
        }
        return false;
    });
}
function promptToShowReleaseNotes(versionDisplay, versionLink) {
    return __awaiter(this, void 0, void 0, function* () {
        const res = yield vs.window.showInformationMessage(`Dart Code has been updated to v${versionDisplay}`, `Show Release Notes`);
        if (res) {
            yield utils_1.envUtils.openInBrowser(`https://dartcode.org/releases/v${versionLink}/`);
        }
        return true; // Always mark this as done; we don't want to prompt the user multiple times.
    });
}
function error(err) {
    var _a;
    vs.window.showErrorMessage(`${(_a = err.message) !== null && _a !== void 0 ? _a : err}`);
}
function handleNewProjects(logger, context) {
    return __awaiter(this, void 0, void 0, function* () {
        yield Promise.all((0, utils_1.getDartWorkspaceFolders)().map((wf) => __awaiter(this, void 0, void 0, function* () {
            try {
                yield handleStagehandTrigger(logger, wf, constants_1.DART_CREATE_PROJECT_TRIGGER_FILE);
                yield handleFlutterCreateTrigger(wf);
            }
            catch (e) {
                logger.error("Failed to create project");
                logger.error(e);
                vs.window.showErrorMessage("Failed to create project");
            }
        })));
    });
}
exports.handleNewProjects = handleNewProjects;
function handleStagehandTrigger(logger, wf, triggerFilename) {
    return __awaiter(this, void 0, void 0, function* () {
        const triggerFile = path.join((0, fs_1.fsPath)(wf.uri), triggerFilename);
        if (!fs.existsSync(triggerFile))
            return;
        const templateJson = fs.readFileSync(triggerFile).toString().trim();
        let template;
        try {
            template = JSON.parse(templateJson);
        }
        catch (e) {
            logger.error("Failed to get Stagehand templates");
            logger.error(e);
            vs.window.showErrorMessage("Failed to run Stagehand to create project");
            return;
        }
        fs.unlinkSync(triggerFile);
        logger.info(`Creating Dart project for ${(0, fs_1.fsPath)(wf.uri)}`, enums_1.LogCategory.CommandProcesses);
        try {
            (0, sdk_1.markProjectCreationStarted)();
            const success = yield createDartProject((0, fs_1.fsPath)(wf.uri), template.name);
            if (success) {
                logger.info(`Fetching packages for newly-created project`, enums_1.LogCategory.CommandProcesses);
                yield vs.commands.executeCommand("dart.getPackages", wf.uri);
                handleDartWelcome(wf, template);
                logger.info(`Finished creating new project!`, enums_1.LogCategory.CommandProcesses);
            }
            else {
                logger.info(`Failed to create new project`, enums_1.LogCategory.CommandProcesses);
            }
        }
        finally {
            (0, sdk_1.markProjectCreationEnded)();
        }
    });
}
function handleFlutterCreateTrigger(wf) {
    return __awaiter(this, void 0, void 0, function* () {
        const flutterTriggerFile = path.join((0, fs_1.fsPath)(wf.uri), constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE);
        if (!fs.existsSync(flutterTriggerFile))
            return;
        const jsonString = fs.readFileSync(flutterTriggerFile).toString().trim();
        const json = jsonString ? JSON.parse(jsonString) : undefined;
        fs.unlinkSync(flutterTriggerFile);
        try {
            (0, sdk_1.markProjectCreationStarted)();
            const success = yield createFlutterProject((0, fs_1.fsPath)(wf.uri), json);
            if (success)
                handleFlutterWelcome(wf, json);
        }
        finally {
            (0, sdk_1.markProjectCreationEnded)();
        }
    });
}
function createDartProject(projectPath, templateName) {
    return __awaiter(this, void 0, void 0, function* () {
        const code = yield vs.commands.executeCommand("_dart.create", projectPath, templateName);
        return code === 0;
    });
}
function createFlutterProject(projectPath, triggerData) {
    return __awaiter(this, void 0, void 0, function* () {
        const projectName = (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample) ? "sample" : undefined;
        const args = { projectPath, projectName, triggerData };
        const code = yield vs.commands.executeCommand("_flutter.create", args);
        return code === 0;
    });
}
function handleFlutterWelcome(workspaceFolder, triggerData) {
    const entryFile = path.join((0, fs_1.fsPath)(workspaceFolder.uri), "lib/main.dart");
    openFile(entryFile);
    if (triggerData === null || triggerData === void 0 ? void 0 : triggerData.sample)
        vs.window.showInformationMessage(`${triggerData.sample} sample ready! Press F5 to start running.`);
    else
        vs.window.showInformationMessage("Your Flutter project is ready! Press F5 to start running.");
}
function handleDartWelcome(workspaceFolder, template) {
    const workspacePath = (0, fs_1.fsPath)(workspaceFolder.uri);
    const projectName = path.basename(workspacePath);
    const entryFile = path.join(workspacePath, template.entrypoint.replace("__projectName__", projectName));
    openFile(entryFile);
    vs.window.showInformationMessage(`${template.label} project ready!`);
}
/// Opens a file, but does it in a setTimeout to work around VS Code reveal bug
/// https://github.com/Microsoft/vscode/issues/71588#event-2252962973
function openFile(entryFile) {
    if (!fs.existsSync(entryFile))
        return;
    // TODO: Remove this setTimeout when it's no longer required.
    setTimeout(() => {
        vs.commands.executeCommand("vscode.open", vs.Uri.file(entryFile));
    }, 100);
}


/***/ }),

/***/ 8779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getExcludedFolders = exports.openLogContents = exports.logTime = exports.promptToReloadExtension = exports.escapeShell = exports.getLatestSdkVersion = exports.isValidEntryFile = exports.ensureDebugLaunchUniqueId = exports.hasTestNameFilter = exports.isInsideFolderNamed = exports.isDartFile = exports.projectShouldUsePubForTests = exports.isTestFolder = exports.isPubRunnableTestFile = exports.isTestFile = exports.isTestFileOrFolder = exports.isWithinWorkspace = exports.isAnalyzableAndInWorkspace = exports.shouldHotReloadFor = exports.isAnalyzable = exports.createFolderForFile = exports.homeRelativePath = exports.resolvePaths = exports.isPathInsideFlutterProject = exports.isInsideFlutterProject = exports.isFlutterWorkspaceFolder = void 0;
const fs = __webpack_require__(7147);
const https = __webpack_require__(5687);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const utils_1 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const extension_1 = __webpack_require__(1892);
const project_1 = __webpack_require__(3886);
function isFlutterWorkspaceFolder(folder) {
    return !!(folder && (0, utils_1.isDartWorkspaceFolder)(folder) && (0, fs_1.isFlutterProjectFolder)((0, fs_1.fsPath)(folder.uri)));
}
exports.isFlutterWorkspaceFolder = isFlutterWorkspaceFolder;
function isInsideFlutterProject(uri) {
    if (!uri)
        return false;
    const projectRoot = (0, project_1.locateBestProjectRoot)((0, fs_1.fsPath)(uri));
    if (projectRoot)
        return (0, fs_1.isFlutterProjectFolder)(projectRoot);
    else
        return isFlutterWorkspaceFolder(vscode_1.workspace.getWorkspaceFolder(uri));
}
exports.isInsideFlutterProject = isInsideFlutterProject;
function isPathInsideFlutterProject(path) {
    const projectRoot = (0, project_1.locateBestProjectRoot)(path);
    if (!projectRoot)
        return false;
    return (0, fs_1.isFlutterProjectFolder)(projectRoot);
}
exports.isPathInsideFlutterProject = isPathInsideFlutterProject;
function resolvePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    if (!path.isAbsolute(p) && vscode_1.workspace.workspaceFolders && vscode_1.workspace.workspaceFolders.length)
        return path.join((0, fs_1.fsPath)(vscode_1.workspace.workspaceFolders[0].uri), p);
    return p;
}
exports.resolvePaths = resolvePaths;
/// Shortens a path to use ~ if it's inside the home directory.
function homeRelativePath(p) {
    if (!p)
        return undefined;
    const homedir = os.homedir();
    if ((0, fs_1.isWithinPath)(p, homedir))
        return path.join("~", path.relative(homedir, p));
    return p;
}
exports.homeRelativePath = homeRelativePath;
function createFolderForFile(file) {
    try {
        if (!file || !path.isAbsolute(file))
            return undefined;
        const folder = path.dirname(file);
        if (!fs.existsSync(folder))
            (0, fs_1.mkDirRecursive)(folder);
        return file;
    }
    catch (_a) {
        console.warn(`Ignoring invalid file path ${file}`);
        return undefined;
    }
}
exports.createFolderForFile = createFolderForFile;
function isAnalyzable(file) {
    if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
        return false;
    const analyzableLanguages = ["dart", "html"];
    const analyzableFilenames = [".analysis_options", "analysis_options.yaml", "pubspec.yaml"];
    // We have to include dart/html extensions as this function may be called without a language ID
    // (for example when triggered by a file system watcher).
    const analyzableFileExtensions = ["dart", "htm", "html"].concat(config_1.config.additionalAnalyzerFileExtensions);
    const extName = path.extname((0, fs_1.fsPath)(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return (file.languageId && analyzableLanguages.indexOf(file.languageId) >= 0)
        || analyzableFilenames.indexOf(path.basename((0, fs_1.fsPath)(file.uri))) >= 0
        || (extension !== undefined && analyzableFileExtensions.includes(extension));
}
exports.isAnalyzable = isAnalyzable;
function shouldHotReloadFor(file) {
    if (file.isUntitled || !(0, fs_1.fsPath)(file.uri) || file.uri.scheme !== "file")
        return false;
    const reloadableFileExtensions = ["dart", "htm", "html", "css"];
    const extName = path.extname((0, fs_1.fsPath)(file.uri));
    const extension = extName ? extName.substr(1) : undefined;
    return extension !== undefined && reloadableFileExtensions.includes(extension);
}
exports.shouldHotReloadFor = shouldHotReloadFor;
function isAnalyzableAndInWorkspace(file) {
    return isAnalyzable(file) && isWithinWorkspace((0, fs_1.fsPath)(file.uri));
}
exports.isAnalyzableAndInWorkspace = isAnalyzableAndInWorkspace;
function isWithinWorkspace(file) {
    return !!vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
}
exports.isWithinWorkspace = isWithinWorkspace;
function isTestFileOrFolder(path) {
    return !!path && (isTestFile(path) || isTestFolder(path));
}
exports.isTestFileOrFolder = isTestFileOrFolder;
function isTestFile(file) {
    // To be a test, you must be _test.dart AND inside a test folder.
    // https://github.com/Dart-Code/Dart-Code/issues/1165
    // https://github.com/Dart-Code/Dart-Code/issues/2021
    // https://github.com/Dart-Code/Dart-Code/issues/2034
    return !!file && isDartFile(file)
        && (isInsideFolderNamed(file, "test")
            || isInsideFolderNamed(file, "integration_test")
            || isInsideFolderNamed(file, "test_driver")
            || config_1.config.allowTestsOutsideTestFolder)
        && file.toLowerCase().endsWith("_test.dart");
}
exports.isTestFile = isTestFile;
// Similar to isTestFile, but requires that the file is _test.dart because it will be used as
// an entry point for pub test running.
function isPubRunnableTestFile(file) {
    return !!file && isDartFile(file) && file.toLowerCase().endsWith("_test.dart");
}
exports.isPubRunnableTestFile = isPubRunnableTestFile;
function isTestFolder(path) {
    return !!path
        && (isInsideFolderNamed(path, "test")
            || isInsideFolderNamed(path, "integration_test")) && fs.existsSync(path)
        && fs.statSync(path).isDirectory();
}
exports.isTestFolder = isTestFolder;
function projectShouldUsePubForTests(folder, config) {
    return (0, fs_1.hasPubspec)(folder) && !config.useVmForTests;
}
exports.projectShouldUsePubForTests = projectShouldUsePubForTests;
function isDartFile(file) {
    return !!file && path.extname(file.toLowerCase()) === ".dart" && fs.existsSync(file) && fs.statSync(file).isFile();
}
exports.isDartFile = isDartFile;
function isInsideFolderNamed(file, folderName) {
    if (!file)
        return false;
    const ws = vscode_1.workspace.getWorkspaceFolder(vscode_1.Uri.file(file));
    if (!ws)
        return false;
    const relPath = path.relative((0, fs_1.fsPath)(ws.uri).toLowerCase(), file.toLowerCase());
    const segments = relPath.split(path.sep);
    return segments.indexOf(folderName.toLowerCase()) !== -1;
}
exports.isInsideFolderNamed = isInsideFolderNamed;
function hasTestNameFilter(...argss) {
    for (const args of argss) {
        if (args && (args.includes("--name") || args.includes("--pname")))
            return true;
    }
    return false;
}
exports.hasTestNameFilter = hasTestNameFilter;
/// Ensures a debug config always has a unique ID we can use to match things up.
///
/// Although VS Code assigns an ID, we cannot get at it until after the debug session starts
/// which might be after we recieve some events (since VS Code fires its event late - after all
/// initialisation has completed).
function ensureDebugLaunchUniqueId(config) {
    const conf = config;
    if (!conf.dartCodeDebugSessionID) {
        const dartCodeDebugSessionID = `session-${(0, fs_1.getRandomInt)(0x10000, 0x100000).toString(16)}`;
        conf.dartCodeDebugSessionID = dartCodeDebugSessionID;
    }
    return conf.dartCodeDebugSessionID;
}
exports.ensureDebugLaunchUniqueId = ensureDebugLaunchUniqueId;
function isValidEntryFile(file) {
    var _a;
    if (!file || !isDartFile(file))
        return false;
    // When in a no-folder workspace, all Dart files are considered runnable.
    if (!((_a = vscode_1.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.length))
        return true;
    return isTestFile(file)
        || isInsideFolderNamed(file, "bin") || isInsideFolderNamed(file, "tool") || isInsideFolderNamed(file, "test_driver")
        || file.endsWith(`lib${path.sep}main.dart`);
}
exports.isValidEntryFile = isValidEntryFile;
function getLatestSdkVersion() {
    return new Promise((resolve, reject) => {
        const options = {
            hostname: "storage.googleapis.com",
            method: "GET",
            path: "/dart-archive/channels/stable/release/latest/VERSION",
            port: 443,
        };
        const req = https.request(options, (resp) => {
            if (!resp || !resp.statusCode || resp.statusCode < 200 || resp.statusCode > 300) {
                reject({ message: `Failed to get Dart SDK Version ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resp.on("data", (d) => {
                    try {
                        const latestVersion = JSON.parse(d.toString()).version;
                        resolve(latestVersion);
                    }
                    catch (e) {
                        reject({ message: `Failed to parse latest Dart SDK Version from JSON: ${d.toString()}` });
                    }
                });
            }
        });
        req.end();
    });
}
exports.getLatestSdkVersion = getLatestSdkVersion;
// Escapes a set of command line arguments so that the escaped string is suitable for passing as an argument
// to another shell command.
// Implementation is taken from https://github.com/xxorax/node-shell-escape
function escapeShell(args) {
    const ret = [];
    args.forEach((arg) => {
        if (/[^A-Za-z0-9_\/:=-]/.test(arg)) {
            arg = "'" + arg.replace(/'/g, "'\\''") + "'";
            arg = arg.replace(/^(?:'')+/g, "") // unduplicate single-quote at the beginning
                .replace(/\\'''/g, "\\'"); // remove non-escaped single-quote if there are enclosed between 2 escaped
        }
        ret.push(arg);
    });
    return ret.join(" ");
}
exports.escapeShell = escapeShell;
function promptToReloadExtension(prompt, buttonText, offerLog) {
    return __awaiter(this, void 0, void 0, function* () {
        const restartAction = buttonText || "Reload";
        const actions = offerLog ? [restartAction, constants_1.showLogAction] : [restartAction];
        const ringLogContents = extension_1.ringLog.toString();
        let showPromptAgain = true;
        const tempLogPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
        while (showPromptAgain) {
            showPromptAgain = false;
            const chosenAction = prompt && (yield vscode_1.window.showInformationMessage(prompt, ...actions));
            if (chosenAction === constants_1.showLogAction) {
                showPromptAgain = true;
                openLogContents(undefined, ringLogContents, tempLogPath);
            }
            else if (!prompt || chosenAction === restartAction) {
                vscode_1.commands.executeCommand("_dart.reloadExtension");
            }
        }
    });
}
exports.promptToReloadExtension = promptToReloadExtension;
const shouldLogTimings = false;
const start = process.hrtime.bigint();
let last = start;
function pad(str, length) {
    while (str.length < length)
        str = "0" + str;
    return str;
}
const logTime = (taskFinished) => {
    if (!shouldLogTimings)
        return;
    const end = process.hrtime.bigint();
    console.log(`${pad((end - last).toString(), 15)} ${taskFinished ? "<== " + taskFinished : ""}`);
    last = end;
};
exports.logTime = logTime;
function openLogContents(logType = `txt`, logContents, tempPath) {
    if (!tempPath)
        tempPath = path.join(os.tmpdir(), `log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.${logType}`);
    fs.writeFileSync(tempPath, logContents);
    vscode_1.workspace.openTextDocument(tempPath).then(vscode_1.window.showTextDocument);
}
exports.openLogContents = openLogContents;
/// Gets all excluded folders (full absolute paths) for a given workspace
/// folder based on config.
function getExcludedFolders(f) {
    if (!f)
        return [];
    const excludedForWorkspace = config_1.config.for(f.uri).analysisExcludedFolders;
    if (!excludedForWorkspace || !Array.isArray(excludedForWorkspace))
        return [];
    const workspacePath = (0, fs_1.fsPath)(f.uri);
    return excludedForWorkspace.map((folder) => {
        // Handle both relative and absolute paths.
        if (!path.isAbsolute(folder))
            folder = path.join(workspacePath, folder);
        return folder;
    });
}
exports.getExcludedFolders = getExcludedFolders;


/***/ }),

/***/ 8202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addToLogHeader = exports.getLogHeader = exports.clearLogHeader = exports.debuggingLogCategories = exports.extensionsLogCategories = exports.analysisServerLogCategories = exports.userSelectableLogCategories = exports.getExtensionLogPath = void 0;
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const fs_1 = __webpack_require__(300);
const config_1 = __webpack_require__(4165);
let extensionLogPath;
function getExtensionLogPath() {
    extensionLogPath = extensionLogPath || config_1.config.extensionLogFile || path.join(process.env.DC_TEST_LOGS || os.tmpdir(), `dart-code-startup-log-${(0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16)}.txt`);
    return extensionLogPath;
}
exports.getExtensionLogPath = getExtensionLogPath;
exports.userSelectableLogCategories = {
    "Analysis Server": enums_1.LogCategory.Analyzer,
    "Analysis Server Timings": enums_1.LogCategory.AnalyzerTiming,
    "Command Processes": enums_1.LogCategory.CommandProcesses,
    "Dart Test": enums_1.LogCategory.DartTest,
    "Debugger DAP Protocol": enums_1.LogCategory.DAP,
    "Debugger VM Service": enums_1.LogCategory.VmService,
    "DevTools": enums_1.LogCategory.DevTools,
    "Flutter Device Daemon": enums_1.LogCategory.FlutterDaemon,
    "Flutter Run": enums_1.LogCategory.FlutterRun,
    "Flutter Test": enums_1.LogCategory.FlutterTest,
    "Web Daemon": enums_1.LogCategory.WebDaemon,
};
exports.analysisServerLogCategories = [
    enums_1.LogCategory.Analyzer,
    enums_1.LogCategory.CommandProcesses,
];
exports.extensionsLogCategories = [
    enums_1.LogCategory.CommandProcesses,
    enums_1.LogCategory.DevTools,
    enums_1.LogCategory.FlutterDaemon,
];
exports.debuggingLogCategories = Object.values(exports.userSelectableLogCategories)
    .filter((c) => c !== enums_1.LogCategory.Analyzer);
const logHeader = [];
function clearLogHeader() {
    logHeader.length = 0;
}
exports.clearLogHeader = clearLogHeader;
function getLogHeader() {
    if (!logHeader.length)
        return "";
    return logHeader.join(constants_1.platformEol) + constants_1.platformEol + constants_1.platformEol;
}
exports.getLogHeader = getLogHeader;
function addToLogHeader(f) {
    try {
        logHeader.push(f().replace(/\r/g, "").replace(/\n/g, "\r\n"));
    }
    catch (_a) {
        // Don't log here; we may be trying to access things that aren't available yet.
    }
}
exports.addToLogHeader = addToLogHeader;


/***/ }),

/***/ 9106:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFlutterConfigValue = exports.reportAnalyzerTerminatedWithError = void 0;
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(8779);
const processes_1 = __webpack_require__(5430);
let isShowingAnalyzerError = false;
function reportAnalyzerTerminatedWithError(duringStartup = false) {
    if (isShowingAnalyzerError)
        return;
    isShowingAnalyzerError = true;
    const message = duringStartup
        ? "The Dart Analyzer could not be started."
        : "The Dart Analyzer has terminated.";
    // tslint:disable-next-line: no-floating-promises
    (0, utils_1.promptToReloadExtension)(message, undefined, true).then(() => isShowingAnalyzerError = false);
}
exports.reportAnalyzerTerminatedWithError = reportAnalyzerTerminatedWithError;
function getFlutterConfigValue(logger, flutterSdkPath, folder, flutterConfigKey) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!flutterSdkPath) {
            throw Error("Cannot find Android Studio without a Flutter SDK");
        }
        const binPath = path.join(flutterSdkPath, constants_1.flutterPath);
        const args = ["config", "--machine"];
        try {
            const proc = yield (0, processes_1.runToolProcess)(logger, folder, binPath, args);
            if (proc.exitCode === 0) {
                const json = JSON.parse(proc.stdout);
                return json[flutterConfigKey];
            }
            throw Error(`Failed to run "flutter config --machine" (${proc.exitCode}): ${proc.stderr}`);
        }
        catch (e) {
            logger.error(e);
            throw e;
        }
    });
}
exports.getFlutterConfigValue = getFlutterConfigValue;


/***/ }),

/***/ 5430:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runToolProcess = exports.safeToolSpawn = exports.setupToolEnv = exports.getGlobalFlutterArgs = exports.getToolEnv = void 0;
const constants_1 = __webpack_require__(5628);
const processes_1 = __webpack_require__(5837);
// Environment used when spawning Dart and Flutter processes.
let toolEnv = {};
let globalFlutterArgs = [];
function getToolEnv() {
    return toolEnv;
}
exports.getToolEnv = getToolEnv;
function getGlobalFlutterArgs() {
    return globalFlutterArgs;
}
exports.getGlobalFlutterArgs = getGlobalFlutterArgs;
function setupToolEnv(envOverrides) {
    toolEnv = {};
    globalFlutterArgs = [];
    toolEnv.FLUTTER_HOST = "VSCode";
    toolEnv.PUB_ENVIRONMENT = (toolEnv.PUB_ENVIRONMENT ? `${toolEnv.PUB_ENVIRONMENT}:` : "") + "vscode.dart-code";
    if (constants_1.isDartCodeTestRun) {
        toolEnv.PUB_ENVIRONMENT += ".test.bot";
        globalFlutterArgs.push("--suppress-analytics");
    }
    // Add on any overrides.
    if (envOverrides)
        toolEnv = Object.assign(toolEnv, envOverrides);
}
exports.setupToolEnv = setupToolEnv;
// TODO: Should we move this to extension activate?
setupToolEnv();
function safeToolSpawn(workingDirectory, binPath, args, envOverrides) {
    const env = Object.assign({}, toolEnv, envOverrides);
    return (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
}
exports.safeToolSpawn = safeToolSpawn;
/// Runs a process and returns the exit code, stdout, stderr. Always resolves even for non-zero exit codes.
function runToolProcess(logger, workingDirectory, binPath, args, envOverrides) {
    return (0, processes_1.runProcess)(logger, binPath, args, workingDirectory, envOverrides, safeToolSpawn);
}
exports.runToolProcess = runToolProcess;


/***/ }),

/***/ 9564:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressMessage = exports.DartDebugSessionInformation = void 0;
class DartDebugSessionInformation {
    constructor(session, debuggerType) {
        this.session = session;
        this.debuggerType = debuggerType;
        this.sessionStart = new Date();
        this.hasStarted = false;
        this.hasEnded = false;
        this.progress = {};
        this.loadedServiceExtensions = [];
    }
}
exports.DartDebugSessionInformation = DartDebugSessionInformation;
class ProgressMessage {
    constructor(reporter, completer) {
        this.reporter = reporter;
        this.completer = completer;
    }
    report(message) {
        this.reporter.report({ message });
    }
    complete() {
        this.completer.resolve();
    }
}
exports.ProgressMessage = ProgressMessage;


/***/ }),

/***/ 9662:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.editSetting = exports.showSimpleSettingsEditor = exports.showInputBoxWithSettings = void 0;
const vs = __webpack_require__(9496);
function showInputBoxWithSettings(context, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const input = vs.window.createInputBox();
        input.title = options.title;
        input.prompt = options.prompt;
        input.placeholder = options.placeholder;
        input.value = options.value;
        if (options.validation) {
            input.onDidChangeValue((s) => {
                input.validationMessage = options.validation(s);
            });
        }
        input.buttons = [
            {
                iconPath: {
                    dark: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
                    light: vs.Uri.file(context.asAbsolutePath("media/commands/settings.svg")),
                },
                tooltip: "Settings",
            },
        ];
        const name = yield new Promise((resolve) => {
            input.onDidTriggerButton((e) => __awaiter(this, void 0, void 0, function* () {
                resolve("SETTINGS");
                input.hide();
            }));
            input.onDidAccept(() => input.value ? resolve({ value: input.value }) : resolve(undefined));
            input.onDidHide(() => {
                resolve(undefined);
            });
            input.show();
        });
        input.dispose();
        return name;
    });
}
exports.showInputBoxWithSettings = showInputBoxWithSettings;
function showSimpleSettingsEditor(title, placeholder, getItems) {
    return __awaiter(this, void 0, void 0, function* () {
        while (true) {
            const quickPick = vs.window.createQuickPick();
            quickPick.title = title;
            quickPick.placeholder = placeholder;
            quickPick.items = getItems();
            const selectedSetting = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0]));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPick.dispose();
            if (selectedSetting) {
                yield editSetting(selectedSetting);
            }
            else {
                return;
            }
        }
    });
}
exports.showSimpleSettingsEditor = showSimpleSettingsEditor;
function editSetting(setting) {
    return __awaiter(this, void 0, void 0, function* () {
        const title = setting.label;
        let placeholder = `Select an option for ${setting.label} (or 'Escape' to cancel)`;
        const prompt = setting.detail;
        const value = setting.currentValue;
        switch (setting.settingKind) {
            case "STRING":
                const stringResult = yield vs.window.showInputBox({ prompt, title, value });
                if (stringResult !== undefined)
                    yield setting.setValue(stringResult);
                break;
            case "ENUM": {
                const quickPick = vs.window.createQuickPick();
                quickPick.placeholder = placeholder;
                quickPick.title = title;
                quickPick.items = setting.enumValues.map((v) => ({ label: v }));
                quickPick.activeItems = quickPick.items.filter((item) => item.label === setting.currentValue);
                const accepted = yield new Promise((resolve) => {
                    quickPick.onDidAccept(() => resolve(true));
                    quickPick.onDidHide(() => resolve(false));
                    quickPick.show();
                });
                const enumResult = accepted && quickPick.activeItems.length ? quickPick.activeItems[0].label : undefined;
                quickPick.dispose();
                if (enumResult !== undefined)
                    yield setting.setValue(enumResult);
                break;
            }
            case "MULTI_ENUM": {
                placeholder = `Select options for ${setting.label} (or 'Escape' to cancel)`;
                const quickPick = vs.window.createQuickPick();
                quickPick.canSelectMany = true;
                quickPick.placeholder = placeholder;
                quickPick.title = title;
                const items = [];
                for (const group of setting.enumValues) {
                    items.push({ label: group.group, kind: vs.QuickPickItemKind.Separator });
                    for (const value of group.values) {
                        items.push({ label: value });
                    }
                }
                quickPick.items = items;
                quickPick.selectedItems = quickPick.items.filter((item) => setting.currentValue.find((current) => current === item.label));
                const accepted = yield new Promise((resolve) => {
                    quickPick.onDidAccept(() => resolve(true));
                    quickPick.onDidHide(() => resolve(false));
                    quickPick.show();
                });
                quickPick.dispose();
                if (accepted)
                    yield setting.setValue(quickPick.selectedItems.map((item) => item.label));
                break;
            }
            case "BOOL":
                const boolResult = yield vs.window.showQuickPick([
                    { label: "enable" },
                    { label: "disable" },
                ], { placeHolder: placeholder, title });
                if (boolResult !== undefined)
                    yield setting.setValue(boolResult.label === "enable");
                break;
        }
    });
}
exports.editSetting = editSetting;


/***/ }),

/***/ 7104:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findNearestOutlineNode = void 0;
function findNearestOutlineNode(fileTracker, document, position, useReducedRange = false, kinds = ["CLASS", "METHOD", "GETTER", "SETTER"]) {
    const outline = fileTracker.getOutlineFor(document.uri);
    return outline && findNode([outline], document.offsetAt(position), useReducedRange, kinds);
}
exports.findNearestOutlineNode = findNearestOutlineNode;
function findNode(outlines, offset, useReducedRange, kinds) {
    if (!outlines)
        return undefined;
    for (const outline of outlines) {
        const outlineStart = outline.offset;
        const outlineEnd = outline.offset + outline.length;
        // Bail if this node is not spanning us.
        if (outlineStart > offset || outlineEnd < offset)
            continue;
        // Although we use the full code range above so that we can walk into children, when performing a match we want to stop
        // at the end of the element, so we use a reduce range to avoid returning a method for the whole of its body.
        const isInReducedRange = !useReducedRange || !outline.element || !outline.element.location
            || (offset >= outlineStart && offset <= outline.element.location.offset + outline.element.location.length);
        return findNode(outline.children, offset, useReducedRange, kinds)
            || (kinds.indexOf(outline.element.kind) !== -1 && isInReducedRange ? outline : undefined);
    }
}


/***/ }),

/***/ 6417:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFolderToRunCommandIn = void 0;
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const editors_1 = __webpack_require__(8805);
const project_1 = __webpack_require__(3886);
const utils_3 = __webpack_require__(8779);
function getFolderToRunCommandIn(logger, placeHolder, selection, flutterOnly = false) {
    return __awaiter(this, void 0, void 0, function* () {
        // Attempt to find a project based on the supplied folder of active file.
        let file = selection && (0, fs_1.fsPath)(selection);
        if (!file) {
            const editor = (0, editors_1.getActiveRealFileEditor)();
            if (editor)
                file = (0, fs_1.fsPath)(editor.document.uri);
        }
        const folder = file && (0, project_1.locateBestProjectRoot)(file);
        if (folder)
            return folder;
        // Otherwise look for what projects we have.
        const selectableFolders = (yield (0, utils_2.getAllProjectFolders)(logger, utils_3.getExcludedFolders, { requirePubspec: true, sort: true, searchDepth: config_1.config.projectSearchDepth }))
            .filter(flutterOnly ? fs_1.isFlutterProjectFolder : () => true);
        if (!selectableFolders || !selectableFolders.length) {
            const projectTypes = flutterOnly ? "Flutter" : "Dart/Flutter";
            vs.window.showWarningMessage(`No ${projectTypes} project roots were found. Do you have a pubspec.yaml file?`);
            return undefined;
        }
        return showFolderPicker(selectableFolders, placeHolder); // TODO: What if the user didn't pick anything?
    });
}
exports.getFolderToRunCommandIn = getFolderToRunCommandIn;
function showFolderPicker(folders, placeHolder) {
    return __awaiter(this, void 0, void 0, function* () {
        // No point asking the user if there's only one.
        if (folders.length === 1) {
            return folders[0];
        }
        const items = folders.map((f) => {
            const workspaceFolder = vs.workspace.getWorkspaceFolder(vscode_1.Uri.file(f));
            if (!workspaceFolder)
                return undefined;
            const workspacePathParent = path.dirname((0, fs_1.fsPath)(workspaceFolder.uri));
            return {
                description: (0, utils_3.homeRelativePath)(workspacePathParent),
                label: path.relative(workspacePathParent, f),
                path: f,
            };
        }).filter(utils_1.notUndefined);
        const selectedFolder = yield vs.window.showQuickPick(items, { placeHolder });
        return selectedFolder && selectedFolder.path;
    });
}


/***/ }),

/***/ 6368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatForTerminal = exports.writeToPseudoTerminal = void 0;
const vs = __webpack_require__(9496);
function writeToPseudoTerminal(messages) {
    const emitter = new vs.EventEmitter();
    const pseudoterminal = {
        close: () => { },
        onDidWrite: emitter.event,
        open: () => {
            for (const output of messages) {
                if (output)
                    emitter.fire(formatForTerminal(output));
            }
        },
    };
    const currentTestTerminal = [
        vs.window.createTerminal({ name: "Test Output", pty: pseudoterminal }),
        emitter,
    ];
    currentTestTerminal[0].show();
    return currentTestTerminal;
}
exports.writeToPseudoTerminal = writeToPseudoTerminal;
function formatForTerminal(output) {
    // For terminal, if we send \n without a \r the rendering will be bad.
    return output.replace(/\n/g, "\r\n").replace(/\r\r\n/g, "\r\n");
}
exports.formatForTerminal = formatForTerminal;


/***/ }),

/***/ 5663:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageDepPackage = exports.PackageDepProjectPackageGroup = exports.PackageDepProject = exports.PackageDepFolder = exports.PackageDepFile = exports.PackageDep = exports.DartPackagesProvider = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const deps_1 = __webpack_require__(2253);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_2 = __webpack_require__(7220);
const config_1 = __webpack_require__(4165);
const utils_3 = __webpack_require__(8779);
class DartPackagesProvider {
    constructor(logger, context, dartCapabilities) {
        this.logger = logger;
        this.context = context;
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        this.onDidChangeTreeDataEmitter = new vs.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeTreeDataEmitter.event;
        this.processPackageMapChangeEvents = true;
        this.disposables.push(vs.commands.registerCommand("_dart.removeDependencyFromTreeNode", this.removeDependency, this));
        context.events.onPackageMapChange.listen(() => {
            // Calling "pub deps --json" modifies .dart_tool/package_config.json which
            // causes a loop here. The file is modified, we rebuild the tree, which triggers
            // the file to be modified, which rebuilds...
            //
            // As a workaround, when this fires, suppress any further events for a short period.
            // This may result in dropped events, but it's better than the loop.
            if (!this.processPackageMapChangeEvents)
                return;
            this.processPackageMapChangeEvents = false;
            setTimeout(() => this.processPackageMapChangeEvents = true, 5000);
            this.onDidChangeTreeDataEmitter.fire(undefined);
        });
        this.deps = new deps_1.PubDeps(logger, context.sdks, dartCapabilities);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!element) {
                const allProjects = yield (0, utils_2.getAllProjectFolders)(this.logger, utils_3.getExcludedFolders, { requirePubspec: true, searchDepth: config_1.config.projectSearchDepth });
                const nodes = allProjects.map((folder) => new PackageDepProject(vs.Uri.file(folder)));
                // If there's only one, just skip over to the deps.
                return nodes.length === 1
                    ? this.getChildren(nodes[0])
                    : nodes;
            }
            else if (element instanceof PackageDepProject) {
                // Try getting dependencies from `pub deps`.
                let packages;
                let shortestPaths;
                if (this.dartCapabilities.supportsPubDepsJson) {
                    // Fetch dependencies with "pub deps --json".
                    const root = yield this.deps.getRootDependency(element.projectFolder);
                    packages = root ? this.deps.getPackageMap(root) : undefined;
                    shortestPaths = packages ? this.deps.computeShortestPaths(packages) : undefined;
                }
                // Get packages from package file.
                const allPackages = yield this.getPackages(element, shortestPaths);
                if (!packages)
                    return allPackages;
                // Split the packages into groups.
                const directPackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "direct"; });
                const devPackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "dev"; });
                const transitivePackages = allPackages.filter((p) => { var _a; return ((_a = packages[p.packageName]) === null || _a === void 0 ? void 0 : _a.kind) === "transitive"; });
                for (const p of directPackages)
                    p.contextValue = constants_1.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                for (const p of devPackages)
                    p.contextValue = constants_1.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                for (const p of transitivePackages)
                    p.contextValue = constants_1.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT;
                const nodes = [];
                if (directPackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("direct dependencies", constants_1.DART_DEP_DEPENDENCIES_NODE_CONTEXT, directPackages));
                if (devPackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("dev dependencies", constants_1.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT, devPackages));
                if (transitivePackages.length)
                    nodes.push(new PackageDepProjectPackageGroup("transitive dependencies", constants_1.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT, transitivePackages, shortestPaths));
                return nodes;
            }
            else if (element instanceof PackageDepProjectPackageGroup) {
                // For the package groups, we've already computed the children when we split
                // them into the grous, so just return them directly.
                return element.packages;
            }
            else if (element instanceof PackageDepPackage) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFolder) {
                return this.getFilesAndFolders(element);
            }
            else if (element instanceof PackageDepFile) {
                return [];
            }
            else {
                this.logger.warn(`Don't know how to show children of ${element.label}/${element.resourceUri}`);
                return [];
            }
        });
    }
    getPackages(project, shortestPaths) {
        return __awaiter(this, void 0, void 0, function* () {
            const map = package_map_1.PackageMap.loadForProject(this.logger, project.projectFolder);
            const packages = map.packages;
            const packageNames = (0, array_1.sortBy)(Object.keys(packages), (s) => s.toLowerCase());
            const packageDepNodes = packageNames
                .filter((name) => packages[name] && !(0, fs_1.areSameFolder)(packages[name], path.join(project.projectFolder, "lib")))
                .map((name) => {
                let packagePath = packages[name];
                if (path.basename(packagePath) === "lib")
                    packagePath = path.normalize(path.join(packagePath, ".."));
                const shortestPath = shortestPaths ? shortestPaths[name] : undefined;
                return new PackageDepPackage(`${name}`, vs.Uri.file(packagePath), project.projectFolder, shortestPath);
            });
            return packageDepNodes;
        });
    }
    getFilesAndFolders(folder) {
        const children = (0, array_1.sortBy)(fs.readdirSync((0, fs_1.fsPath)(folder.resourceUri), { withFileTypes: true }), (s) => s.name.toLowerCase());
        const folders = [];
        const files = [];
        if (!folder.resourceUri)
            return [];
        const folderPath = (0, fs_1.fsPath)(folder.resourceUri);
        children.forEach((child) => {
            const filePath = path.join(folderPath, child.name);
            if (child.isFile()) {
                files.push(new PackageDepFile(vs.Uri.file(filePath)));
            }
            else if (child.isDirectory()) {
                folders.push(new PackageDepFolder(vs.Uri.file(filePath)));
            }
        });
        return [...folders, ...files];
    }
    removeDependency(treeNode) {
        return __awaiter(this, void 0, void 0, function* () {
            const packageName = treeNode === null || treeNode === void 0 ? void 0 : treeNode.packageName;
            const projectFolder = treeNode === null || treeNode === void 0 ? void 0 : treeNode.projectFolder;
            if (packageName && projectFolder)
                yield vs.commands.executeCommand("_dart.removeDependency", treeNode.projectFolder, treeNode.packageName);
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DartPackagesProvider = DartPackagesProvider;
class PackageDep extends vs.TreeItem {
    constructor(label, resourceUri, collapsibleState) {
        if (label) {
            super(label, collapsibleState);
            this.resourceUri = resourceUri;
        }
        else if (resourceUri) {
            super(resourceUri, collapsibleState);
        }
        else {
            super("<unnamed>", collapsibleState);
        }
    }
}
exports.PackageDep = PackageDep;
class PackageDepFile extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.None);
        this.contextValue = constants_1.DART_DEP_FILE_NODE_CONTEXT;
        this.command = {
            arguments: [resourceUri],
            command: "dart.package.openFile",
            title: "Open File",
        };
    }
}
exports.PackageDepFile = PackageDepFile;
class PackageDepFolder extends PackageDep {
    constructor(resourceUri) {
        super(undefined, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.contextValue = constants_1.DART_DEP_FOLDER_NODE_CONTEXT;
    }
}
exports.PackageDepFolder = PackageDepFolder;
class PackageDepProject extends PackageDep {
    constructor(projectUri) {
        const projectFolder = (0, fs_1.fsPath)(projectUri);
        super(path.basename(projectFolder), undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.projectFolder = projectFolder;
        this.contextValue = constants_1.DART_DEP_PROJECT_NODE_CONTEXT;
        // Calculate relative path to the folder for the description.
        const wf = vs.workspace.getWorkspaceFolder(projectUri);
        if (wf) {
            const workspaceFolder = (0, fs_1.fsPath)(wf.uri);
            this.description = path.relative(path.dirname(workspaceFolder), path.dirname(projectFolder));
        }
    }
}
exports.PackageDepProject = PackageDepProject;
class PackageDepProjectPackageGroup extends PackageDep {
    constructor(label, context, packages, shortestPaths) {
        super(label, undefined, vs.TreeItemCollapsibleState.Collapsed);
        this.packages = packages;
        this.shortestPaths = shortestPaths;
        this.contextValue = context;
    }
}
exports.PackageDepProjectPackageGroup = PackageDepProjectPackageGroup;
class PackageDepPackage extends PackageDep {
    constructor(packageName, resourceUri, projectFolder, shortestPath) {
        super(packageName, resourceUri, vs.TreeItemCollapsibleState.Collapsed);
        this.packageName = packageName;
        this.projectFolder = projectFolder;
        this.contextValue = constants_1.DART_DEP_PACKAGE_NODE_CONTEXT;
        if (shortestPath)
            this.tooltip = shortestPath.join(" → ");
    }
}
exports.PackageDepPackage = PackageDepPackage;


/***/ }),

/***/ 556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteStatementRequest = exports.ReanalyzeRequest = exports.DiagnosticServerRequest = exports.SuperRequest = exports.PublishFlutterOutlineNotification = exports.PublishOutlineNotification = exports.PublishClosingLabelsNotification = exports.AnalyzerStatusNotification = void 0;
const vscode_languageclient_1 = __webpack_require__(2850);
class AnalyzerStatusNotification {
}
exports.AnalyzerStatusNotification = AnalyzerStatusNotification;
AnalyzerStatusNotification.type = new vscode_languageclient_1.NotificationType("$/analyzerStatus");
class PublishClosingLabelsNotification {
}
exports.PublishClosingLabelsNotification = PublishClosingLabelsNotification;
PublishClosingLabelsNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishClosingLabels");
class PublishOutlineNotification {
}
exports.PublishOutlineNotification = PublishOutlineNotification;
PublishOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishOutline");
class PublishFlutterOutlineNotification {
}
exports.PublishFlutterOutlineNotification = PublishFlutterOutlineNotification;
PublishFlutterOutlineNotification.type = new vscode_languageclient_1.NotificationType("dart/textDocument/publishFlutterOutline");
class SuperRequest {
}
exports.SuperRequest = SuperRequest;
SuperRequest.type = new vscode_languageclient_1.RequestType("dart/textDocument/super");
class DiagnosticServerRequest {
}
exports.DiagnosticServerRequest = DiagnosticServerRequest;
DiagnosticServerRequest.type = new vscode_languageclient_1.RequestType0("dart/diagnosticServer");
class ReanalyzeRequest {
}
exports.ReanalyzeRequest = ReanalyzeRequest;
ReanalyzeRequest.type = new vscode_languageclient_1.RequestType0("dart/reanalyze");
class CompleteStatementRequest {
}
exports.CompleteStatementRequest = CompleteStatementRequest;
CompleteStatementRequest.type = new vscode_languageclient_1.RequestType("dart/completeStatement");


/***/ }),

/***/ 458:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Analyzer = void 0;
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const promises_1 = __webpack_require__(776);
class Analyzer {
    constructor(logger) {
        this.logger = logger;
        this.disposables = [];
        this.onReadyCompleter = new utils_1.PromiseCompleter();
        this.onReady = this.onReadyCompleter.promise;
        this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
        // InitialAnalysis uses the very first promise from onAnalysisCompleteCompleter.
        this.onInitialAnalysis = this.onAnalysisCompleteCompleter.promise;
        // TODO: Remove suppressProgress when non-LSP is gone and Flutter stable has LSP server that uses $/progress.
        this.onAnalysisStatusChangeEmitter = new events_1.EventEmitter();
        this.onAnalysisStatusChange = this.onAnalysisStatusChangeEmitter.event;
        this.isAnalyzing = false;
        this.disposables.push(this.onAnalysisStatusChangeEmitter);
        // tslint:disable-next-line: no-floating-promises
        this.setup();
    }
    get onCurrentAnalysisComplete() { return this.isAnalyzing ? this.onAnalysisCompleteCompleter.promise : promises_1.resolvedPromise; }
    get onNextAnalysisComplete() { return this.onAnalysisCompleteCompleter.promise; }
    setup() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onReady;
            this.onAnalysisStatusChange.listen((status) => {
                this.isAnalyzing = status.isAnalyzing;
                if (!status.isAnalyzing) {
                    this.onAnalysisCompleteCompleter.resolve();
                    this.onAnalysisCompleteCompleter = new utils_1.PromiseCompleter();
                }
            });
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.Analyzer = Analyzer;


/***/ }),

/***/ 7355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartCapabilities = void 0;
const utils_1 = __webpack_require__(4586);
const constants_1 = __webpack_require__(5628);
class DartCapabilities {
    constructor(dartVersion) {
        this.version = dartVersion;
    }
    static get empty() { return new DartCapabilities("0.0.0"); }
    get canDefaultLsp() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get canDefaultSdkDaps() {
        // For Windows, we need a higher version.
        // https://github.com/Dart-Code/Dart-Code/issues/4149
        // https://github.com/dart-lang/sdk/commit/1b9adcb502c5e4ec1bc5ce8e8b0387db25216833
        if (constants_1.isWin)
            return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-196");
        else
            return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-0");
    }
    // This is also missing in v2.10, but assume it will be back in v2.11.
    // https://github.com/dart-lang/sdk/issues/43207
    get includesSourceForSdkLibs() { return (0, utils_1.versionIsAtLeast)(this.version, "2.2.1") && !this.version.startsWith("2.10."); }
    get hasLspInsertTextModeSupport() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-0"); }
    get supportsSnippetTextEdits() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-150"); }
    get supportsRefactorValidate() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0"); }
    get supportsWriteServiceInfo() { return (0, utils_1.versionIsAtLeast)(this.version, "2.7.1"); }
    get supportsDartCreate() { return (0, utils_1.versionIsAtLeast)(this.version, "2.10.0"); }
    get supportsDebugInternalLibraries() { return (0, utils_1.versionIsAtLeast)(this.version, "2.9.0-a"); }
    get supportsDisableDartDev() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get hasDdsTimingFix() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-117"); }
    get hasZeroParamNoTabStopFix() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0-117"); }
    get hasDapShutdownFix() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-0"); }
    get hasHoverNamedConstructorIssue() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-0") && !(0, utils_1.versionIsAtLeast)(this.version, "2.19.0-300"); }
    get hasHoverNamedConstructorFix() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-300"); }
    get hasHoverNewlineFix4120() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-173"); }
    get supportsLanguageServerCommand() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.4"); }
    get supportsNoServeDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-172.0"); }
    get supportsPubUpgradeMajorVersions() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0"); }
    get supportsPubOutdated() { return (0, utils_1.versionIsAtLeast)(this.version, "2.8.0-a"); }
    get supportsPubDepsJson() { return (0, utils_1.versionIsAtLeast)(this.version, "2.14.0-0"); }
    get supportsPubAddMultiple() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0"); }
    get supportsDartPub() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsDartRunForPub() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0-0"); }
    get supportsDartDoc() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0"); }
    get supportsDartDevTools() { return (0, utils_1.versionIsAtLeast)(this.version, "2.15.0"); }
    get supportsDartDevToolsPathUrls() { return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-0"); }
    get supportsDartRunTest() { return (0, utils_1.versionIsAtLeast)(this.version, "2.12.0-0"); }
    get supportsMoveTopLevelToFile() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-283"); }
    get supportsNonFileSchemeWorkspaces() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-28"); }
    get supportsCommandParameterSupportedKinds() { return (0, utils_1.versionIsAtLeast)(this.version, "2.19.0-283"); }
    get supportsServerSnippets() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0-258"); }
    get supportsSdkDap() { return (0, utils_1.versionIsAtLeast)(this.version, "2.17.0-0"); }
    get supportsShowTodoArray() { return (0, utils_1.versionIsAtLeast)(this.version, "2.16.0-0"); }
    get sdkDapProvidesExceptionText() { return (0, utils_1.versionIsAtLeast)(this.version, "2.18.0-265"); }
    // TODO: Update these (along with Flutter) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.DartCapabilities = DartCapabilities;


/***/ }),

/***/ 239:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartTestCapabilities = void 0;
const utils_1 = __webpack_require__(4586);
class DartTestCapabilities {
    constructor(testVersion) {
        this.version = testVersion;
    }
    static get empty() { return new DartTestCapabilities("0.0.0"); }
    get supportsIgnoreTimeouts() { return (0, utils_1.versionIsAtLeast)(this.version, "1.20.1"); }
}
exports.DartTestCapabilities = DartTestCapabilities;


/***/ }),

/***/ 4790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DaemonCapabilities = exports.FlutterCapabilities = void 0;
const utils_1 = __webpack_require__(4586);
class FlutterCapabilities {
    constructor(flutterVersion) {
        this.version = flutterVersion;
    }
    static get empty() { return new FlutterCapabilities("0.0.0"); }
    get canDefaultSdkDaps() { return (0, utils_1.versionIsAtLeast)(this.version, "3.4.0-33"); }
    get supportsCreateSkeleton() { return (0, utils_1.versionIsAtLeast)(this.version, "2.5.0"); }
    get supportsCreateEmpty() { return (0, utils_1.versionIsAtLeast)(this.version, "3.6.0-3"); }
    get supportsCreatingSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.0.0"); }
    get hasLatestStructuredErrorsWork() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-5.0"); }
    get supportsFlutterCreateListSamples() { return (0, utils_1.versionIsAtLeast)(this.version, "1.3.10"); }
    get supportsWsVmService() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsWsDebugBackend() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsWsInjectedClient() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-13.0"); }
    get supportsExposeUrl() { return (0, utils_1.versionIsAtLeast)(this.version, "1.18.0-5"); }
    get supportsDartDefine() { return (0, utils_1.versionIsAtLeast)(this.version, "1.17.0"); }
    get supportsRestartDebounce() { return (0, utils_1.versionIsAtLeast)(this.version, "1.21.0-0"); }
    get supportsRunSkippedTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.1.0-11"); }
    get supportsShowWebServerDevice() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-0"); }
    get supportsWebRendererOption() { return (0, utils_1.versionIsAtLeast)(this.version, "1.25.0-0"); }
    get supportsDevToolsServerAddress() { return (0, utils_1.versionIsAtLeast)(this.version, "1.26.0-12"); }
    get supportsRunningIntegrationTests() { return (0, utils_1.versionIsAtLeast)(this.version, "2.2.0-10"); }
    get supportsSdkDap() { return (0, utils_1.versionIsAtLeast)(this.version, "2.13.0-0"); }
    get supportsEnvInSdkDAP() { return (0, utils_1.versionIsAtLeast)(this.version, "3.4.0-18"); }
    get supportsWebInSdkDAP() { return (0, utils_1.versionIsAtLeast)(this.version, "3.4.0-18"); }
    get requiresDdsDisabledForSdkDapTestRuns() { return !(0, utils_1.versionIsAtLeast)(this.version, "3.1.0"); }
    // TODO: Update these (along with Dart) when supported.
    get webSupportsEvaluation() { return false; }
    get webSupportsDebugging() { return true; }
    get webSupportsHotReload() { return false; }
}
exports.FlutterCapabilities = FlutterCapabilities;
class DaemonCapabilities {
    constructor(daemonProtocolVersion) {
        this.version = daemonProtocolVersion;
    }
    static get empty() { return new DaemonCapabilities("0.0.0"); }
    get canCreateEmulators() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.0"); }
    get canFlutterAttach() { return (0, utils_1.versionIsAtLeast)(this.version, "0.4.1"); }
    get providesPlatformTypes() { return (0, utils_1.versionIsAtLeast)(this.version, "0.5.2"); }
    get supportsAvdColdBootLaunch() { return (0, utils_1.versionIsAtLeast)(this.version, "0.6.1"); }
}
exports.DaemonCapabilities = DaemonCapabilities;


/***/ }),

/***/ 7068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.vsCodeVersion = exports.CodeCapabilities = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_cloud_1 = __webpack_require__(9492);
class CodeCapabilities {
    constructor(version) {
        this.version = version;
    }
    // This version should match the minimum the LSP client we're using supports.
    // https://github.com/microsoft/vscode-languageserver-node/blob/main/client/src/node/main.ts#L25
    get supportsLatestLspClient() { return (0, utils_1.versionIsAtLeast)(this.version, "1.67.0"); }
    // Theia doesn't currently support launching without a launch.json. This may need updating to also
    // check the version in future.
    get supportsDebugWithoutLaunchJson() { return !utils_cloud_1.isTheia; }
    // Cloud IDEs may have authentication issues trying to use embedded DevTools so just disable it.
    get supportsEmbeddedDevTools() { return !utils_cloud_1.isKnownCloudIde; }
    get supportsDevTools() { return !utils_cloud_1.isCloudShell; } // Until DevTools can work without SSE, it will not work on Cloud Shell.
    get editorConfigFolder() { return utils_cloud_1.isTheia ? ".theia" : ".vscode"; }
}
exports.CodeCapabilities = CodeCapabilities;
exports.vsCodeVersion = new CodeCapabilities(vscode_1.version);


/***/ }),

/***/ 5628:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wantToTryDevToolsPrompt = exports.issueTrackerUri = exports.issueTrackerAction = exports.stagehandInstallationInstructionsUrl = exports.pubGlobalDocsUrl = exports.debugTerminatingProgressId = exports.debugLaunchProgressId = exports.restartReasonSave = exports.restartReasonManual = exports.captureLogsMaxLineLength = exports.showLogAction = exports.stopLoggingAction = exports.IS_RUNNING_LOCALLY_CONTEXT = exports.PUB_OUTDATED_SUPPORTED_CONTEXT = exports.DART_IS_CAPTURING_LOGS_CONTEXT = exports.DART_DEP_FILE_NODE_CONTEXT = exports.DART_DEP_FOLDER_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = exports.DART_DEP_PACKAGE_NODE_CONTEXT = exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = exports.DART_DEP_PROJECT_NODE_CONTEXT = exports.IS_LSP_CONTEXT = exports.FLUTTER_DOWNLOAD_URL = exports.DART_DOWNLOAD_URL = exports.androidStudioPaths = exports.analyzerSnapshotPath = exports.pubSnapshotPath = exports.flutterPath = exports.pubPath = exports.dartDocPath = exports.dartVMPath = exports.getExecutableName = exports.executableNames = exports.androidStudioExecutableNames = exports.platformEol = exports.platformDisplayName = exports.dartPlatformName = exports.isChromeOS = exports.isLinux = exports.isMac = exports.isWin = exports.isDartCodeTestRun = exports.isCI = exports.debugAdapterPath = exports.flutterExtensionIdentifier = exports.dartCodeExtensionIdentifier = void 0;
exports.vmServiceListeningBannerPattern = exports.reactivateDevToolsAction = exports.openSettingsAction = exports.recommendedSettingsUrl = exports.showRecommendedSettingsAction = exports.iUnderstandAction = exports.skipAction = exports.noAction = exports.yesAction = exports.useRecommendedSettingsPromptKey = exports.installFlutterExtensionPromptKey = exports.userPromptContextPrefix = exports.debugAnywayAction = exports.showErrorsAction = exports.isInFlutterReleaseModeDebugSessionContext = exports.isInFlutterProfileModeDebugSessionContext = exports.isInFlutterDebugModeDebugSessionContext = exports.isInDartDebugSessionContext = exports.HAS_LAST_TEST_DEBUG_CONFIG = exports.HAS_LAST_DEBUG_CONFIG = exports.REFACTOR_ANYWAY = exports.REFACTOR_FAILED_DOC_MODIFIED = exports.flutterCreateTemplatesSupportingPlatforms = exports.flutterCreateAvailablePlatforms = exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = exports.DART_CREATE_PROJECT_TRIGGER_FILE = exports.CHROME_OS_VM_SERVICE_PORT = exports.CHROME_OS_DEVTOOLS_PORT = exports.projectSearchCacheTimeInMs = exports.projectSearchProgressNotificationDelayInMs = exports.projectSearchProgressText = exports.pleaseReportBug = exports.longRepeatPromptThreshold = exports.noRepeatPromptThreshold = exports.fortyHoursInMs = exports.twentyHoursInMs = exports.twoHoursInMs = exports.twentyMinutesInMs = exports.tenMinutesInMs = exports.fiveMinutesInMs = exports.initializingFlutterMessage = exports.modifyingFilesOutsideWorkspaceInfoUrl = exports.skipThisSurveyAction = exports.takeSurveyAction = exports.flutterSurveyDataUrl = exports.moreInfoAction = exports.doNotAskAgainAction = exports.notTodayAction = exports.alwaysOpenAction = exports.openAction = void 0;
exports.MAX_VERSION = exports.defaultLaunchJson = exports.dartRecommendedConfig = exports.devToolsPages = exports.performancePage = exports.cpuProfilerPage = exports.widgetInspectorPage = exports.validClassNameRegex = exports.validMethodNameRegex = exports.cancelAction = exports.runFlutterCreatePrompt = exports.vmServiceHttpLinkPattern = void 0;
const fs = __webpack_require__(7147);
const utils_1 = __webpack_require__(4586);
exports.dartCodeExtensionIdentifier = "Dart-Code.dart-code";
exports.flutterExtensionIdentifier = "Dart-Code.flutter";
exports.debugAdapterPath = "out/dist/debug.js";
exports.isCI = !!process.env.CI;
exports.isDartCodeTestRun = !!process.env.DART_CODE_IS_TEST_RUN;
exports.isWin = process.platform.startsWith("win");
exports.isMac = process.platform === "darwin";
exports.isLinux = !exports.isWin && !exports.isMac;
exports.isChromeOS = exports.isLinux && fs.existsSync("/dev/.cros_milestone");
// Used for code checks and in Dart SDK urls so Chrome OS is considered Linux.
exports.dartPlatformName = exports.isWin ? "win" : exports.isMac ? "mac" : "linux";
// Used for display (logs, analytics) so Chrome OS is its own.
exports.platformDisplayName = exports.isWin ? "win" : exports.isMac ? "mac" : exports.isChromeOS ? "chromeos" : "linux";
exports.platformEol = exports.isWin ? "\r\n" : "\n";
exports.androidStudioExecutableNames = exports.isWin ? ["studio64.exe"] : ["studio.sh", "studio"];
exports.executableNames = {
    dart: exports.isWin ? "dart.exe" : "dart",
    dartdoc: exports.isWin ? "dartdoc.bat" : "dartdoc",
    flutter: exports.isWin ? "flutter.bat" : "flutter",
    pub: exports.isWin ? "pub.bat" : "pub",
};
const getExecutableName = (cmd) => { var _a; return (_a = exports.executableNames[cmd]) !== null && _a !== void 0 ? _a : cmd; };
exports.getExecutableName = getExecutableName;
exports.dartVMPath = "bin/" + exports.executableNames.dart;
exports.dartDocPath = "bin/" + exports.executableNames.dartdoc;
exports.pubPath = "bin/" + exports.executableNames.pub;
exports.flutterPath = "bin/" + exports.executableNames.flutter;
exports.pubSnapshotPath = "bin/snapshots/pub.dart.snapshot";
exports.analyzerSnapshotPath = "bin/snapshots/analysis_server.dart.snapshot";
exports.androidStudioPaths = exports.androidStudioExecutableNames.map((s) => "bin/" + s);
exports.DART_DOWNLOAD_URL = "https://dart.dev/get-dart";
exports.FLUTTER_DOWNLOAD_URL = "https://flutter.dev/setup/";
exports.IS_LSP_CONTEXT = "dart-code:isLsp";
exports.DART_DEP_PROJECT_NODE_CONTEXT = "dart-code:depProjectNode";
exports.DART_DEP_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDependenciesNode";
exports.DART_DEP_DEV_DEPENDENCIES_NODE_CONTEXT = "dart-code:depDevDependenciesNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCIES_NODE_CONTEXT = "dart-code:depTransitiveDependenciesNode";
exports.DART_DEP_PACKAGE_NODE_CONTEXT = "dart-code:depPackageNode";
exports.DART_DEP_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDependencyPackageNode";
exports.DART_DEP_DEV_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depDevDependencyPackageNode";
exports.DART_DEP_TRANSITIVE_DEPENDENCY_PACKAGE_NODE_CONTEXT = "dart-code:depTransitiveDependencyPackageNode";
exports.DART_DEP_FOLDER_NODE_CONTEXT = "dart-code:depFolderNode";
exports.DART_DEP_FILE_NODE_CONTEXT = "dart-code:depFileNode";
exports.DART_IS_CAPTURING_LOGS_CONTEXT = "dart-code:isCapturingLogs";
exports.PUB_OUTDATED_SUPPORTED_CONTEXT = "dart-code:pubOutdatedSupported";
exports.IS_RUNNING_LOCALLY_CONTEXT = "dart-code:isRunningLocally";
exports.stopLoggingAction = "Stop Logging";
exports.showLogAction = "Show Log";
exports.captureLogsMaxLineLength = 999999999;
exports.restartReasonManual = "manual";
exports.restartReasonSave = "save";
exports.debugLaunchProgressId = "launch";
exports.debugTerminatingProgressId = "terminate";
exports.pubGlobalDocsUrl = "https://www.dartlang.org/tools/pub/cmd/pub-global";
exports.stagehandInstallationInstructionsUrl = "https://github.com/dart-lang/stagehand#installation";
exports.issueTrackerAction = "Issue Tracker";
exports.issueTrackerUri = "https://github.com/Dart-Code/Dart-Code/issues";
exports.wantToTryDevToolsPrompt = "Dart DevTools includes additional tools for debugging and profiling Flutter apps, including a Widget Inspector. Try it?";
exports.openAction = "Open";
exports.alwaysOpenAction = "Always Open";
exports.notTodayAction = "Not Now";
exports.doNotAskAgainAction = "Never Ask";
exports.moreInfoAction = "More Info";
exports.flutterSurveyDataUrl = "https://docs.flutter.dev/f/flutter-survey-metadata.json";
exports.takeSurveyAction = "Take Survey";
exports.skipThisSurveyAction = "Skip This Survey";
exports.modifyingFilesOutsideWorkspaceInfoUrl = "https://dartcode.org/docs/modifying-files-outside-workspace/";
exports.initializingFlutterMessage = "Initializing Flutter. This may take a few minutes.";
// Minutes.
exports.fiveMinutesInMs = 1000 * 60 * 5;
exports.tenMinutesInMs = 1000 * 60 * 10;
exports.twentyMinutesInMs = 1000 * 60 * 20;
// Hours.
exports.twoHoursInMs = 1000 * 60 * 60 * 2;
exports.twentyHoursInMs = 1000 * 60 * 60 * 20;
exports.fortyHoursInMs = 1000 * 60 * 60 * 40;
// Duration for not showing a prompt that has been shown before.
exports.noRepeatPromptThreshold = exports.twentyHoursInMs;
exports.longRepeatPromptThreshold = exports.fortyHoursInMs;
exports.pleaseReportBug = "Please raise a bug against the Dart extension for VS Code.";
exports.projectSearchProgressText = "Searching for projects...";
// Search for 2s before showing progress notification.
exports.projectSearchProgressNotificationDelayInMs = 2000;
exports.projectSearchCacheTimeInMs = exports.fiveMinutesInMs;
// Chrome OS exposed ports: 8000, 8008, 8080, 8085, 8888, 9005, 3000, 4200, 5000
exports.CHROME_OS_DEVTOOLS_PORT = 8080;
exports.CHROME_OS_VM_SERVICE_PORT = 8085;
exports.DART_CREATE_PROJECT_TRIGGER_FILE = "dart.create";
exports.FLUTTER_CREATE_PROJECT_TRIGGER_FILE = "flutter.create";
exports.flutterCreateAvailablePlatforms = ["android", "ios", "linux", "macos", "windows", "web"];
exports.flutterCreateTemplatesSupportingPlatforms = ["app", "plugin", "plugin_ffi", "skeleton"];
exports.REFACTOR_FAILED_DOC_MODIFIED = "This refactor cannot be applied because the document has changed.";
exports.REFACTOR_ANYWAY = "Refactor Anyway";
exports.HAS_LAST_DEBUG_CONFIG = "dart-code:hasLastDebugConfig";
exports.HAS_LAST_TEST_DEBUG_CONFIG = "dart-code:hasLastTestDebugConfig";
exports.isInDartDebugSessionContext = "dart-code:isInDartDebugSession";
exports.isInFlutterDebugModeDebugSessionContext = "dart-code:isInFlutterDebugModeDebugSession";
exports.isInFlutterProfileModeDebugSessionContext = "dart-code:isInFlutterProfileModeDebugSession";
exports.isInFlutterReleaseModeDebugSessionContext = "dart-code:isInFlutterReleaseModeDebugSession";
exports.showErrorsAction = "Show Errors";
exports.debugAnywayAction = "Debug Anyway";
exports.userPromptContextPrefix = "hasPrompted.";
exports.installFlutterExtensionPromptKey = "install_flutter_extension_3";
exports.useRecommendedSettingsPromptKey = "use_recommended_settings";
exports.yesAction = "Yes";
exports.noAction = "No";
exports.skipAction = "Skip";
exports.iUnderstandAction = "I Understand";
exports.showRecommendedSettingsAction = "Show Recommended Settings";
exports.recommendedSettingsUrl = "https://dartcode.org/docs/recommended-settings/";
exports.openSettingsAction = "Open Settings File";
exports.reactivateDevToolsAction = "Reactivate DevTools";
exports.vmServiceListeningBannerPattern = new RegExp("(?:Observatory|The Dart VM service is) (?:listening on|.* is available at:) (http:.+)");
exports.vmServiceHttpLinkPattern = new RegExp("(http://[\\d\\.:]+/)");
const runFlutterCreatePrompt = (platformType, platformNeedsGloballyEnabling) => platformNeedsGloballyEnabling
    ? `Enable the ${platformType} platform and add it to this project?`
    : `Add the ${platformType} platform to this project?`;
exports.runFlutterCreatePrompt = runFlutterCreatePrompt;
exports.cancelAction = "Cancel";
exports.validMethodNameRegex = new RegExp("^[a-zA-Z_][a-zA-Z0-9_]*$");
exports.validClassNameRegex = exports.validMethodNameRegex;
exports.widgetInspectorPage = { id: "inspector", commandId: "dart.openDevToolsInspector", title: "Widget Inspector" };
exports.cpuProfilerPage = { id: "cpu-profiler", commandId: "dart.openDevToolsCpuProfiler", title: "CPU Profiler" };
exports.performancePage = {
    commandId: "dart.openDevToolsPerformance",
    id: "performance",
    routeId: (flutterVersion) => !flutterVersion || (0, utils_1.versionIsAtLeast)(flutterVersion, "2.3.1" /* 2.3.0-16.0? */) ? "performance" : "legacy-performance",
    title: "Performance",
};
exports.devToolsPages = [
    // First entry is the default page.
    exports.widgetInspectorPage,
    exports.cpuProfilerPage,
    { id: "memory", commandId: "dart.openDevToolsMemory", title: "Memory" },
    exports.performancePage,
    { id: "network", commandId: "dart.openDevToolsNetwork", title: "Network" },
    { id: "logging", commandId: "dart.openDevToolsLogging", title: "Logging" },
];
exports.dartRecommendedConfig = {
    // Automatically format code on save and during typing of certain characters
    // (like `;` and `}`).
    "editor.formatOnSave": true,
    "editor.formatOnType": true,
    // Draw a guide line at 80 characters, where Dart's formatting will wrap code.
    "editor.rulers": [80],
    // Disables built-in highlighting of words that match your selection. Without
    // this, all instances of the selected text will be highlighted, interfering
    // with Dart's ability to highlight only exact references to the selected variable.
    "editor.selectionHighlight": false,
    // By default, VS Code prevents code completion from popping open when in
    // "snippet mode" (editing placeholders in inserted code). Setting this option
    // to `false` stops that and allows completion to open as normal, as if you
    // weren't in a snippet placeholder.
    "editor.suggest.snippetsPreventQuickSuggestions": false,
    // By default, VS Code will pre-select the most recently used item from code
    // completion. This is usually not the most relevant item.
    //
    // "first" will always select top item
    // "recentlyUsedByPrefix" will filter the recently used items based on the
    //     text immediately preceeding where completion was invoked.
    "editor.suggestSelection": "first",
    // Allows pressing <TAB> to complete snippets such as `for` even when the
    // completion list is not visible.
    "editor.tabCompletion": "onlySnippets",
    // By default, VS Code will populate code completion with words found in the
    // current file when a language service does not provide its own completions.
    // This results in code completion suggesting words when editing comments and
    // strings. This setting will prevent that.
    "editor.wordBasedSuggestions": false,
};
exports.defaultLaunchJson = JSON.stringify({
    "configurations": [
        {
            "name": "Dart & Flutter",
            "request": "launch",
            "type": "dart",
        },
    ],
    "version": "0.2.0",
}, undefined, "\t");
// This indicates that a version is the latest possible.
exports.MAX_VERSION = "999.999.999";


/***/ }),

/***/ 7341:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DebugOption = exports.debugOptionNames = exports.LogSeverity = exports.LogCategory = exports.VersionStatus = exports.VmService = exports.VmServiceExtension = exports.TestStatus = exports.DebuggerType = void 0;
var DebuggerType;
(function (DebuggerType) {
    DebuggerType[DebuggerType["Dart"] = 0] = "Dart";
    DebuggerType[DebuggerType["DartTest"] = 1] = "DartTest";
    DebuggerType[DebuggerType["Flutter"] = 2] = "Flutter";
    DebuggerType[DebuggerType["FlutterTest"] = 3] = "FlutterTest";
    DebuggerType[DebuggerType["Web"] = 4] = "Web";
    DebuggerType[DebuggerType["WebTest"] = 5] = "WebTest";
})(DebuggerType = exports.DebuggerType || (exports.DebuggerType = {}));
var TestStatus;
(function (TestStatus) {
    // This should be in order such that the highest number is the one to show
    // when aggregating (eg. from children).
    TestStatus[TestStatus["Waiting"] = 0] = "Waiting";
    TestStatus[TestStatus["Skipped"] = 1] = "Skipped";
    TestStatus[TestStatus["Passed"] = 2] = "Passed";
    TestStatus[TestStatus["Unknown"] = 3] = "Unknown";
    TestStatus[TestStatus["Failed"] = 4] = "Failed";
    TestStatus[TestStatus["Running"] = 5] = "Running";
})(TestStatus = exports.TestStatus || (exports.TestStatus = {}));
/// The service extensions we know about.
var VmServiceExtension;
(function (VmServiceExtension) {
    VmServiceExtension["PlatformOverride"] = "ext.flutter.platformOverride";
    VmServiceExtension["DebugBanner"] = "ext.flutter.debugAllowBanner";
    VmServiceExtension["DebugPaint"] = "ext.flutter.debugPaint";
    VmServiceExtension["Driver"] = "ext.flutter.driver";
    VmServiceExtension["PaintBaselines"] = "ext.flutter.debugPaintBaselinesEnabled";
    VmServiceExtension["InspectorSelectMode"] = "ext.flutter.inspector.show";
    VmServiceExtension["InspectorSetPubRootDirectories"] = "ext.flutter.inspector.setPubRootDirectories";
    VmServiceExtension["BrightnessOverride"] = "ext.flutter.brightnessOverride";
    VmServiceExtension["RepaintRainbow"] = "ext.flutter.repaintRainbow";
    VmServiceExtension["PerformanceOverlay"] = "ext.flutter.showPerformanceOverlay";
    VmServiceExtension["SlowAnimations"] = "ext.flutter.timeDilation";
})(VmServiceExtension = exports.VmServiceExtension || (exports.VmServiceExtension = {}));
/// The service extensions we know about and allow toggling via commands.
var VmService;
(function (VmService) {
    VmService["HotReload"] = "reloadSources";
    VmService["HotRestart"] = "hotRestart";
    VmService["LaunchDevTools"] = "launchDevTools";
})(VmService = exports.VmService || (exports.VmService = {}));
var VersionStatus;
(function (VersionStatus) {
    VersionStatus[VersionStatus["NotInstalled"] = 0] = "NotInstalled";
    VersionStatus[VersionStatus["UpdateRequired"] = 1] = "UpdateRequired";
    VersionStatus[VersionStatus["UpdateAvailable"] = 2] = "UpdateAvailable";
    VersionStatus[VersionStatus["Valid"] = 3] = "Valid";
})(VersionStatus = exports.VersionStatus || (exports.VersionStatus = {}));
var LogCategory;
(function (LogCategory) {
    LogCategory[LogCategory["General"] = 0] = "General";
    LogCategory[LogCategory["CI"] = 1] = "CI";
    LogCategory[LogCategory["CommandProcesses"] = 2] = "CommandProcesses";
    LogCategory[LogCategory["DAP"] = 3] = "DAP";
    LogCategory[LogCategory["DevTools"] = 4] = "DevTools";
    LogCategory[LogCategory["Analyzer"] = 5] = "Analyzer";
    LogCategory[LogCategory["AnalyzerTiming"] = 6] = "AnalyzerTiming";
    LogCategory[LogCategory["DartTest"] = 7] = "DartTest";
    LogCategory[LogCategory["FlutterDaemon"] = 8] = "FlutterDaemon";
    LogCategory[LogCategory["FlutterRun"] = 9] = "FlutterRun";
    LogCategory[LogCategory["FlutterTest"] = 10] = "FlutterTest";
    LogCategory[LogCategory["VmService"] = 11] = "VmService";
    LogCategory[LogCategory["WebDaemon"] = 12] = "WebDaemon";
})(LogCategory = exports.LogCategory || (exports.LogCategory = {}));
var LogSeverity;
(function (LogSeverity) {
    LogSeverity[LogSeverity["Info"] = 0] = "Info";
    LogSeverity[LogSeverity["Warn"] = 1] = "Warn";
    LogSeverity[LogSeverity["Error"] = 2] = "Error";
})(LogSeverity = exports.LogSeverity || (exports.LogSeverity = {}));
exports.debugOptionNames = ["my code", "my code + packages", "my code + packages + SDK", "my code + SDK"];
var DebugOption;
(function (DebugOption) {
    DebugOption[DebugOption["MyCode"] = 0] = "MyCode";
    DebugOption[DebugOption["MyCodePackages"] = 1] = "MyCodePackages";
    DebugOption[DebugOption["MyCodePackagesSdk"] = 2] = "MyCodePackagesSdk";
    DebugOption[DebugOption["MyCodeSdk"] = 3] = "MyCodeSdk";
})(DebugOption = exports.DebugOption || (exports.DebugOption = {}));


/***/ }),

/***/ 3254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventEmitter = void 0;
const evt = __webpack_require__(2361);
class EventEmitter {
    constructor() {
        this.emitter = new evt.EventEmitter();
    }
    fire(x) {
        this.emitter.emit("thing", x);
    }
    listen(listener) {
        this.emitter.on("thing", listener);
        return {
            dispose: () => { this.emitter.removeListener("thing", listener); },
        };
    }
    get event() { return this; }
    dispose() {
        this.emitter.removeAllListeners();
    }
}
exports.EventEmitter = EventEmitter;


/***/ }),

/***/ 2183:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebClient = void 0;
const http = __webpack_require__(3685);
const https = __webpack_require__(5687);
const url = __webpack_require__(7310);
const zlib = __webpack_require__(9796);
class WebClient {
    constructor(extensionVersion) {
        this.userAgent = `Dart-Code/${extensionVersion} (https://dartcode.org/)`;
    }
    // TODO: Move over things over to this...
    fetch(urlString, headers) {
        const u = url.parse(urlString);
        if (u.protocol === "https:" && u.hostname)
            return this.fetchHttps(u.hostname, u.port || "443", u.path || "", headers);
        else if (u.protocol === "http:" && u.hostname)
            return this.fetchHttp(u.hostname, u.port || "80", u.path || "", headers);
        else
            throw new Error(`Cannot fetch URL ${urlString}`);
    }
    fetchHttps(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = https.request(options, (res) => this.handleResponse(headers, res, resolve, reject, path));
            req.end();
        });
    }
    handleResponse(headers, resp, resolve, reject, path) {
        if (!resp || !resp.statusCode) {
            reject({ message: `Failed to get ${path}: ${resp && resp.statusMessage}` });
        }
        else if (resp.statusCode >= 301 && resp.statusCode <= 302) {
            const newLocation = resp.headers.location;
            if (!newLocation) {
                reject({ message: `Redirect with no 'location' header for ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
            }
            else {
                resolve(this.fetch(newLocation, headers));
            }
        }
        else if (resp.statusCode < 200 || resp.statusCode > 300) {
            reject({ message: `Bad status code for ${path}: ${resp && resp.statusCode}: ${resp && resp.statusMessage}` });
        }
        else {
            const chunks = [];
            resp.on("data", (b) => chunks.push(b));
            resp.on("end", () => {
                const buffer = Buffer.concat(chunks);
                const encoding = resp.headers["content-encoding"];
                if (encoding === "gzip") {
                    zlib.gunzip(buffer, (err, decoded) => {
                        if (err)
                            reject(err);
                        else
                            resolve(decoded === null || decoded === void 0 ? void 0 : decoded.toString());
                    });
                }
                else {
                    resolve(buffer.toString());
                }
            });
        }
    }
    fetchHttp(hostname, port, path, headers = {}) {
        return new Promise((resolve, reject) => {
            const options = {
                headers: Object.assign(Object.assign({}, headers), { "User-Agent": this.userAgent }),
                hostname,
                method: "GET",
                path,
                port,
            };
            const req = http.request(options, (res) => this.handleResponse(headers, res, resolve, reject, path));
            req.end();
        });
    }
}
exports.WebClient = WebClient;


/***/ }),

/***/ 2241:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// Generated file - do not edit.
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.flutterCSSColors = exports.flutterCupertinoColors = exports.flutterMaterialColors = void 0;
// tslint:disable: object-literal-sort-keys
exports.flutterMaterialColors = {
    "amber.primary": "ffffc107",
    "amber[50]": "fffff8e1",
    "amber[100]": "ffffecb3",
    "amber[200]": "ffffe082",
    "amber[300]": "ffffd54f",
    "amber[400]": "ffffca28",
    "amber[500]": "ffffc107",
    "amber[600]": "ffffb300",
    "amber[700]": "ffffa000",
    "amber[800]": "ffff8f00",
    "amber[900]": "ffff6f00",
    "amberAccent.primary": "ffffd740",
    "amberAccent[100]": "ffffe57f",
    "amberAccent[200]": "ffffd740",
    "amberAccent[400]": "ffffc400",
    "amberAccent[700]": "ffffab00",
    "black": "ff000000",
    "black12": "1f000000",
    "black26": "42000000",
    "black38": "61000000",
    "black45": "73000000",
    "black54": "8a000000",
    "black87": "dd000000",
    "blue.primary": "ff2196f3",
    "blue[50]": "ffe3f2fd",
    "blue[100]": "ffbbdefb",
    "blue[200]": "ff90caf9",
    "blue[300]": "ff64b5f6",
    "blue[400]": "ff42a5f5",
    "blue[500]": "ff2196f3",
    "blue[600]": "ff1e88e5",
    "blue[700]": "ff1976d2",
    "blue[800]": "ff1565c0",
    "blue[900]": "ff0d47a1",
    "blueAccent.primary": "ff448aff",
    "blueAccent[100]": "ff82b1ff",
    "blueAccent[200]": "ff448aff",
    "blueAccent[400]": "ff2979ff",
    "blueAccent[700]": "ff2962ff",
    "blueGrey.primary": "ff607d8b",
    "blueGrey[50]": "ffeceff1",
    "blueGrey[100]": "ffcfd8dc",
    "blueGrey[200]": "ffb0bec5",
    "blueGrey[300]": "ff90a4ae",
    "blueGrey[400]": "ff78909c",
    "blueGrey[500]": "ff607d8b",
    "blueGrey[600]": "ff546e7a",
    "blueGrey[700]": "ff455a64",
    "blueGrey[800]": "ff37474f",
    "blueGrey[900]": "ff263238",
    "brown.primary": "ff795548",
    "brown[50]": "ffefebe9",
    "brown[100]": "ffd7ccc8",
    "brown[200]": "ffbcaaa4",
    "brown[300]": "ffa1887f",
    "brown[400]": "ff8d6e63",
    "brown[500]": "ff795548",
    "brown[600]": "ff6d4c41",
    "brown[700]": "ff5d4037",
    "brown[800]": "ff4e342e",
    "brown[900]": "ff3e2723",
    "cyan.primary": "ff00bcd4",
    "cyan[50]": "ffe0f7fa",
    "cyan[100]": "ffb2ebf2",
    "cyan[200]": "ff80deea",
    "cyan[300]": "ff4dd0e1",
    "cyan[400]": "ff26c6da",
    "cyan[500]": "ff00bcd4",
    "cyan[600]": "ff00acc1",
    "cyan[700]": "ff0097a7",
    "cyan[800]": "ff00838f",
    "cyan[900]": "ff006064",
    "cyanAccent.primary": "ff18ffff",
    "cyanAccent[100]": "ff84ffff",
    "cyanAccent[200]": "ff18ffff",
    "cyanAccent[400]": "ff00e5ff",
    "cyanAccent[700]": "ff00b8d4",
    "deepOrange.primary": "ffff5722",
    "deepOrange[50]": "fffbe9e7",
    "deepOrange[100]": "ffffccbc",
    "deepOrange[200]": "ffffab91",
    "deepOrange[300]": "ffff8a65",
    "deepOrange[400]": "ffff7043",
    "deepOrange[500]": "ffff5722",
    "deepOrange[600]": "fff4511e",
    "deepOrange[700]": "ffe64a19",
    "deepOrange[800]": "ffd84315",
    "deepOrange[900]": "ffbf360c",
    "deepOrangeAccent.primary": "ffff6e40",
    "deepOrangeAccent[100]": "ffff9e80",
    "deepOrangeAccent[200]": "ffff6e40",
    "deepOrangeAccent[400]": "ffff3d00",
    "deepOrangeAccent[700]": "ffdd2c00",
    "deepPurple.primary": "ff673ab7",
    "deepPurple[50]": "ffede7f6",
    "deepPurple[100]": "ffd1c4e9",
    "deepPurple[200]": "ffb39ddb",
    "deepPurple[300]": "ff9575cd",
    "deepPurple[400]": "ff7e57c2",
    "deepPurple[500]": "ff673ab7",
    "deepPurple[600]": "ff5e35b1",
    "deepPurple[700]": "ff512da8",
    "deepPurple[800]": "ff4527a0",
    "deepPurple[900]": "ff311b92",
    "deepPurpleAccent.primary": "ff7c4dff",
    "deepPurpleAccent[100]": "ffb388ff",
    "deepPurpleAccent[200]": "ff7c4dff",
    "deepPurpleAccent[400]": "ff651fff",
    "deepPurpleAccent[700]": "ff6200ea",
    "green.primary": "ff4caf50",
    "green[50]": "ffe8f5e9",
    "green[100]": "ffc8e6c9",
    "green[200]": "ffa5d6a7",
    "green[300]": "ff81c784",
    "green[400]": "ff66bb6a",
    "green[500]": "ff4caf50",
    "green[600]": "ff43a047",
    "green[700]": "ff388e3c",
    "green[800]": "ff2e7d32",
    "green[900]": "ff1b5e20",
    "greenAccent.primary": "ff69f0ae",
    "greenAccent[100]": "ffb9f6ca",
    "greenAccent[200]": "ff69f0ae",
    "greenAccent[400]": "ff00e676",
    "greenAccent[700]": "ff00c853",
    "grey.primary": "ff9e9e9e",
    "grey[50]": "fffafafa",
    "grey[100]": "fff5f5f5",
    "grey[200]": "ffeeeeee",
    "grey[300]": "ffe0e0e0",
    "grey[350]": "ffd6d6d6",
    "grey[400]": "ffbdbdbd",
    "grey[500]": "ff9e9e9e",
    "grey[600]": "ff757575",
    "grey[700]": "ff616161",
    "grey[800]": "ff424242",
    "grey[850]": "ff303030",
    "grey[900]": "ff212121",
    "indigo.primary": "ff3f51b5",
    "indigo[50]": "ffe8eaf6",
    "indigo[100]": "ffc5cae9",
    "indigo[200]": "ff9fa8da",
    "indigo[300]": "ff7986cb",
    "indigo[400]": "ff5c6bc0",
    "indigo[500]": "ff3f51b5",
    "indigo[600]": "ff3949ab",
    "indigo[700]": "ff303f9f",
    "indigo[800]": "ff283593",
    "indigo[900]": "ff1a237e",
    "indigoAccent.primary": "ff536dfe",
    "indigoAccent[100]": "ff8c9eff",
    "indigoAccent[200]": "ff536dfe",
    "indigoAccent[400]": "ff3d5afe",
    "indigoAccent[700]": "ff304ffe",
    "lightBlue.primary": "ff03a9f4",
    "lightBlue[50]": "ffe1f5fe",
    "lightBlue[100]": "ffb3e5fc",
    "lightBlue[200]": "ff81d4fa",
    "lightBlue[300]": "ff4fc3f7",
    "lightBlue[400]": "ff29b6f6",
    "lightBlue[500]": "ff03a9f4",
    "lightBlue[600]": "ff039be5",
    "lightBlue[700]": "ff0288d1",
    "lightBlue[800]": "ff0277bd",
    "lightBlue[900]": "ff01579b",
    "lightBlueAccent.primary": "ff40c4ff",
    "lightBlueAccent[100]": "ff80d8ff",
    "lightBlueAccent[200]": "ff40c4ff",
    "lightBlueAccent[400]": "ff00b0ff",
    "lightBlueAccent[700]": "ff0091ea",
    "lightGreen.primary": "ff8bc34a",
    "lightGreen[50]": "fff1f8e9",
    "lightGreen[100]": "ffdcedc8",
    "lightGreen[200]": "ffc5e1a5",
    "lightGreen[300]": "ffaed581",
    "lightGreen[400]": "ff9ccc65",
    "lightGreen[500]": "ff8bc34a",
    "lightGreen[600]": "ff7cb342",
    "lightGreen[700]": "ff689f38",
    "lightGreen[800]": "ff558b2f",
    "lightGreen[900]": "ff33691e",
    "lightGreenAccent.primary": "ffb2ff59",
    "lightGreenAccent[100]": "ffccff90",
    "lightGreenAccent[200]": "ffb2ff59",
    "lightGreenAccent[400]": "ff76ff03",
    "lightGreenAccent[700]": "ff64dd17",
    "lime.primary": "ffcddc39",
    "lime[50]": "fff9fbe7",
    "lime[100]": "fff0f4c3",
    "lime[200]": "ffe6ee9c",
    "lime[300]": "ffdce775",
    "lime[400]": "ffd4e157",
    "lime[500]": "ffcddc39",
    "lime[600]": "ffc0ca33",
    "lime[700]": "ffafb42b",
    "lime[800]": "ff9e9d24",
    "lime[900]": "ff827717",
    "limeAccent.primary": "ffeeff41",
    "limeAccent[100]": "fff4ff81",
    "limeAccent[200]": "ffeeff41",
    "limeAccent[400]": "ffc6ff00",
    "limeAccent[700]": "ffaeea00",
    "orange.primary": "ffff9800",
    "orange[50]": "fffff3e0",
    "orange[100]": "ffffe0b2",
    "orange[200]": "ffffcc80",
    "orange[300]": "ffffb74d",
    "orange[400]": "ffffa726",
    "orange[500]": "ffff9800",
    "orange[600]": "fffb8c00",
    "orange[700]": "fff57c00",
    "orange[800]": "ffef6c00",
    "orange[900]": "ffe65100",
    "orangeAccent.primary": "ffffab40",
    "orangeAccent[100]": "ffffd180",
    "orangeAccent[200]": "ffffab40",
    "orangeAccent[400]": "ffff9100",
    "orangeAccent[700]": "ffff6d00",
    "pink.primary": "ffe91e63",
    "pink[50]": "fffce4ec",
    "pink[100]": "fff8bbd0",
    "pink[200]": "fff48fb1",
    "pink[300]": "fff06292",
    "pink[400]": "ffec407a",
    "pink[500]": "ffe91e63",
    "pink[600]": "ffd81b60",
    "pink[700]": "ffc2185b",
    "pink[800]": "ffad1457",
    "pink[900]": "ff880e4f",
    "pinkAccent.primary": "ffff4081",
    "pinkAccent[100]": "ffff80ab",
    "pinkAccent[200]": "ffff4081",
    "pinkAccent[400]": "fff50057",
    "pinkAccent[700]": "ffc51162",
    "purple.primary": "ff9c27b0",
    "purple[50]": "fff3e5f5",
    "purple[100]": "ffe1bee7",
    "purple[200]": "ffce93d8",
    "purple[300]": "ffba68c8",
    "purple[400]": "ffab47bc",
    "purple[500]": "ff9c27b0",
    "purple[600]": "ff8e24aa",
    "purple[700]": "ff7b1fa2",
    "purple[800]": "ff6a1b9a",
    "purple[900]": "ff4a148c",
    "purpleAccent.primary": "ffe040fb",
    "purpleAccent[100]": "ffea80fc",
    "purpleAccent[200]": "ffe040fb",
    "purpleAccent[400]": "ffd500f9",
    "purpleAccent[700]": "ffaa00ff",
    "red.primary": "fff44336",
    "red[50]": "ffffebee",
    "red[100]": "ffffcdd2",
    "red[200]": "ffef9a9a",
    "red[300]": "ffe57373",
    "red[400]": "ffef5350",
    "red[500]": "fff44336",
    "red[600]": "ffe53935",
    "red[700]": "ffd32f2f",
    "red[800]": "ffc62828",
    "red[900]": "ffb71c1c",
    "redAccent.primary": "ffff5252",
    "redAccent[100]": "ffff8a80",
    "redAccent[200]": "ffff5252",
    "redAccent[400]": "ffff1744",
    "redAccent[700]": "ffd50000",
    "teal.primary": "ff009688",
    "teal[50]": "ffe0f2f1",
    "teal[100]": "ffb2dfdb",
    "teal[200]": "ff80cbc4",
    "teal[300]": "ff4db6ac",
    "teal[400]": "ff26a69a",
    "teal[500]": "ff009688",
    "teal[600]": "ff00897b",
    "teal[700]": "ff00796b",
    "teal[800]": "ff00695c",
    "teal[900]": "ff004d40",
    "tealAccent.primary": "ff64ffda",
    "tealAccent[100]": "ffa7ffeb",
    "tealAccent[200]": "ff64ffda",
    "tealAccent[400]": "ff1de9b6",
    "tealAccent[700]": "ff00bfa5",
    "transparent": "00000000",
    "white": "ffffffff",
    "white10": "1affffff",
    "white12": "1fffffff",
    "white24": "3dffffff",
    "white30": "4dffffff",
    "white38": "62ffffff",
    "white54": "8affffff",
    "white60": "99ffffff",
    "white70": "b3ffffff",
    "yellow.primary": "ffffeb3b",
    "yellow[50]": "fffffde7",
    "yellow[100]": "fffff9c4",
    "yellow[200]": "fffff59d",
    "yellow[300]": "fffff176",
    "yellow[400]": "ffffee58",
    "yellow[500]": "ffffeb3b",
    "yellow[600]": "fffdd835",
    "yellow[700]": "fffbc02d",
    "yellow[800]": "fff9a825",
    "yellow[900]": "fff57f17",
    "yellowAccent.primary": "ffffff00",
    "yellowAccent[100]": "ffffff8d",
    "yellowAccent[200]": "ffffff00",
    "yellowAccent[400]": "ffffea00",
    "yellowAccent[700]": "ffffd600",
};
exports.flutterCupertinoColors = {
    "activeBlue": "ff007aff",
    "activeBlue.darkColor": "ff0a84ff",
    "activeBlue.darkElevatedColor": "ff0a84ff",
    "activeBlue.darkHighContrastColor": "ff409cff",
    "activeBlue.darkHighContrastElevatedColor": "ff409cff",
    "activeBlue.elevatedColor": "ff007aff",
    "activeBlue.highContrastColor": "ff0040dd",
    "activeBlue.highContrastElevatedColor": "ff0040dd",
    "activeGreen": "ff34c759",
    "activeGreen.darkColor": "ff30d158",
    "activeGreen.darkElevatedColor": "ff30d158",
    "activeGreen.darkHighContrastColor": "ff30db5b",
    "activeGreen.darkHighContrastElevatedColor": "ff30db5b",
    "activeGreen.elevatedColor": "ff34c759",
    "activeGreen.highContrastColor": "ff248a3d",
    "activeGreen.highContrastElevatedColor": "ff248a3d",
    "activeOrange": "ffff9500",
    "activeOrange.darkColor": "ffff9f0a",
    "activeOrange.darkElevatedColor": "ffff9f0a",
    "activeOrange.darkHighContrastColor": "ffffb340",
    "activeOrange.darkHighContrastElevatedColor": "ffffb340",
    "activeOrange.elevatedColor": "ffff9500",
    "activeOrange.highContrastColor": "ffc93400",
    "activeOrange.highContrastElevatedColor": "ffc93400",
    "black": "ff000000",
    "darkBackgroundGray": "ff171717",
    "destructiveRed": "ffff3b30",
    "destructiveRed.darkColor": "ffff453a",
    "destructiveRed.darkElevatedColor": "ffff453a",
    "destructiveRed.darkHighContrastColor": "ffff6961",
    "destructiveRed.darkHighContrastElevatedColor": "ffff6961",
    "destructiveRed.elevatedColor": "ffff3b30",
    "destructiveRed.highContrastColor": "ffd70015",
    "destructiveRed.highContrastElevatedColor": "ffd70015",
    "extraLightBackgroundGray": "ffefeff4",
    "inactiveGray": "ff999999",
    "inactiveGray.darkColor": "ff757575",
    "inactiveGray.darkElevatedColor": "ff757575",
    "inactiveGray.darkHighContrastColor": "ff757575",
    "inactiveGray.darkHighContrastElevatedColor": "ff757575",
    "inactiveGray.elevatedColor": "ff999999",
    "inactiveGray.highContrastColor": "ff999999",
    "inactiveGray.highContrastElevatedColor": "ff999999",
    "label": "ff000000",
    "label.darkColor": "ffffffff",
    "label.darkElevatedColor": "ffffffff",
    "label.darkHighContrastColor": "ffffffff",
    "label.darkHighContrastElevatedColor": "ffffffff",
    "label.elevatedColor": "ff000000",
    "label.highContrastColor": "ff000000",
    "label.highContrastElevatedColor": "ff000000",
    "lightBackgroundGray": "ffe5e5ea",
    "link": "ff007aff",
    "link.darkColor": "ff0984ff",
    "link.darkElevatedColor": "ff0984ff",
    "link.darkHighContrastColor": "ff0984ff",
    "link.darkHighContrastElevatedColor": "ff0984ff",
    "link.elevatedColor": "ff007aff",
    "link.highContrastColor": "ff007aff",
    "link.highContrastElevatedColor": "ff007aff",
    "opaqueSeparator": "ffc6c6c8",
    "opaqueSeparator.darkColor": "ff38383a",
    "opaqueSeparator.darkElevatedColor": "ff38383a",
    "opaqueSeparator.darkHighContrastColor": "ff38383a",
    "opaqueSeparator.darkHighContrastElevatedColor": "ff38383a",
    "opaqueSeparator.elevatedColor": "ffc6c6c8",
    "opaqueSeparator.highContrastColor": "ffc6c6c8",
    "opaqueSeparator.highContrastElevatedColor": "ffc6c6c8",
    "placeholderText": "4c3c3c43",
    "placeholderText.darkColor": "4cebebf5",
    "placeholderText.darkElevatedColor": "4cebebf5",
    "placeholderText.darkHighContrastColor": "60ebebf5",
    "placeholderText.darkHighContrastElevatedColor": "60ebebf5",
    "placeholderText.elevatedColor": "4c3c3c43",
    "placeholderText.highContrastColor": "603c3c43",
    "placeholderText.highContrastElevatedColor": "603c3c43",
    "quaternaryLabel": "2d3c3c43",
    "quaternaryLabel.darkColor": "28ebebf5",
    "quaternaryLabel.darkElevatedColor": "28ebebf5",
    "quaternaryLabel.darkHighContrastColor": "3debebf5",
    "quaternaryLabel.darkHighContrastElevatedColor": "3debebf5",
    "quaternaryLabel.elevatedColor": "2d3c3c43",
    "quaternaryLabel.highContrastColor": "423c3c43",
    "quaternaryLabel.highContrastElevatedColor": "423c3c43",
    "quaternarySystemFill": "14747480",
    "quaternarySystemFill.darkColor": "2d767680",
    "quaternarySystemFill.darkElevatedColor": "2d767680",
    "quaternarySystemFill.darkHighContrastColor": "42767680",
    "quaternarySystemFill.darkHighContrastElevatedColor": "42767680",
    "quaternarySystemFill.elevatedColor": "14747480",
    "quaternarySystemFill.highContrastColor": "28747480",
    "quaternarySystemFill.highContrastElevatedColor": "28747480",
    "secondaryLabel": "993c3c43",
    "secondaryLabel.darkColor": "99ebebf5",
    "secondaryLabel.darkElevatedColor": "99ebebf5",
    "secondaryLabel.darkHighContrastColor": "adebebf5",
    "secondaryLabel.darkHighContrastElevatedColor": "adebebf5",
    "secondaryLabel.elevatedColor": "993c3c43",
    "secondaryLabel.highContrastColor": "ad3c3c43",
    "secondaryLabel.highContrastElevatedColor": "ad3c3c43",
    "secondarySystemBackground": "fff2f2f7",
    "secondarySystemBackground.darkColor": "ff1c1c1e",
    "secondarySystemBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemBackground.darkHighContrastColor": "ff242426",
    "secondarySystemBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemBackground.elevatedColor": "fff2f2f7",
    "secondarySystemBackground.highContrastColor": "ffebebf0",
    "secondarySystemBackground.highContrastElevatedColor": "ffebebf0",
    "secondarySystemFill": "28787880",
    "secondarySystemFill.darkColor": "51787880",
    "secondarySystemFill.darkElevatedColor": "51787880",
    "secondarySystemFill.darkHighContrastColor": "66787880",
    "secondarySystemFill.darkHighContrastElevatedColor": "66787880",
    "secondarySystemFill.elevatedColor": "28787880",
    "secondarySystemFill.highContrastColor": "3d787880",
    "secondarySystemFill.highContrastElevatedColor": "3d787880",
    "secondarySystemGroupedBackground": "ffffffff",
    "secondarySystemGroupedBackground.darkColor": "ff1c1c1e",
    "secondarySystemGroupedBackground.darkElevatedColor": "ff2c2c2e",
    "secondarySystemGroupedBackground.darkHighContrastColor": "ff242426",
    "secondarySystemGroupedBackground.darkHighContrastElevatedColor": "ff363638",
    "secondarySystemGroupedBackground.elevatedColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastColor": "ffffffff",
    "secondarySystemGroupedBackground.highContrastElevatedColor": "ffffffff",
    "separator": "493c3c43",
    "separator.darkColor": "99545458",
    "separator.darkElevatedColor": "99545458",
    "separator.darkHighContrastColor": "ad545458",
    "separator.darkHighContrastElevatedColor": "ad545458",
    "separator.elevatedColor": "493c3c43",
    "separator.highContrastColor": "5e3c3c43",
    "separator.highContrastElevatedColor": "5e3c3c43",
    "systemBackground": "ffffffff",
    "systemBackground.darkColor": "ff000000",
    "systemBackground.darkElevatedColor": "ff1c1c1e",
    "systemBackground.darkHighContrastColor": "ff000000",
    "systemBackground.darkHighContrastElevatedColor": "ff242426",
    "systemBackground.elevatedColor": "ffffffff",
    "systemBackground.highContrastColor": "ffffffff",
    "systemBackground.highContrastElevatedColor": "ffffffff",
    "systemBlue": "ff007aff",
    "systemBlue.darkColor": "ff0a84ff",
    "systemBlue.darkElevatedColor": "ff0a84ff",
    "systemBlue.darkHighContrastColor": "ff409cff",
    "systemBlue.darkHighContrastElevatedColor": "ff409cff",
    "systemBlue.elevatedColor": "ff007aff",
    "systemBlue.highContrastColor": "ff0040dd",
    "systemBlue.highContrastElevatedColor": "ff0040dd",
    "systemFill": "33787880",
    "systemFill.darkColor": "5b787880",
    "systemFill.darkElevatedColor": "5b787880",
    "systemFill.darkHighContrastColor": "70787880",
    "systemFill.darkHighContrastElevatedColor": "70787880",
    "systemFill.elevatedColor": "33787880",
    "systemFill.highContrastColor": "47787880",
    "systemFill.highContrastElevatedColor": "47787880",
    "systemGreen": "ff34c759",
    "systemGreen.darkColor": "ff30d158",
    "systemGreen.darkElevatedColor": "ff30d158",
    "systemGreen.darkHighContrastColor": "ff30db5b",
    "systemGreen.darkHighContrastElevatedColor": "ff30db5b",
    "systemGreen.elevatedColor": "ff34c759",
    "systemGreen.highContrastColor": "ff248a3d",
    "systemGreen.highContrastElevatedColor": "ff248a3d",
    "systemGrey": "ff8e8e93",
    "systemGrey.darkColor": "ff8e8e93",
    "systemGrey.darkElevatedColor": "ff8e8e93",
    "systemGrey.darkHighContrastColor": "ffaeaeb2",
    "systemGrey.darkHighContrastElevatedColor": "ffaeaeb2",
    "systemGrey.elevatedColor": "ff8e8e93",
    "systemGrey.highContrastColor": "ff6c6c70",
    "systemGrey.highContrastElevatedColor": "ff6c6c70",
    "systemGrey2": "ffaeaeb2",
    "systemGrey2.darkColor": "ff636366",
    "systemGrey2.darkElevatedColor": "ff636366",
    "systemGrey2.darkHighContrastColor": "ff7c7c80",
    "systemGrey2.darkHighContrastElevatedColor": "ff7c7c80",
    "systemGrey2.elevatedColor": "ffaeaeb2",
    "systemGrey2.highContrastColor": "ff8e8e93",
    "systemGrey2.highContrastElevatedColor": "ff8e8e93",
    "systemGrey3": "ffc7c7cc",
    "systemGrey3.darkColor": "ff48484a",
    "systemGrey3.darkElevatedColor": "ff48484a",
    "systemGrey3.darkHighContrastColor": "ff545456",
    "systemGrey3.darkHighContrastElevatedColor": "ff545456",
    "systemGrey3.elevatedColor": "ffc7c7cc",
    "systemGrey3.highContrastColor": "ffaeaeb2",
    "systemGrey3.highContrastElevatedColor": "ffaeaeb2",
    "systemGrey4": "ffd1d1d6",
    "systemGrey4.darkColor": "ff3a3a3c",
    "systemGrey4.darkElevatedColor": "ff3a3a3c",
    "systemGrey4.darkHighContrastColor": "ff444446",
    "systemGrey4.darkHighContrastElevatedColor": "ff444446",
    "systemGrey4.elevatedColor": "ffd1d1d6",
    "systemGrey4.highContrastColor": "ffbcbcc0",
    "systemGrey4.highContrastElevatedColor": "ffbcbcc0",
    "systemGrey5": "ffe5e5ea",
    "systemGrey5.darkColor": "ff2c2c2e",
    "systemGrey5.darkElevatedColor": "ff2c2c2e",
    "systemGrey5.darkHighContrastColor": "ff363638",
    "systemGrey5.darkHighContrastElevatedColor": "ff363638",
    "systemGrey5.elevatedColor": "ffe5e5ea",
    "systemGrey5.highContrastColor": "ffd8d8dc",
    "systemGrey5.highContrastElevatedColor": "ffd8d8dc",
    "systemGrey6": "fff2f2f7",
    "systemGrey6.darkColor": "ff1c1c1e",
    "systemGrey6.darkElevatedColor": "ff1c1c1e",
    "systemGrey6.darkHighContrastColor": "ff242426",
    "systemGrey6.darkHighContrastElevatedColor": "ff242426",
    "systemGrey6.elevatedColor": "fff2f2f7",
    "systemGrey6.highContrastColor": "ffebebf0",
    "systemGrey6.highContrastElevatedColor": "ffebebf0",
    "systemGroupedBackground": "fff2f2f7",
    "systemGroupedBackground.darkColor": "ff000000",
    "systemGroupedBackground.darkElevatedColor": "ff1c1c1e",
    "systemGroupedBackground.darkHighContrastColor": "ff000000",
    "systemGroupedBackground.darkHighContrastElevatedColor": "ff242426",
    "systemGroupedBackground.elevatedColor": "fff2f2f7",
    "systemGroupedBackground.highContrastColor": "ffebebf0",
    "systemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "systemIndigo": "ff5856d6",
    "systemIndigo.darkColor": "ff5e5ce6",
    "systemIndigo.darkElevatedColor": "ff5e5ce6",
    "systemIndigo.darkHighContrastColor": "ff7d7aff",
    "systemIndigo.darkHighContrastElevatedColor": "ff7d7aff",
    "systemIndigo.elevatedColor": "ff5856d6",
    "systemIndigo.highContrastColor": "ff3634a3",
    "systemIndigo.highContrastElevatedColor": "ff3634a3",
    "systemOrange": "ffff9500",
    "systemOrange.darkColor": "ffff9f0a",
    "systemOrange.darkElevatedColor": "ffff9f0a",
    "systemOrange.darkHighContrastColor": "ffffb340",
    "systemOrange.darkHighContrastElevatedColor": "ffffb340",
    "systemOrange.elevatedColor": "ffff9500",
    "systemOrange.highContrastColor": "ffc93400",
    "systemOrange.highContrastElevatedColor": "ffc93400",
    "systemPink": "ffff2d55",
    "systemPink.darkColor": "ffff375f",
    "systemPink.darkElevatedColor": "ffff375f",
    "systemPink.darkHighContrastColor": "ffff6482",
    "systemPink.darkHighContrastElevatedColor": "ffff6482",
    "systemPink.elevatedColor": "ffff2d55",
    "systemPink.highContrastColor": "ffd30f45",
    "systemPink.highContrastElevatedColor": "ffd30f45",
    "systemPurple": "ffaf52de",
    "systemPurple.darkColor": "ffbf5af2",
    "systemPurple.darkElevatedColor": "ffbf5af2",
    "systemPurple.darkHighContrastColor": "ffda8fff",
    "systemPurple.darkHighContrastElevatedColor": "ffda8fff",
    "systemPurple.elevatedColor": "ffaf52de",
    "systemPurple.highContrastColor": "ff8944ab",
    "systemPurple.highContrastElevatedColor": "ff8944ab",
    "systemRed": "ffff3b30",
    "systemRed.darkColor": "ffff453a",
    "systemRed.darkElevatedColor": "ffff453a",
    "systemRed.darkHighContrastColor": "ffff6961",
    "systemRed.darkHighContrastElevatedColor": "ffff6961",
    "systemRed.elevatedColor": "ffff3b30",
    "systemRed.highContrastColor": "ffd70015",
    "systemRed.highContrastElevatedColor": "ffd70015",
    "systemTeal": "ff5ac8fa",
    "systemTeal.darkColor": "ff64d2ff",
    "systemTeal.darkElevatedColor": "ff64d2ff",
    "systemTeal.darkHighContrastColor": "ff70d7ff",
    "systemTeal.darkHighContrastElevatedColor": "ff70d7ff",
    "systemTeal.elevatedColor": "ff5ac8fa",
    "systemTeal.highContrastColor": "ff0071a4",
    "systemTeal.highContrastElevatedColor": "ff0071a4",
    "systemYellow": "ffffcc00",
    "systemYellow.darkColor": "ffffd60a",
    "systemYellow.darkElevatedColor": "ffffd60a",
    "systemYellow.darkHighContrastColor": "ffffd426",
    "systemYellow.darkHighContrastElevatedColor": "ffffd426",
    "systemYellow.elevatedColor": "ffffcc00",
    "systemYellow.highContrastColor": "ffa05a00",
    "systemYellow.highContrastElevatedColor": "ffa05a00",
    "tertiaryLabel": "4c3c3c43",
    "tertiaryLabel.darkColor": "4cebebf5",
    "tertiaryLabel.darkElevatedColor": "4cebebf5",
    "tertiaryLabel.darkHighContrastColor": "60ebebf5",
    "tertiaryLabel.darkHighContrastElevatedColor": "60ebebf5",
    "tertiaryLabel.elevatedColor": "4c3c3c43",
    "tertiaryLabel.highContrastColor": "603c3c43",
    "tertiaryLabel.highContrastElevatedColor": "603c3c43",
    "tertiarySystemBackground": "ffffffff",
    "tertiarySystemBackground.darkColor": "ff2c2c2e",
    "tertiarySystemBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemBackground.elevatedColor": "ffffffff",
    "tertiarySystemBackground.highContrastColor": "ffffffff",
    "tertiarySystemBackground.highContrastElevatedColor": "ffffffff",
    "tertiarySystemFill": "1e767680",
    "tertiarySystemFill.darkColor": "3d767680",
    "tertiarySystemFill.darkElevatedColor": "3d767680",
    "tertiarySystemFill.darkHighContrastColor": "51767680",
    "tertiarySystemFill.darkHighContrastElevatedColor": "51767680",
    "tertiarySystemFill.elevatedColor": "1e767680",
    "tertiarySystemFill.highContrastColor": "33767680",
    "tertiarySystemFill.highContrastElevatedColor": "33767680",
    "tertiarySystemGroupedBackground": "fff2f2f7",
    "tertiarySystemGroupedBackground.darkColor": "ff2c2c2e",
    "tertiarySystemGroupedBackground.darkElevatedColor": "ff3a3a3c",
    "tertiarySystemGroupedBackground.darkHighContrastColor": "ff363638",
    "tertiarySystemGroupedBackground.darkHighContrastElevatedColor": "ff444446",
    "tertiarySystemGroupedBackground.elevatedColor": "fff2f2f7",
    "tertiarySystemGroupedBackground.highContrastColor": "ffebebf0",
    "tertiarySystemGroupedBackground.highContrastElevatedColor": "ffebebf0",
    "white": "ffffffff",
};
exports.flutterCSSColors = {
    "aliceBlue": "fff0f8ff",
    "antiqueWhite": "fffaebd7",
    "aqua": "ff00ffff",
    "aquamarine": "ff7fffd4",
    "azure": "fff0ffff",
    "beige": "fff5f5dc",
    "bisque": "ffffe4c4",
    "black": "ff000000",
    "blanchedAlmond": "ffffebcd",
    "blue": "ff0000ff",
    "blueViolet": "ff8a2be2",
    "brown": "ffa52a2a",
    "burlyWood": "ffdeb887",
    "cadetBlue": "ff5f9ea0",
    "chartreuse": "ff7fff00",
    "chocolate": "ffd2691e",
    "coral": "ffff7f50",
    "cornflowerBlue": "ff6495ed",
    "cornsilk": "fffff8dc",
    "crimson": "ffdc143c",
    "cyan": "ff00ffff",
    "darkBlue": "ff00008b",
    "darkCyan": "ff008b8b",
    "darkGoldenRod": "ffb8860b",
    "darkGray": "ffa9a9a9",
    "darkGreen": "ff006400",
    "darkGrey": "ffa9a9a9",
    "darkKhaki": "ffbdb76b",
    "darkMagenta": "ff8b008b",
    "darkOliveGreen": "ff556b2f",
    "darkOrange": "ffff8c00",
    "darkOrchid": "ff9932cc",
    "darkRed": "ff8b0000",
    "darkSalmon": "ffe9967a",
    "darkSeaGreen": "ff8fbc8f",
    "darkSlateBlue": "ff483d8b",
    "darkSlateGray": "ff2f4f4f",
    "darkSlateGrey": "ff2f4f4f",
    "darkTurquoise": "ff00ced1",
    "darkViolet": "ff9400d3",
    "deepPink": "ffff1493",
    "deepSkyBlue": "ff00bfff",
    "dimGray": "ff696969",
    "dimGrey": "ff696969",
    "dodgerBlue": "ff1e90ff",
    "fireBrick": "ffb22222",
    "floralWhite": "fffffaf0",
    "forestGreen": "ff228b22",
    "fuchsia": "ffff00ff",
    "gainsboro": "ffdcdcdc",
    "ghostWhite": "fff8f8ff",
    "gold": "ffffd700",
    "goldenRod": "ffdaa520",
    "gray": "ff808080",
    "green": "ff008000",
    "greenYellow": "ffadff2f",
    "grey": "ff808080",
    "honeyDew": "fff0fff0",
    "hotPink": "ffff69b4",
    "indianRed": "ffcd5c5c",
    "indigo": "ff4b0082",
    "ivory": "fffffff0",
    "khaki": "fff0e68c",
    "lavender": "ffe6e6fa",
    "lavenderBlush": "fffff0f5",
    "lawnGreen": "ff7cfc00",
    "lemonChiffon": "fffffacd",
    "lightBlue": "ffadd8e6",
    "lightCoral": "fff08080",
    "lightCyan": "ffe0ffff",
    "lightGoldenRodYellow": "fffafad2",
    "lightGray": "ffd3d3d3",
    "lightGreen": "ff90ee90",
    "lightGrey": "ffd3d3d3",
    "lightPink": "ffffb6c1",
    "lightSalmon": "ffffa07a",
    "lightSeaGreen": "ff20b2aa",
    "lightSkyBlue": "ff87cefa",
    "lightSlateGray": "ff778899",
    "lightSlateGrey": "ff778899",
    "lightSteelBlue": "ffb0c4de",
    "lightYellow": "ffffffe0",
    "lime": "ff00ff00",
    "limeGreen": "ff32cd32",
    "linen": "fffaf0e6",
    "magenta": "ffff00ff",
    "maroon": "ff800000",
    "mediumAquaMarine": "ff66cdaa",
    "mediumBlue": "ff0000cd",
    "mediumOrchid": "ffba55d3",
    "mediumPurple": "ff9370db",
    "mediumSeaGreen": "ff3cb371",
    "mediumSlateBlue": "ff7b68ee",
    "mediumSpringGreen": "ff00fa9a",
    "mediumTurquoise": "ff48d1cc",
    "mediumVioletRed": "ffc71585",
    "midnightBlue": "ff191970",
    "mintCream": "fff5fffa",
    "mistyRose": "ffffe4e1",
    "moccasin": "ffffe4b5",
    "navajoWhite": "ffffdead",
    "navy": "ff000080",
    "oldLace": "fffdf5e6",
    "olive": "ff808000",
    "oliveDrab": "ff6b8e23",
    "orange": "ffffa500",
    "orangeRed": "ffff4500",
    "orchid": "ffda70d6",
    "paleGoldenRod": "ffeee8aa",
    "paleGreen": "ff98fb98",
    "paleTurquoise": "ffafeeee",
    "paleVioletRed": "ffdb7093",
    "papayaWhip": "ffffefd5",
    "peachPuff": "ffffdab9",
    "peru": "ffcd853f",
    "pink": "ffffc0cb",
    "plum": "ffdda0dd",
    "powderBlue": "ffb0e0e6",
    "purple": "ff800080",
    "rebeccaPurple": "ff663399",
    "red": "ffff0000",
    "rosyBrown": "ffbc8f8f",
    "royalBlue": "ff4169e1",
    "saddleBrown": "ff8b4513",
    "salmon": "fffa8072",
    "sandyBrown": "fff4a460",
    "seaGreen": "ff2e8b57",
    "seaShell": "fffff5ee",
    "sienna": "ffa0522d",
    "silver": "ffc0c0c0",
    "skyBlue": "ff87ceeb",
    "slateBlue": "ff6a5acd",
    "slateGray": "ff708090",
    "slateGrey": "ff708090",
    "snow": "fffffafa",
    "springGreen": "ff00ff7f",
    "steelBlue": "ff4682b4",
    "tan": "ffd2b48c",
    "teal": "ff008080",
    "thistle": "ffd8bfd8",
    "tomato": "ffff6347",
    "turquoise": "ff40e0d0",
    "violet": "ffee82ee",
    "wheat": "fff5deb3",
    "white": "ffffffff",
    "whiteSmoke": "fff5f5f5",
    "yellow": "ffffff00",
    "yellowGreen": "ff9acd32",
};


/***/ }),

/***/ 5820:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getFutterWebRenderer = void 0;
function getFutterWebRenderer(flutterCapabilities, renderer) {
    if (!flutterCapabilities.supportsWebRendererOption)
        return;
    if (!renderer || renderer === "auto")
        return;
    return renderer;
}
exports.getFutterWebRenderer = getFutterWebRenderer;


/***/ }),

/***/ 8323:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RingLog = exports.captureLogs = exports.logToConsole = exports.logProcess = exports.nullLogger = exports.CategoryLogger = exports.EmittingLogger = void 0;
const events_1 = __webpack_require__(2361);
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const utils_1 = __webpack_require__(4586);
class LogEmitter extends events_1.EventEmitter {
    fire(msg) {
        this.emit("log", msg);
    }
    onLog(listener) {
        this.on("log", listener);
        return {
            dispose: () => { this.removeListener("log", listener); },
        };
    }
}
class EmittingLogger {
    constructor() {
        this.onLogEmitter = new LogEmitter();
        this.onLog = (listener) => this.onLogEmitter.onLog(listener);
    }
    log(message, severity, category = enums_1.LogCategory.General) {
        this.onLogEmitter.fire(new LogMessageImpl(message, severity, category));
    }
    info(message, category) {
        this.log(message, enums_1.LogSeverity.Info, category);
    }
    warn(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Warn, category);
    }
    error(errorOrMessage, category) {
        this.log((0, utils_1.errorString)(errorOrMessage), enums_1.LogSeverity.Error, category);
    }
    dispose() {
        this.onLogEmitter.removeAllListeners();
    }
}
exports.EmittingLogger = EmittingLogger;
class LogMessageImpl {
    constructor(message, severity, category) {
        this.message = message;
        this.severity = severity;
        this.category = category;
    }
    toLine(maxLength) {
        const logMessage = (maxLength && this.message && this.message.length > maxLength
            ? this.message.substring(0, maxLength) + "…"
            : (this.message || "<empty message>")).trimRight();
        const time = `[${(new Date()).toLocaleTimeString()}]`;
        const prefix = `[${enums_1.LogCategory[this.category]}] [${enums_1.LogSeverity[this.severity]}]`;
        return `${time} ${prefix} ${logMessage}`;
    }
}
class CategoryLogger {
    constructor(base, defaultCategory) {
        this.base = base;
        this.defaultCategory = defaultCategory;
    }
    info(message, category = this.defaultCategory) {
        this.base.info(message, category);
    }
    warn(errorOrMessage, category = this.defaultCategory) {
        this.base.warn(errorOrMessage, category);
    }
    error(errorOrMessage, category = this.defaultCategory) {
        this.base.error(errorOrMessage, category);
    }
}
exports.CategoryLogger = CategoryLogger;
class NullLogger {
    // tslint:disable-next-line: no-empty
    info(message, category) { }
    // tslint:disable-next-line: no-empty
    warn(message, category) { }
    // tslint:disable-next-line: no-empty
    error(error, category) { }
}
exports.nullLogger = new NullLogger();
function logProcess(logger, category, process) {
    const prefix = `(PROC ${process.pid})`;
    logger.info(`${prefix} Logging data for process...`, category);
    process.stdout.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.stderr.on("data", (data) => logger.info(`${prefix} ${data}`, category));
    process.on("close", (code, signal) => logger.info(`${prefix} closed (${code}, ${signal})`, category));
    process.on("exit", (code, signal) => logger.info(`${prefix} exited (${code}, ${signal})`, category));
}
exports.logProcess = logProcess;
function logToConsole(logger) {
    return logger.onLog((m) => {
        if (m.severity === enums_1.LogSeverity.Error)
            console.error(m.toLine(1000));
        else if (m.severity === enums_1.LogSeverity.Warn)
            console.warn(m.toLine(1000));
    });
}
exports.logToConsole = logToConsole;
function captureLogs(logger, file, header, maxLogLineLength, logCategories, excludeLogCategories = false) {
    if (!file || !path.isAbsolute(file))
        throw new Error("Path passed to logTo must be an absolute path");
    const time = (detailed = false) => detailed ? `[${(new Date()).toTimeString()}] ` : `[${(new Date()).toLocaleTimeString()}] `;
    let logStream = fs.createWriteStream(file);
    if (header)
        logStream.write(header);
    const categoryNames = logCategories.map((c) => enums_1.LogCategory[c]);
    logStream.write(`Logging Categories:${constants_1.platformEol}    ${categoryNames.join(", ")}${constants_1.platformEol}${constants_1.platformEol}`);
    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file started${constants_1.platformEol}`);
    let fileLogger = logger.onLog((e) => {
        if (!logStream)
            return;
        // We should log this event if:
        // - We don't have a category filter; or
        // - The category filter includes this category; or
        // - The log is WARN/ERROR (they get logged everywhere).
        const shouldLog = (excludeLogCategories
            ? logCategories.indexOf(e.category) === -1
            : logCategories.indexOf(e.category) !== -1)
            || e.severity === enums_1.LogSeverity.Warn
            || e.severity === enums_1.LogSeverity.Error;
        if (!shouldLog)
            return;
        logStream.write(`${e.toLine(maxLogLineLength)}${os.EOL}`);
    });
    return {
        dispose() {
            if (fileLogger) {
                fileLogger.dispose();
                fileLogger = undefined;
            }
            return new Promise((resolve) => {
                if (logStream) {
                    logStream.write(`${(new Date()).toDateString()} ${time(true)}Log file ended${os.EOL}`);
                    logStream.end(resolve);
                    logStream = undefined;
                }
            });
        },
    };
}
exports.captureLogs = captureLogs;
class RingLog {
    constructor(size) {
        this.size = size;
        this.pointer = 0;
        this.lines = new Array(this.size);
    }
    get rawLines() { return this.lines; }
    log(message) {
        this.lines[this.pointer] = message;
        this.pointer = (this.pointer + 1) % this.size;
    }
    toString() {
        return this.lines.slice(this.pointer, this.size).concat(this.lines.slice(0, this.pointer)).filter((l) => l).join("\n");
    }
}
exports.RingLog = RingLog;


/***/ }),

/***/ 5837:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPubExecutionInfo = exports.runProcess = exports.RunProcessResult = exports.safeSpawn = void 0;
const child_process = __webpack_require__(2081);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
function safeSpawn(workingDirectory, binPath, args, env) {
    const quotedArgs = args.map(quoteAndEscapeArg);
    const customEnv = Object.assign({}, process.env, env);
    return child_process.spawn(`"${binPath}"`, quotedArgs, { cwd: workingDirectory, env: customEnv, shell: true });
}
exports.safeSpawn = safeSpawn;
function quoteAndEscapeArg(arg) {
    // Spawning processes on Windows with funny symbols in the path requires quoting. However if you quote an
    // executable with a space in its path and an argument also has a space, you have to then quote _all_ of the
    // arguments!
    // https://github.com/nodejs/node/issues/7367
    let escaped = arg.replace(/"/g, `\\"`);
    // Additionally, on Windows escape redirection symbols with ^ if they come
    // directly after quotes (?).
    // https://ss64.com/nt/syntax-esc.html
    if (constants_1.isWin)
        escaped = escaped.replace(/"([<>])/g, "\"^$1");
    return `"${escaped}"`;
}
class RunProcessResult {
    constructor(exitCode, stdout, stderr) {
        this.exitCode = exitCode;
        this.stdout = stdout;
        this.stderr = stderr;
    }
}
exports.RunProcessResult = RunProcessResult;
function runProcess(logger, binPath, args, workingDirectory, env, spawn) {
    return new Promise((resolve) => {
        logger.info(`Spawning ${binPath} with args ${JSON.stringify(args)} in ${workingDirectory} with env ${JSON.stringify(env)}`);
        const proc = spawn(workingDirectory, binPath, args, env);
        (0, logging_1.logProcess)(logger, enums_1.LogCategory.CommandProcesses, proc);
        const out = [];
        const err = [];
        proc.stdout.on("data", (data) => out.push(data.toString()));
        proc.stderr.on("data", (data) => err.push(data.toString()));
        proc.on("exit", (code) => {
            resolve(new RunProcessResult((0, utils_1.nullToUndefined)(code), out.join(""), err.join("")));
        });
    });
}
exports.runProcess = runProcess;
function getPubExecutionInfo(dartCapabilities, dartSdkPath, args) {
    if (dartCapabilities.supportsDartPub) {
        return {
            args: ["pub", ...args],
            executable: path.join(dartSdkPath, constants_1.dartVMPath),
        };
    }
    else {
        return {
            args,
            executable: path.join(dartSdkPath, constants_1.pubPath),
        };
    }
}
exports.getPubExecutionInfo = getPubExecutionInfo;


/***/ }),

/***/ 8316:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubApi = void 0;
class PubApi {
    constructor(webClient) {
        this.webClient = webClient;
        this.pubUrlBase = process.env.PUB_HOSTED_URL || "https://pub.dev";
    }
    getPackage(packageID) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`packages/${packageID}`);
        });
    }
    getPackageNames() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.get(`package-name-completion-data`);
        });
    }
    get(url) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = {
                Accept: "application/vnd.pub.v2+json",
                "Accept-Encoding": "gzip",
            };
            const response = yield this.webClient.fetch(`${this.pubUrlBase}/api/${url}`, headers);
            return JSON.parse(response);
        });
    }
}
exports.PubApi = PubApi;


/***/ }),

/***/ 2253:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PubDeps = void 0;
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
const processes_1 = __webpack_require__(5837);
/// Interacts with "pub deps --json" to look up types of dependencies.
class PubDeps {
    constructor(logger, sdks, dartCapabilities) {
        this.logger = logger;
        this.sdks = sdks;
        this.dartCapabilities = dartCapabilities;
    }
    getRootDependency(projectDirectory) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.dartCapabilities.supportsPubDepsJson) {
                return undefined;
            }
            const binPath = this.sdks.flutter
                ? path.join(this.sdks.flutter, constants_1.flutterPath)
                : path.join(this.sdks.dart, constants_1.dartVMPath);
            const result = yield (0, processes_1.runProcess)(this.logger, binPath, ["pub", "deps", "--json"], projectDirectory, undefined, processes_1.safeSpawn);
            if (result.exitCode !== 0) {
                this.logger.error(`Running "pub deps --json" returned exit code ${result.exitCode}:\n${result.stdout}\n${result.stderr}`);
                return undefined;
            }
            try {
                return JSON.parse(result.stdout);
            }
            catch (e) {
                this.logger.error(`"pub deps --json" returned invalid JSON ${e}:\n${result.stdout}`);
                return undefined;
            }
        });
    }
    getPackageMap(root) {
        const packages = {};
        for (const p of root.packages) {
            packages[p.name] = p;
        }
        return packages;
    }
    computeShortestPaths(packageMap) {
        var _a, _b, _c, _d, _e;
        const results = {};
        const rootName = (_a = Object.values(packageMap).find((p) => p.kind === "root")) === null || _a === void 0 ? void 0 : _a.name;
        // Queue is a list of pairs of packages to process, and the paths to get to them.
        const queue = [];
        for (const name of Object.keys(packageMap)) {
            if (((_b = packageMap[name]) === null || _b === void 0 ? void 0 : _b.kind) === "direct" || ((_c = packageMap[name]) === null || _c === void 0 ? void 0 : _c.kind) === "dev") {
                const path = rootName ? [rootName, name] : [name];
                results[name] = path;
                queue.push([name, path]);
            }
        }
        // Traverse the tree breadth-first, so that the first time we come across any node, we know that is
        // the shortest path.
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let i = 0; i < queue.length; i++) {
            const [pkg, path] = queue[i];
            const dependencies = (_e = (_d = packageMap[pkg]) === null || _d === void 0 ? void 0 : _d.dependencies) !== null && _e !== void 0 ? _e : [];
            // Loop over this packages dependencies, and if we've not previously been to them
            // this is (one of) the shortest paths there.
            for (const dep of dependencies) {
                if (results[dep])
                    continue;
                const newPath = [...path, dep];
                results[dep] = newPath;
                // Also push the dependency onto the queue to process its dependencies.
                queue.push([dep, newPath]);
            }
        }
        return results;
    }
}
exports.PubDeps = PubDeps;


/***/ }),

/***/ 143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageMap = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const url = __webpack_require__(7310);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
class PackageMap {
    static findPackagesFile(entryPoint) {
        if (!entryPoint)
            return undefined;
        const file = (0, utils_1.findFileInAncestor)([path.join(".dart_tool/package_config.json"), ".packages"], entryPoint);
        return file;
    }
    static loadForProject(logger, projectFolder) {
        const paths = [
            ".dart_tool/package_config.json",
            ".packages",
        ];
        for (const p of paths) {
            const fullP = path.join(projectFolder, p);
            if (fs.existsSync(fullP))
                return this.load(logger, fullP);
        }
        return new MissingPackageMap();
    }
    static load(logger, file) {
        if (!file)
            return new MissingPackageMap();
        try {
            if (path.basename(file).toLowerCase() === ".packages")
                return new DotPackagesPackageMap(file);
            else
                return new PackageConfigJsonPackageMap(logger, file);
        }
        catch (e) {
            logger.error(e);
            return new MissingPackageMap();
        }
    }
    getPackagePath(name) {
        return this.packages[name];
    }
    resolvePackageUri(uri) {
        if (!uri)
            return undefined;
        let name = uri;
        if (name.startsWith("package:"))
            name = name.substring(8);
        const index = name.indexOf("/");
        if (index === -1)
            return undefined;
        const rest = name.substring(index + 1);
        name = name.substring(0, index);
        const location = this.getPackagePath(name);
        if (location)
            return path.join(location, rest);
        else
            return undefined;
    }
}
exports.PackageMap = PackageMap;
class MissingPackageMap extends PackageMap {
    get packages() {
        return {};
    }
    getPackagePath(name) {
        return undefined;
    }
    resolvePackageUri(uri) {
        return undefined;
    }
    reload() { }
}
class DotPackagesPackageMap extends PackageMap {
    constructor(file) {
        super();
        this.map = {};
        if (!file)
            return;
        this.file = file;
        this.localPackageRoot = path.dirname(file);
        this.load();
    }
    get packages() { return Object.assign({}, this.map); }
    reload() {
        this.load();
    }
    load() {
        if (!this.file || !this.localPackageRoot)
            return;
        this.map = {};
        const lines = fs.readFileSync(this.file, { encoding: "utf8" }).split("\n");
        for (let line of lines) {
            line = line.trim();
            if (line.length === 0 || line.startsWith("#"))
                continue;
            const index = line.indexOf(":");
            if (index !== -1) {
                const name = line.substr(0, index);
                const rest = line.substring(index + 1);
                if (rest.startsWith("file:"))
                    this.map[name] = (0, utils_1.uriToFilePath)(rest);
                else
                    this.map[name] = path.join(this.localPackageRoot, rest);
            }
        }
    }
}
class PackageConfigJsonPackageMap extends PackageMap {
    constructor(logger, packageConfigPath) {
        super();
        this.logger = logger;
        this.packageConfigPath = packageConfigPath;
        this.map = {};
        this.load();
    }
    reload() {
        this.load();
    }
    load() {
        const json = fs.readFileSync(this.packageConfigPath, "utf8");
        this.config = JSON.parse(json);
        this.map = {};
        for (const pkg of this.config.packages) {
            try {
                const packageConfigFolderPath = path.dirname(this.packageConfigPath);
                const packageRootPath = this.getPathForUri(pkg.rootUri);
                const packageLibPath = this.getPathForUri(pkg.packageUri);
                this.map[pkg.name] = path.resolve(packageConfigFolderPath, packageRootPath !== null && packageRootPath !== void 0 ? packageRootPath : "", packageLibPath !== null && packageLibPath !== void 0 ? packageLibPath : "");
            }
            catch (e) {
                this.logger.error(`Failed to resolve path for package ${pkg.name}: ${e}`);
            }
        }
    }
    getPathForUri(uri) {
        if (!uri)
            return undefined;
        const parsedPath = (0, fs_1.normalizeSlashes)(uri.startsWith("file:")
            ? url.fileURLToPath(uri)
            : unescape(uri));
        return parsedPath.endsWith(path.sep) ? parsedPath : `${parsedPath}${path.sep}`;
    }
    get packages() { return Object.assign({}, this.map); }
    getPackagePath(name) {
        return this.map[name];
    }
}


/***/ }),

/***/ 1119:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageCacheData = void 0;
class PackageCacheData {
    constructor(lastUpdated, packages) {
        this.lastUpdated = lastUpdated;
        this.packages = packages;
    }
    static get maxCacheAgeMs() { return PackageCacheData.maxCacheAgeHours * 60 * 60 * 1000; }
    static fromPackageNames(packages) {
        const packageMap = new Map();
        packages.forEach((p) => packageMap.set(p, undefined));
        return new PackageCacheData(new Date().getTime(), packageMap);
    }
    get packageNames() {
        // TODO: Can we avoid this and just iterate in the callee, since we often
        // bail out early?
        return Array.from(this.packages.keys());
    }
    get cacheTimeRemainingMs() {
        const ageMs = new Date().getTime() - this.lastUpdated;
        const timeRemainingMs = PackageCacheData.maxCacheAgeMs - ageMs;
        return timeRemainingMs < 0
            ? 0
            : timeRemainingMs;
    }
    static fromJson(json) {
        const data = JSON.parse(json, PackageCacheData.mapReviver);
        if (data.version !== PackageCacheData.cacheVersion)
            return undefined;
        return new PackageCacheData(data.lastUpdated, data.packages);
    }
    toJson() {
        return JSON.stringify({
            lastUpdated: this.lastUpdated,
            packages: this.packages,
            version: PackageCacheData.cacheVersion,
        }, PackageCacheData.mapReplacer, 2);
    }
    static mapReplacer(key, value) {
        return value instanceof Map
            ? {
                dataType: "Map",
                value: [...value],
            }
            : value;
    }
    static mapReviver(key, value) {
        return typeof value === "object" && (value === null || value === void 0 ? void 0 : value.dataType) === "Map"
            ? new Map(value.value) // eslint-disable-line @typescript-eslint/no-unsafe-argument
            : value;
    }
}
exports.PackageCacheData = PackageCacheData;
PackageCacheData.cacheVersion = 1;
PackageCacheData.maxCacheAgeHours = 18;
PackageCacheData.maxPackageDetailsRequestsInFlight = 5;


/***/ }),

/***/ 3438:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanPubOutput = void 0;
function cleanPubOutput(pubOutput) {
    // Sometimes pub will output additional text that we need to discard:
    // Precompiling executable...\nPrecompiled stagehand:stagehand.\n[{"name":"console-full","label"
    const precompilingHeaderPattern = RegExp("^Precompil(?:ing|ed).*$", "gm");
    const json = pubOutput.replace(precompilingHeaderPattern, "");
    return json;
}
exports.cleanPubOutput = cleanPubOutput;


/***/ }),

/***/ 3058:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StdIOService = void 0;
const fs = __webpack_require__(7147);
const processes_1 = __webpack_require__(5837);
// Reminder: This class is used in the debug adapter as well as the main Code process!
class StdIOService {
    constructor(logger, maxLogLineLength, messagesWrappedInBrackets = false, treatHandlingErrorsAsUnhandledMessages = false, treatCarriageReturnsAsNewlines = false, logFile) {
        this.logger = logger;
        this.maxLogLineLength = maxLogLineLength;
        this.messagesWrappedInBrackets = messagesWrappedInBrackets;
        this.treatHandlingErrorsAsUnhandledMessages = treatHandlingErrorsAsUnhandledMessages;
        this.treatCarriageReturnsAsNewlines = treatCarriageReturnsAsNewlines;
        this.logFile = logFile;
        this.disposables = [];
        this.additionalPidsToTerminate = [];
        this.nextRequestID = 1;
        this.activeRequests = {};
        this.messageBuffers = [];
        this.requestErrorSubscriptions = [];
        this.processExited = false;
    }
    createProcess(workingDirectory, binPath, args, envOverrides) {
        this.logTraffic(`Spawning ${binPath} with args ${JSON.stringify(args)}`);
        this.description = binPath;
        if (workingDirectory)
            this.logTraffic(`..  in ${workingDirectory}`);
        if (envOverrides.envOverrides || envOverrides.toolEnv)
            this.logTraffic(`..  with ${JSON.stringify(envOverrides)}`);
        const env = Object.assign({}, envOverrides.toolEnv, envOverrides.envOverrides);
        this.process = (0, processes_1.safeSpawn)(workingDirectory, binPath, args, env);
        this.logTraffic(`    PID: ${process.pid}`);
        this.process.stdout.on("data", (data) => this.handleStdOut(data));
        this.process.stderr.on("data", (data) => this.handleStdErr(data));
        this.process.on("exit", (code, signal) => this.handleExit(code, signal));
        this.process.on("error", (error) => this.handleError(error));
    }
    /// Flutter may send only \r as a line terminator for improved terminal output
    /// but we should always treat this as a standard newline (eg. terminating a message)
    /// so all \r's can be replaced with \n immediately. Blank lines (from \n\n)
    /// are already handled gracefully.
    ///
    /// https://github.com/flutter/flutter/pull/57590
    normalizeNewlines(data) {
        const normalised = this.treatCarriageReturnsAsNewlines
            ? Buffer.from(data.toString().replace(/\r/g, "\n"))
            : data;
        return Buffer.from(normalised);
    }
    handleStdOut(data) {
        data = this.normalizeNewlines(data);
        // Add this message to the buffer for processing.
        this.messageBuffers.push(data);
        // Kick off processing if we have a full message.
        if (data.indexOf("\n") >= 0)
            this.processMessageBuffer();
    }
    handleStdErr(data) {
        this.logTraffic(`${data.toString()}`, true);
    }
    handleExit(code, signal) {
        this.logTraffic(`Process ${this.description} terminated! ${code}, ${signal}`);
        this.processExited = true;
    }
    handleError(error) {
        this.logTraffic(`Process errored! ${error}`);
    }
    buildRequest(id, method, params) {
        return {
            id: id.toString(),
            method,
            params,
        };
    }
    sendRequest(method, params) {
        // Generate an ID for this request so we can match up the response.
        const id = this.nextRequestID++;
        return new Promise((resolve, reject) => {
            // Stash the callbacks so we can call them later.
            this.activeRequests[id.toString()] = [resolve, reject, method];
            const req = this.buildRequest(id, method, params);
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(req) + "]\r\n"
                : JSON.stringify(req) + "\r\n";
            this.sendMessage(json);
        });
    }
    cancelAllRequests() {
        Object.keys(this.activeRequests).forEach((key) => this.activeRequests[key] = "CANCELLED");
    }
    sendMessage(json) {
        this.logTraffic(`==> ${json}`);
        if (this.process)
            this.process.stdin.write(json);
        else
            this.logTraffic(`  (not sent: no process)`);
    }
    processMessageBuffer() {
        let fullBuffer = Buffer.concat(this.messageBuffers);
        this.messageBuffers = [];
        // If the message doesn't end with \n then put the last part back into the buffer.
        const lastNewline = fullBuffer.lastIndexOf("\n");
        if (lastNewline !== fullBuffer.length - 1) {
            const incompleteMessage = fullBuffer.slice(lastNewline + 1);
            fullBuffer = fullBuffer.slice(0, lastNewline);
            this.messageBuffers.push(incompleteMessage);
        }
        // Process the complete messages in the buffer.
        fullBuffer.toString().split("\n").filter((m) => m.trim() !== "").forEach((m) => this.handleMessage(`${m}\n`));
    }
    // tslint:disable-next-line:no-empty
    processUnhandledMessage(message) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    handleMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logTraffic(`<== ${message.trimRight()}\r\n`);
            if (!this.shouldHandleMessage(message.trim())) {
                return this.processUnhandledMessage(message);
            }
            let msg;
            try {
                msg = JSON.parse(message);
                if (this.messagesWrappedInBrackets && msg && msg.length === 1)
                    msg = msg[0];
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Unexpected non-JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    return this.processUnhandledMessage(message);
                }
                else {
                    throw e;
                }
            }
            try {
                if (msg && this.isNotification(msg))
                    // tslint:disable-next-line: no-floating-promises
                    this.handleNotification(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isRequest(msg))
                    this.processServerRequest(msg).catch((e) => this.logger.error(e));
                else if (msg && this.isResponse(msg))
                    this.handleResponse(msg).catch((e) => this.logger.error(e));
                else {
                    this.logger.error(`Unexpected JSON message, assuming normal stdout : ${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
            }
            catch (e) {
                if (this.treatHandlingErrorsAsUnhandledMessages) {
                    this.logger.error(`Failed to handle JSON message, assuming normal stdout (${e})\n\n${e.stack}\n\n${message}`);
                    this.processUnhandledMessage(message).catch((e) => this.logger.error(e));
                }
                else {
                    throw e;
                }
            }
        });
    }
    // tslint:disable-next-line: no-empty
    handleRequest(method, args) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    isNotification(msg) { return !!msg.event; }
    isRequest(msg) { return !!msg.method && !!msg.id; }
    isResponse(msg) { return !!msg.id; }
    processServerRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            let error;
            try {
                result = yield this.handleRequest(request.method, request.params);
            }
            catch (e) {
                error = e;
            }
            const resp = { id: request.id, result, error };
            const json = this.messagesWrappedInBrackets
                ? "[" + JSON.stringify(resp) + "]\r\n"
                : JSON.stringify(resp) + "\r\n";
            this.sendMessage(json);
        });
    }
    handleResponse(evt) {
        return __awaiter(this, void 0, void 0, function* () {
            const handler = this.activeRequests[evt.id];
            delete this.activeRequests[evt.id];
            if (handler === "CANCELLED") {
                this.logger.info(`Ignoring response to ${evt.id} because it was cancelled:\n\n${JSON.stringify(evt, undefined, 4)}`);
                return;
            }
            else if (!handler) {
                this.logger.error(`Unable to handle response with ID ${evt.id} because its handler is not available`);
                return;
            }
            const method = handler[2];
            const error = evt.error;
            if (error && error.code === "SERVER_ERROR") {
                error.method = method;
                this.notify(this.requestErrorSubscriptions, error).catch((e) => this.logger.error(e));
            }
            if (error) {
                yield handler[1](error);
            }
            else {
                yield handler[0](evt.result);
            }
        });
    }
    notify(subscriptions, notification) {
        return Promise.all(subscriptions.slice().map((sub) => sub(notification))).catch((e) => console.error(e));
    }
    subscribe(subscriptions, subscriber) {
        subscriptions.push(subscriber);
        const disposable = {
            dispose: () => {
                // Remove from the subscription list.
                let index = subscriptions.indexOf(subscriber);
                if (index >= 0) {
                    subscriptions.splice(index, 1);
                }
                // Also remove from our disposables (else we'll leak it).
                index = this.disposables.indexOf(disposable);
                if (index >= 0) {
                    this.disposables.splice(index, 1);
                }
            },
        };
        this.disposables.push(disposable);
        return disposable;
    }
    registerForRequestError(subscriber) {
        return this.subscribe(this.requestErrorSubscriptions, subscriber);
    }
    logTraffic(message, isError = false) {
        if (isError)
            this.logger.error(message);
        else
            this.logger.info(message);
        if (this.openLogFile !== this.logFile && this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
        if (!this.logFile)
            return;
        if (!this.logStream) {
            this.logStream = fs.createWriteStream(this.logFile);
            this.openLogFile = this.logFile;
        }
        this.logStream.write(`[${(new Date()).toLocaleTimeString()}]: `);
        if (this.maxLogLineLength && message.length > this.maxLogLineLength)
            this.logStream.write(message.substring(0, this.maxLogLineLength) + "…\r\n");
        else
            this.logStream.write(message.trim() + "\r\n");
    }
    dispose() {
        for (const pid of this.additionalPidsToTerminate) {
            try {
                process.kill(pid);
            }
            catch (e) {
                // TODO: Logger knows the category!
                this.logger.error({ message: e.toString() });
            }
        }
        this.additionalPidsToTerminate.length = 0;
        try {
            if (!this.processExited && this.process && !this.process.killed)
                this.process.kill();
        }
        catch (e) {
            // This tends to throw a lot because the shell process quit when we terminated the related
            // process above, so just swallow the error.
        }
        this.process = undefined;
        this.disposables.forEach((d) => __awaiter(this, void 0, void 0, function* () {
            try {
                return yield d.dispose();
            }
            catch (e) {
                this.logger.error({ message: e.toString() });
            }
        }));
        this.disposables.length = 0;
        // Clear log file so if any more log events come through later, we don't
        // create a new log file and overwrite what we had.
        this.logFile = undefined;
        if (this.logStream) {
            this.logStream.end();
            this.logStream = undefined;
            this.openLogFile = undefined;
        }
    }
}
exports.StdIOService = StdIOService;


/***/ }),

/***/ 9055:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.internalApiSymbol = void 0;
// TODO: Can we make this work better when webpack'd?
exports.internalApiSymbol = "_privateApi"; // Symbol();


/***/ }),

/***/ 6171:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSessionCoordinator = void 0;
const utils_1 = __webpack_require__(4586);
const outline_lsp_1 = __webpack_require__(4215);
const test_model_1 = __webpack_require__(1159);
/// Handles results from a test debug session and provides them to the test model.
class TestSessionCoordinator {
    constructor(logger, data, fileTracker) {
        this.logger = logger;
        this.data = data;
        this.fileTracker = fileTracker;
        this.disposables = [];
        /// A link between a suite path and the debug session ID that owns it, so we can ensure
        /// it is correctly ended when the debug session ends, even if we don't get the correct
        /// end events.
        this.owningDebugSessions = {};
        /// For a given debug session, lookups by IDs to get back to the suite.
        this.debugSessionLookups = {};
        /// A link between a suite path and a visitor for visiting its latest outline data.
        /// This data is refreshed when a test suite starts running.
        this.suiteOutlineVisitors = {};
        /// For each debug session ID, stores a mapping of phantom (empty) groups and their parent IDs so we can
        /// jump over them.
        this.phantomGroupParents = {};
    }
    handleDebugSessionCustomEvent(debugSessionID, dartCodeDebugSessionID, event, body) {
        if (event === "dart.testNotification") {
            // tslint:disable-next-line: no-floating-promises
            this.handleNotification(debugSessionID, dartCodeDebugSessionID !== null && dartCodeDebugSessionID !== void 0 ? dartCodeDebugSessionID : `untagged-session-${debugSessionID}`, body).catch((e) => this.logger.error(e));
        }
    }
    handleDebugSessionEnd(debugSessionID, dartCodeDebugSessionID) {
        // Get the suite paths that have us as the owning debug session.
        const suitePaths = Object.keys(this.owningDebugSessions).filter((suitePath) => {
            const owningSessionID = this.owningDebugSessions[suitePath];
            return owningSessionID === debugSessionID;
        });
        // End them all and remove from the lookup.
        for (const suitePath of suitePaths) {
            this.handleSuiteEnd(dartCodeDebugSessionID, this.data.suites[suitePath]);
            this.owningDebugSessions[suitePath] = undefined;
            delete this.owningDebugSessions[suitePath];
        }
    }
    handleNotification(debugSessionID, dartCodeDebugSessionID, evt) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (evt.type) {
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "start":
                // 	this.handleStartNotification(evt as StartNotification);
                // 	break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "allSuites":
                // 	this.handleAllSuitesNotification(evt as AllSuitesNotification);
                // 	break;
                case "suite":
                    this.handleSuiteNotification(dartCodeDebugSessionID, evt);
                    break;
                case "testStart":
                    this.handleTestStartNotification(dartCodeDebugSessionID, evt);
                    break;
                case "testDone":
                    this.handleTestDoneNotification(dartCodeDebugSessionID, evt);
                    break;
                case "group":
                    this.handleGroupNotification(dartCodeDebugSessionID, evt);
                    break;
                // We won't get notifications that aren't directly tied to Suites because
                // of how the DA works.
                // case "done":
                // 	this.handleDoneNotification(suite, evt as DoneNotification);
                // 	break;
                case "print":
                    this.handlePrintNotification(dartCodeDebugSessionID, evt);
                    break;
                case "error":
                    this.handleErrorNotification(dartCodeDebugSessionID, evt);
                    break;
            }
        });
    }
    handleSuiteNotification(dartCodeDebugSessionID, evt) {
        if (!this.debugSessionLookups[dartCodeDebugSessionID])
            this.debugSessionLookups[dartCodeDebugSessionID] = { suiteForID: {}, suiteForTestID: {} };
        const suiteData = this.data.suiteDiscovered(dartCodeDebugSessionID, evt.suite.path);
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.suite.id] = suiteData;
        // Also capture the test nodes from the outline so that we can look up the full range for a test (instead of online its line/col)
        // to provide to VS Code to better support "run test at cursor".
        this.captureTestOutlne(evt.suite.path);
    }
    captureTestOutlne(path) {
        var _a;
        const visitor = new outline_lsp_1.LspTestOutlineVisitor(this.logger, path);
        this.suiteOutlineVisitors[path] = visitor;
        const outline = (_a = this.fileTracker) === null || _a === void 0 ? void 0 : _a.getOutlineFor(path);
        if (outline)
            visitor.visit(outline);
    }
    handleTestStartNotification(dartCodeDebugSessionID, evt) {
        var _a, _b, _c;
        // Skip loading tests.
        if (((_a = evt.test.name) === null || _a === void 0 ? void 0 : _a.startsWith("loading ")) && !((_b = evt.test.groupIDs) === null || _b === void 0 ? void 0 : _b.length))
            return;
        const suite = this.debugSessionLookups[dartCodeDebugSessionID].suiteForID[evt.test.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.test.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        this.debugSessionLookups[dartCodeDebugSessionID].suiteForTestID[evt.test.id] = suite;
        const path = (evt.test.root_url || evt.test.url) ? (0, utils_1.uriToFilePath)(evt.test.root_url || evt.test.url) : undefined;
        const line = evt.test.root_line || evt.test.line;
        const character = evt.test.root_column || evt.test.column;
        const range = this.getRangeForNode(suite, line, character);
        const groupID = ((_c = evt.test.groupIDs) === null || _c === void 0 ? void 0 : _c.length) ? evt.test.groupIDs[evt.test.groupIDs.length - 1] : undefined;
        this.data.testDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.test.id, evt.test.name, this.getRealGroupId(dartCodeDebugSessionID, groupID), path, range, evt.time, true);
    }
    handleTestDoneNotification(dartCodeDebugSessionID, evt) {
        var _a;
        // If we don't have a test, it was likely a "loading foo.dart" test that we skipped over, so skip the result too.
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        if (!test)
            return;
        const result = evt.skipped ? "skipped" : evt.result;
        this.data.testDone(dartCodeDebugSessionID, suite.path, evt.testID, result, evt.time);
    }
    handleGroupNotification(dartCodeDebugSessionID, evt) {
        var _a, _b;
        // Skip phantom groups.
        if (!evt.group.name) {
            if (dartCodeDebugSessionID) {
                this.phantomGroupParents[dartCodeDebugSessionID] = this.phantomGroupParents[dartCodeDebugSessionID] || {};
                this.phantomGroupParents[dartCodeDebugSessionID][evt.group.id] = (_a = evt.group.parentID) !== null && _a !== void 0 ? _a : null; // Null signifies top-level.
            }
            return;
        }
        const suite = (_b = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _b === void 0 ? void 0 : _b.suiteForID[evt.group.suiteID];
        if (!suite) {
            this.logger.warn(`Could not find suite ${evt.group.suiteID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const path = (evt.group.root_url || evt.group.url) ? (0, utils_1.uriToFilePath)(evt.group.root_url || evt.group.url) : undefined;
        const line = evt.group.root_line || evt.group.line;
        const character = evt.group.root_column || evt.group.column;
        const range = this.getRangeForNode(suite, line, character);
        this.data.groupDiscovered(dartCodeDebugSessionID, suite.path, test_model_1.TestSource.Result, evt.group.id, evt.group.name, this.getRealGroupId(dartCodeDebugSessionID, evt.group.parentID), path, range, true);
    }
    getRealGroupId(dartCodeDebugSessionID, groupID) {
        const mapping = dartCodeDebugSessionID ? this.phantomGroupParents[dartCodeDebugSessionID] : undefined;
        const mappedValue = mapping && groupID ? mapping[groupID] : undefined;
        // Null is a special value that means undefined top-level)
        return mappedValue === null
            ? undefined
            // Whereas a real undefined we just pass-through as it was.
            : mappedValue !== null && mappedValue !== void 0 ? mappedValue : groupID;
    }
    handleSuiteEnd(dartCodeDebugSessionID, suite) {
        this.data.suiteDone(dartCodeDebugSessionID, suite.path);
    }
    handlePrintNotification(dartCodeDebugSessionID, evt) {
        var _a;
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        test.outputEvents.push(evt);
        this.data.testOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.message);
    }
    handleErrorNotification(dartCodeDebugSessionID, evt) {
        var _a;
        const suite = (_a = this.debugSessionLookups[dartCodeDebugSessionID]) === null || _a === void 0 ? void 0 : _a.suiteForTestID[evt.testID];
        if (!suite) {
            this.logger.warn(`Could not find suite for test ${evt.testID} for session ${dartCodeDebugSessionID}`);
            return;
        }
        const test = suite.getCurrentTest(dartCodeDebugSessionID, evt.testID);
        // It's possible we'll get notifications for tests we don't track (like loading tests) - for example package:test
        // may send "Consider enabling the flag chain-stack-traces to receive more detailed exceptions" against the first
        // loading test.
        if (!test)
            return;
        // Flutter emits an error when tests fail which when reported to the VS Code API will result in not-so-useful text
        // in the Test Error Peek window, so we suppress messages that match this pattern.
        const pattern = new RegExp(`
Test failed. See exception logs above.
The test description was: .*
`.trim());
        if (pattern.test(evt.error.trim()))
            return;
        test.outputEvents.push(evt);
        this.data.testErrorOutput(dartCodeDebugSessionID, suite.path, evt.testID, evt.isFailure, evt.error, evt.stackTrace);
    }
    getRangeForNode(suite, line, character) {
        var _a, _b;
        if (!line || !character)
            return;
        // VS Code is zero-based, but package:test is 1-based.
        const zeroBasedLine = line - 1;
        const zeroBasedCharacter = character - 1;
        // In test notifications, we only get the start line/column but we need to give VS Code the full range for "Run Test at Cursor" to work.
        // The outline data was captured when the suite started, so we can assume it's reasonable accurate, so try to look up the node
        // there and use its range. Otherwise, just make a range that goes from the start position to the next line (assuming the rest
        // of the line is the test name, and we can at least support running it there).
        const testsOnLine = line ? (_a = this.suiteOutlineVisitors[suite.path]) === null || _a === void 0 ? void 0 : _a.testsByLine[zeroBasedLine] : undefined;
        const test = testsOnLine ? testsOnLine.find((t) => t.range.start.character === zeroBasedCharacter) : undefined;
        const range = line && character
            ? (_b = test === null || test === void 0 ? void 0 : test.range) !== null && _b !== void 0 ? _b : {
                end: { line: zeroBasedLine + 1, character: zeroBasedCharacter },
                start: { line: zeroBasedLine, character: zeroBasedCharacter },
            }
            : undefined;
        return range;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.TestSessionCoordinator = TestSessionCoordinator;


/***/ }),

/***/ 1159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSource = exports.SuiteData = exports.TestModel = exports.TestNode = exports.GroupNode = exports.SuiteNode = exports.TreeNode = void 0;
const path = __webpack_require__(1017);
const enums_1 = __webpack_require__(7341);
const events_1 = __webpack_require__(3254);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const test_1 = __webpack_require__(8729);
class TreeNode {
    constructor(suiteData) {
        this.suiteData = suiteData;
        this._isStale = false;
        this.testSource = TestSource.Outline;
        this.isPotentiallyDeleted = false;
        this.children = [];
        this.statuses = new Set([enums_1.TestStatus.Unknown]);
    }
    /// Adds a status to the existing statuses list.
    appendStatus(status) {
        if (status === enums_1.TestStatus.Failed
            || status === enums_1.TestStatus.Passed
            || status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
        }
        this.statuses.add(status);
    }
    clearStatuses() {
        this.statuses.clear();
        this.description = undefined; // Clear old run duration.
    }
    hasStatus(status) {
        return this.statuses.has(status);
    }
    getHighestStatus(includeSkipped) {
        const statuses = this instanceof TestNode
            ? new Set(this.children.map((c) => c.status))
            : this.statuses;
        // Always include Skipped status for Suite nodes that have only that status, else they'll
        // show as unknown.
        if (!includeSkipped && this instanceof SuiteNode && statuses.size === 1 && statuses.has(enums_1.TestStatus.Skipped))
            includeSkipped = true;
        const validStatues = [...statuses].filter((s) => includeSkipped || s !== enums_1.TestStatus.Skipped);
        return validStatues.length
            ? Math.max(...validStatues)
            : enums_1.TestStatus.Unknown;
    }
    getTestCount(includeSkipped) {
        return this.children.map((t) => t.getTestCount(includeSkipped))
            .reduce((total, value) => total + value, 0);
    }
    get label() {
        const name = this instanceof GroupNode
            ? this.name
            : this instanceof TestNode
                ? this.name
                : undefined;
        let parent = this.parent;
        while (name && parent) {
            const parentName = parent instanceof GroupNode
                ? parent.name
                : parent instanceof TestNode
                    ? parent.name
                    : undefined;
            if (parentName && name.startsWith(`${parentName} `))
                return name.substr(parentName.length + 1); // +1 because of the space (included above).
            // Otherwise try next parent up.
            parent = parent === null || parent === void 0 ? void 0 : parent.parent;
        }
        return name !== null && name !== void 0 ? name : "<unnamed>";
    }
    get testPassCount() {
        return this.children.map((t) => t.testPassCount)
            .reduce((total, value) => total + value, 0);
    }
    get isStale() {
        return this._isStale;
    }
    set isStale(value) {
        this._isStale = value;
    }
}
exports.TreeNode = TreeNode;
class SuiteNode extends TreeNode {
    constructor(suiteData) {
        super(suiteData);
    }
    get parent() { return undefined; }
}
exports.SuiteNode = SuiteNode;
class GroupNode extends TreeNode {
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
    }
}
exports.GroupNode = GroupNode;
class TestNode extends TreeNode {
    // TODO: Flatten test into this class so we're not tied to the test protocol.
    constructor(suiteData, parent, name, path, range) {
        super(suiteData);
        this.suiteData = suiteData;
        this.parent = parent;
        this.name = name;
        this.path = path;
        this.range = range;
        this._status = enums_1.TestStatus.Unknown;
        this.outputEvents = [];
    }
    getTestCount(includeSkipped) {
        if (this.children.length)
            return super.getTestCount(includeSkipped);
        return includeSkipped || this.status !== enums_1.TestStatus.Skipped ? 1 : 0;
    }
    get testPassCount() {
        if (this.children.length)
            return super.testPassCount;
        return this.status === enums_1.TestStatus.Passed ? 1 : 0;
    }
    get status() {
        if (this.children.length)
            return super.getHighestStatus(true);
        return this._status;
    }
    set status(value) {
        this._status = value;
        if (this._status === enums_1.TestStatus.Failed
            || this._status === enums_1.TestStatus.Passed
            || this._status === enums_1.TestStatus.Skipped) {
            this.isStale = false;
            this.isPotentiallyDeleted = false;
        }
    }
    get isStale() {
        if (this.children.length)
            return !!this.children.find((c) => c.isStale);
        return super.isStale;
    }
    set isStale(value) {
        super.isStale = value;
    }
}
exports.TestNode = TestNode;
class TestModel {
    constructor(config, isPathInsideFlutterProject) {
        this.config = config;
        this.isPathInsideFlutterProject = isPathInsideFlutterProject;
        this.onDidChangeDataEmitter = new events_1.EventEmitter();
        this.onDidChangeTreeData = this.onDidChangeDataEmitter.event;
        this.testEventListeners = [];
        // TODO: Make private?
        this.suites = {};
    }
    addTestEventListener(listener) {
        this.testEventListeners.push(listener);
    }
    flagSuiteStart(suitePath, isRunningWholeSuite) {
        if (suitePath && path.isAbsolute(suitePath)) {
            const suite = this.suites[(0, fs_1.fsPath)(suitePath)];
            if (suite) {
                // Mark all test for this suite as "stale" which will make them faded, so that results from
                // the "new" run are more obvious in the tree.
                suite.getAllGroups().forEach((g) => g.isStale = true);
                suite.getAllTests().forEach((t) => t.isStale = true);
                if (isRunningWholeSuite && suite) {
                    this.markAllAsPotentiallyDeleted(suite, TestSource.Result);
                }
            }
        }
    }
    // When running the whole suite (or updating from Outline), we flag all tests as being
    // potentially deleted and then any tests that aren't run are removed from the tree. This
    // is to ensure if a test is renamed, we don't keep the old version of it in the test tree
    // forever since we don't have the necessary information to know the test was renamed.
    //
    // When updating from the outline, we'll skip children of dynamic nodes as we don't
    // know if they've been deleted or not, and don't want to cause their results to
    // immediately disappear.
    markAllAsPotentiallyDeleted(suite, source) {
        function doNode(node) {
            if (node.testSource === source)
                node.isPotentiallyDeleted = true;
            node.children.forEach(doNode);
        }
        doNode(suite.node);
    }
    // Marks a node and all of its parents as not-deleted so they will not be cleaned up.
    markAsNotDeleted(node) {
        while (node) {
            node.isPotentiallyDeleted = false;
            node = node.parent;
        }
    }
    removeAllPotentiallyDeletedNodes(suite) {
        // Delete nodes that were marked as potentially deleted and then never updated.
        // This means they weren't run in the last run, so probably were deleted (or
        // renamed and got new nodes, which still means the old ones should be removed).
        const toDelete = [
            ...suite.getAllGroups(),
            ...suite.getAllTests(),
        ].filter((t) => t.isPotentiallyDeleted);
        const toUpdate = new Set(toDelete.map((node) => node.parent));
        toDelete.forEach((node) => this.removeNode(node));
        toUpdate.forEach((node) => this.updateNode(node));
    }
    getOrCreateSuite(suitePath) {
        let suite = this.suites[suitePath];
        if (!suite) {
            suite = new SuiteData(suitePath, this.isPathInsideFlutterProject(suitePath));
            this.suites[suitePath] = suite;
            return [suite, true];
        }
        return [suite, false];
    }
    clearSuite(suitePath) {
        if (!this.suites[suitePath])
            return;
        delete this.suites[suitePath];
        this.updateNode();
    }
    clearSuiteOrDirectory(suiteOrDirectoryPath) {
        // We can't tell if it's a file or directory because it's already been deleted, so just
        // try both.
        let found = false;
        if (this.suites[suiteOrDirectoryPath]) {
            found = true;
            delete this.suites[suiteOrDirectoryPath];
        }
        else {
            for (const suitePath of Object.keys(this.suites)) {
                if ((0, fs_1.isWithinPath)(suitePath, suiteOrDirectoryPath)) {
                    delete this.suites[suitePath];
                    found = true;
                }
            }
        }
        if (found)
            this.updateNode();
    }
    handleConfigChange() {
        // When config changes, some things may change (for example
        // skipped tests may be hidden, so the test counts need
        // recomputing).
        Object.values(this.suites).forEach((suite) => this.rebuildSuiteNode(suite));
    }
    updateNode(node) {
        this.onDidChangeDataEmitter.fire(node);
    }
    rebuildSuiteNode(suite) {
        // Walk the tree to get the status.
        this.rebuildNode(suite.node);
        this.updateNode(suite.node);
    }
    /// Rebuilds any data on a node that is dependent on its children.
    rebuildNode(node) {
        if (!node.children.length)
            return;
        const childStatuses = (0, utils_1.flatMap)(node.children.map((c) => {
            this.rebuildNode(c);
            if (c instanceof GroupNode) {
                return [...c.statuses];
            }
            if (c instanceof TestNode)
                return [c.status];
            return [enums_1.TestStatus.Unknown];
        }), (s) => s);
        const childStatusesSet = new Set(childStatuses);
        const statusAreEqual = node.statuses.size === childStatusesSet.size && [...childStatusesSet].every((s) => node.statuses.has(s));
        if (!statusAreEqual) {
            node.clearStatuses();
            childStatuses.forEach((s) => node.appendStatus(s));
        }
        node.description = `${node.testPassCount}/${node.getTestCount(this.config.showSkippedTests)} passed`;
    }
    suiteDiscovered(dartCodeDebugSessionID, suitePath) {
        const [suite, didCreate] = this.getOrCreateSuite(suitePath);
        suite.node.appendStatus(enums_1.TestStatus.Waiting);
        this.updateNode(suite.node);
        this.updateNode();
        this.testEventListeners.forEach((l) => l.suiteDiscovered(dartCodeDebugSessionID, suite.node));
        return suite;
    }
    groupDiscovered(dartCodeDebugSessionID, suitePath, source, groupID, groupName, parentID, groupPath, range, hasStarted = false) {
        var _a;
        const suite = this.suites[suitePath];
        const existingGroup = suite.reuseMatchingGroup(groupName);
        const oldParent = existingGroup === null || existingGroup === void 0 ? void 0 : existingGroup.parent;
        let parent = parentID ? suite.getMyGroup(dartCodeDebugSessionID, parentID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (groupName && source === TestSource.Result)
            parent = (_a = this.findMatchingDynamicNode(parent, groupName)) !== null && _a !== void 0 ? _a : parent;
        const groupNode = existingGroup || new GroupNode(suite, parent, groupName, groupPath, range);
        suite.storeGroup(dartCodeDebugSessionID, groupID, groupNode);
        if (existingGroup) {
            groupNode.parent = parent;
            groupNode.name = groupName;
            groupNode.path = groupPath;
            groupNode.range = range;
        }
        else {
            groupNode.testSource = source;
        }
        this.markAsNotDeleted(groupNode);
        // Remove from old parent if required
        const hasChangedParent = oldParent !== parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(groupNode), 1);
            this.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!groupNode.parent.children.find((n) => n === groupNode))
            groupNode.parent.children.push(groupNode);
        if (hasStarted) {
            groupNode.appendStatus(enums_1.TestStatus.Running);
        }
        this.updateNode(groupNode.parent);
        this.testEventListeners.forEach((l) => l.groupDiscovered(dartCodeDebugSessionID, groupNode));
        return groupNode;
    }
    testDiscovered(dartCodeDebugSessionID, suitePath, source, testID, testName, groupID, testPath, range, startTime, hasStarted = false) {
        var _a;
        const suite = this.suites[suitePath];
        const existingTest = suite.reuseMatchingTest(testName);
        const oldParent = existingTest === null || existingTest === void 0 ? void 0 : existingTest.parent;
        let parent = groupID ? suite.getMyGroup(dartCodeDebugSessionID, groupID) : suite.node;
        /// If we're a dynamic test/group, we should be re-parented under the dynamic node that came from
        /// the analyzer.
        if (testName && source === TestSource.Result)
            parent = (_a = this.findMatchingDynamicNode(parent, testName)) !== null && _a !== void 0 ? _a : parent;
        const testNode = existingTest || new TestNode(suite, parent, testName, testPath, range);
        suite.storeTest(dartCodeDebugSessionID, testID, testNode);
        if (existingTest) {
            testNode.parent = parent;
            testNode.name = testName;
            testNode.path = testPath;
            const originalRange = testNode.range;
            testNode.range = range;
            // If we're an Outline node being updated, and we have Results children that
            // had the same range as us, they should be updated too, so Results nodes do not
            // drift away from the location over time.
            if (testNode.testSource === TestSource.Outline) {
                const children = testNode.children
                    .filter((c) => c.testSource === TestSource.Result)
                    .filter((c) => !c.range || (originalRange && this.rangeEquals(c.range, originalRange)));
                for (const child of children)
                    child.range = range;
            }
        }
        else {
            testNode.testSource = source;
        }
        this.markAsNotDeleted(testNode);
        testNode.testStartTime = startTime;
        // Remove from old parent if required.
        const hasChangedParent = oldParent && oldParent !== testNode.parent;
        if (oldParent && hasChangedParent) {
            oldParent.children.splice(oldParent.children.indexOf(testNode), 1);
            this.updateNode(oldParent);
        }
        // Push to new parent if required.
        if (!testNode.parent.children.find((n) => n === testNode))
            testNode.parent.children.push(testNode);
        if (hasStarted) {
            // Clear any test output from previous runs.
            testNode.outputEvents.length = 0;
            testNode.status = enums_1.TestStatus.Running;
        }
        this.updateNode(testNode.parent);
        this.rebuildSuiteNode(suite);
        if (hasStarted && dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testStarted(dartCodeDebugSessionID, testNode));
        return testNode;
    }
    /// Find a matching node in 'parent' that might be a node for a dynamic test/group that name is
    /// an instance of.
    findMatchingDynamicNode(parent, name) {
        // If the parent has any children exactly named us, they should be used regardless.
        if (parent.children.find((c) => c.name === name))
            return;
        for (const child of parent.children) {
            if (!child.name || typeof child !== typeof parent)
                continue;
            const regex = new RegExp((0, test_1.makeRegexForTests)([{ name: child.name, isGroup: child instanceof GroupNode }]));
            if (regex.test(name))
                return child;
        }
    }
    testDone(dartCodeDebugSessionID, suitePath, testID, result, endTime) {
        const suite = this.suites[suitePath];
        const testNode = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (result === "skipped") {
            testNode.status = enums_1.TestStatus.Skipped;
        }
        else if (result === "success") {
            testNode.status = enums_1.TestStatus.Passed;
        }
        else if (result === "failure") {
            testNode.status = enums_1.TestStatus.Failed;
        }
        else if (result === "error")
            testNode.status = enums_1.TestStatus.Failed;
        else {
            testNode.status = enums_1.TestStatus.Unknown;
        }
        if (endTime && testNode.testStartTime) {
            testNode.duration = endTime - testNode.testStartTime;
            testNode.description = ``;
            // Don't clear this, as concurrent runs will overwrite each
            // other and then we'll get no time at the end.
            // testNode.testStartTime = undefined;
        }
        this.updateNode(testNode);
        this.updateNode(testNode.parent);
        this.rebuildSuiteNode(suite);
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.testDone(dartCodeDebugSessionID, testNode, result));
    }
    suiteDone(dartCodeDebugSessionID, suitePath) {
        const suite = this.suites[suitePath];
        if (!suite)
            return;
        // TODO: Some notification that things are complete?
        // TODO: Maybe a progress bar during the run?
        this.removeAllPotentiallyDeletedNodes(suite);
        // Anything marked as running should be set back to Unknown
        suite.getAllTests().filter((t) => t.status === enums_1.TestStatus.Running).forEach((t) => {
            t.status = enums_1.TestStatus.Unknown;
            this.updateNode(t);
        });
        this.rebuildSuiteNode(suite);
        if (dartCodeDebugSessionID)
            this.testEventListeners.forEach((l) => l.suiteDone(dartCodeDebugSessionID, suite.node));
    }
    testOutput(dartCodeDebugSessionID, suitePath, testID, message) {
        const suite = this.suites[suitePath];
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testOutput(dartCodeDebugSessionID, test, message));
    }
    testErrorOutput(dartCodeDebugSessionID, suitePath, testID, isFailure, message, stack) {
        const suite = this.suites[suitePath];
        const test = suite.getCurrentTest(dartCodeDebugSessionID, testID);
        if (test)
            this.testEventListeners.forEach((l) => l.testErrorOutput(dartCodeDebugSessionID, test, message, isFailure, stack));
    }
    removeNode(node) {
        const parent = node.parent;
        const index = parent.children.indexOf(node);
        if (index > -1)
            parent.children.splice(index, 1);
    }
    rangeEquals(r1, r2) {
        return this.positionEquals(r1.start, r2.start) && this.positionEquals(r1.end, r2.end);
    }
    positionEquals(p1, p2) {
        return p1.line === p2.line && p1.character === p2.character;
    }
}
exports.TestModel = TestModel;
class SuiteData {
    constructor(path, isFlutterSuite) {
        this.path = path;
        this.isFlutterSuite = isFlutterSuite;
        this.groups = new Map();
        this.tests = new Map();
        this.node = new SuiteNode(this);
    }
    getAllGroups() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.groups.values()]);
    }
    getAllTests() {
        // We need to uniq() these because we store values in the map from
        // other runs so that concurrent runs can look up parent nodes from
        // their own IDs.
        return (0, utils_1.uniq)([...this.tests.values()]);
    }
    getCurrentTest(sessionID, id) {
        return this.tests.get(`${sessionID}_${id}`);
    }
    getMyGroup(sessionID, id) {
        return this.groups.get(`${sessionID}_${id}`);
    }
    getMyTest(sessionID, id) {
        return this.tests.get(`${sessionID}_${id}`);
    }
    storeGroup(sessionID, groupID, node) {
        return this.groups.set(`${sessionID}_${groupID}`, node);
    }
    storeTest(sessionID, testID, node) {
        return this.tests.set(`${sessionID}_${testID}`, node);
    }
    reuseMatchingGroup(groupName) {
        return this.getAllGroups().find((g) => g.name === groupName);
    }
    reuseMatchingTest(testName) {
        return this.getAllTests().find((t) => t.name === testName);
    }
}
exports.SuiteData = SuiteData;
var TestSource;
(function (TestSource) {
    TestSource[TestSource["Outline"] = 0] = "Outline";
    TestSource[TestSource["Result"] = 1] = "Result";
})(TestSource = exports.TestSource || (exports.TestSource = {}));


/***/ }),

/***/ 1883:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPackageTestCapabilities = void 0;
const path = __webpack_require__(1017);
const semver = __webpack_require__(1249);
const dart_test_1 = __webpack_require__(239);
const constants_1 = __webpack_require__(5628);
const processes_1 = __webpack_require__(5837);
function getPackageTestCapabilities(logger, sdks, folder) {
    return __awaiter(this, void 0, void 0, function* () {
        const binPath = path.join(sdks.dart, constants_1.dartVMPath);
        const proc = yield (0, processes_1.runProcess)(logger, binPath, ["run", "test:test", "--version"], folder, {}, processes_1.safeSpawn);
        const capabilities = dart_test_1.DartTestCapabilities.empty;
        if (proc.exitCode === 0) {
            if (semver.valid(proc.stdout.trim()))
                capabilities.version = proc.stdout.trim();
        }
        return capabilities;
    });
}
exports.getPackageTestCapabilities = getPackageTestCapabilities;


/***/ }),

/***/ 4586:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withTimeout = exports.disposeAll = exports.isWebDevice = exports.escapeDartString = exports.generateTestNameFromFileName = exports.clamp = exports.asHex = exports.asHexColor = exports.notNullOrUndefined = exports.notNull = exports.notUndefined = exports.nullToUndefined = exports.BufferedLogger = exports.errorString = exports.usingCustomScript = exports.isStableSdk = exports.pubVersionIsAtLeast = exports.versionIsAtLeast = exports.isDartSdkFromFlutter = exports.uriToFilePath = exports.findFileInAncestor = exports.PromiseCompleter = exports.escapeRegExp = exports.filenameSafe = exports.flatMapAsync = exports.flatMap = exports.uniq = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const semver = __webpack_require__(1249);
const constants_1 = __webpack_require__(5628);
function uniq(array) {
    return array.filter((value, index) => array.indexOf(value) === index);
}
exports.uniq = uniq;
function flatMap(input, f) {
    return input.reduce((acc, x) => acc.concat(f(x)), []);
}
exports.flatMap = flatMap;
function flatMapAsync(input, f) {
    return __awaiter(this, void 0, void 0, function* () {
        let res = [];
        for (const x of input)
            res = res.concat(yield f(x));
        return res;
    });
}
exports.flatMapAsync = flatMapAsync;
function filenameSafe(input) {
    return input.replace(/[^a-z0-9]+/gi, "_").toLowerCase();
}
exports.filenameSafe = filenameSafe;
function escapeRegExp(input) {
    return input.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
exports.escapeRegExp = escapeRegExp;
class PromiseCompleter {
    constructor() {
        this.promise = new Promise((res, rej) => {
            this.resolve = res;
            this.reject = rej;
        });
    }
}
exports.PromiseCompleter = PromiseCompleter;
function findFileInAncestor(files, startLocation) {
    let lastParent;
    let parent = startLocation;
    while (parent && parent.length > 1 && parent !== lastParent) {
        for (const file of files) {
            const child = path.join(parent, file);
            if (fs.existsSync(child))
                return child;
        }
        lastParent = parent;
        parent = path.dirname(parent);
    }
    return undefined;
}
exports.findFileInAncestor = findFileInAncestor;
/// Converts a file URI to file path without a dependency on vs.Uri.
function uriToFilePath(uri, returnWindowsPath = constants_1.isWin) {
    let filePath = uri;
    if (uri.startsWith("file://"))
        filePath = decodeURI(uri.substring(7));
    else if (uri.startsWith("file:"))
        filePath = decodeURI(uri.substring(5)); // TODO: Does this case ever get hit? Will it be over-decoded?
    // Windows fixup.
    if (returnWindowsPath) {
        filePath = filePath.replace(/\//g, "\\");
        if (filePath.startsWith("\\"))
            filePath = filePath.substring(1);
    }
    else {
        if (!filePath.startsWith("/"))
            filePath = `/${filePath}`;
    }
    return filePath;
}
exports.uriToFilePath = uriToFilePath;
function isDartSdkFromFlutter(dartSdkPath) {
    const possibleFlutterSdkPath = path.join(path.dirname(path.dirname(path.dirname(dartSdkPath))), "bin");
    return fs.existsSync(path.join(possibleFlutterSdkPath, constants_1.executableNames.flutter));
}
exports.isDartSdkFromFlutter = isDartSdkFromFlutter;
function versionIsAtLeast(inputVersion, requiredVersion) {
    return semver.gte(inputVersion, requiredVersion);
}
exports.versionIsAtLeast = versionIsAtLeast;
function pubVersionIsAtLeast(inputVersion, requiredVersion) {
    // Standard semver gt/lt
    if (semver.gt(inputVersion, requiredVersion))
        return true;
    else if (semver.lt(inputVersion, requiredVersion))
        return false;
    // If the versions are equal, we need to handle build metadata like pub does.
    // https://github.com/dart-lang/pub_semver/
    // If only one of them has build metadata, it's newest.
    if (inputVersion.indexOf("+") !== -1 && requiredVersion.indexOf("+") === -1)
        return true;
    if (inputVersion.indexOf("+") === -1 && requiredVersion.indexOf("+") !== -1)
        return false;
    // Otherwise, since they're both otherwise equal and both have build
    // metadata we can treat the build metadata like pre-release by converting
    // it to pre-release (with -) or appending it to existing pre-release.
    inputVersion = inputVersion.replace("+", inputVersion.indexOf("-") === -1 ? "-" : ".");
    requiredVersion = requiredVersion.replace("+", requiredVersion.indexOf("-") === -1 ? "-" : ".");
    return versionIsAtLeast(inputVersion, requiredVersion);
}
exports.pubVersionIsAtLeast = pubVersionIsAtLeast;
function isStableSdk(sdkVersion) {
    // We'll consider empty versions as dev; stable versions will likely always
    // be shipped with valid version files.
    return !!(sdkVersion && !semver.prerelease(sdkVersion));
}
exports.isStableSdk = isStableSdk;
function usingCustomScript(binPath, binArgs, customScript) {
    if (customScript === null || customScript === void 0 ? void 0 : customScript.script) {
        binPath = customScript.script;
        if (customScript.replacesArgs)
            binArgs = binArgs.slice(customScript.replacesArgs);
    }
    return { executable: binPath, args: binArgs };
}
exports.usingCustomScript = usingCustomScript;
function errorString(error) {
    if (!error)
        return "<empty error>";
    else if (error instanceof Error)
        return error.message + (error.stack ? `\n${error.stack}` : "");
    else if (error.message)
        return error.message;
    else if (typeof error === "string")
        return error;
    else
        return `${error}`;
}
exports.errorString = errorString;
class BufferedLogger {
    constructor() {
        this.buffer = [];
    }
    info(message, category) {
        this.buffer.push({ type: "info", message, category });
    }
    warn(message, category) {
        this.buffer.push({ type: "warn", message, category });
    }
    error(error, category) {
        this.buffer.push({ type: "error", message: error, category });
    }
    flushTo(logger) {
        if (!this.buffer.length)
            return;
        logger.info("Flushing log messages...");
        for (const log of this.buffer) {
            switch (log.type) {
                case "info":
                    logger.info(log.message, log.category);
                    break;
                case "warn":
                    logger.warn(log.message, log.category);
                    break;
                case "error":
                    logger.error(log.message, log.category);
                    break;
            }
        }
        logger.info("Done flushing log messages...");
    }
}
exports.BufferedLogger = BufferedLogger;
function nullToUndefined(value) {
    return (value === null ? undefined : value);
}
exports.nullToUndefined = nullToUndefined;
function notUndefined(x) {
    return x !== undefined;
}
exports.notUndefined = notUndefined;
function notNull(x) {
    return x !== null;
}
exports.notNull = notNull;
function notNullOrUndefined(x) {
    return notUndefined(x) && notNull(x);
}
exports.notNullOrUndefined = notNullOrUndefined;
function asHexColor({ r, g, b, a }) {
    r = clamp(r, 0, 255);
    g = clamp(g, 0, 255);
    b = clamp(b, 0, 255);
    a = clamp(a, 0, 255);
    return `${asHex(a)}${asHex(r)}${asHex(g)}${asHex(b)}`.toLowerCase();
}
exports.asHexColor = asHexColor;
function asHex(v) {
    return Math.round(v).toString(16).padStart(2, "0");
}
exports.asHex = asHex;
function clamp(v, min, max) {
    return Math.min(Math.max(min, v), max);
}
exports.clamp = clamp;
function generateTestNameFromFileName(input) {
    return path.basename(input).replace("_test.dart", "").replace(/_/g, " ");
}
exports.generateTestNameFromFileName = generateTestNameFromFileName;
function escapeDartString(input) {
    return input.replace(/(['"\\])/g, "\\$1");
}
exports.escapeDartString = escapeDartString;
function isWebDevice(deviceId) {
    return !!((deviceId === null || deviceId === void 0 ? void 0 : deviceId.startsWith("web")) || deviceId === "chrome" || deviceId === "edge");
}
exports.isWebDevice = isWebDevice;
function disposeAll(disposables) {
    const toDispose = disposables.slice();
    disposables.length = 0;
    for (const d of toDispose) {
        try {
            d.dispose();
        }
        catch (e) {
            console.warn(e);
        }
    }
}
exports.disposeAll = disposeAll;
function withTimeout(promise, message, seconds = 360) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            // Set a timeout to reject the promise after the timeout period.
            const timeoutTimer = setTimeout(() => {
                const msg = typeof message === "string" ? message : message();
                reject(new Error(`${msg} within ${seconds}s`));
            }, seconds * 1000);
            // When the main promise completes, cancel the timeout and return its result.
            // eslint-disable-next-line @typescript-eslint/no-floating-promises
            promise.then((result) => {
                clearTimeout(timeoutTimer);
                resolve(result);
            });
        });
    });
}
exports.withTimeout = withTimeout;


/***/ }),

/***/ 7434:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayContainsArray = exports.arrayStartsWith = exports.arraysEqual = exports.unique = exports.not = exports.sortBy = void 0;
function sortBy(items, f) {
    return items.sort((item1, item2) => {
        const r1 = f(item1);
        const r2 = f(item2);
        if (r1 < r2)
            return -1;
        if (r1 > r2)
            return 1;
        return 0;
    });
}
exports.sortBy = sortBy;
function not(f) {
    return (x) => !f(x);
}
exports.not = not;
function unique(items) {
    return Array.from(new Set(items));
}
exports.unique = unique;
function arraysEqual(items1, items2) {
    return items1.length === items2.length && items1.every((val, i) => val === items2[i]);
}
exports.arraysEqual = arraysEqual;
function arrayStartsWith(items1, items2) {
    return items1.length >= items2.length && arraysEqual(items1.slice(0, items2.length), items2);
}
exports.arrayStartsWith = arrayStartsWith;
function arrayContainsArray(haystack, needle) {
    // Loop over valid starting points for the subarray
    for (let i = 0; i <= haystack.length - needle.length; i++) {
        // Check if the relevant length sublist equals the other array.
        if (arraysEqual(haystack.slice(i, i + needle.length), needle))
            return true;
    }
    return false;
}
exports.arrayContainsArray = arrayContainsArray;


/***/ }),

/***/ 8854:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleTimeBasedCache = void 0;
/// Simple time-base cache.
class SimpleTimeBasedCache {
    constructor() {
        this.data = new Map();
    }
    get(key) {
        const item = this.data.get(key);
        if (item && item.expiryTime < new Date().getTime()) {
            this.data.delete(key);
            return undefined;
        }
        return item === null || item === void 0 ? void 0 : item.data;
    }
    add(key, item, millisecondsToCache) {
        this.data.set(key, {
            data: item,
            expiryTime: new Date().getTime() + millisecondsToCache,
        });
    }
}
exports.SimpleTimeBasedCache = SimpleTimeBasedCache;


/***/ }),

/***/ 9439:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stripMarkdown = exports.cleanDartdoc = void 0;
const utils_1 = __webpack_require__(4586);
const materialIconRegex = new RegExp((0, utils_1.escapeRegExp)('<i class="material-icons')
    + "(?:-([\\w]+))?"
    + (0, utils_1.escapeRegExp)(' md-36">')
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const cupertinoIconRegex = new RegExp((0, utils_1.escapeRegExp)(`<i class='cupertino-icons md-36'>`)
    + "([\\w\\s_]+)"
    + (0, utils_1.escapeRegExp)("</i> &#x2014;")
    + "\\s+", "gi");
const dartDocDirectives = new RegExp(`(\\n\\s*{@.*?}$)|(^{@.*?}\\s*\\n)|(^{@.*?}$)`, "gim");
const dartDocCodeBlockSections = new RegExp(`(\`\`\`\\w+) +\\w+`, "gi");
function cleanDartdoc(doc, iconPathFormat) {
    if (!doc)
        return "";
    // Clean up some dart.core dartdoc.
    const index = doc.indexOf("## Other resources");
    if (index !== -1)
        doc = doc.substring(0, index);
    // Remove colons from old-style references like [:foo:].
    doc = doc.replace(/\[:\S+:\]/g, (match) => `[${match.substring(2, match.length - 2)}]`);
    // Replace material icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(materialIconRegex, (_fullMatch, variant, icon) => {
        if (variant) {
            variant = fixVariant(variant);
            icon = `${icon}_${variant}`;
        }
        icon = fixIcon(icon);
        const iconPath = iconPathFormat.replace("$1", `material/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Replace cupertino icon HTML blocks with markdown to load the images from the correct place.
    doc = doc.replace(cupertinoIconRegex, (_fullMatch, icon) => {
        const iconPath = iconPathFormat.replace("$1", `cupertino/${icon}`);
        return `![${icon}](${iconPath}|width=32,height=32)\n\n`;
    });
    // Remove any directives like {@template xxx}
    doc = doc.replace(dartDocDirectives, "");
    // Remove any code block section names like ```dart preamble
    doc = doc.replace(dartDocCodeBlockSections, "$1");
    return doc;
}
exports.cleanDartdoc = cleanDartdoc;
/// Strips markdown to make nicer plain text.
function stripMarkdown(doc) {
    if (!doc)
        return "";
    // Remove links like [foo](bar).
    doc = doc.replace(/\[(.+?)\]\(.+?\)/g, "$1");
    // Remove references like [foo].
    doc = doc.replace(/\[(.+?)\]/g, "$1");
    return doc;
}
exports.stripMarkdown = stripMarkdown;
function fixVariant(variant) {
    // Class names don't always match the filenames.
    return variant === "round" ? "rounded" : variant;
}
const identifierPrefixRewritePattern = new RegExp(`3d|\\d+`);
const identifierPrefixRewrites = {
    // See identifierPrefixRewrites in
    // https://github.com/flutter/flutter/blob/master/dev/tools/update_icons.dart
    "1": "one_",
    "10": "ten_",
    "11": "eleven_",
    "12": "twelve_",
    "123": "onetwothree",
    "13": "thirteen_",
    "14": "fourteen_",
    "15": "fifteen_",
    "16": "sixteen_",
    "17": "seventeen_",
    "18": "eighteen_",
    "19": "nineteen_",
    "2": "two_",
    "20": "twenty_",
    "21": "twenty_one_",
    "22": "twenty_two_",
    "23": "twenty_three_",
    "24": "twenty_four_",
    "2d": "twod",
    "3": "three_",
    "30": "thirty_",
    "360": "threesixty",
    "3d": "threed",
    "4": "four_",
    "5": "five_",
    "6": "six_",
    "60": "sixty_",
    "7": "seven_",
    "8": "eight_",
    "9": "nine_",
};
const identifierExactRewrites = {
    // See identifierExactRewrites in
    // https://github.com/flutter/flutter/blob/master/dev/tools/update_icons.dart
    "class": "class_",
    "door_back": "door_back_door",
    "door_front": "door_front_door",
    "new": "new_",
    "switch": "switch_",
    "try": "try_sms_star",
};
function fixIcon(icon) {
    // Things starting with numbers are textual in their names too.
    const prefixMatch = identifierPrefixRewritePattern.exec(icon);
    if (prefixMatch) {
        const prefix = prefixMatch[0];
        const newPrefix = identifierPrefixRewrites[prefix];
        if (newPrefix)
            return `${newPrefix}${icon.slice(prefix.length)}`;
    }
    // Also try exact rewrites.
    const newIdentifier = identifierExactRewrites[icon];
    if (newIdentifier)
        return newIdentifier;
    return icon;
}


/***/ }),

/***/ 2335:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDebugAdapterPort = exports.getDebugAdapterName = void 0;
const enums_1 = __webpack_require__(7341);
function getDebugAdapterName(debugType) {
    let debuggerName;
    switch (debugType) {
        case enums_1.DebuggerType.Flutter:
            debuggerName = "flutter";
            break;
        case enums_1.DebuggerType.FlutterTest:
            debuggerName = "flutter_test";
            break;
        case enums_1.DebuggerType.Web:
            debuggerName = "web";
            break;
        case enums_1.DebuggerType.WebTest:
            debuggerName = "web_test";
            break;
        case enums_1.DebuggerType.Dart:
            debuggerName = "dart";
            break;
        case enums_1.DebuggerType.DartTest:
            debuggerName = "dart_test";
            break;
        default:
            throw new Error(`Unknown debugger type: ${debugType}`);
    }
    return debuggerName;
}
exports.getDebugAdapterName = getDebugAdapterName;
function getDebugAdapterPort(debuggerName) {
    const debugAdapterNames = [
        "flutter",
        "flutter_test",
        "web",
        "web_test",
        "dart",
        "dart_test",
    ];
    const index = debugAdapterNames.indexOf(debuggerName);
    if (index === -1)
        throw new Error(`Unknown debugger type: ${debuggerName}`);
    return 4711 + index;
}
exports.getDebugAdapterPort = getDebugAdapterPort;


/***/ }),

/***/ 359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterOutlineVisitorLsp = exports.FlutterOutlineVisitor = void 0;
class FlutterOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitor = FlutterOutlineVisitor;
class FlutterOutlineVisitorLsp {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.kind) {
            case "DART_ELEMENT":
                this.visitDartElement(outline);
                break;
            case "GENERIC":
                this.visitGeneric(outline);
                break;
            case "NEW_INSTANCE":
                this.visitNewInstance(outline);
                break;
            case "INVOCATION":
                this.visitInvocation(outline);
                break;
            case "VARIABLE":
                this.visitVariable(outline);
                break;
            case "PLACEHOLDER":
                this.visitPlaceholder(outline);
                break;
            default:
                this.logger.error(`Unknown Flutter Outline item! ${outline && outline.kind}`);
        }
        if (outline.attributes) {
            for (const attribute of outline.attributes)
                this.visitAttribute(attribute);
        }
    }
    visitDartElement(outline) { this.visitChildren(outline); }
    visitGeneric(outline) { this.visitChildren(outline); }
    visitNewInstance(outline) { this.visitChildren(outline); }
    visitInvocation(outline) { this.visitChildren(outline); }
    visitVariable(outline) { this.visitChildren(outline); }
    visitPlaceholder(outline) { this.visitChildren(outline); }
    // tslint:disable-next-line: no-empty
    visitAttribute(attribute) { }
}
exports.FlutterOutlineVisitorLsp = FlutterOutlineVisitorLsp;


/***/ }),

/***/ 300:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nextAvailableFilename = exports.normalizeSlashes = exports.areSameFolder = exports.mkDirRecursive = exports.getRandomInt = exports.tryDeleteFile = exports.getPubGeneratorVersion = exports.getSdkVersion = exports.findProjectFolders = exports.resolveTildePaths = exports.extractFlutterSdkPathFromPackagesFile = exports.referencesBuildRunner = exports.pubspecContentReferencesFlutterSdk = exports.projectReferencesFlutterSdk = exports.isFlutterProjectFolder = exports.isFlutterRepoAsync = exports.hasCreateTriggerFileAsync = exports.hasPubspecAsync = exports.hasPubspec = exports.hasPackageMapFile = exports.readDirAsync = exports.getChildFolders = exports.findCommonAncestorFolder = exports.isEqualOrWithinPath = exports.isWithinPathOrEqual = exports.isWithinPath = exports.forceWindowsDriveLetterToUppercase = exports.fsPath = void 0;
const fs = __webpack_require__(7147);
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const semver = __webpack_require__(1249);
const constants_1 = __webpack_require__(5628);
const logging_1 = __webpack_require__(8323);
const package_map_1 = __webpack_require__(143);
const utils_1 = __webpack_require__(4586);
const array_1 = __webpack_require__(7434);
function fsPath(uri, { useRealCasing = false } = {}) {
    // tslint:disable-next-line:disallow-fspath
    let newPath = typeof uri === "string" ? uri : uri.fsPath;
    if (useRealCasing) {
        const realPath = fs.existsSync(newPath) && fs.realpathSync.native(newPath);
        // Since realpathSync.native will resolve symlinks, only do anything if the paths differ
        // _only_ by case.
        // when there was no symlink (eg. the lowercase version of both paths match).
        if (realPath && realPath.toLowerCase() === newPath.toLowerCase() && realPath !== newPath) {
            console.warn(`Rewriting path:\n  ${newPath}\nto:\n  ${realPath} because the casing appears munged`);
            newPath = realPath;
        }
    }
    newPath = forceWindowsDriveLetterToUppercase(newPath);
    return newPath;
}
exports.fsPath = fsPath;
function forceWindowsDriveLetterToUppercase(p) {
    if (typeof p !== "string")
        return undefined;
    if (p && constants_1.isWin && path.isAbsolute(p) && p.startsWith(p.charAt(0).toLowerCase()))
        return p.substr(0, 1).toUpperCase() + p.substr(1);
    return p;
}
exports.forceWindowsDriveLetterToUppercase = forceWindowsDriveLetterToUppercase;
function isWithinPath(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return !!relative && !relative.startsWith("..") && !path.isAbsolute(relative);
}
exports.isWithinPath = isWithinPath;
function isWithinPathOrEqual(file, folder) {
    const relative = path.relative(folder, file);
    return !relative || isWithinPath(file, folder);
}
exports.isWithinPathOrEqual = isWithinPathOrEqual;
function isEqualOrWithinPath(file, folder) {
    const relative = path.relative(folder.toLowerCase(), file.toLowerCase());
    return relative === "" || (!!relative && !relative.startsWith("..") && !path.isAbsolute(relative));
}
exports.isEqualOrWithinPath = isEqualOrWithinPath;
function findCommonAncestorFolder(folderPaths) {
    if (!folderPaths.length)
        return undefined;
    const commonAncestorSegments = folderPaths[0].split(path.sep);
    for (const folderPath of folderPaths.slice(1)) {
        const pathSegments = folderPath.split(path.sep);
        for (let i = 0; i < Math.min(commonAncestorSegments.length, pathSegments.length); i++) {
            if (commonAncestorSegments[i] !== pathSegments[i]) {
                commonAncestorSegments.splice(i);
                break;
            }
        }
        if (commonAncestorSegments.length > pathSegments.length) {
            commonAncestorSegments.splice(pathSegments.length);
        }
    }
    // If we got up to the root, consider that not a match.
    if (commonAncestorSegments.length <= 1)
        return undefined;
    return commonAncestorSegments.join(path.sep);
}
exports.findCommonAncestorFolder = findCommonAncestorFolder;
function getChildFolders(logger, parent, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs.existsSync(parent))
            return [];
        const files = yield readDirAsync(logger, parent);
        return files.filter((f) => f.isDirectory())
            .filter((f) => f.name !== "bin" || (options && options.allowBin)) // Don't look in bin folders
            .filter((f) => f.name !== "cache" || (options && options.allowCache)) // Don't look in cache folders
            .map((item) => path.join(parent, item.name));
    });
}
exports.getChildFolders = getChildFolders;
function readDirAsync(logger, folder) {
    return new Promise((resolve) => fs.readdir(folder, { withFileTypes: true }, (err, files) => {
        // We will generate errors if we don't have access to this folder
        // so just skip over it.
        if (err) {
            logger.warn(`Skipping folder ${folder} due to error: ${err}`);
            resolve([]);
        }
        else {
            resolve(files);
        }
    }));
}
exports.readDirAsync = readDirAsync;
function hasPackageMapFile(folder) {
    return fs.existsSync(path.join(folder, ".dart_tool", "package_config.json")) || fs.existsSync(path.join(folder, ".packages"));
}
exports.hasPackageMapFile = hasPackageMapFile;
function hasPubspec(folder) {
    return fs.existsSync(path.join(folder, "pubspec.yaml"));
}
exports.hasPubspec = hasPubspec;
function hasPubspecAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, "pubspec.yaml"));
    });
}
exports.hasPubspecAsync = hasPubspecAsync;
function hasCreateTriggerFileAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield fileExists(path.join(folder, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE));
    });
}
exports.hasCreateTriggerFileAsync = hasCreateTriggerFileAsync;
function isFlutterRepoAsync(folder) {
    return __awaiter(this, void 0, void 0, function* () {
        return (yield fileExists(path.join(folder, "bin/flutter"))) && (yield fileExists(path.join(folder, "bin/cache/dart-sdk")));
    });
}
exports.isFlutterRepoAsync = isFlutterRepoAsync;
function isFlutterProjectFolder(folder) {
    return projectReferencesFlutterSdk(folder);
}
exports.isFlutterProjectFolder = isFlutterProjectFolder;
function projectReferencesFlutterSdk(folder) {
    if (folder && hasPubspec(folder)) {
        return pubspecContentReferencesFlutterSdk(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.projectReferencesFlutterSdk = projectReferencesFlutterSdk;
function pubspecContentReferencesFlutterSdk(content) {
    const regex = new RegExp("sdk\\s*:\\s*[\"']?flutter[\"']?", "i");
    return regex.test(content);
}
exports.pubspecContentReferencesFlutterSdk = pubspecContentReferencesFlutterSdk;
function referencesBuildRunner(folder) {
    if (folder && hasPubspec(folder)) {
        const regex = new RegExp("build_runner\\s*:", "i");
        return regex.test(fs.readFileSync(path.join(folder, "pubspec.yaml")).toString());
    }
    return false;
}
exports.referencesBuildRunner = referencesBuildRunner;
function extractFlutterSdkPathFromPackagesFile(projectFolder) {
    if (!fs.existsSync(projectFolder))
        return undefined;
    let packagePath = package_map_1.PackageMap.loadForProject(logging_1.nullLogger, projectFolder).getPackagePath("flutter");
    if (!packagePath)
        return undefined;
    // Set windows slashes to / while manipulating.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\\/g, "/");
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Trim suffix we don't need.
    const pathSuffix = "/packages/flutter/lib/";
    if (packagePath.endsWith(pathSuffix)) {
        packagePath = packagePath.substr(0, packagePath.length - pathSuffix.length);
    }
    // Make sure ends with a slash.
    if (!packagePath.endsWith("/"))
        packagePath = packagePath + "/";
    // Append bin if required.
    if (!packagePath.endsWith("/bin/")) {
        packagePath = packagePath + "bin/";
    }
    // Set windows paths back.
    if (constants_1.isWin) {
        packagePath = packagePath.replace(/\//g, "\\");
        if (packagePath.startsWith("\\"))
            packagePath = packagePath.substring(1);
    }
    return packagePath;
}
exports.extractFlutterSdkPathFromPackagesFile = extractFlutterSdkPathFromPackagesFile;
function fileExists(p) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield fs.promises.access(p);
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
function resolveTildePaths(p) {
    if (typeof p !== "string")
        return undefined;
    if (p.startsWith("~/"))
        return path.join(os.homedir(), p.substr(2));
    return p;
}
exports.resolveTildePaths = resolveTildePaths;
// Walks a few levels down and returns all folders that look like project
// folders, such as:
// - have a pubspec.yaml
// - have a project create trigger file
// - are the Flutter repo root
function findProjectFolders(logger, roots, excludedFolders, options, token) {
    return __awaiter(this, void 0, void 0, function* () {
        const dartToolFolderName = `${path.sep}.dart_tool${path.sep}`;
        let previousLevelFolders = roots.slice();
        let allPossibleFolders = previousLevelFolders.slice();
        // Start at 1, as we already added the roots.
        const searchDepth = options.onlyWorkspaceRoots ? 1 : options.searchDepth;
        for (let i = 1; i < searchDepth; i++) {
            let nextLevelFolders = [];
            for (const folder of previousLevelFolders) {
                if (token.isCancellationRequested)
                    break;
                nextLevelFolders = nextLevelFolders.concat(yield getChildFolders(logger, folder));
            }
            allPossibleFolders = allPossibleFolders.concat(nextLevelFolders);
            previousLevelFolders = nextLevelFolders;
        }
        allPossibleFolders = allPossibleFolders
            .filter((f) => !f.includes(dartToolFolderName) && excludedFolders.every((ef) => !isEqualOrWithinPath(f, ef)));
        const projectFolderPromises = allPossibleFolders.map((folder) => __awaiter(this, void 0, void 0, function* () {
            return ({
                exists: options && options.requirePubspec
                    ? yield hasPubspecAsync(folder)
                    : options.onlyWorkspaceRoots || (yield hasPubspecAsync(folder)) || (yield hasCreateTriggerFileAsync(folder)) || (yield isFlutterRepoAsync(folder)),
                folder,
            });
        }));
        const projectFoldersChecks = yield Promise.all(projectFolderPromises);
        const projectFolders = projectFoldersChecks
            .filter((res) => res.exists)
            .map((res) => res.folder);
        return options && options.sort
            ? (0, array_1.sortBy)(projectFolders, (p) => p.toLowerCase())
            : projectFolders;
    });
}
exports.findProjectFolders = findProjectFolders;
function getSdkVersion(logger, { sdkRoot }) {
    if (!sdkRoot)
        return undefined;
    const versionFile = path.join(sdkRoot, "version");
    if (!fs.existsSync(versionFile))
        return undefined;
    try {
        return (0, utils_1.nullToUndefined)(semver.valid(fs
            .readFileSync(versionFile, "utf8")
            .trim()
            .split("\n")
            .filter((l) => l)
            .filter((l) => l.trim().substr(0, 1) !== "#")
            .join("\n")
            .trim()));
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
exports.getSdkVersion = getSdkVersion;
function getPubGeneratorVersion(logger, packageMapPath) {
    if (!fs.existsSync(packageMapPath))
        return undefined;
    try {
        const content = fs.readFileSync(packageMapPath, "utf8");
        const data = JSON.parse(content);
        const version = data.generatorVersion;
        return (0, utils_1.nullToUndefined)(semver.valid(version));
    }
    catch (e) {
        logger.error(e);
        return undefined;
    }
}
exports.getPubGeneratorVersion = getPubGeneratorVersion;
function tryDeleteFile(filePath) {
    if (fs.existsSync(filePath)) {
        try {
            fs.unlinkSync(filePath);
        }
        catch (_a) {
            console.warn(`Failed to delete file ${path}.`);
        }
    }
}
exports.tryDeleteFile = tryDeleteFile;
function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min)) + min;
}
exports.getRandomInt = getRandomInt;
function mkDirRecursive(folder) {
    const parent = path.dirname(folder);
    if (!fs.existsSync(parent))
        mkDirRecursive(parent);
    if (!fs.existsSync(folder))
        fs.mkdirSync(folder);
}
exports.mkDirRecursive = mkDirRecursive;
function areSameFolder(folder1, folder2) {
    // Trim any trailing path separators of either direction.
    folder1 = folder1.replace(/[\\/]+$/, "");
    folder2 = folder2.replace(/[\\/]+$/, "");
    return folder1 === folder2;
}
exports.areSameFolder = areSameFolder;
function normalizeSlashes(p) {
    return p.replace(/[\\/]/g, path.sep);
}
exports.normalizeSlashes = normalizeSlashes;
/**
 * Gets a unique path or filename for the specified {folderUri} location, appending a numerical value
 * between {prefix} and suffix, as required.
 *
 * A directory/file location will be generated from {prefix} with a trailing number (eg. `mydir1`) and
 * its existence will be checked; if it already exists, the number will be incremented and checked again.
 *
 * This will continue until a non-existent directory/file is available, or until the maxiumum search
 * limit (of 128) is reached.
 *
 * @param folder directory to check for existing directories or files.
 * @param prefix prefix of the directory/file
 * @param suffix suffix of the directory/file
 */
function nextAvailableFilename(folder, prefix, suffix = "") {
    // Set an upper bound on how many attempts we should make in getting a non-existent name.
    const maxSearchLimit = 128;
    for (let index = 1; index <= maxSearchLimit; index++) {
        const name = `${prefix}${index}${suffix}`;
        const fullPath = path.join(folder, name);
        if (!fs.existsSync(fullPath)) {
            // Name doesn't appear to exist on-disk and thus can be used - return it.
            return name;
        }
    }
    // We hit the search limit, so return {prefix}{index} (eg. mydir1) and allow the extension to
    // handle the already-exists condition if user doesn't change it manually.
    return `${prefix}1${suffix}`;
}
exports.nextAvailableFilename = nextAvailableFilename;


/***/ }),

/***/ 6074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassOutlineVisitor = exports.TestOutlineVisitor = exports.OutlineVisitor = void 0;
const test_1 = __webpack_require__(8729);
class OutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visit(child);
            }
        }
    }
    visitNode(outline) {
        var _a, _b, _c;
        switch ((_a = outline === null || outline === void 0 ? void 0 : outline.element) === null || _a === void 0 ? void 0 : _a.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${(_b = outline === null || outline === void 0 ? void 0 : outline.element) === null || _b === void 0 ? void 0 : _b.kind} (${(_c = outline === null || outline === void 0 ? void 0 : outline.element) === null || _c === void 0 ? void 0 : _c.name})`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.OutlineVisitor = OutlineVisitor;
class TestOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.tests = [];
        this.names = [];
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.location)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        this.tests.push({
            file: outline.element.location.file,
            fullName,
            isGroup,
            length: outline.codeLength || outline.element.location.length,
            offset: outline.codeOffset || outline.element.location.offset,
        });
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.TestOutlineVisitor = TestOutlineVisitor;
class ClassOutlineVisitor extends OutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.location || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeLength: outline.codeLength,
            codeOffset: outline.codeOffset,
            length: outline.length,
            offset: outline.offset,
        });
    }
}
exports.ClassOutlineVisitor = ClassOutlineVisitor;


/***/ }),

/***/ 4215:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LspClassOutlineVisitor = exports.LspTestOutlineVisitor = exports.LspOutlineVisitor = void 0;
const test_1 = __webpack_require__(8729);
class LspOutlineVisitor {
    constructor(logger) {
        this.logger = logger;
    }
    visit(outline) {
        this.visitNode(outline);
    }
    visitChildren(outline) {
        if (outline.children) {
            for (const child of outline.children) {
                this.visitNode(child);
            }
        }
    }
    visitNode(outline) {
        switch (outline && outline.element && outline.element.kind) {
            case "CLASS":
                this.visitClass(outline);
                break;
            case "CLASS_TYPE_ALIAS":
                this.visitClassTypeAlias(outline);
                break;
            case "COMPILATION_UNIT":
                this.visitCompilationUnit(outline);
                break;
            case "CONSTRUCTOR":
                this.visitConstructor(outline);
                break;
            case "CONSTRUCTOR_INVOCATION":
                this.visitContructorInvocation(outline);
                break;
            case "ENUM":
                this.visitEnum(outline);
                break;
            case "ENUM_CONSTANT":
                this.visitEnumConstant(outline);
                break;
            case "FIELD":
                this.visitField(outline);
                break;
            case "FILE":
                this.visitFile(outline);
                break;
            case "FUNCTION":
                this.visitFunction(outline);
                break;
            case "FUNCTION_INVOCATION":
                this.visitFunctionInvocation(outline);
                break;
            case "FUNCTION_TYPE_ALIAS":
                this.visitFunctionTypeAlias(outline);
                break;
            case "GETTER":
                this.visitGetter(outline);
                break;
            case "LABEL":
                this.visitLabel(outline);
                break;
            case "LIBRARY":
                this.visitLibrary(outline);
                break;
            case "LOCAL_VARIABLE":
                this.visitLocalVariable(outline);
                break;
            case "METHOD":
                this.visitMethod(outline);
                break;
            case "MIXIN":
                this.visitMixin(outline);
                break;
            case "PARAMETER":
                this.visitParameter(outline);
                break;
            case "PREFIX":
                this.visitPrefix(outline);
                break;
            case "SETTER":
                this.visitSetter(outline);
                break;
            case "TOP_LEVEL_VARIABLE":
                this.visitTopLevelVariable(outline);
                break;
            case "TYPE_PARAMETER":
                this.visitTypeParameter(outline);
                break;
            case "UNIT_TEST_GROUP":
                this.visitUnitTestGroup(outline);
                break;
            case "UNIT_TEST_TEST":
                this.visitUnitTestTest(outline);
                break;
            case "UNKNOWN":
                this.visitUnknown(outline);
                break;
            default:
                this.logger.error(`Unknown Outline item! ${outline && outline.element && outline.element.kind}`);
        }
    }
    visitClass(outline) { this.visitChildren(outline); }
    visitClassTypeAlias(outline) { this.visitChildren(outline); }
    visitCompilationUnit(outline) { this.visitChildren(outline); }
    visitConstructor(outline) { this.visitChildren(outline); }
    visitContructorInvocation(outline) { this.visitChildren(outline); }
    visitEnum(outline) { this.visitChildren(outline); }
    visitEnumConstant(outline) { this.visitChildren(outline); }
    visitField(outline) { this.visitChildren(outline); }
    visitFile(outline) { this.visitChildren(outline); }
    visitFunction(outline) { this.visitChildren(outline); }
    visitFunctionInvocation(outline) { this.visitChildren(outline); }
    visitFunctionTypeAlias(outline) { this.visitChildren(outline); }
    visitGetter(outline) { this.visitChildren(outline); }
    visitLabel(outline) { this.visitChildren(outline); }
    visitLibrary(outline) { this.visitChildren(outline); }
    visitLocalVariable(outline) { this.visitChildren(outline); }
    visitMethod(outline) { this.visitChildren(outline); }
    visitMixin(outline) { this.visitChildren(outline); }
    visitParameter(outline) { this.visitChildren(outline); }
    visitPrefix(outline) { this.visitChildren(outline); }
    visitSetter(outline) { this.visitChildren(outline); }
    visitTopLevelVariable(outline) { this.visitChildren(outline); }
    visitTypeParameter(outline) { this.visitChildren(outline); }
    visitUnitTestGroup(outline) { this.visitChildren(outline); }
    visitUnitTestTest(outline) { this.visitChildren(outline); }
    visitUnknown(outline) { this.visitChildren(outline); }
}
exports.LspOutlineVisitor = LspOutlineVisitor;
class LspTestOutlineVisitor extends LspOutlineVisitor {
    constructor(logger, file) {
        super(logger);
        this.file = file;
        this.tests = [];
        this.testsByLine = {};
        this.names = [];
    }
    visit(outline) {
        this.tests.length = 0;
        for (const line of Object.keys(this.testsByLine)) {
            delete this.testsByLine[parseInt(line)];
        }
        super.visit(outline);
    }
    visitUnitTestTest(outline) {
        this.addTest(outline, super.visitUnitTestTest);
    }
    visitUnitTestGroup(outline) {
        this.addTest(outline, super.visitUnitTestGroup);
    }
    addTest(outline, base) {
        const name = (0, test_1.extractTestNameFromOutline)(outline.element.name);
        if (!name || !outline.element.range)
            return;
        this.names.push(name);
        const fullName = this.names.join(" ");
        const isGroup = outline.element.kind === "UNIT_TEST_GROUP";
        const range = outline.codeRange || outline.range || (outline.element ? outline.element.range : undefined);
        const info = {
            file: this.file,
            fullName,
            isGroup,
            range,
        };
        this.tests.push(info);
        if (range) {
            if (!this.testsByLine[range.start.line])
                this.testsByLine[range.start.line] = [];
            this.testsByLine[range.start.line].push(info);
        }
        try {
            base.bind(this)(outline);
        }
        finally {
            this.names.pop();
        }
    }
}
exports.LspTestOutlineVisitor = LspTestOutlineVisitor;
class LspClassOutlineVisitor extends LspOutlineVisitor {
    constructor() {
        super(...arguments);
        this.classes = [];
    }
    visitClass(outline) {
        this.addClass(outline);
        super.visitClass(outline);
    }
    visitMixin(outline) {
        this.addClass(outline);
        super.visitMixin(outline);
    }
    addClass(outline) {
        if (!outline.element || !outline.element.range || !outline.element.name)
            return;
        this.classes.push({
            className: outline.element.name,
            codeRange: outline.codeRange,
            range: outline.range,
        });
    }
}
exports.LspClassOutlineVisitor = LspClassOutlineVisitor;


/***/ }),

/***/ 3953:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.writeSettingIntoProject = exports.writeFlutterSdkSettingIntoProject = exports.writeFlutterTriggerFile = exports.writeDartSdkSettingIntoProject = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
function writeDartSdkSettingIntoProject(dartSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.sdkPath": dartSdkPath });
}
exports.writeDartSdkSettingIntoProject = writeDartSdkSettingIntoProject;
function writeFlutterTriggerFile(folderPath, triggerData) {
    const jsonString = triggerData ? JSON.stringify(triggerData) : "";
    fs.writeFileSync(path.join(folderPath, constants_1.FLUTTER_CREATE_PROJECT_TRIGGER_FILE), jsonString);
}
exports.writeFlutterTriggerFile = writeFlutterTriggerFile;
function writeFlutterSdkSettingIntoProject(flutterSdkPath, projectFolder) {
    writeSettingIntoProject(projectFolder, { "dart.flutterSdkPath": flutterSdkPath });
}
exports.writeFlutterSdkSettingIntoProject = writeFlutterSdkSettingIntoProject;
function writeSettingIntoProject(projectFolder, settings) {
    const vsCodeFolder = path.join(projectFolder, ".vscode");
    const settingsFile = path.join(vsCodeFolder, "settings.json");
    if (!fs.existsSync(vsCodeFolder))
        fs.mkdirSync(vsCodeFolder);
    // The file should never exist, because the user has to select a new folder
    // to create projects. If it exists, something is wrong. We can't just load
    // the file, because VS Code settings file are not standard JSON (they can
    // have comments) so we don't want to try and deal with parsing them.
    if (fs.existsSync(settingsFile))
        return;
    fs.writeFileSync(settingsFile, JSON.stringify(settings, undefined, 4));
}
exports.writeSettingIntoProject = writeSettingIntoProject;


/***/ }),

/***/ 776:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.waitFor = exports.resolvedPromise = void 0;
exports.resolvedPromise = Promise.resolve(true);
function waitFor(action, checkEveryMilliseconds = 100, tryForMilliseconds = 10000, token) {
    return __awaiter(this, void 0, void 0, function* () {
        let timeRemaining = tryForMilliseconds;
        while (timeRemaining > 0 && !(token && token.isCancellationRequested)) {
            const res = yield action();
            if (res)
                return res;
            yield new Promise((resolve) => setTimeout(resolve, checkEveryMilliseconds));
            timeRemaining -= checkEveryMilliseconds;
        }
    });
}
exports.waitFor = waitFor;


/***/ }),

/***/ 8729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractTestNameFromOutline = exports.defaultDartTestFileContents = exports.defaultFlutterTestFileContents = exports.defaultTestFileContents = exports.createTestFileAction = exports.makeRegexForTests = exports.getLaunchConfig = void 0;
const path = __webpack_require__(1017);
const utils_1 = __webpack_require__(4586);
function getLaunchConfig(noDebug, path, testNames, runSkippedTests, template) {
    let toolArgs = [];
    if (template === null || template === void 0 ? void 0 : template.toolArgs)
        toolArgs = toolArgs.concat(template === null || template === void 0 ? void 0 : template.toolArgs);
    if (testNames) {
        toolArgs.push("--name");
        toolArgs.push(makeRegexForTests(testNames));
    }
    if (runSkippedTests)
        toolArgs.push("--run-skipped");
    return Object.assign({
        // Trailing space is a workaround for https://github.com/microsoft/vscode/issues/100115
        name: "Tests ",
        noDebug,
        request: "launch",
        type: "dart",
    }, template, {
        args: template === null || template === void 0 ? void 0 : template.args,
        expectSingleTest: (testNames === null || testNames === void 0 ? void 0 : testNames.length) === 1 && !testNames[0].name.includes("$") && !testNames[0].isGroup,
        program: path,
        toolArgs,
    });
}
exports.getLaunchConfig = getLaunchConfig;
const regexEscapedInterpolationExpressionPattern = /\\\$(?:(?:\w+)|(?:\\\{.*\\\}))/g;
function makeRegexForTests(names) {
    const regexSegments = [];
    for (const name of names) {
        const prefix = "^";
        // We can't anchor to the end for groups, as we want them to run all children.
        const suffix = name.isGroup ? "" : "( \\(variant: .*\\))?$";
        let escapedName = (0, utils_1.escapeRegExp)(name.name);
        // Replace any literal newlines with \n because literals can cause
        // issues in the shell.
        // https://github.com/Dart-Code/Dart-Code/issues/4007
        escapedName = escapedName
            .replace(/\n/g, "\\n")
            .replace(/\r/g, "\\r");
        // If a test name contains interpolated expressions, passing the exact
        // name won't match. So we just replace them out with wildcards. We'll need
        // to do this after escaping for regex, to ensure the original expression
        // is escaped but our wildcard is not.
        const substitutedName = escapedName.replace(regexEscapedInterpolationExpressionPattern, ".*");
        regexSegments.push(`${prefix}${substitutedName}${suffix}`);
    }
    return regexSegments.join("|");
}
exports.makeRegexForTests = makeRegexForTests;
const createTestFileAction = (file) => `Create ${path.basename(file)}`;
exports.createTestFileAction = createTestFileAction;
const defaultTestFileContents = (isFlutterProject, dartEscapedTestName) => isFlutterProject ? defaultFlutterTestFileContents(dartEscapedTestName) : defaultDartTestFileContents(dartEscapedTestName);
exports.defaultTestFileContents = defaultTestFileContents;
const defaultTestFileSelectionPlaceholder = "// TODO: Implement test";
function defaultFlutterTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:flutter_test/flutter_test.dart';

void main() {
  testWidgets('${dartEscapedTestName} ...', (tester) async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultFlutterTestFileContents = defaultFlutterTestFileContents;
function defaultDartTestFileContents(dartEscapedTestName) {
    const contents = `
import 'package:test/test.dart';

void main() {
  test('${dartEscapedTestName} ...', () async {
    ${defaultTestFileSelectionPlaceholder}
  });
}
`.trim();
    return {
        contents,
        selectionLength: defaultTestFileSelectionPlaceholder.length,
        selectionOffset: contents.indexOf(defaultTestFileSelectionPlaceholder),
    };
}
exports.defaultDartTestFileContents = defaultDartTestFileContents;
function extractTestNameFromOutline(elementName) {
    if (!elementName)
        return;
    // Strip off the function name/parent like test( or testWidget(
    const openParen = elementName.indexOf("(");
    const closeParen = elementName.lastIndexOf(")");
    if (openParen === -1 || closeParen === -1 || openParen >= closeParen)
        return;
    elementName = elementName.substring(openParen + 2, closeParen - 1);
    // For tests with variables, we often end up with additional quotes wrapped
    // around them...
    if ((elementName.startsWith("'") || elementName.startsWith('"')) && (elementName.endsWith("'") || elementName.endsWith('"')))
        elementName = elementName.substring(1, elementName.length - 1);
    return elementName;
}
exports.extractTestNameFromOutline = extractTestNameFromOutline;


/***/ }),

/***/ 2479:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tryProcessBazelFlutterConfig = exports.processBazelWorkspace = exports.processFuchsiaWorkspace = exports.processDartSdkRepository = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const constants_1 = __webpack_require__(5628);
function processDartSdkRepository(logger, config, dartSdkRoot) {
    config.disableAutomaticPackageGet = true;
    // The Dart SDKs tests cannot run using pub, so also force them to use the VM.
    config.useVmForTests = true;
}
exports.processDartSdkRepository = processDartSdkRepository;
function processFuchsiaWorkspace(logger, config, fuchsiaRoot) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
}
exports.processFuchsiaWorkspace = processFuchsiaWorkspace;
function processBazelWorkspace(logger, config, bazelWorkspaceRoot) {
    config.disableAutomaticPackageGet = true;
    config.disableSdkUpdateChecks = true;
    tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot);
}
exports.processBazelWorkspace = processBazelWorkspace;
function tryProcessBazelFlutterConfig(logger, config, bazelWorkspaceRoot) {
    // flutter.json does not support windows.
    if (constants_1.isWin)
        return;
    try {
        const flutterConfigPath = path.join(bazelWorkspaceRoot, "dart/config/ide/flutter.json");
        if (!fs.existsSync(flutterConfigPath))
            return;
        logger.info(`Loading Bazel Flutter config from ${flutterConfigPath}`);
        const flutterConfigJson = fs.readFileSync(flutterConfigPath, "utf8");
        const flutterConfig = JSON.parse(flutterConfigJson);
        function makeFullPath(relOrAbsolute) {
            if (!relOrAbsolute)
                return relOrAbsolute;
            if (path.isAbsolute(relOrAbsolute))
                return relOrAbsolute;
            return path.join(bazelWorkspaceRoot, relOrAbsolute);
        }
        function makeScript(relOrAbsolute, replacesArgs = 1) {
            if (relOrAbsolute) {
                return {
                    replacesArgs,
                    script: makeFullPath(relOrAbsolute),
                };
            }
        }
        config.forceFlutterWorkspace = true;
        config.forceFlutterDebug = true;
        config.skipFlutterInitialization = true;
        config.omitTargetFlag = true;
        config.startDevToolsServerEagerly = true;
        config.flutterVersion = constants_1.MAX_VERSION;
        config.flutterDevToolsScript = makeScript(flutterConfig.devToolsScript);
        config.flutterDaemonScript = makeScript(flutterConfig.daemonScript);
        config.flutterDoctorScript = makeScript(flutterConfig.doctorScript);
        config.flutterRunScript = makeScript(flutterConfig.runScript);
        config.flutterSdkHome = makeFullPath(flutterConfig.sdkHome);
        config.flutterTestScript = makeScript(flutterConfig.testScript);
        // TODO (helin24): This is a generic script that can be used with some of the Flutter commands, e.g. `debug_adapter`, `doctor`, and `daemon`.
        // We should eventually change over the other scripts to use this one to reduce the number of scripts needed.
        config.flutterToolsScript = makeScript(flutterConfig.toolsScript, 0);
        config.defaultDartSdk = makeFullPath(flutterConfig.defaultDartSdk);
        config.restartMacDaemonMessage = flutterConfig.restartMacDaemonMessage;
        config.localDeviceCommandAdviceMessage = flutterConfig.localDeviceCommandAdviceMessage;
        config.localMacWarningMessage = flutterConfig.localMacWarningMessage;
    }
    catch (e) {
        logger.error(e);
    }
}
exports.tryProcessBazelFlutterConfig = tryProcessBazelFlutterConfig;


/***/ }),

/***/ 1197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorRangeComputer = void 0;
const colors_1 = __webpack_require__(2241);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
class ColorRangeComputer {
    constructor() {
        this.materialNameColorPattern = "\\bColors\\.(?<mc>[\\w_\\[\\]\\.]+)";
        this.cupertinoNameColorPattern = "\\bCupertinoColors\\.(?<cc>[\\w_\\[\\]\\.]+)";
        this.cssNameColorPattern = "\\bCSSColors\\.(?<css>[\\w]+)";
        this.colorConstructorPattern = "\\bColor\\(\\s*0[xX](?<cons>[A-Fa-f0-9]{8}),{0,1}\\s*\\)";
        this.colorConstructorRgbo = "\\bColor\\.fromRGBO\\(\\s*(?<rgboR>[\\w_]+),\\s*(?<rgboG>[\\w_]+),\\s*(?<rgboB>[\\w_]+),\\s*(?<rgboO>[\\w_.]+),{0,1}\\s*\\)";
        this.colorConstructorArgb = "\\bColor\\.fromARGB\\(\\s*(?<argbA>[\\w_]+),\\s*(?<argbR>[\\w_]+),\\s*(?<argbG>[\\w_]+),\\s*(?<argbB>[\\w_]+),{0,1}\\s*\\)";
        this.allColors = [
            this.materialNameColorPattern,
            this.cupertinoNameColorPattern,
            this.cssNameColorPattern,
            this.colorConstructorPattern,
            this.colorConstructorRgbo,
            this.colorConstructorArgb,
        ];
        this.allColorsPattern = new RegExp(`^.*?(?<range>${this.allColors.join("|")})`, "gm");
    }
    compute(document) {
        const text = document.getText();
        // Build a map of all possible decorations, with those in this file. We need to include all
        // colors so if any were removed, we will clear their decorations.
        const decs = {};
        let result;
        this.allColorsPattern.lastIndex = -1;
        // eslint-disable-next-line no-cond-assign
        while (result = this.allColorsPattern.exec(text)) {
            if (!result.groups)
                continue;
            let colorHex;
            if (result.groups.mc)
                colorHex = this.extractMaterialColor(result.groups.mc);
            else if (result.groups.cc)
                colorHex = this.extractCupertinoColor(result.groups.cc);
            else if (result.groups.css)
                colorHex = this.extractCSSColor(result.groups.css);
            else if (result.groups.cons)
                colorHex = result.groups.cons.toLowerCase();
            else if (result.groups.rgboR && result.groups.rgboG && result.groups.rgboB && result.groups.rgboO)
                colorHex = this.extractRgboColor(result.groups.rgboR, result.groups.rgboG, result.groups.rgboB, result.groups.rgboO);
            else if (result.groups.argbA && result.groups.argbR && result.groups.argbG && result.groups.argbB)
                colorHex = this.extractArgbColor(result.groups.argbA, result.groups.argbR, result.groups.argbG, result.groups.argbB);
            if (colorHex) {
                if (!decs[colorHex])
                    decs[colorHex] = [];
                // We can't get the index of the captures yet (https://github.com/tc39/proposal-regexp-match-indices) but we do know
                // - the length of the whole match
                // - the length of the main capture
                // - that the main capture ends at the same point as the whole match
                // Therefore the index we want, is the (match index + match length - capture length).
                const index = result.index + result[0].length - result.groups.range.length;
                decs[colorHex].push((0, utils_2.toRange)(document, index, result.groups.range.length));
            }
        }
        return decs;
    }
    extractMaterialColor(input) {
        const colorName = input.replace(/\.shade(\d+)/, "[$1]");
        if (!(colorName in colors_1.flutterMaterialColors || `${colorName}.primary` in colors_1.flutterMaterialColors))
            return;
        return (colors_1.flutterMaterialColors[colorName] || colors_1.flutterMaterialColors[`${colorName}.primary`]).toLowerCase();
    }
    extractCupertinoColor(input) {
        const colorName = input.replace(/\.color/, "[$1]");
        if (!(colorName in colors_1.flutterCupertinoColors || `${colorName}.color` in colors_1.flutterCupertinoColors))
            return;
        return (colors_1.flutterCupertinoColors[colorName] || colors_1.flutterCupertinoColors[`${colorName}.color`]).toLowerCase();
    }
    extractCSSColor(input) {
        if (!(input in colors_1.flutterCSSColors))
            return;
        return (colors_1.flutterCSSColors[input]).toLowerCase();
    }
    extractRgboColor(inputR, inputG, inputB, inputO) {
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        const opacity = parseFloat(inputO);
        if (isNaN(r) || isNaN(g) || isNaN(b) || isNaN(opacity))
            return;
        return (0, utils_1.asHexColor)({ r, g, b, a: opacity * 255 });
    }
    extractArgbColor(inputA, inputR, inputG, inputB) {
        const a = parseInt(inputA);
        const r = parseInt(inputR);
        const g = parseInt(inputG);
        const b = parseInt(inputB);
        if (isNaN(a) || isNaN(r) || isNaN(g) || isNaN(b))
            return;
        return (0, utils_1.asHexColor)({ a, r, g, b });
    }
}
exports.ColorRangeComputer = ColorRangeComputer;


/***/ }),

/***/ 6249:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTML_MODE = exports.ANALYSIS_FILTERS = exports.ANALYSIS_OPTIONS_FILTER = exports.PUBSPEC_FILTER = exports.DART_MODE = void 0;
exports.DART_MODE = { language: "dart", scheme: "file" };
exports.PUBSPEC_FILTER = { pattern: "**/pubspec.yaml", scheme: "file" };
exports.ANALYSIS_OPTIONS_FILTER = { pattern: "**/analysis_options.yaml", scheme: "file" };
exports.ANALYSIS_FILTERS = [
    exports.DART_MODE,
    exports.PUBSPEC_FILTER,
    exports.ANALYSIS_OPTIONS_FILTER,
];
exports.HTML_MODE = { language: "html", scheme: "file" };


/***/ }),

/***/ 2074:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isTemplateOfType = exports.getTemplatedLaunchConfigs = exports.getLaunchConfigDefaultTemplate = void 0;
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const fs_1 = __webpack_require__(300);
const debugTypeTokenRegex = new RegExp((0, utils_1.escapeRegExp)("${debugType}"), "gi");
/// Allows overriding the launch config used by Code Lens "Run"/"Debug" and runs through test runner.
///
/// Tries to get the most specific config first (eg. using an explicit `noDebug` flag) and otherwise falls back to
/// a generic (no `noDebug` specified) one, injecting the value of `debug` inverted as `noDebug`.
function getLaunchConfigDefaultTemplate(documentUri, debug) {
    var _a, _b;
    const runConfigs = vscode_1.workspace.getConfiguration("launch", documentUri).get("configurations") || [];
    const filePath = (0, fs_1.fsPath)(documentUri);
    const workspaceUri = (_a = vscode_1.workspace.getWorkspaceFolder(documentUri)) === null || _a === void 0 ? void 0 : _a.uri;
    const workspacePath = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
    const validConfigs = runConfigs.filter((c) => c.type === "dart"
        && c.templateFor !== undefined && c.templateFor !== null
        && workspacePath ? (0, fs_1.isWithinPathOrEqual)(filePath, path.join(workspacePath, c.templateFor)) : false);
    const requiredNoDebugValue = !debug;
    const bestConfig = 
    // Try specific config first.
    (_b = validConfigs.find((c) => c.noDebug === requiredNoDebugValue)) !== null && _b !== void 0 ? _b : validConfigs.find((c) => c.noDebug === undefined);
    return bestConfig ? Object.assign(Object.assign({}, bestConfig), { noDebug: requiredNoDebugValue }) : undefined;
}
exports.getLaunchConfigDefaultTemplate = getLaunchConfigDefaultTemplate;
function getTemplatedLaunchConfigs(documentUri, fileType) {
    var _a, _b;
    const runConfigs = vscode_1.workspace.getConfiguration("launch", documentUri).get("configurations") || [];
    const wantedTemplateTypes = [`run-${fileType}`, `debug-${fileType}`];
    const filePath = (0, fs_1.fsPath)(documentUri);
    const workspaceUri = (_a = vscode_1.workspace.getWorkspaceFolder(documentUri)) === null || _a === void 0 ? void 0 : _a.uri;
    const workspacePath = workspaceUri ? (0, fs_1.fsPath)(workspaceUri) : undefined;
    // Loop through each launch config and add the relevant templates. Configs may be
    // added multiple times if they have multiple template types.
    const runFileTemplates = [];
    for (const templateType of wantedTemplateTypes) {
        const relevantLaunchConfigs = runConfigs
            .filter((c) => c.type === "dart" && isTemplateOfType(c, templateType))
            .filter((c) => { var _a, _b, _c; return ((_a = c.codeLens) === null || _a === void 0 ? void 0 : _a.path) && workspacePath ? (0, fs_1.isWithinPathOrEqual)(filePath, path.join(workspacePath, (_b = c.codeLens) === null || _b === void 0 ? void 0 : _b.path)) : !((_c = c.codeLens) === null || _c === void 0 ? void 0 : _c.path); });
        for (const launchConfig of relevantLaunchConfigs) {
            runFileTemplates.push(Object.assign(Object.assign({}, launchConfig), { name: (((_b = launchConfig.codeLens) === null || _b === void 0 ? void 0 : _b.title) || launchConfig.name || "${debugType}").replace(debugTypeTokenRegex, templateType.startsWith("run-") ? "Run" : "Debug"), noDebug: templateType.startsWith("run-") }));
        }
    }
    // If we didn't find any, try the defaults.
    if (!runFileTemplates.length) {
        const defaultRunTemplate = getLaunchConfigDefaultTemplate(documentUri, false);
        const defaultDebugTemplate = getLaunchConfigDefaultTemplate(documentUri, true);
        if (defaultRunTemplate)
            runFileTemplates.push(Object.assign(Object.assign({}, defaultRunTemplate), { name: "Run" }));
        if (defaultDebugTemplate)
            runFileTemplates.push(Object.assign(Object.assign({}, defaultDebugTemplate), { name: "Debug" }));
    }
    return runFileTemplates;
}
exports.getTemplatedLaunchConfigs = getTemplatedLaunchConfigs;
function isTemplateOfType(config, templateType) {
    var _a;
    const template = (_a = config.codeLens) === null || _a === void 0 ? void 0 : _a.for;
    return !!template && ((typeof template === "string" && template === templateType)
        || (Array.isArray(template) && template.indexOf(templateType) !== -1));
}
exports.isTemplateOfType = isTemplateOfType;


/***/ }),

/***/ 6711:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterDeviceManager = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
const utils_2 = __webpack_require__(7220);
const constants_1 = __webpack_require__(5628);
const enums_1 = __webpack_require__(7341);
const logging_1 = __webpack_require__(8323);
const processes_1 = __webpack_require__(5837);
const array_1 = __webpack_require__(7434);
const fs_1 = __webpack_require__(300);
const utils_3 = __webpack_require__(7220);
class FlutterDeviceManager {
    constructor(logger, daemon, config, workspaceContext, runIfNoDevices, daemonPortOverride) {
        this.logger = logger;
        this.daemon = daemon;
        this.config = config;
        this.workspaceContext = workspaceContext;
        this.daemonPortOverride = daemonPortOverride;
        this.subscriptions = [];
        this.devices = [];
        this.emulators = [];
        this.knownEmulatorNames = {};
        this.statusBarItem = vs.window.createStatusBarItem("dartStatusFlutterDevice", vs.StatusBarAlignment.Right, 1);
        this.statusBarItem.name = "Flutter Device";
        this.statusBarItem.tooltip = "Flutter";
        this.statusBarItem.command = "flutter.selectDevice";
        this.statusBarItem.show();
        this.updateStatusBar();
        // Force a request for emulators to stash their names, so we can display
        // the better name if the automatically-selected device happens to be an
        // emulator.
        this.getEmulators().then(() => this.updateStatusBar()).catch((e) => console.error(e));
        this.subscriptions.push(this.statusBarItem);
        daemon.registerForDeviceAdded(this.deviceAdded.bind(this));
        daemon.registerForDeviceRemoved(this.deviceRemoved.bind(this));
        if (runIfNoDevices) {
            setTimeout(() => {
                if (this.devices.length === 0) {
                    runIfNoDevices();
                }
            }, 10000);
        }
    }
    dispose() {
        (0, utils_1.disposeAll)(this.subscriptions);
    }
    isSupported(types, device) {
        // types being `undefined` means we shouldn't filter, but being empty means we legit
        // don't support any types.
        return device && (!types || !types || !device.platformType || types.indexOf(device.platformType) !== -1);
    }
    deviceAdded(dev) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            dev = Object.assign(Object.assign({}, dev), { type: "device" });
            this.devices.push(dev);
            // undefined is treated as true for backwards compatibility.
            let canAutoSelectDevice = dev.ephemeral !== false;
            // In a remote workspace, allow selecting web-server over a non-ephemeral device so
            // that we don't seem to default to Linux on a remote we probably can't see.
            if (!utils_3.isRunningLocally && ((_a = this.currentDevice) === null || _a === void 0 ? void 0 : _a.ephemeral) === false && dev.id === "web-server")
                canAutoSelectDevice = true;
            const maySelectThisDevice = () => {
                var _a;
                return !this.currentDevice
                    || (this.config.flutterSelectDeviceWhenConnected && canAutoSelectDevice)
                    // HACK: If the Chrome device becomes available and the selected device is
                    // web-server, allow switching because most users would prefer the Chrome device.
                    // We can revert this in future if Flutter changes the order these devices show up
                    // or has some other way of deciding priority.
                    || (((_a = this.currentDevice) === null || _a === void 0 ? void 0 : _a.id) === "web-server" && dev.id === "chrome");
            };
            if (maySelectThisDevice()) {
                // Finally, check if it's valid for the workspace. We don't want to
                // auto-select to a mobile if you have a web-only project open.
                const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                // We need to re-check maySelectThisDevice() as the answer may have changed if
                // another device was selected while we were awaiting (which would prevent us
                // selecting a non-ephemeral device here).
                if (maySelectThisDevice() && this.isSupported(supportedPlatforms, dev)) {
                    this.currentDevice = dev;
                    this.updateStatusBar();
                }
            }
        });
    }
    deviceRemoved(dev) {
        return __awaiter(this, void 0, void 0, function* () {
            this.devices = this.devices.filter((d) => d.id !== dev.id);
            if (this.currentDevice && this.currentDevice.id === dev.id) {
                this.currentDevice = undefined;
                // Try to select the next-best device
                if (this.devices.length) {
                    const supportedPlatforms = yield this.getSupportedPlatformsForWorkspace();
                    const supportedDevices = this.devices.filter((d) => this.isSupported(supportedPlatforms, d));
                    if (supportedDevices && supportedDevices.length)
                        this.currentDevice = supportedDevices[0];
                }
                this.updateStatusBar();
            }
        });
    }
    showDevicePicker(supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            // If we weren't passed any supported types, we should try to get them for
            // the whole workspace.
            if (!supportedTypes && this.daemon.capabilities.providesPlatformTypes) {
                supportedTypes = yield this.getSupportedPlatformsForWorkspace();
            }
            const quickPick = vs.window.createQuickPick();
            quickPick.placeholder = "Select a device to use";
            quickPick.busy = true;
            quickPick.ignoreFocusOut = true;
            let quickPickIsValid = true;
            let emulatorDevices;
            const updatePickableDeviceList = () => {
                if (!quickPickIsValid)
                    return;
                quickPick.items = this.getPickableDevices(supportedTypes, emulatorDevices);
            };
            // Kick off a request to get emulators only once.
            this.getPickableEmulators(true, supportedTypes)
                .then((emulators) => emulatorDevices = emulators)
                .finally(() => quickPick.busy = false)
                .finally(() => updatePickableDeviceList())
                .catch((e) => console.error(e));
            // If new devices are attached while the list is open, add them to the end.
            const deviceAddedSubscription = this.daemon.registerForDeviceAdded((d) => updatePickableDeviceList());
            const deviceRemovedSubscription = this.daemon.registerForDeviceRemoved((d) => updatePickableDeviceList());
            // Build the initial list.
            updatePickableDeviceList();
            const selection = yield new Promise((resolve) => {
                quickPick.onDidAccept(() => resolve(quickPick.selectedItems && quickPick.selectedItems[0] /* Seperators can't be selected */));
                quickPick.onDidHide(() => resolve(undefined));
                quickPick.show();
            });
            quickPickIsValid = false;
            quickPick.dispose();
            deviceAddedSubscription.dispose();
            deviceRemovedSubscription.dispose();
            if (selection && (yield this.selectDevice(selection)))
                return this.currentDevice;
            return undefined;
        });
    }
    selectDevice(selection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const emulatorTypeLabel = this.emulatorLabel(selection.device.platformType);
            switch (selection.device.type) {
                case "emulator-creator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Creating ${emulatorTypeLabel}...`;
                    yield this.createEmulator();
                    this.updateStatusBar();
                    break;
                case "emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    const coldBoot = (_a = selection.coldBoot) !== null && _a !== void 0 ? _a : false;
                    yield this.launchEmulator(selection.device, coldBoot);
                    this.updateStatusBar();
                    break;
                case "custom-emulator":
                    // Clear the current device so we can wait for the new one
                    // to connect.
                    this.currentDevice = undefined;
                    this.statusBarItem.text = `Launching ${emulatorTypeLabel}...`;
                    yield this.launchCustomEmulator(selection.device);
                    this.updateStatusBar();
                    break;
                case "platform-enabler":
                    const platformType = selection.device.platformType;
                    const platformNeedsGloballyEnabling = yield this.daemon.checkIfPlatformGloballyDisabled(platformType);
                    const action = yield vs.window.showInformationMessage((0, constants_1.runFlutterCreatePrompt)(platformType, platformNeedsGloballyEnabling), constants_1.yesAction, constants_1.cancelAction);
                    if (action !== constants_1.yesAction)
                        return false;
                    if (platformNeedsGloballyEnabling)
                        yield this.daemon.enablePlatformGlobally(platformType);
                    const createArgs = { platform: selection.device.platformType };
                    yield vs.commands.executeCommand("_flutter.create", createArgs);
                    if (platformNeedsGloballyEnabling) {
                        const restartAction = "Reload";
                        const chosenAction = yield vs.window.showInformationMessage("You must reload after enabling a new platform", restartAction, constants_1.skipAction);
                        if (chosenAction === restartAction)
                            vs.commands.executeCommand("_dart.reloadExtension");
                    }
                    break;
                case "device":
                    this.currentDevice = selection.device;
                    this.updateStatusBar();
                    break;
            }
            return true;
        });
    }
    getDevice(id) {
        return this.devices.find((d) => d.id === id);
    }
    getValidDevicesForProject(projectFolder) {
        return __awaiter(this, void 0, void 0, function* () {
            const sortedDevices = this.devices.sort(this.deviceSortComparer.bind(this));
            const supportedPlatforms = this.daemon.capabilities.providesPlatformTypes
                ? (yield this.daemon.getSupportedPlatforms(projectFolder)).platforms
                : undefined;
            return sortedDevices.filter((d) => this.isSupported(supportedPlatforms, d));
        });
    }
    getPickableDevices(supportedTypes, emulatorDevices) {
        const sortedDevices = this.devices.sort(this.deviceSortComparer.bind(this));
        let pickableItems = [];
        const supportedDevices = sortedDevices.filter((d) => this.isSupported(supportedTypes, d));
        if (supportedDevices.length) {
            pickableItems = pickableItems.concat([
                {
                    kind: vs.QuickPickItemKind.Separator,
                    label: "Available Devices",
                },
                ...supportedDevices.map((d) => ({
                    description: d.category || d.platform,
                    device: d,
                    label: this.labelForDevice(d, { withIcon: true }),
                })),
            ]);
        }
        // If we've got emulators, add them to the list.
        if (emulatorDevices && emulatorDevices.length) {
            // Fliter out any emulators we know are running.
            const emulatorIdsAlreadyRunning = this.devices.map((d) => d.emulatorId).filter((id) => id);
            const emulatorDevicesNotRunning = emulatorDevices.filter((e) => emulatorIdsAlreadyRunning.indexOf(e.device.id) === -1);
            if (emulatorDevicesNotRunning.length) {
                pickableItems = pickableItems.concat([
                    {
                        kind: vs.QuickPickItemKind.Separator,
                        label: "Offline Emulators",
                    },
                    ...emulatorDevicesNotRunning,
                ]);
            }
        }
        // Add any unsupported platforms that we have devices/emulators for (eg. things that could be
        // enabled) to the bottom.
        const potentialPlatformTypes = (0, utils_1.uniq)([
            ...sortedDevices.map((d) => d),
            ...this.emulators.map((e) => e),
        ]
            .filter((d) => !this.isSupported(supportedTypes, d))
            .map((d) => d.platformType)
            .filter(utils_1.notNullOrUndefined));
        if (potentialPlatformTypes.length) {
            pickableItems = pickableItems.concat([
                {
                    kind: vs.QuickPickItemKind.Separator,
                    label: "Other Available Platforms",
                },
                ...potentialPlatformTypes.map((p) => ({
                    device: { type: "platform-enabler", platformType: p },
                    label: `Enable ${p} for this project`,
                })),
            ]);
        }
        return pickableItems;
    }
    getSupportedPlatformsForWorkspace() {
        return __awaiter(this, void 0, void 0, function* () {
            // To avoid triggering this lots of times at startup when lots of devices "connect" at
            // the same time, we cache the results for 10 seconds. Every time we set the cache, we
            // set a timer to expire it in 10 seconds.
            if (this.shortCacheForSupportedPlatforms) {
                this.logger.info(`Returning cached promise for getSupportedPlatforms()`);
                return this.shortCacheForSupportedPlatforms;
            }
            this.shortCacheForSupportedPlatforms = new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                // An internal workspace that we assume to be Flutter will not generate project folders, but the daemon will respond to an empty path.
                const projectFolders = this.workspaceContext.config.forceFlutterWorkspace ? [""] : yield (0, utils_2.getAllProjectFolders)(this.logger, undefined, { requirePubspec: true, searchDepth: this.config.projectSearchDepth });
                this.logger.info(`Checking ${projectFolders.length} projects for supported platforms`);
                const getPlatformPromises = projectFolders.map((folder) => this.daemon.getSupportedPlatforms(folder));
                const resps = yield Promise.all(getPlatformPromises).catch((e) => {
                    this.logger.error(e);
                    return [];
                });
                const supportedTypes = (0, array_1.unique)((0, utils_1.flatMap)(resps, (r) => r.platforms));
                this.logger.info(`Supported platforms for the workspace are ${supportedTypes.join(", ")}`);
                resolve(supportedTypes);
                setTimeout(() => this.shortCacheForSupportedPlatforms = undefined, 10000);
            }));
            return this.shortCacheForSupportedPlatforms;
        });
    }
    labelForDevice(device, { withIcon = false } = {}) {
        let icon;
        switch (device.category) {
            case "mobile":
                icon = "$(device-mobile) ";
                break;
            case "web":
                icon = "$(browser) ";
                break;
            case "desktop":
                icon = "$(device-desktop) ";
        }
        const name = device.emulatorId && this.knownEmulatorNames[device.emulatorId] && device.platformType === "android"
            ? this.knownEmulatorNames[device.emulatorId]
            : device.name;
        return withIcon ? `${icon !== null && icon !== void 0 ? icon : ""}${name}` : name;
    }
    deviceSortComparer(d1, d2) {
        // Always consider current device to be first.
        if (d1 === this.currentDevice)
            return -1;
        if (d2 === this.currentDevice)
            return 1;
        // Otherwise, sort by name.
        return d1.name.localeCompare(d2.name);
    }
    updateStatusBar() {
        if (this.currentDevice) {
            const emulatorLabel = this.currentDevice.emulator ? this.emulatorLabel(this.currentDevice.platformType) : "";
            const platformLabel = `${this.currentDevice.platform} ${emulatorLabel}`.trim();
            this.statusBarItem.text = `${this.labelForDevice(this.currentDevice)} (${platformLabel})`.trim();
        }
        else {
            this.statusBarItem.text = "No Device";
        }
        if (this.devices.length > 1) {
            this.statusBarItem.tooltip = `${this.devices.length} Devices Connected`;
        }
        else if (this.devices.length === 1) {
            this.statusBarItem.tooltip = `1 Device Connected`;
        }
        else {
            this.statusBarItem.tooltip = undefined;
        }
    }
    getEmulators() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const emus = yield this.daemon.getEmulators();
                const allEmulatorsByID = {};
                for (const e of emus) {
                    allEmulatorsByID[e.id] = {
                        category: e.category,
                        id: e.id,
                        name: e.name || e.id,
                        platformType: e.platformType,
                        type: "emulator",
                    };
                }
                // Add/update any custom emulators.
                for (const e of this.config.flutterCustomEmulators) {
                    const existing = allEmulatorsByID[e.id];
                    allEmulatorsByID[e.id] = Object.assign(Object.assign(Object.assign({ category: "custom" }, existing), e), { type: "custom-emulator" });
                }
                const emulators = Object.values(allEmulatorsByID);
                this.emulators = emulators;
                // Whenever we see emulators, record all their names.
                for (const e of emulators)
                    this.knownEmulatorNames[e.id] = e.name;
                return emulators;
            }
            catch (e) {
                this.logger.error({ message: e });
                return [];
            }
        });
    }
    promptForAndLaunchEmulator(allowAutomaticSelection = false) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const emulators = yield this.getPickableEmulators(false);
            // Because the above call is async, it's possible a device was connected while we were calling. If so,
            // just use that instead of showing the prompt.
            if (allowAutomaticSelection && this.currentDevice)
                return true;
            if (emulators.length === 0) {
                return false;
            }
            const cancellationTokenSource = new vs.CancellationTokenSource();
            const waitingForRealDeviceSubscription = this.daemon.registerForDeviceAdded(() => {
                cancellationTokenSource.cancel();
                waitingForRealDeviceSubscription.dispose();
            });
            const selectedEmulator = yield vs.window.showQuickPick(emulators, {
                matchOnDescription: true,
                placeHolder: "Connect a device or select an emulator to launch",
            }, cancellationTokenSource.token);
            waitingForRealDeviceSubscription.dispose();
            if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator-creator") {
                return this.createEmulator();
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "emulator") {
                const coldBoot = (_a = selectedEmulator.coldBoot) !== null && _a !== void 0 ? _a : false;
                return this.launchEmulator(selectedEmulator.device, coldBoot);
            }
            else if (selectedEmulator && selectedEmulator.device && selectedEmulator.device.type === "custom-emulator") {
                return this.launchCustomEmulator(selectedEmulator.device);
            }
            else {
                return !!(this.currentDevice);
            }
        });
    }
    createEmulator() {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Allow user to create names when we let them customise the emulator type.
            // const name = await vs.window.showInputBox({
            // 	prompt: "Enter a name for your new Android Emulator",
            // 	validateInput: this.validateEmulatorName,
            // });
            // if (!name) bail() // Pressing ENTER doesn't work, but escape does, so if
            // no name, user probably wanted to cancel
            const name = undefined;
            const create = this.daemon.createEmulator(name);
            vs.window.withProgress({
                location: vs.ProgressLocation.Notification,
                title: `${`Creating emulator ${name ? name : ""}`.trim()}...`,
            }, () => create);
            const res = yield create;
            if (res.success) {
                return this.launchEmulator({
                    id: res.emulatorName,
                    name: res.emulatorName,
                }, false);
            }
            else {
                vs.window.showErrorMessage(res.error);
                return false;
            }
        });
    }
    emulatorLabel(platformType) {
        return platformType && (platformType === "ios" || platformType === "macos")
            ? "simulator"
            : "emulator";
    }
    getPickableEmulators(showAsEmulators, supportedTypes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.config.flutterShowEmulators === "never")
                return [];
            if (this.config.flutterShowEmulators === "local" && !utils_3.isRunningLocally)
                return [];
            const pickableEmulators = [];
            const supportedEmulators = (yield this.getEmulators()).filter((e) => this.isSupported(supportedTypes, e));
            for (const e of supportedEmulators) {
                const pickableEmulator = {
                    alwaysShow: false,
                    coldBoot: false,
                    description: showAsEmulators ? `${e.category || "mobile"} ${this.emulatorLabel(e.platformType)}` : e.platformType || undefined,
                    device: e,
                    label: showAsEmulators ? "$(play) " + `Start ${e.name}` : e.name,
                };
                pickableEmulators.push(pickableEmulator);
                // Add a cold boot option for each android based emulator
                if (pickableEmulator.device.platformType && pickableEmulator.device.platformType === "android" && this.daemon.capabilities.supportsAvdColdBootLaunch) {
                    pickableEmulators.push({
                        alwaysShow: pickableEmulator.alwaysShow,
                        coldBoot: true,
                        description: `${pickableEmulator.description} (cold boot)`,
                        device: pickableEmulator.device,
                        label: pickableEmulator.label,
                    });
                }
            }
            // Add an option to create a new emulator if the daemon supports it.
            if (this.daemon.capabilities.canCreateEmulators && this.isSupported(supportedTypes, { platformType: "android" })) {
                pickableEmulators.push({
                    alwaysShow: true,
                    device: { type: "emulator-creator", platformType: "android", name: "Create Android emulator" },
                    label: "$(plus) " + "Create Android emulator",
                });
            }
            return pickableEmulators;
        });
    }
    launchEmulator(emulator, coldBoot) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    progress.report({ message: `Launching ${emulator.name}...` });
                    yield this.daemon.launchEmulator(emulator.id, coldBoot);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
    launchCustomEmulator(emulator) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield vs.window.withProgress({
                    location: vs.ProgressLocation.Notification,
                }, (progress) => __awaiter(this, void 0, void 0, function* () {
                    progress.report({ message: `Launching ${emulator.name}...` });
                    const binPath = (0, fs_1.resolveTildePaths)(emulator.executable);
                    const args = emulator.args || [];
                    const env = emulator.env;
                    const customEmulatorProc = (0, processes_1.safeSpawn)(undefined, binPath, args, env);
                    this.logger.info(`(PROC ${customEmulatorProc.pid}) Spawned ${binPath} ${args.join(" ")}`, enums_1.LogCategory.CommandProcesses);
                    (0, logging_1.logProcess)(this.logger, enums_1.LogCategory.CommandProcesses, customEmulatorProc);
                    progress.report({ message: `Waiting for ${emulator.name} to connect...` });
                    // Wait up to 60 seconds for emulator to launch.
                    for (let i = 0; i < 120; i++) {
                        yield new Promise((resolve) => setTimeout(resolve, 500));
                        if (this.currentDevice)
                            return;
                        if (customEmulatorProc.exitCode !== null && customEmulatorProc.exitCode !== 0) {
                            throw Error(`Exit code ${customEmulatorProc.exitCode}`);
                        }
                    }
                    throw new Error("Emulator didn't connect within 60 seconds");
                }));
            }
            catch (e) {
                vs.window.showErrorMessage(`Failed to launch ${emulator.name}: ${e}`);
                return false;
            }
            // Wait an additional second to try and void some possible races.
            yield new Promise((resolve) => setTimeout(resolve, 1000));
            return true;
        });
    }
}
exports.FlutterDeviceManager = FlutterDeviceManager;


/***/ }),

/***/ 6143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMarkdownString = exports.cleanDartdoc = exports.checkHasFlutterExtension = exports.readJson = exports.docsIconPathFormat = exports.hasFlutterExtension = exports.isDevExtension = exports.isPreReleaseExtension = exports.vsCodeVersionConstraint = exports.extensionVersion = exports.extensionPath = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const dartdoc = __webpack_require__(9439);
exports.extensionPath = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier).extensionPath;
exports.extensionVersion = getExtensionVersion();
exports.vsCodeVersionConstraint = getVsCodeVersionConstraint();
exports.isPreReleaseExtension = checkIsPreReleaseExtension();
exports.isDevExtension = checkIsDevExtension();
exports.hasFlutterExtension = checkHasFlutterExtension();
exports.docsIconPathFormat = vscode_1.Uri.file(path.join(exports.extensionPath, "media/doc-icons/")).toString() + "$1%402x.png";
function readJson(file) {
    return JSON.parse(fs.readFileSync(file).toString());
}
exports.readJson = readJson;
function getExtensionVersion() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.version;
}
function getVsCodeVersionConstraint() {
    const packageJson = readJson(path.join(exports.extensionPath, "package.json"));
    return packageJson.engines.vscode;
}
function checkIsDevExtension() {
    return exports.extensionVersion.endsWith("-dev");
}
function checkIsPreReleaseExtension() {
    const segments = exports.extensionVersion.split(".");
    const minSegment = parseInt(segments[1]);
    return minSegment % 2 === 1;
}
function checkHasFlutterExtension() {
    return vscode_1.extensions.getExtension(constants_1.flutterExtensionIdentifier) !== undefined;
}
exports.checkHasFlutterExtension = checkHasFlutterExtension;
function cleanDartdoc(doc) {
    return dartdoc.cleanDartdoc(doc, exports.docsIconPathFormat);
}
exports.cleanDartdoc = cleanDartdoc;
function createMarkdownString(doc) {
    const md = new vscode_1.MarkdownString(doc);
    md.supportHtml = true;
    return md;
}
exports.createMarkdownString = createMarkdownString;


/***/ }),

/***/ 3150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createFlutterSampleInTempFolder = void 0;
const os = __webpack_require__(2037);
const path = __webpack_require__(1017);
const vs = __webpack_require__(9496);
const constants_1 = __webpack_require__(5628);
const fs_1 = __webpack_require__(300);
const projects_1 = __webpack_require__(3953);
function createFlutterSampleInTempFolder(flutterCapabilities, sampleID, flutterSdkOverride) {
    // Ensure we're on at least Flutter v1 so we know creating samples works.
    if (!flutterCapabilities.supportsCreatingSamples) {
        vs.window.showErrorMessage("Opening sample projects requires Flutter v1.0 or later");
        return;
    }
    // Create a temp folder for the sample.
    const tempSamplePath = path.join(os.tmpdir(), constants_1.dartCodeExtensionIdentifier, "flutter", "sample", sampleID, (0, fs_1.getRandomInt)(0x1000, 0x10000).toString(16));
    // Create the empty folder so we can open it.
    (0, fs_1.mkDirRecursive)(tempSamplePath);
    const triggerData = { sample: sampleID };
    (0, projects_1.writeFlutterTriggerFile)(tempSamplePath, triggerData);
    // If we're using a custom SDK, we need to apply it to the new project too.
    if (flutterSdkOverride)
        (0, projects_1.writeFlutterSdkSettingIntoProject)(flutterSdkOverride, tempSamplePath);
    const folderUri = vs.Uri.file(tempSamplePath);
    vs.commands.executeCommand("vscode.openFolder", folderUri);
    return folderUri;
}
exports.createFlutterSampleInTempFolder = createFlutterSampleInTempFolder;


/***/ }),

/***/ 7731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IconRangeComputerLsp = exports.IconRangeComputer = void 0;
const flutter_outline_1 = __webpack_require__(359);
const utils_1 = __webpack_require__(7220);
class IconRangeComputer {
    constructor(logger) {
        this.logger = logger;
    }
    compute(document, outline) {
        const iconVisitor = new FlutterOutlineIconVisitor(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.toRange)(document, icon.offset, icon.length));
        });
        return decs;
    }
}
exports.IconRangeComputer = IconRangeComputer;
class FlutterOutlineIconVisitor extends flutter_outline_1.FlutterOutlineVisitor {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueLocation) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "material", length: attribute.valueLocation.length });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], offset: attribute.valueLocation.offset, type: "cupertino", length: attribute.valueLocation.length });
        }
    }
}
class IconRangeComputerLsp {
    constructor(logger) {
        this.logger = logger;
    }
    compute(outline) {
        const iconVisitor = new FlutterOutlineIconVisitorLsp(this.logger);
        iconVisitor.visit(outline);
        // Now build a map of all possible decorations, with those in this file. We need to include all
        // icons so if any were removed, we will clear their decorations.
        const decs = {};
        iconVisitor.icons.forEach((icon) => {
            const iconFile = `${icon.type}/${icon.iconName}`;
            if (!decs[iconFile])
                decs[iconFile] = [];
            decs[iconFile].push((0, utils_1.lspToRange)(icon.range));
        });
        return decs;
    }
}
exports.IconRangeComputerLsp = IconRangeComputerLsp;
class FlutterOutlineIconVisitorLsp extends flutter_outline_1.FlutterOutlineVisitorLsp {
    constructor() {
        super(...arguments);
        this.icons = [];
        this.materialIconValuePattern = new RegExp("^Icons\\.([\\w_]+)$");
        this.cupertinoIconValuePattern = new RegExp("^CupertinoIcons\\.([\\w_]+)$");
    }
    visitAttribute(attribute) {
        if (attribute.label && attribute.valueRange) {
            let match = this.materialIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "material" });
            match = this.cupertinoIconValuePattern.exec(attribute.label);
            if (match)
                this.icons.push({ iconName: match[1], range: attribute.valueRange, type: "cupertino" });
        }
    }
}


/***/ }),

/***/ 8789:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SupportedParameterKind = exports.InteractiveRefactors = void 0;
const vscode_1 = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
class InteractiveRefactors {
    constructor(logger, dartCapabilities) {
        this.logger = logger;
        this.dartCapabilities = dartCapabilities;
        this.disposables = [];
        this.disposables.push(vscode_1.commands.registerCommand(InteractiveRefactors.commandName, this.handleRefactor, this));
    }
    get feature() {
        const dartCapabilities = this.dartCapabilities;
        return {
            dispose() { },
            fillClientCapabilities(capabilities) {
                var _a, _b;
                capabilities.experimental = (_a = capabilities.experimental) !== null && _a !== void 0 ? _a : {};
                capabilities.experimental.dartCodeAction = (_b = capabilities.experimental.dartCodeAction) !== null && _b !== void 0 ? _b : {};
                // Originally server expected a `bool` for `commandParameterSupport` so we can only send
                // this object to new versions.
                if (dartCapabilities.supportsCommandParameterSupportedKinds) {
                    capabilities.experimental.dartCodeAction.commandParameterSupport = {
                        "supportedKinds": Object.values(SupportedParameterKind),
                    };
                }
            },
            getState() {
                return { kind: "static" };
            },
            initialize() { },
        };
    }
    /// Rewrites any commands in `actions` that are interactive refactors to go through
    /// our own local command that can prompt the user before calling the server.
    rewriteCommands(actions) {
        for (const action of actions) {
            if (!("kind" in action))
                continue;
            const command = action.command;
            if (!command || !("command" in command))
                continue;
            if (!action.kind || !vscode_1.CodeActionKind.Refactor.contains(action.kind))
                continue;
            const originalCommandName = command.command;
            const argObject = this.getCommandArgumentObject(command.arguments);
            if (!argObject)
                continue;
            const parameters = this.getCommandParameters(action, argObject);
            if (!parameters)
                continue;
            command.command = InteractiveRefactors.commandName;
            command.arguments = [originalCommandName, parameters, argObject];
        }
    }
    /// Gets the parameters from the 'data' field of the CodeAction.
    getCommandParameters(action, argObject) {
        // 'data' is an LSP concept and not exposed in the VS Code type.
        const data = action.data;
        const parameters = data === null || data === void 0 ? void 0 : data.parameters;
        // Check the parameters look sensible - a list with a length that matches the original
        // argument set.
        if (Array.isArray(parameters) && parameters.length === argObject.arguments.length)
            return parameters;
        return undefined;
    }
    /// Extract the single arguments object from the command arguments.
    ///
    /// For new refactors, command arguments are always a single object in the list
    /// which has named values (like 'file' and 'offset') as well as a well-known
    /// 'arguments' list which is updated by the interactive parameters.
    getCommandArgumentObject(args) {
        if (Array.isArray(args) && args.length === 1 && Array.isArray(args[0].arguments)) {
            return args[0];
        }
    }
    handleRefactor(command, parameters, originalArguments) {
        return __awaiter(this, void 0, void 0, function* () {
            // Enumerate through each parameter and prompt the user.
            const paramValues = originalArguments.arguments.slice();
            for (let i = 0; i < parameters.length; i++) {
                const newValue = yield this.promptUser(parameters[i]);
                // If no value, user cancelled so we should abort.
                if (!newValue)
                    return;
                paramValues[i] = newValue;
            }
            // Do nothing yet.
            return vscode_1.commands.executeCommand(command, Object.assign(Object.assign({}, originalArguments), { arguments: paramValues }));
        });
    }
    /// Prompts the user for a value for `parameter`.
    ///
    /// If the user cancels, returns `undefined`.
    ///
    /// If the type of `parameter` is not supported, its default value.
    promptUser(parameter) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (SaveUriParameter.is(parameter)) {
                return (_a = (yield this.promptUserSaveUri(parameter))) === null || _a === void 0 ? void 0 : _a.toString();
            }
            else {
                this.logger.warn(`Unknown parameter kind ${parameter.kind}. Using default value (${parameter.defaultValue})`);
                return parameter.defaultValue;
            }
        });
    }
    promptUserSaveUri(parameter) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = yield vscode_1.window.showSaveDialog({
                defaultUri: parameter.defaultValue ? vscode_1.Uri.parse(parameter.defaultValue) : undefined,
                filters: parameter.filters,
                saveLabel: parameter.actionLabel,
                title: parameter.parameterTitle,
            });
            return uri;
        });
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.InteractiveRefactors = InteractiveRefactors;
InteractiveRefactors.commandName = "_dart.interactiveRefactor";
var SupportedParameterKind;
(function (SupportedParameterKind) {
    SupportedParameterKind["saveUri"] = "saveUri";
})(SupportedParameterKind = exports.SupportedParameterKind || (exports.SupportedParameterKind = {}));
var SaveUriParameter;
(function (SaveUriParameter) {
    function is(parameter) {
        return parameter.kind === SupportedParameterKind.saveUri;
    }
    SaveUriParameter.is = is;
})(SaveUriParameter || (SaveUriParameter = {}));


/***/ }),

/***/ 3978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getIconForSymbolKind = void 0;
const vs = __webpack_require__(9496);
const iconsForKind = {
    [vs.SymbolKind.Array]: "indexer",
    [vs.SymbolKind.Boolean]: "boolean",
    [vs.SymbolKind.Class]: "class",
    [vs.SymbolKind.Constant]: "constant",
    [vs.SymbolKind.Constructor]: "method",
    [vs.SymbolKind.Enum]: "enumerator",
    [vs.SymbolKind.EnumMember]: "enumerator-item",
    [vs.SymbolKind.Event]: "event",
    [vs.SymbolKind.Field]: "field",
    [vs.SymbolKind.File]: "file",
    [vs.SymbolKind.Function]: "method",
    [vs.SymbolKind.Interface]: "interface",
    [vs.SymbolKind.Key]: "string",
    [vs.SymbolKind.Method]: "method",
    [vs.SymbolKind.Module]: "namespace",
    [vs.SymbolKind.Namespace]: "namespace",
    [vs.SymbolKind.Null]: "boolean",
    [vs.SymbolKind.Number]: "numeric",
    [vs.SymbolKind.Object]: "namespace",
    [vs.SymbolKind.Operator]: "operator",
    [vs.SymbolKind.Package]: "namespace",
    [vs.SymbolKind.Property]: "property",
    [vs.SymbolKind.String]: "string",
    [vs.SymbolKind.Struct]: "structure",
    [vs.SymbolKind.TypeParameter]: "type-parameter",
    [vs.SymbolKind.Variable]: "variable",
};
function getIconForSymbolKind(kind) {
    return iconsForKind[kind] || "field";
}
exports.getIconForSymbolKind = getIconForSymbolKind;


/***/ }),

/***/ 2105:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runPubUpgrade = exports.promptToRunPubUpgrade = exports.runPubGet = exports.promptToRunPubGet = exports.getPubPackageStatus = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const semver = __webpack_require__(1249);
const vscode_1 = __webpack_require__(9496);
const package_map_1 = __webpack_require__(143);
const fs_1 = __webpack_require__(300);
// TODO: Wrap these up into a class.
function getPubPackageStatus(sdks, logger, folderUri) {
    const nonRequired = undefined;
    const getRequired = { probablyRequiresGet: true, probablyRequiresUpgrade: false };
    const upgradeRequired = { probablyRequiresGet: true, probablyRequiresUpgrade: true };
    const folder = (0, fs_1.fsPath)(folderUri);
    const pubspecPath = path.join(folder, "pubspec.yaml");
    const pubspecLockPath = path.join(folder, "pubspec.lock");
    const packageMapPath = path.join(folder, ".dart_tool", "package_config.json");
    if (!folder || !fs.existsSync(pubspecPath))
        return nonRequired;
    // If we don't appear to have deps listed in pubspec, then no point prompting.
    const regex = new RegExp("dependencies\\s*:", "i");
    if (!regex.test(fs.readFileSync(pubspecPath).toString()))
        return nonRequired;
    // If we don't have package_config, we probably need running.
    if (!fs.existsSync(packageMapPath))
        return getRequired;
    // If the Dart SDK version has upgraded by more than just a patch, we should
    // prefer upgrade.
    const lastUsedSdkVersion = (0, fs_1.getPubGeneratorVersion)(logger, packageMapPath);
    const currentSdkVersion = sdks.dartVersion;
    if (lastUsedSdkVersion && currentSdkVersion) {
        const lastUsedSdkMajorMinor = `${semver.major(lastUsedSdkVersion)}.${semver.minor(lastUsedSdkVersion)}.0`;
        const currentSdkMajorMinor = `${semver.major(currentSdkVersion)}.${semver.minor(currentSdkVersion)}.0`;
        logger.info(`Version last used for Pub is ${lastUsedSdkVersion} (${lastUsedSdkMajorMinor}), current is ${currentSdkVersion} (${currentSdkMajorMinor})`);
        // For an SDK upgrade, we want to encourage upgrading.
        if (semver.gt(currentSdkMajorMinor, lastUsedSdkMajorMinor))
            return upgradeRequired;
        // For a downgrade, Pub Get is enough to fix.
        else if (semver.lt(currentSdkMajorMinor, lastUsedSdkMajorMinor))
            return getRequired;
    }
    const pubspecModified = fs.statSync(pubspecPath).mtime;
    const pubspecLockModified = fs.existsSync(pubspecLockPath)
        ? fs.statSync(pubspecLockPath).mtime
        : pubspecModified;
    const packageMapModified = fs.statSync(packageMapPath).mtime;
    if (!(pubspecModified <= pubspecLockModified && pubspecLockModified <= packageMapModified))
        return getRequired;
    // If we're a Flutter project and our SDK doesn't match the one used
    // in the package file, we also need running.
    if (sdks.flutter) {
        const packageMap = package_map_1.PackageMap.loadForProject(logger, folder);
        const flutterPackagePath = packageMap.getPackagePath("flutter");
        if (flutterPackagePath && !(0, fs_1.isWithinPath)(flutterPackagePath, sdks.flutter)) {
            return getRequired;
        }
    }
    return nonRequired;
}
exports.getPubPackageStatus = getPubPackageStatus;
function promptToRunPubGet(folders) {
    return __awaiter(this, void 0, void 0, function* () {
        const label = "Run 'pub get'";
        const clickedButton = yield vscode_1.window.showInformationMessage("Some packages are missing or out of date, would you like to get them now?", label);
        if (clickedButton === label)
            yield runPubGet(folders);
    });
}
exports.promptToRunPubGet = promptToRunPubGet;
function runPubGet(folders) {
    return vscode_1.commands.executeCommand("dart.getPackages", folders);
}
exports.runPubGet = runPubGet;
function promptToRunPubUpgrade(folders) {
    return __awaiter(this, void 0, void 0, function* () {
        const label = "Run 'pub upgrade'";
        const clickedButton = yield vscode_1.window.showInformationMessage("Your SDK has been updated since you last fetched packages, would you like to fetch updated packages?", label);
        if (clickedButton === label)
            yield runPubUpgrade(folders);
    });
}
exports.promptToRunPubUpgrade = promptToRunPubUpgrade;
function runPubUpgrade(folders) {
    return vscode_1.commands.executeCommand("dart.upgradePackages", folders);
}
exports.runPubUpgrade = runPubUpgrade;


/***/ }),

/***/ 821:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatLineColFragment = exports.findFileUriLinks = exports.findPackageUriLinks = void 0;
const vs = __webpack_require__(9496);
const fileUriPattern = new RegExp("(?<uri>file:\\/{3}\\S+[\\/]\\S+\\.dart)(?:(?:[: ]| line )(?<line>\\d+)(?::(?<col>\\d+))?)?", "mg");
const packageUriPattern = new RegExp("(?<uri>package:\\S+[\\/]\\S+\\.dart)(?:(?:[: ]| line )(?<line>\\d+)(?::(?<col>\\d+))?)?", "mg");
function findPackageUriLinks(content, isKnownPackage) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        packageUriPattern.lastIndex = -1;
        let result;
        // tslint:disable-next-line: no-conditional-assignment
        while ((result = packageUriPattern.exec(content)) && result.groups) {
            let uri;
            try {
                uri = vs.Uri.parse(result.groups.uri, true);
            }
            catch (e) {
                continue;
            }
            if (!uri)
                continue;
            const packageName = uri.path.split("/")[0];
            if (!isKnownPackage(packageName))
                continue;
            const line = result.groups.line ? parseInt(result.groups.line) : undefined;
            const col = result.groups.col ? parseInt(result.groups.col) : undefined;
            const startIndex = result.index;
            const length = result[0].length;
            results.push({
                col,
                length,
                line,
                packageName,
                startIndex,
                tooltip: "Open file in editor",
                uri: result.groups.uri,
            });
        }
        return results;
    });
}
exports.findPackageUriLinks = findPackageUriLinks;
function findFileUriLinks(line) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = [];
        fileUriPattern.lastIndex = -1;
        let result;
        // tslint:disable-next-line: no-conditional-assignment
        while ((result = fileUriPattern.exec(line)) && result.groups) {
            let uri;
            try {
                uri = vs.Uri.parse(result.groups.uri, true);
            }
            catch (e) {
                continue;
            }
            if (!uri)
                continue;
            const line = result.groups.line ? parseInt(result.groups.line) : undefined;
            const col = result.groups.col ? parseInt(result.groups.col) : undefined;
            const startIndex = result.index;
            const length = result[0].length;
            results.push({
                col,
                length,
                line,
                startIndex,
                tooltip: "Open file in editor",
                uri,
            });
        }
        return results;
    });
}
exports.findFileUriLinks = findFileUriLinks;
function formatLineColFragment(link) {
    if (link.line !== undefined && link.col !== undefined)
        return `${link.line},${link.col}`;
    else if (!link.line !== undefined)
        return `${link.line}`;
    else
        return "";
}
exports.formatLineColFragment = formatLineColFragment;


/***/ }),

/***/ 4191:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOffsetTracker = exports.DocumentPositionTracker = void 0;
const vs = __webpack_require__(9496);
const utils_1 = __webpack_require__(4586);
class DocumentPositionTracker {
    constructor() {
        this.disposables = [];
        this.tracker = new DocumentOffsetTracker();
        this.positionMap = new Map();
        this.onPositionsChangedEmitter = new vs.EventEmitter();
        this.onPositionsChanged = this.onPositionsChangedEmitter.event;
        this.disposables.push(this.tracker);
        this.tracker.onOffsetsChanged(([doc, offsets]) => {
            // Map all our original positions onto new positions based on their
            // new offsets.
            const newPositions = new Map();
            for (const position of this.positionMap.keys()) {
                const currentOffset = this.positionMap.get(position);
                const newOffset = offsets.get(currentOffset);
                if (newOffset)
                    newPositions.set(position, doc.positionAt(newOffset));
                else
                    newPositions.delete(position);
            }
            this.onPositionsChangedEmitter.fire([doc, newPositions]);
        });
    }
    clear() {
        this.positionMap.clear();
        this.tracker.clear();
    }
    trackDoc(document, positions) {
        // Stash all positions as offsets.
        this.positionMap.clear();
        for (const position of positions)
            this.positionMap.set(position, document.offsetAt(position));
        // Track via the offset tracker.
        this.tracker.trackDoc(document, [...this.positionMap.values()]);
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentPositionTracker = DocumentPositionTracker;
class DocumentOffsetTracker {
    constructor() {
        this.disposables = [];
        this.offsetMap = new Map();
        this.onOffsetsChangedEmitter = new vs.EventEmitter();
        this.onOffsetsChanged = this.onOffsetsChangedEmitter.event;
        this.disposables.push(vs.workspace.onDidChangeTextDocument((e) => this.handleUpdate(e)));
    }
    trackDoc(document, offsets) {
        this.document = document;
        // Set all offsets to just point to themeselves.
        this.offsetMap.clear();
        for (const offset of offsets)
            this.offsetMap.set(offset, offset);
    }
    clear() {
        this.document = undefined;
        this.offsetMap.clear();
    }
    handleUpdate(e) {
        if (e.document !== this.document)
            return;
        for (const offset of [...this.offsetMap.keys()]) {
            // The key (offset) is the original offset, which we must use in the
            // map to track the current offset.
            // updateOffset takes the *value*, since we need to map the "current" (not
            // original) value, and then updates the value in the map.
            const currentOffset = this.offsetMap.get(offset);
            const newOffset = this.updateOffset(currentOffset, e);
            if (newOffset)
                this.offsetMap.set(offset, newOffset);
            else
                this.offsetMap.delete(offset);
        }
        this.onOffsetsChangedEmitter.fire([e.document, this.offsetMap]);
    }
    updateOffset(offset, change) {
        // If any edit spans us, consider us deleted.
        if (change.contentChanges.find((edit) => edit.rangeOffset < offset && edit.rangeOffset + edit.rangeLength > offset)) {
            return undefined;
        }
        // Otherwise, shift us along to account for any edits before us.
        const totalDiff = change.contentChanges
            // Edits that end before us.
            .filter((edit) => edit.rangeOffset + edit.rangeLength <= offset)
            // Get the difference in lengths to know if we inserted or removed.
            .map((edit) => edit.text.length - edit.rangeLength)
            .reduce((total, n) => total + n, 0);
        return offset + totalDiff;
    }
    dispose() {
        (0, utils_1.disposeAll)(this.disposables);
    }
}
exports.DocumentOffsetTracker = DocumentOffsetTracker;


/***/ }),

/***/ 4068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlutterSampleUriHandler = void 0;
const vs = __webpack_require__(9496);
const flutter_samples_1 = __webpack_require__(3150);
class FlutterSampleUriHandler {
    constructor(flutterCapabilities) {
        this.flutterCapabilities = flutterCapabilities;
        this.validSampleIdentifierPattern = new RegExp("^[\\w\\.]+$");
    }
    handle(sampleID) {
        if (!this.isValidSampleName(sampleID)) {
            vs.window.showErrorMessage(`${sampleID} is not a valid Flutter sample identifier`);
            return;
        }
        (0, flutter_samples_1.createFlutterSampleInTempFolder)(this.flutterCapabilities, sampleID);
    }
    isValidSampleName(name) {
        return this.validSampleIdentifierPattern.test(name);
    }
}
exports.FlutterSampleUriHandler = FlutterSampleUriHandler;


/***/ }),

/***/ 5652:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DartUriHandler = void 0;
const vs = __webpack_require__(9496);
const flutter_sample_handler_1 = __webpack_require__(4068);
class DartUriHandler {
    constructor(flutterCapabilities) {
        this.handlers = {
            "/flutter/sample/": new flutter_sample_handler_1.FlutterSampleUriHandler(flutterCapabilities),
        };
    }
    handleUri(uri) {
        return __awaiter(this, void 0, void 0, function* () {
            const handlerPrefix = Object.keys(this.handlers).find((key) => uri.path.startsWith(key));
            if (handlerPrefix) {
                yield this.handlers[handlerPrefix].handle(uri.path.substr(handlerPrefix.length));
            }
            else {
                vs.window.showErrorMessage(`No handler for '${uri.path}'. Check you have the latest version of the Dart plugin and try again.`);
            }
        });
    }
}
exports.DartUriHandler = DartUriHandler;


/***/ }),

/***/ 7622:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.showDevToolsNotificationIfAppropriate = exports.showFlutterSurveyNotificationIfAppropriate = void 0;
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(7068);
const constants_1 = __webpack_require__(5628);
const utils_1 = __webpack_require__(7220);
/// Shows Survey notification if appropriate. Returns whether a notification was shown
/// (not whether it was clicked/opened).
function showFlutterSurveyNotificationIfAppropriate(context, webClient, analytics, openInBrowser, now, logger) {
    return __awaiter(this, void 0, void 0, function* () {
        let surveyData;
        try {
            const rawSurveyJson = yield webClient.fetch(constants_1.flutterSurveyDataUrl);
            const rawSurveyData = JSON.parse(rawSurveyJson);
            surveyData = Object.assign(Object.assign({}, rawSurveyData), { endDate: new Date(rawSurveyData.endDate).getTime(), startDate: new Date(rawSurveyData.startDate).getTime() });
            if (!surveyData.uniqueId || !surveyData.title || !surveyData.url)
                throw new Error(`Survey data did not include ID, Title or URL:\n${rawSurveyJson}`);
        }
        catch (e) {
            logger.error(e);
            return false;
        }
        if (now <= surveyData.startDate || now >= surveyData.endDate)
            return false;
        const lastShown = context.getFlutterSurveyNotificationLastShown(surveyData.uniqueId);
        const doNotShow = context.getFlutterSurveyNotificationDoNotShow(surveyData.uniqueId);
        // Don't show this notification if user previously said not to.
        if (doNotShow)
            return false;
        // Don't show this notification if we've shown it in the last 40 hours.
        if (lastShown && now - lastShown < constants_1.longRepeatPromptThreshold)
            return false;
        const firstQsSep = surveyData.url.indexOf("?") !== -1 ? "&" : "?";
        const surveyUrl = `${surveyData.url}${firstQsSep}Source=VSCode`;
        // Mark the last time we've shown it (now) so we can avoid showing again for
        // 40 hours.
        context.setFlutterSurveyNotificationLastShown(surveyData.uniqueId, Date.now());
        // Prompt to show and handle response.
        analytics.logFlutterSurveyShown();
        vs.window.showInformationMessage(surveyData.title, constants_1.takeSurveyAction, constants_1.skipThisSurveyAction).then((choice) => __awaiter(this, void 0, void 0, function* () {
            if (choice === constants_1.skipThisSurveyAction) {
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
                analytics.logFlutterSurveyDismissed();
            }
            else if (choice === constants_1.takeSurveyAction) {
                // Mark as do-not-show-again if they answer it, since it seems silly
                // to show them again if they already completed it.
                context.setFlutterSurveyNotificationDoNotShow(surveyData.uniqueId, true);
                yield openInBrowser(surveyUrl);
                analytics.logFlutterSurveyClicked();
            }
        }));
        // Return true because we showed the notification and don't want to cause more
        // than one notification per activation.
        return true;
    });
}
exports.showFlutterSurveyNotificationIfAppropriate = showFlutterSurveyNotificationIfAppropriate;
function showDevToolsNotificationIfAppropriate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!vscode_1.vsCodeVersion.supportsDevTools)
            return { didOpen: false };
        // Don't show in remote workspaces because currently DevTools fails to load if SSE doesn't work (which
        // is the case for some cloud IDE proxies).
        if (!utils_1.isRunningLocally)
            return { didOpen: false };
        const lastShown = context.devToolsNotificationLastShown;
        const doNotShow = context.devToolsNotificationDoNotShow;
        // Don't show this notification more than 10 times or if user said not to.
        if (doNotShow)
            return { didOpen: false };
        // Don't show this notification if we've shown it in the last 20 hours.
        if (lastShown && Date.now() - lastShown < constants_1.noRepeatPromptThreshold)
            return { didOpen: false };
        context.devToolsNotificationLastShown = Date.now();
        const choice = yield vs.window.showInformationMessage(constants_1.wantToTryDevToolsPrompt, constants_1.openAction, constants_1.alwaysOpenAction, constants_1.notTodayAction, constants_1.doNotAskAgainAction);
        if (choice === constants_1.doNotAskAgainAction) {
            context.devToolsNotificationDoNotShow = true;
            return { didOpen: false };
        }
        else if (choice === constants_1.alwaysOpenAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true, shouldAlwaysOpen: true };
        }
        else if (choice === constants_1.openAction) {
            vs.commands.executeCommand("dart.openDevTools");
            return { didOpen: true };
        }
        else {
            // No thanks.
            return { didOpen: false };
        }
    });
}
exports.showDevToolsNotificationIfAppropriate = showDevToolsNotificationIfAppropriate;


/***/ }),

/***/ 7220:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createWatcher = exports.firstEditorColumn = exports.firstNonEditorColumn = exports.envUtils = exports.treeLabel = exports.warnIfPathCaseMismatch = exports.trimTrailingSlashes = exports.showCode = exports.toRangeOnLine = exports.lspToPosition = exports.toPosition = exports.lspToRange = exports.toRange = exports.isDartWorkspaceFolder = exports.getAllProjectFolders = exports.getDartWorkspaceFolders = exports.isRunningLocally = exports.SourceSortMembersCodeActionKind = void 0;
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const url_1 = __webpack_require__(7310);
const vs = __webpack_require__(9496);
const vscode_1 = __webpack_require__(9496);
const YAML = __webpack_require__(3419);
const constants_1 = __webpack_require__(5628);
const logging_1 = __webpack_require__(8323);
const utils_1 = __webpack_require__(4586);
const cache_1 = __webpack_require__(8854);
const fs_1 = __webpack_require__(300);
const utils_cloud_1 = __webpack_require__(9492);
exports.SourceSortMembersCodeActionKind = vscode_1.CodeActionKind.Source.append("sortMembers");
const dartExtension = vscode_1.extensions.getExtension(constants_1.dartCodeExtensionIdentifier);
const projectFolderCache = new cache_1.SimpleTimeBasedCache();
let inProgressProjectFolderSearch;
// The extension kind is declared as Workspace, but VS Code will return UI in the
// case that there is no remote extension host.
exports.isRunningLocally = 
// Some cloud IDEs mis-report the extension kind, so if we _know_ something is a cloud IDE,
// override that.
!utils_cloud_1.isKnownCloudIde
    && (!dartExtension || dartExtension.extensionKind === vscode_1.ExtensionKind.UI);
function getDartWorkspaceFolders() {
    if (!vscode_1.workspace.workspaceFolders)
        return [];
    return vscode_1.workspace.workspaceFolders.filter(isDartWorkspaceFolder);
}
exports.getDartWorkspaceFolders = getDartWorkspaceFolders;
function getAnalysisOptionsExcludedFolders(logger, projectFolders) {
    var _a;
    const results = [];
    for (const projectFolder of projectFolders) {
        const analysisOptionsPath = path.join(projectFolder, "analysis_options.yaml");
        try {
            const analysisOptionsContent = fs.readFileSync(analysisOptionsPath);
            const yaml = YAML.parse(analysisOptionsContent.toString());
            const excluded = (_a = yaml === null || yaml === void 0 ? void 0 : yaml.analyzer) === null || _a === void 0 ? void 0 : _a.exclude;
            if (excluded && Array.isArray(excluded)) {
                for (let exclude of excluded) {
                    // Only exclude an entire folder if the /** is at the end. If it's
                    // something like foo/**/*.generated.* then it does not exclude
                    // everything in foo.
                    if (exclude.endsWith("/**"))
                        exclude = exclude.substring(0, exclude.length - 3);
                    // Handle relative paths.
                    if (!exclude.startsWith("/"))
                        exclude = path.join(projectFolder, exclude);
                    // Now, if no wildcards remain in the path, we can use it as an exclusion.
                    if (!exclude.includes("*"))
                        results.push(exclude);
                }
            }
        }
        catch (e) {
            if ((e === null || e === void 0 ? void 0 : e.code) !== "ENOENT") // Don't warn for missing files.
                logger.error(`Failed to read ${analysisOptionsPath}: ${e}`);
        }
    }
    return results;
}
function getAllProjectFolders(logger, getExcludedFolders, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const workspaceFolders = (_a = options.workspaceFolders) !== null && _a !== void 0 ? _a : getDartWorkspaceFolders();
        // If another search is in progress, use its Promise to avoid overlapping searches.
        if (inProgressProjectFolderSearch) {
            logger.info(`Returning cached Promise for in-progress project search`);
            return inProgressProjectFolderSearch;
        }
        const cacheKey = `folders_${workspaceFolders.map((f) => f.uri.toString()).join(path.sep)}_${options.onlyWorkspaceRoots ? "true" : "false"}`;
        const cachedFolders = projectFolderCache.get(cacheKey);
        if (cachedFolders) {
            logger.info(`Returning cached results for project search`);
            return cachedFolders;
        }
        let startTimeMs = new Date().getTime();
        const tokenSource = new vs.CancellationTokenSource();
        let isComplete = false;
        const topLevelFolders = workspaceFolders.map((w) => (0, fs_1.fsPath)(w.uri));
        const allExcludedFolders = getExcludedFolders ? (0, utils_1.flatMap)(workspaceFolders, getExcludedFolders) : [];
        const resultsPromise = (0, fs_1.findProjectFolders)(logger, topLevelFolders, allExcludedFolders, options, tokenSource.token);
        inProgressProjectFolderSearch = resultsPromise;
        // After some time, if we still have not completed, show a progress notification that can be cancelled
        // to stop the search, which automatically hides when `resultsPromise` resolves.
        setTimeout(() => {
            if (!isComplete) {
                vs.window.withProgress({
                    cancellable: true,
                    location: vs.ProgressLocation.Notification,
                    title: constants_1.projectSearchProgressText,
                }, (progress, token) => {
                    token.onCancellationRequested(() => {
                        tokenSource.cancel();
                        logger.info(`Project search was cancelled after ${new Date().getTime() - startTimeMs}ms (was searching ${options.searchDepth} levels)`);
                    });
                    return resultsPromise;
                });
            }
        }, constants_1.projectSearchProgressNotificationDelayInMs);
        let results = yield resultsPromise;
        isComplete = true;
        logger.info(`Took ${new Date().getTime() - startTimeMs}ms to search for projects (${options.searchDepth} levels)`);
        startTimeMs = new Date().getTime();
        // Filter out any folders excluded by analysis_options.
        try {
            const excludedFolders = getAnalysisOptionsExcludedFolders(logger, results);
            results = results.filter((p) => !excludedFolders.find((f) => p.startsWith(f)));
            logger.info(`Took ${new Date().getTime() - startTimeMs}ms to filter out excluded projects (${excludedFolders.length} exclusion rules)`);
        }
        catch (e) {
            logger.error(`Failed to filter out analysis_options exclusions: ${e}`);
        }
        // Cache the results.
        projectFolderCache.add(cacheKey, results, constants_1.projectSearchCacheTimeInMs);
        // Clear the promise if it's still ours.
        if (inProgressProjectFolderSearch === resultsPromise)
            inProgressProjectFolderSearch = undefined;
        return results;
    });
}
exports.getAllProjectFolders = getAllProjectFolders;
function isDartWorkspaceFolder(folder) {
    if (!folder || folder.uri.scheme !== "file")
        return false;
    // Currently we don't have good logic to know what's a Dart folder.
    // We could require a pubspec, but it's valid to just write scripts without them.
    // For now, nothing calls this that will do bad things if the folder isn't a Dart
    // project so we can review amend this in future if required.
    return true;
}
exports.isDartWorkspaceFolder = isDartWorkspaceFolder;
function toRange(document, offset, length) {
    return new vscode_1.Range(document.positionAt(offset), document.positionAt(offset + length));
}
exports.toRange = toRange;
function lspToRange(range) {
    return new vscode_1.Range(lspToPosition(range.start), lspToPosition(range.end));
}
exports.lspToRange = lspToRange;
function toPosition(location) {
    return new vscode_1.Position(location.startLine - 1, location.startColumn - 1);
}
exports.toPosition = toPosition;
function lspToPosition(position) {
    return new vscode_1.Position(position.line, position.character);
}
exports.lspToPosition = lspToPosition;
// Translates an offset/length to a Range.
// NOTE: Does not wrap lines because it does not have access to a TextDocument to know
// where the line ends.
function toRangeOnLine(location) {
    const startPos = toPosition(location);
    return new vscode_1.Range(startPos, startPos.translate(0, location.length));
}
exports.toRangeOnLine = toRangeOnLine;
function showCode(editor, displayRange, highlightRange, selectionRange) {
    if (selectionRange)
        editor.selection = new vscode_1.Selection(selectionRange.start, selectionRange.end);
    // Ensure the code is visible on screen.
    editor.revealRange(displayRange, vscode_1.TextEditorRevealType.InCenterIfOutsideViewport);
    // TODO: Implement highlighting
    // See https://github.com/Microsoft/vscode/issues/45059
}
exports.showCode = showCode;
function trimTrailingSlashes(s) {
    return s.replace(/[\/\\]+$/, "");
}
exports.trimTrailingSlashes = trimTrailingSlashes;
function warnIfPathCaseMismatch(logger, p, pathDescription, helpText) {
    const userPath = trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(p));
    const realPath = fs.existsSync(userPath) && trimTrailingSlashes((0, fs_1.forceWindowsDriveLetterToUppercase)(fs.realpathSync.native(userPath)));
    // Since realpathSync.native will resolve symlinks, we'll only show these warnings
    // when there was no symlink (eg. the lowercase version of both paths match).
    if (userPath && realPath && userPath.toLowerCase() === realPath.toLowerCase() && userPath !== realPath) {
        const message = `The casing of ${pathDescription} does not match the casing on disk; please ${helpText}. `
            + `Expected ${realPath} but got ${userPath}`;
        logger.warn(message);
        vs.window.showWarningMessage(message);
        return true;
    }
    return false;
}
exports.warnIfPathCaseMismatch = warnIfPathCaseMismatch;
class EnvUtils {
    openInBrowser(url, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info(`Opening external URL: ${url}`);
            return vscode_1.env.openExternal(vscode_1.Uri.parse(url));
        });
    }
    exposeUrl(urlString, logger = logging_1.nullLogger) {
        return __awaiter(this, void 0, void 0, function* () {
            const uri = vs.Uri.parse(urlString, true);
            logger.info(`Exposing URL: ${uri.toString()}`);
            const isWebSocket = uri.scheme === "ws" || uri.scheme === "wss";
            const isSecure = uri.scheme === "wss" || uri.scheme === "https";
            // TODO: Remove this scheme mapping when https://github.com/microsoft/vscode/issues/84819
            // is resolved.
            let fakeScheme = uri.scheme;
            if (isWebSocket)
                fakeScheme = isSecure ? "https" : "http";
            const url = new url_1.URL(urlString);
            // Ensure the URL always has a port, as some cloud providers fail to expose URLs correctly
            // that don't have explicit port numbers.
            //
            // Additionally, on some cloud providers we get an IPv6 loopback which fails to connect
            // correctly. Assume that if we get this, it's safe to use the "localhost" hostname.
            const fakeHostname = url.hostname === "[::]" ? "localhost" : url.hostname;
            const fakePort = url.port || (isSecure ? "443" : "80"); // Don't change to ??, port can be empty string!
            const fakeAuthority = `${fakeHostname}:${fakePort}`;
            const uriToMap = uri.with({ scheme: fakeScheme, authority: fakeAuthority });
            logger.info(`Mapping URI: ${uriToMap.toString()}`);
            const mappedUri = yield vscode_1.env.asExternalUri(uriToMap);
            logger.info(`Mapped URI: ${mappedUri.toString()}`);
            // Now we need to map the scheme back to WS if that's what was originally asked for, however
            // we need to take into account whether asExternalUri pushed is up to secure, so use
            // the http/https to decide which to go back to.
            let newScheme = mappedUri.scheme;
            if (isWebSocket)
                // Note: We use mappedUri.scheme here and not isSecure because we
                // care if the *exposed* URI is secure.
                newScheme = mappedUri.scheme === "https" ? "wss" : "ws";
            const mappedUrl = new url_1.URL(uriToString(mappedUri));
            logger.info(`Mapped URL: ${mappedUrl}`);
            // Copy the important (mapped) parts back onto the original URL, preserving
            // the path/querystring that was not messed with by VS Code's Uri class.
            url.protocol = newScheme;
            url.host = mappedUrl.host;
            url.port = mappedUrl.port;
            logger.info(`Final URL: ${url}`);
            return url.toString();
        });
    }
}
function uriToString(uri) {
    return uri.toString()
        .replace(/%24/g, "$")
        .replace(/%5B/g, "[");
}
function treeLabel(item) {
    if (!item.label || typeof item.label === "string")
        return item.label;
    return item.label.label;
}
exports.treeLabel = treeLabel;
exports.envUtils = new EnvUtils();
function usedEditorColumns() {
    return new Set(vs.window.visibleTextEditors.map((e) => e.viewColumn).filter(utils_1.notUndefined));
}
function firstNonEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (!usedColumns.has(i))
            return i;
    }
}
exports.firstNonEditorColumn = firstNonEditorColumn;
function firstEditorColumn() {
    const usedColumns = usedEditorColumns();
    for (let i = 1; i <= 9; i++) {
        if (usedColumns.has(i))
            return i;
    }
}
exports.firstEditorColumn = firstEditorColumn;
function createWatcher(pattern, emitter) {
    const watcher = vs.workspace.createFileSystemWatcher(pattern);
    watcher.onDidChange((uri) => emitter.fire(uri));
    watcher.onDidCreate((uri) => emitter.fire(uri));
    watcher.onDidDelete((uri) => emitter.fire(uri));
    return watcher;
}
exports.createWatcher = createWatcher;


/***/ }),

/***/ 9492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b, _c, _d;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isKnownCloudIde = exports.isCloudShell = exports.isTheia = void 0;
const vs = __webpack_require__(9496);
exports.isTheia = (_b = (_a = vs.env.appName) === null || _a === void 0 ? void 0 : _a.includes("Theia")) !== null && _b !== void 0 ? _b : false;
exports.isCloudShell = (_d = (_c = vs.env.appName) === null || _c === void 0 ? void 0 : _c.includes("Cloud Shell")) !== null && _d !== void 0 ? _d : false;
exports.isKnownCloudIde = exports.isTheia || exports.isCloudShell;


/***/ }),

/***/ 6105:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
class Context {
    constructor(context) {
        this.context = context;
    }
    static for(context) {
        return new Context(context);
    }
    get extensionStorageUri() {
        return this.context.globalStorageUri;
    }
    get devToolsNotificationLastShown() { return this.context.globalState.get("devToolsNotificationLastShown"); }
    set devToolsNotificationLastShown(value) { this.context.globalState.update("devToolsNotificationLastShown", value); }
    get devToolsNotificationDoNotShow() { return !!this.context.globalState.get("devToolsNotificationDoNotShowAgain"); }
    set devToolsNotificationDoNotShow(value) { this.context.globalState.update("devToolsNotificationDoNotShowAgain", value); }
    get breakpointInNonDebuggableFileDoNotShowAgain() { return !!this.context.globalState.get("breakpointInNonDebuggableFileDoNotShowAgain"); }
    set breakpointInNonDebuggableFileDoNotShowAgain(value) { this.context.globalState.update("breakpointInNonDebuggableFileDoNotShowAgain", value); }
    getFlutterSurveyNotificationLastShown(id) { return this.context.globalState.get(`flutterSurvey${id}NotificationLastShown`); }
    setFlutterSurveyNotificationLastShown(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationLastShown`, value); }
    getFlutterSurveyNotificationDoNotShow(id) { return !!this.context.globalState.get(`flutterSurvey${id}NotificationDoNotShowAgain`); }
    setFlutterSurveyNotificationDoNotShow(id, value) { this.context.globalState.update(`flutterSurvey${id}NotificationDoNotShowAgain`, value); }
    get hasWarnedAboutFormatterSyntaxLimitation() { return !!this.context.globalState.get("hasWarnedAboutFormatterSyntaxLimitation"); }
    set hasWarnedAboutFormatterSyntaxLimitation(value) { this.context.globalState.update("hasWarnedAboutFormatterSyntaxLimitation", value); }
    get hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation() { return !!this.context.globalState.get("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation"); }
    set hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation(value) { this.context.globalState.update("hasWarnedAboutPubUpgradeMajorVersionsPubpecMutation", value); }
    get hasNotifiedAboutProfileModeDefaultConfiguration() { return !!this.context.globalState.get("hasNotifiedAboutProfileModeDefaultConfiguration"); }
    set hasNotifiedAboutProfileModeDefaultConfiguration(value) { this.context.globalState.update("hasNotifiedAboutProfileModeDefaultConfiguration", value); }
    get lastSeenVersion() { return this.context.globalState.get("lastSeenVersion"); }
    set lastSeenVersion(value) { this.context.globalState.update("lastSeenVersion", value); }
    get lastUsedNewProjectPath() { return this.context.globalState.get("lastUsedNewProjectPath"); }
    set lastUsedNewProjectPath(value) { this.context.globalState.update("lastUsedNewProjectPath", value); }
    getPackageLastCheckedForUpdates(packageID) { return this.context.globalState.get(`packageLastCheckedForUpdates:${packageID}`); }
    setPackageLastCheckedForUpdates(packageID, value) { this.context.globalState.update(`packageLastCheckedForUpdates:${packageID}`, value); }
    update(key, value) {
        return this.context.globalState.update(key, value);
    }
    get(key) {
        return this.context.globalState.get(key);
    }
    asAbsolutePath(relativePath) {
        return this.context.asAbsolutePath(relativePath);
    }
}
exports.Context = Context;


/***/ }),

/***/ 2329:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceContext = void 0;
const events_1 = __webpack_require__(3254);
class WorkspaceContext {
    // TODO: Move things from Sdks to this class that aren't related to the SDKs.
    constructor(sdks, config, hasAnyFlutterProjects, hasAnyWebProjects, hasAnyStandardDartProjects, hasProjectsInFuchsiaTree) {
        this.sdks = sdks;
        this.config = config;
        this.hasAnyFlutterProjects = hasAnyFlutterProjects;
        this.hasAnyWebProjects = hasAnyWebProjects;
        this.hasAnyStandardDartProjects = hasAnyStandardDartProjects;
        this.hasProjectsInFuchsiaTree = hasProjectsInFuchsiaTree;
        this.events = new WorkspaceEvents();
        this.workspaceTypeDescription = this.buildWorkspaceTypeDescription();
    }
    get shouldLoadFlutterExtension() { return this.hasAnyFlutterProjects; }
    /// Used only for display (for ex stats), not behaviour.
    buildWorkspaceTypeDescription() {
        const types = [];
        // Don't re-order these, else stats won't easily combine as we could have
        // Dart, Flutter and also Flutter, Dart.
        if (this.hasAnyStandardDartProjects)
            types.push("Dart");
        if (this.hasAnyFlutterProjects)
            types.push("Flutter");
        if (this.hasProjectsInFuchsiaTree)
            types.push("Fuchsia");
        // If we didn't detect any projects, record as unknown, but include info
        // on the type of SDK we had found.
        if (types.length === 0) {
            if (this.sdks && this.sdks.dartSdkIsFromFlutter)
                types.push("Unknown (Flutter SDK)");
            else if (this.sdks && this.sdks.dart)
                types.push("Unknown (Dart SDK)");
            else
                types.push("Unknown (No SDK)");
        }
        return types.join(", ");
    }
    dispose() {
        this.events.dispose();
    }
}
exports.WorkspaceContext = WorkspaceContext;
class WorkspaceEvents {
    constructor() {
        this.onPackageMapChange = new events_1.EventEmitter();
    }
    dispose() {
        this.onPackageMapChange.dispose();
    }
}


/***/ }),

/***/ 3870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TraceFormat = exports.TraceValues = exports.Trace = exports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;
exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = void 0;
const messages_1 = __webpack_require__(839);
Object.defineProperty(exports, "Message", ({ enumerable: true, get: function () { return messages_1.Message; } }));
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(6184);
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(3911);
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(2320);
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(3881);
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(6525);
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(6654);
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(1343);
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressToken", ({ enumerable: true, get: function () { return connection_1.ProgressToken; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceValues", ({ enumerable: true, get: function () { return connection_1.TraceValues; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(147);
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 3881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const events_1 = __webpack_require__(2320);
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ 1343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const messages_1 = __webpack_require__(839);
const linkedMap_1 = __webpack_require__(6184);
const events_1 = __webpack_require__(2320);
const cancellation_1 = __webpack_require__(3881);
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressToken;
(function (ProgressToken) {
    function is(value) {
        return typeof value === 'string' || typeof value === 'number';
    }
    ProgressToken.is = is;
})(ProgressToken = exports.ProgressToken || (exports.ProgressToken = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Compact"] = 2] = "Compact";
    Trace[Trace["Verbose"] = 3] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceValues;
(function (TraceValues) {
    /**
     * Turn tracing off.
     */
    TraceValues.Off = 'off';
    /**
     * Trace messages only.
     */
    TraceValues.Messages = 'messages';
    /**
     * Compact message tracing.
     */
    TraceValues.Compact = 'compact';
    /**
     * Verbose message tracing.
     */
    TraceValues.Verbose = 'verbose';
})(TraceValues = exports.TraceValues || (exports.TraceValues = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'compact':
                return Trace.Compact;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Compact:
                return 'compact';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = new Map();
    let starNotificationHandler = undefined;
    const notificationHandlers = new Map();
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = new Map();
    let knownCanceledRequests = new Set();
    let requestTokens = new Map();
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.Message.isResponse(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.Message.isRequest(message)) {
                handleRequest(message);
            }
            else if (messages_1.Message.isNotification(message)) {
                handleNotification(message);
            }
            else if (messages_1.Message.isResponse(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.Message.isRequest(toCancel)) {
                    const strategy = options?.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        requestTokens.delete(cancelId);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                        return;
                    }
                }
                const cancellationToken = requestTokens.get(cancelId);
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = requestMessage.id ?? String(Date.now()); //
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            if (requestMessage.id !== null) {
                requestTokens.set(tokenKey, cancellationSource);
            }
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    requestTokens.delete(tokenKey);
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        requestTokens.delete(tokenKey);
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        requestTokens.delete(tokenKey);
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    requestTokens.delete(tokenKey);
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = responseMessage.id;
            const responsePromise = responsePromises.get(key);
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise !== undefined) {
                responsePromises.delete(key);
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers.get(message.method);
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        // There are JSON-RPC libraries that send progress message as positional params although
                        // specified as named. So convert them if this is the case.
                        const params = message.params;
                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                            notificationHandler({ token: params[0], value: params[1] });
                        }
                        else {
                            if (type !== undefined) {
                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                                }
                                if (type.numberOfParams !== message.params.length) {
                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                                }
                            }
                            notificationHandler(...params);
                        }
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = responseMessage.id;
            const responseHandler = responsePromises.get(key);
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function stringifyTrace(params) {
        if (params === undefined || params === null) {
            return undefined;
        }
        switch (trace) {
            case Trace.Verbose:
                return JSON.stringify(params, null, 4);
            case Trace.Compact:
                return JSON.stringify(params);
            default:
                return undefined;
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
                data = `Params: ${stringifyTrace(message.params)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.params) {
                    data = `Params: ${stringifyTrace(message.params)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose || trace === Trace.Compact) {
                if (message.error && message.error.data) {
                    data = `Error data: ${stringifyTrace(message.error.data)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${stringifyTrace(message.result)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers.set(type, { type: undefined, handler });
                }
                else {
                    method = type.method;
                    notificationHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        notificationHandlers.delete(method);
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    const p = cancellationStrategy.sender.sendCancellation(connection, id);
                    if (p === undefined) {
                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                        return Promise.resolve();
                    }
                    else {
                        return p.catch(() => {
                            logger.log(`Sending cancellation messages for id ${id} failed`);
                        });
                    }
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable?.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises.set(id, responsePromise);
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers.set(type, { handler: handler, type: undefined });
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers.set(type.method, { type, handler });
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        requestHandlers.delete(method);
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        hasPendingResponse: () => {
            return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');
            for (const promise of responsePromises.values()) {
                promise.reject(error);
            }
            responsePromises = new Map();
            requestTokens = new Map();
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            (0, ral_1.default)().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 3911:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ 2320:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(147);
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ 7574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 6184:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        return this._head?.value;
    }
    get last() {
        return this._tail?.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ 5530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ 6525:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const events_1 = __webpack_require__(2320);
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options ?? 'utf-8';
        }
        else {
            charset = options.charset ?? 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ 6654:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(147);
const Is = __webpack_require__(7574);
const semaphore_1 = __webpack_require__(142);
const events_1 = __webpack_require__(2320);
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        if (options === undefined || typeof options === 'string') {
            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        }
        else {
            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ 839:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(7574);
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = -32099;
    /**
     * An error occurred when write a message to the transport layer.
     */
    ErrorCodes.MessageWriteError = -32099;
    /**
     * An error occurred when reading a message from the transport layer.
     */
    ErrorCodes.MessageReadError = -32098;
    /**
     * The connection got disposed or lost and all pending responses got
     * rejected.
     */
    ErrorCodes.PendingResponseRejected = -32097;
    /**
     * The connection is inactive and a use of it failed.
     */
    ErrorCodes.ConnectionInactive = -32096;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = -32000;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
var Message;
(function (Message) {
    /**
     * Tests if the given message is a request message
     */
    function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
    }
    Message.isRequest = isRequest;
    /**
     * Tests if the given message is a notification message
     */
    function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
    }
    Message.isNotification = isNotification;
    /**
     * Tests if the given message is a response message
     */
    function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
    }
    Message.isResponse = isResponse;
})(Message = exports.Message || (exports.Message = {}));
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ 142:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(147);
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ 4389:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(3034);
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(3870);
const path = __webpack_require__(1017);
const os = __webpack_require__(2037);
const crypto_1 = __webpack_require__(6113);
const net_1 = __webpack_require__(1808);
__exportStar(__webpack_require__(3870), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = (0, net_1.createConnection)(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, api_1.createMessageConnection)(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 3034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(147);
const util_1 = __webpack_require__(3837);
const disposable_1 = __webpack_require__(3911);
const messageBuffer_1 = __webpack_require__(5530);
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ 5028:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(4389);

/***/ }),

/***/ 5734:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticPullMode = exports.vsdiag = void 0;
__exportStar(__webpack_require__(273), exports);
__exportStar(__webpack_require__(8909), exports);
var diagnostic_1 = __webpack_require__(2570);
Object.defineProperty(exports, "vsdiag", ({ enumerable: true, get: function () { return diagnostic_1.vsdiag; } }));
Object.defineProperty(exports, "DiagnosticPullMode", ({ enumerable: true, get: function () { return diagnostic_1.DiagnosticPullMode; } }));
__exportStar(__webpack_require__(4384), exports);
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 5578:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyOutgoingCalls
            ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ 4384:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.BaseLanguageClient = exports.MessageTransports = exports.SuspendMode = exports.State = exports.CloseAction = exports.ErrorAction = exports.RevealOutputChannelOn = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const c2p = __webpack_require__(71);
const p2c = __webpack_require__(8785);
const Is = __webpack_require__(9763);
const async_1 = __webpack_require__(4904);
const UUID = __webpack_require__(1980);
const progressPart_1 = __webpack_require__(8071);
const features_1 = __webpack_require__(8909);
const diagnostic_1 = __webpack_require__(2570);
const notebook_1 = __webpack_require__(203);
const configuration_1 = __webpack_require__(6495);
const textSynchronization_1 = __webpack_require__(743);
const completion_1 = __webpack_require__(1435);
const hover_1 = __webpack_require__(6782);
const definition_1 = __webpack_require__(122);
const signatureHelp_1 = __webpack_require__(2908);
const documentHighlight_1 = __webpack_require__(9959);
const documentSymbol_1 = __webpack_require__(2483);
const workspaceSymbol_1 = __webpack_require__(3051);
const reference_1 = __webpack_require__(8480);
const codeAction_1 = __webpack_require__(9474);
const codeLens_1 = __webpack_require__(7711);
const formatting_1 = __webpack_require__(6426);
const rename_1 = __webpack_require__(6458);
const documentLink_1 = __webpack_require__(3471);
const executeCommand_1 = __webpack_require__(4849);
const fileSystemWatcher_1 = __webpack_require__(5338);
const colorProvider_1 = __webpack_require__(3069);
const implementation_1 = __webpack_require__(9889);
const typeDefinition_1 = __webpack_require__(328);
const workspaceFolder_1 = __webpack_require__(5941);
const foldingRange_1 = __webpack_require__(6454);
const declaration_1 = __webpack_require__(707);
const selectionRange_1 = __webpack_require__(750);
const progress_1 = __webpack_require__(3603);
const callHierarchy_1 = __webpack_require__(5578);
const semanticTokens_1 = __webpack_require__(8961);
const fileOperations_1 = __webpack_require__(8406);
const linkedEditingRange_1 = __webpack_require__(3483);
const typeHierarchy_1 = __webpack_require__(4175);
const inlineValue_1 = __webpack_require__(5098);
const inlayHint_1 = __webpack_require__(6190);
/**
 * Controls when the output channel is revealed.
 */
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
/**
 * Signals in which state the language client is in.
 */
var State;
(function (State) {
    /**
     * The client is stopped or got never started.
     */
    State[State["Stopped"] = 1] = "Stopped";
    /**
     * The client is starting but not ready yet.
     */
    State[State["Starting"] = 3] = "Starting";
    /**
     * The client is running and ready.
     */
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var SuspendMode;
(function (SuspendMode) {
    /**
     * Don't allow suspend mode.
     */
    SuspendMode["off"] = "off";
    /**
     * Support suspend mode even if not all
     * registered providers have a corresponding
     * activation listener.
     */
    SuspendMode["on"] = "on";
})(SuspendMode = exports.SuspendMode || (exports.SuspendMode = {}));
class DefaultErrorHandler {
    constructor(client, maxRestartCount) {
        this.client = client;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return { action: ErrorAction.Continue };
        }
        return { action: ErrorAction.Shutdown };
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
            return { action: CloseAction.Restart };
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                return { action: CloseAction.DoNotRestart, message: `The ${this.client.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted. See the output for more information.` };
            }
            else {
                this.restarts.shift();
                return { action: CloseAction.Restart };
            }
        }
    }
}
var ClientState;
(function (ClientState) {
    ClientState["Initial"] = "initial";
    ClientState["Starting"] = "starting";
    ClientState["StartFailed"] = "startFailed";
    ClientState["Running"] = "running";
    ClientState["Stopping"] = "stopping";
    ClientState["Stopped"] = "stopped";
})(ClientState || (ClientState = {}));
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._diagnosticQueue = new Map();
        this._diagnosticQueueState = { state: 'idle' };
        this._features = [];
        this._dynamicFeatures = new Map();
        this.workspaceEditLock = new async_1.Semaphore(1);
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false, supportHtml: false };
        if (clientOptions.markdown !== undefined) {
            markdown.isTrusted = clientOptions.markdown.isTrusted === true;
            markdown.supportHtml = clientOptions.markdown.supportHtml === true;
        }
        // const defaultInterval = (clientOptions as TestOptions).$testMode ? 50 : 60000;
        this._clientOptions = {
            documentSelector: clientOptions.documentSelector ?? [],
            synchronize: clientOptions.synchronize ?? {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: clientOptions.outputChannelName ?? this._name,
            revealOutputChannelOn: clientOptions.revealOutputChannelOn ?? RevealOutputChannelOn.Error,
            stdioEncoding: clientOptions.stdioEncoding ?? 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: clientOptions.errorHandler ?? this.createDefaultErrorHandler(clientOptions.connectionOptions?.maxRestartCount),
            middleware: clientOptions.middleware ?? {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            // suspend: {
            // 	mode: clientOptions.suspend?.mode ?? SuspendMode.off,
            // 	callback: clientOptions.suspend?.callback ?? (() => Promise.resolve(true)),
            // 	interval: clientOptions.suspend?.interval ? Math.max(clientOptions.suspend.interval, defaultInterval) : defaultInterval
            // },
            diagnosticPullOptions: clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false },
            notebookDocumentOptions: clientOptions.notebookDocumentOptions ?? {}
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._ignoredRegistrations = new Set();
        this._listeners = [];
        this._notificationHandlers = new Map();
        this._pendingNotificationHandlers = new Map();
        this._notificationDisposables = new Map();
        this._requestHandlers = new Map();
        this._pendingRequestHandlers = new Map();
        this._requestDisposables = new Map();
        this._progressHandlers = new Map();
        this._pendingProgressHandlers = new Map();
        this._progressDisposables = new Map();
        this._connection = undefined;
        // this._idleStart = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined, this._clientOptions.markdown.isTrusted, this._clientOptions.markdown.supportHtml);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get name() {
        return this._name;
    }
    get middleware() {
        return this._clientOptions.middleware ?? Object.create(null);
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    get state() {
        return this.getPublicState();
    }
    get $state() {
        return this._state;
    }
    set $state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        switch (this.$state) {
            case ClientState.Starting:
                return State.Starting;
            case ClientState.Running:
                return State.Running;
            default:
                return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    async sendRequest(type, ...params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._requestHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._requestDisposables.set(method, connection.onRequest(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingRequestHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingRequestHandlers.delete(method);
                    const disposable = this._requestDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._requestDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._requestHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendNotification(type, params) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            await this.forceDocumentSync();
            return connection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        const method = typeof type === 'string' ? type : type.method;
        this._notificationHandlers.set(method, handler);
        const connection = this.activeConnection();
        let disposable;
        if (connection !== undefined) {
            this._notificationDisposables.set(method, connection.onNotification(type, handler));
            disposable = {
                dispose: () => {
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        else {
            this._pendingNotificationHandlers.set(method, handler);
            disposable = {
                dispose: () => {
                    this._pendingNotificationHandlers.delete(method);
                    const disposable = this._notificationDisposables.get(method);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._notificationDisposables.delete(method);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._notificationHandlers.delete(method);
                disposable.dispose();
            }
        };
    }
    async sendProgress(type, token, value) {
        if (this.$state === ClientState.StartFailed || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped) {
            return Promise.reject(new vscode_languageserver_protocol_1.ResponseError(vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive, `Client is not running`));
        }
        try {
            // Ensure we have a connection before we force the document sync.
            const connection = await this.$start();
            return connection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        this._progressHandlers.set(token, { type, handler });
        const connection = this.activeConnection();
        let disposable;
        const handleWorkDoneProgress = this._clientOptions.middleware?.handleWorkDoneProgress;
        const realHandler = vscode_languageserver_protocol_1.WorkDoneProgress.is(type) && handleWorkDoneProgress !== undefined
            ? (params) => {
                handleWorkDoneProgress(token, params, () => handler(params));
            }
            : handler;
        if (connection !== undefined) {
            this._progressDisposables.set(token, connection.onProgress(type, token, realHandler));
            disposable = {
                dispose: () => {
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        else {
            this._pendingProgressHandlers.set(token, { type, handler });
            disposable = {
                dispose: () => {
                    this._pendingProgressHandlers.delete(token);
                    const disposable = this._progressDisposables.get(token);
                    if (disposable !== undefined) {
                        disposable.dispose();
                        this._progressDisposables.delete(token);
                    }
                }
            };
        }
        return {
            dispose: () => {
                this._progressHandlers.delete(token);
                disposable.dispose();
            }
        };
    }
    createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== undefined && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this, maxRestartCount ?? 4);
    }
    async setTrace(value) {
        this._trace = value;
        const connection = this.activeConnection();
        if (connection !== undefined) {
            await connection.trace(this._trace, this._tracer, {
                sendNotification: false,
                traceFormat: this._traceFormat
            });
        }
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Info, message);
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Warning, message);
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification === 'force' || (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error)) {
            this.showNotificationMessage(vscode_languageserver_protocol_1.MessageType.Error, message);
        }
    }
    showNotificationMessage(type, message) {
        message = message ?? 'A request has failed. See the output for more information.';
        const messageFunc = type === vscode_languageserver_protocol_1.MessageType.Error
            ? vscode_1.window.showErrorMessage
            : type === vscode_languageserver_protocol_1.MessageType.Warning
                ? vscode_1.window.showWarningMessage
                : vscode_1.window.showInformationMessage;
        void messageFunc(message, 'Go to output').then((selection) => {
            if (selection !== undefined) {
                this.outputChannel.show(true);
            }
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.$state === ClientState.Initial || this.$state === ClientState.Stopping || this.$state === ClientState.Stopped;
    }
    needsStop() {
        return this.$state === ClientState.Starting || this.$state === ClientState.Running;
    }
    activeConnection() {
        return this.$state === ClientState.Running && this._connection !== undefined ? this._connection : undefined;
    }
    isRunning() {
        return this.$state === ClientState.Running;
    }
    async start() {
        if (this._disposed === 'disposing' || this._disposed === 'disposed') {
            throw new Error(`Client got disposed and can't be restarted.`);
        }
        if (this.$state === ClientState.Stopping) {
            throw new Error(`Client is currently stopping. Can only restart a full stopped client`);
        }
        // We are already running or are in the process of getting up
        // to speed.
        if (this._onStart !== undefined) {
            return this._onStart;
        }
        const [promise, resolve, reject] = this.createOnStartPromise();
        this._onStart = promise;
        // If we restart then the diagnostics collection is reused.
        if (this._diagnostics === undefined) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        // When we start make all buffer handlers pending so that they
        // get added.
        for (const [method, handler] of this._notificationHandlers) {
            if (!this._pendingNotificationHandlers.has(method)) {
                this._pendingNotificationHandlers.set(method, handler);
            }
        }
        for (const [method, handler] of this._requestHandlers) {
            if (!this._pendingRequestHandlers.has(method)) {
                this._pendingRequestHandlers.set(method, handler);
            }
        }
        for (const [token, data] of this._progressHandlers) {
            if (!this._pendingProgressHandlers.has(token)) {
                this._pendingProgressHandlers.set(token, data);
            }
        }
        this.$state = ClientState.Starting;
        try {
            const connection = await this.createConnection();
            connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, (message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        void vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        void vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        void vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        void vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, (data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
                const showDocument = async (params) => {
                    const uri = this.protocol2CodeConverter.asUri(params.uri);
                    try {
                        if (params.external === true) {
                            const success = await vscode_1.env.openExternal(uri);
                            return { success };
                        }
                        else {
                            const options = {};
                            if (params.selection !== undefined) {
                                options.selection = this.protocol2CodeConverter.asRange(params.selection);
                            }
                            if (params.takeFocus === undefined || params.takeFocus === false) {
                                options.preserveFocus = true;
                            }
                            else if (params.takeFocus === true) {
                                options.preserveFocus = false;
                            }
                            await vscode_1.window.showTextDocument(uri, options);
                            return { success: true };
                        }
                    }
                    catch (error) {
                        return { success: false };
                    }
                };
                const middleware = this._clientOptions.middleware.window?.showDocument;
                if (middleware !== undefined) {
                    return middleware(params, showDocument);
                }
                else {
                    return showDocument(params);
                }
            });
            connection.listen();
            await this.initialize(connection);
            resolve();
        }
        catch (error) {
            this.$state = ClientState.StartFailed;
            this.error(`${this._name} client: couldn't create connection to server.`, error, 'force');
            reject(error);
        }
        return this._onStart;
    }
    createOnStartPromise() {
        let resolve;
        let reject;
        const promise = new Promise((_resolve, _reject) => {
            resolve = _resolve;
            reject = _reject;
        });
        return [promise, resolve, reject];
    }
    async initialize(connection) {
        this.refreshTrace(connection, false);
        const initOption = this._clientOptions.initializationOptions;
        // If the client is locked to a workspace folder use it. In this case the workspace folder
        // feature is not registered and we need to initialize the value here.
        const [rootPath, workspaceFolders] = this._clientOptions.workspaceFolder !== undefined
            ? [this._clientOptions.workspaceFolder.uri.fsPath, [{ uri: this._c2p.asUri(this._clientOptions.workspaceFolder.uri), name: this._clientOptions.workspaceFolder.name }]]
            : [this._clientGetRootPath(), null];
        const initParams = {
            processId: null,
            clientInfo: {
                name: vscode_1.env.appName,
                version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: workspaceFolders
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            try {
                const result = await this.doInitialize(connection, initParams);
                part.done();
                return result;
            }
            catch (error) {
                part.cancel();
                throw error;
            }
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    async doInitialize(connection, initParams) {
        try {
            const result = await connection.initialize(initParams);
            if (result.capabilities.positionEncoding !== undefined && result.capabilities.positionEncoding !== vscode_languageserver_protocol_1.PositionEncodingKind.UTF16) {
                throw new Error(`Unsupported position encoding (${result.capabilities.positionEncoding}) received from server ${this.name}`);
            }
            this._initializeResult = result;
            this.$state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            // Add pending notification, request and progress handlers.
            for (const [method, handler] of this._pendingNotificationHandlers) {
                this._notificationDisposables.set(method, connection.onNotification(method, handler));
            }
            this._pendingNotificationHandlers.clear();
            for (const [method, handler] of this._pendingRequestHandlers) {
                this._requestDisposables.set(method, connection.onRequest(method, handler));
            }
            this._pendingRequestHandlers.clear();
            for (const [token, data] of this._pendingProgressHandlers) {
                this._progressDisposables.set(token, connection.onProgress(data.type, token, data.handler));
            }
            this._pendingProgressHandlers.clear();
            // if (this._clientOptions.suspend.mode !== SuspendMode.off) {
            // 	this._idleInterval =  RAL().timer.setInterval(() => this.checkSuspend(), this._clientOptions.suspend.interval);
            // }
            await connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            return result;
        }
        catch (error) {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    void this.initialize(connection);
                }
                else {
                    void this.stop();
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                void vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        void this.initialize(connection);
                    }
                    else {
                        void this.stop();
                    }
                });
            }
            else {
                if (error && error.message) {
                    void vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                void this.stop();
            }
            throw error;
        }
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop(timeout = 2000) {
        // Wait 2 seconds on stop
        return this.shutdown('stop', timeout);
    }
    dispose(timeout = 2000) {
        try {
            this._disposed = 'disposing';
            return this.stop(timeout);
        }
        finally {
            this._disposed = 'disposed';
        }
    }
    async shutdown(mode, timeout) {
        // If the client is stopped or in its initial state return.
        if (this.$state === ClientState.Stopped || this.$state === ClientState.Initial) {
            return;
        }
        // If we are stopping the client and have a stop promise return it.
        if (this.$state === ClientState.Stopping) {
            if (this._onStop !== undefined) {
                return this._onStop;
            }
            else {
                throw new Error(`Client is stopping but no stop promise available.`);
            }
        }
        const connection = this.activeConnection();
        // We can't stop a client that is not running (e.g. has no connection). Especially not
        // on that us starting since it can't be correctly synchronized.
        if (connection === undefined || this.$state !== ClientState.Running) {
            throw new Error(`Client is not running and can't be stopped. It's current state is: ${this.$state}`);
        }
        this._initializeResult = undefined;
        this.$state = ClientState.Stopping;
        this.cleanUp(mode);
        const tp = new Promise(c => { (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(c, timeout); });
        const shutdown = (async (connection) => {
            await connection.shutdown();
            await connection.exit();
            return connection;
        })(connection);
        return this._onStop = Promise.race([tp, shutdown]).then((connection) => {
            // The connection won the race with the timeout.
            if (connection !== undefined) {
                connection.end();
                connection.dispose();
            }
            else {
                this.error(`Stopping server timed out`, undefined, false);
                throw new Error(`Stopping the server timed out`);
            }
        }, (error) => {
            this.error(`Stopping server failed`, error, false);
            throw error;
        }).finally(() => {
            this.$state = ClientState.Stopped;
            mode === 'stop' && this.cleanUpChannel();
            this._onStart = undefined;
            this._onStop = undefined;
            this._connection = undefined;
            this._ignoredRegistrations.clear();
        });
    }
    cleanUp(mode) {
        // purge outstanding file events.
        this._fileEvents = [];
        this._fileEventDelayer.cancel();
        const disposables = this._listeners.splice(0, this._listeners.length);
        for (const disposable of disposables) {
            disposable.dispose();
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        // Dispose features in reverse order;
        for (const feature of Array.from(this._features.entries()).map(entry => entry[1]).reverse()) {
            feature.dispose();
        }
        if (mode === 'stop' && this._diagnostics !== undefined) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
        if (this._idleInterval !== undefined) {
            this._idleInterval.dispose();
            this._idleInterval = undefined;
        }
        // this._idleStart = undefined;
    }
    cleanUpChannel() {
        if (this._outputChannel !== undefined && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        const client = this;
        async function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            return client._fileEventDelayer.trigger(async () => {
                const connection = await client.$start();
                await client.forceDocumentSync();
                const result = connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, { changes: client._fileEvents });
                client._fileEvents = [];
                return result;
            });
        }
        const workSpaceMiddleware = this.clientOptions.middleware?.workspace;
        (workSpaceMiddleware?.didChangeWatchedFile ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event)).catch((error) => {
            client.error(`Notify file events failed.`, error);
        });
    }
    async forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === undefined) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        return this._didChangeTextDocumentFeature.forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        const key = params.uri;
        if (this._diagnosticQueueState.state === 'busy' && this._diagnosticQueueState.document === key) {
            // Cancel the active run;
            this._diagnosticQueueState.tokenSource.cancel();
        }
        this._diagnosticQueue.set(params.uri, params.diagnostics);
        this.triggerDiagnosticQueue();
    }
    triggerDiagnosticQueue() {
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => { this.workDiagnosticQueue(); });
    }
    workDiagnosticQueue() {
        if (this._diagnosticQueueState.state === 'busy') {
            return;
        }
        const next = this._diagnosticQueue.entries().next();
        if (next.done === true) {
            // Nothing in the queue
            return;
        }
        const [document, diagnostics] = next.value;
        this._diagnosticQueue.delete(document);
        const tokenSource = new vscode_1.CancellationTokenSource();
        this._diagnosticQueueState = { state: 'busy', document: document, tokenSource };
        this._p2c.asDiagnostics(diagnostics, tokenSource.token).then((converted) => {
            if (!tokenSource.token.isCancellationRequested) {
                const uri = this._p2c.asUri(document);
                const middleware = this.clientOptions.middleware;
                if (middleware.handleDiagnostics) {
                    middleware.handleDiagnostics(uri, converted, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
                }
                else {
                    this.setDiagnostics(uri, converted);
                }
            }
        }).finally(() => {
            this._diagnosticQueueState = { state: 'idle' };
            this.triggerDiagnosticQueue();
        });
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    async $start() {
        if (this.$state === ClientState.StartFailed) {
            throw new Error(`Previous start failed. Can't restart server.`);
        }
        await this.start();
        const connection = this.activeConnection();
        if (connection === undefined) {
            throw new Error(`Starting server failed`);
        }
        return connection;
    }
    async createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        const transports = await this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8');
        this._connection = createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        return this._connection;
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.$state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._connection !== undefined) {
                this._connection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let handlerResult = { action: CloseAction.DoNotRestart };
        if (this.$state !== ClientState.Stopping) {
            try {
                handlerResult = this._clientOptions.errorHandler.closed();
            }
            catch (error) {
                // Ignore errors coming from the error handler.
            }
        }
        this._connection = undefined;
        if (handlerResult.action === CloseAction.DoNotRestart) {
            this.error(handlerResult.message ?? 'Connection to server got closed. Server will not be restarted.', undefined, 'force');
            this.cleanUp('stop');
            if (this.$state === ClientState.Starting) {
                this.$state = ClientState.StartFailed;
            }
            else {
                this.$state = ClientState.Stopped;
            }
            this._onStop = Promise.resolve();
            this._onStart = undefined;
        }
        else if (handlerResult.action === CloseAction.Restart) {
            this.info(handlerResult.message ?? 'Connection to server got closed. Server will restart.');
            this.cleanUp('restart');
            this.$state = ClientState.Initial;
            this._onStop = Promise.resolve();
            this._onStart = undefined;
            this.start().catch((error) => this.error(`Restarting server failed`, error, 'force'));
        }
    }
    handleConnectionError(error, message, count) {
        const handlerResult = this._clientOptions.errorHandler.error(error, message, count);
        if (handlerResult.action === ErrorAction.Shutdown) {
            this.error(handlerResult.message ?? `Client ${this._name}: connection to server is erroring. Shutting down server.`, undefined, 'force');
            this.stop().catch((error) => {
                this.error(`Stopping server failed`, error, false);
            });
        }
    }
    hookConfigurationChanged(connection) {
        this._listeners.push(vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        }));
    }
    refreshTrace(connection, sendNotification = false) {
        const config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        }).catch((error) => { this.error(`Updating trace failed with error`, error, false); });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (features_1.DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    hasDedicatedTextSynchronizationFeature(textDocument) {
        const feature = this.getFeature(vscode_languageserver_protocol_1.NotebookDocumentSyncRegistrationType.method);
        if (feature === undefined || !(feature instanceof notebook_1.NotebookDocumentSyncFeature)) {
            return false;
        }
        return feature.handles(textDocument);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new textSynchronization_1.DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new textSynchronization_1.DidChangeTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveFeature(this));
        this.registerFeature(new textSynchronization_1.WillSaveWaitUntilFeature(this));
        this.registerFeature(new textSynchronization_1.DidSaveTextDocumentFeature(this));
        this.registerFeature(new textSynchronization_1.DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new fileSystemWatcher_1.FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new completion_1.CompletionItemFeature(this));
        this.registerFeature(new hover_1.HoverFeature(this));
        this.registerFeature(new signatureHelp_1.SignatureHelpFeature(this));
        this.registerFeature(new definition_1.DefinitionFeature(this));
        this.registerFeature(new reference_1.ReferencesFeature(this));
        this.registerFeature(new documentHighlight_1.DocumentHighlightFeature(this));
        this.registerFeature(new documentSymbol_1.DocumentSymbolFeature(this));
        this.registerFeature(new workspaceSymbol_1.WorkspaceSymbolFeature(this));
        this.registerFeature(new codeAction_1.CodeActionFeature(this));
        this.registerFeature(new codeLens_1.CodeLensFeature(this));
        this.registerFeature(new formatting_1.DocumentFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentRangeFormattingFeature(this));
        this.registerFeature(new formatting_1.DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new rename_1.RenameFeature(this));
        this.registerFeature(new documentLink_1.DocumentLinkFeature(this));
        this.registerFeature(new executeCommand_1.ExecuteCommandFeature(this));
        this.registerFeature(new configuration_1.SyncConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        // We only register the workspace folder feature if the client is not locked
        // to a specific workspace folder.
        if (this.clientOptions.workspaceFolder === undefined) {
            this.registerFeature(new workspaceFolder_1.WorkspaceFoldersFeature(this));
        }
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
        this.registerFeature(new typeHierarchy_1.TypeHierarchyFeature(this));
        this.registerFeature(new inlineValue_1.InlineValueFeature(this));
        this.registerFeature(new inlayHint_1.InlayHintsFeature(this));
        this.registerFeature(new diagnostic_1.DiagnosticFeature(this));
        this.registerFeature(new notebook_1.NotebookDocumentSyncFeature(this));
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        (0, features_1.ensure)(result, 'workspace').applyEdit = true;
        const workspaceEdit = (0, features_1.ensure)((0, features_1.ensure)(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
        };
        const diagnostics = (0, features_1.ensure)((0, features_1.ensure)(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = (0, features_1.ensure)(result, 'window');
        const showMessage = (0, features_1.ensure)(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = (0, features_1.ensure)(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = (0, features_1.ensure)(result, 'general');
        generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = {
            parser: 'marked',
            version: '1.1.0',
        };
        generalCapabilities.positionEncodings = ['utf-16'];
        if (this._clientOptions.markdown.supportHtml) {
            generalCapabilities.markdown.allowedTags = ['ul', 'li', 'p', 'code', 'blockquote', 'ol', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'em', 'pre', 'table', 'thead', 'tbody', 'tr', 'th', 'td', 'div', 'del', 'a', 'strong', 'br', 'img', 'span'];
        }
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        const documentSelector = this._clientOptions.documentSelector;
        for (const feature of this._features) {
            if (Is.func(feature.preInitialize)) {
                feature.preInitialize(this._capabilities, documentSelector);
            }
        }
        for (const feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    async handleRegistrationRequest(params) {
        // We will not receive a registration call before a client is running
        // from a server. However if we stop or shutdown we might which might
        // try to restart the server. So ignore registrations if we are not running
        if (!this.isRunning()) {
            for (const registration of params.registrations) {
                this._ignoredRegistrations.add(registration.id);
            }
            return;
        }
        for (const registration of params.registrations) {
            const feature = this._dynamicFeatures.get(registration.method);
            if (feature === undefined) {
                return Promise.reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
            }
            const options = registration.registerOptions ?? {};
            options.documentSelector = options.documentSelector ?? this._clientOptions.documentSelector;
            const data = {
                id: registration.id,
                registerOptions: options
            };
            try {
                feature.register(data);
            }
            catch (err) {
                return Promise.reject(err);
            }
        }
    }
    async handleUnregistrationRequest(params) {
        for (let unregistration of params.unregisterations) {
            if (this._ignoredRegistrations.has(unregistration.id)) {
                continue;
            }
            const feature = this._dynamicFeatures.get(unregistration.method);
            if (!feature) {
                return Promise.reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
            }
            feature.unregister(unregistration.id);
        }
    }
    async handleApplyWorkspaceEdit(params) {
        const workspaceEdit = params.edit;
        // Make sure we convert workspace edits one after the other. Otherwise
        // we might execute a workspace edit received first after we received another
        // one since the conversion might race.
        const converted = await this.workspaceEditLock.lock(() => {
            return this._p2c.asWorkspaceEdit(workspaceEdit);
        });
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        const openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    const textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(converted).then((value) => { return { applied: value }; }));
    }
    handleFailedRequest(type, token, error, defaultValue, showNotification = true) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            // The connection got disposed while we were waiting for a response.
            // Simply return the default value. Is the best we can do.
            if (error.code === vscode_languageserver_protocol_1.ErrorCodes.PendingResponseRejected || error.code === vscode_languageserver_protocol_1.ErrorCodes.ConnectionInactive) {
                return defaultValue;
            }
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
                if (token !== undefined && token.isCancellationRequested) {
                    return defaultValue;
                }
                else {
                    if (error.data !== undefined) {
                        throw new features_1.LSPCancellationError(error.data);
                    }
                    else {
                        throw new vscode_1.CancellationError();
                    }
                }
            }
            else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
                if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                    throw new vscode_1.CancellationError();
                }
                else {
                    return defaultValue;
                }
            }
        }
        this.error(`Request ${type.method} failed.`, error, showNotification);
        throw error;
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.RequestsToCancelOnContentModified = new Set([
    vscode_languageserver_protocol_1.SemanticTokensRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
]);
class ConsoleLogger {
    error(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.error(message);
    }
    warn(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.warn(message);
    }
    info(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.info(message);
    }
    log(message) {
        (0, vscode_languageserver_protocol_1.RAL)().console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler, options) {
    let _lastUsed = -1;
    const logger = new ConsoleLogger();
    const connection = (0, vscode_languageserver_protocol_1.createProtocolConnection)(input, output, logger, options);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    const result = {
        get lastUsed() {
            return _lastUsed;
        },
        resetLastUsed: () => {
            _lastUsed = -1;
        },
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(type, ...params);
        },
        onRequest: (type, handler) => connection.onRequest(type, handler),
        hasPendingResponse: () => connection.hasPendingResponse(),
        sendNotification: (type, params) => {
            _lastUsed = Date.now();
            return connection.sendNotification(type, params);
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === undefined) {
                return connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                return connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params);
        },
        shutdown: () => {
            _lastUsed = Date.now();
            return connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined);
        },
        exit: () => {
            _lastUsed = Date.now();
            return connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type);
        },
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
// Exporting proposed protocol.
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=client.js.map

/***/ }),

/***/ 9474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeActionFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
class CodeActionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const cap = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        // We can only resolve the edit property.
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
        cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = async (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: await client.code2ProtocolConverter.asCodeActionContext(context, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (token.isCancellationRequested || values === null || values === undefined) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeActionResult(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCodeAction = async (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, await client.code2ProtocolConverter.asCodeAction(item, token), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return item;
                            }
                            return client.protocol2CodeConverter.asCodeAction(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeActionsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
exports.CodeActionFeature = CodeActionFeature;
//# sourceMappingURL=codeAction.js.map

/***/ }),

/***/ 71:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(9496);
const proto = __webpack_require__(273);
const Is = __webpack_require__(9763);
const async = __webpack_require__(4904);
const protocolCompletionItem_1 = __webpack_require__(1807);
const protocolCodeLens_1 = __webpack_require__(583);
const protocolDocumentLink_1 = __webpack_require__(8705);
const protocolCodeAction_1 = __webpack_require__(6434);
const protocolDiagnostic_1 = __webpack_require__(6640);
const protocolCallHierarchyItem_1 = __webpack_require__(8714);
const protocolTypeHierarchyItem_1 = __webpack_require__(1365);
const protocolWorkspaceSymbol_1 = __webpack_require__(3912);
const protocolInlayHint_1 = __webpack_require__(1065);
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asTextDocumentItem(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            languageId: textDocument.languageId,
            version: textDocument.version,
            text: textDocument.getText()
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentItem(textDocument)
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.line, character: value.character > proto.uinteger.MAX_VALUE ? proto.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value, token) {
        return async.map(value, asPosition, token);
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items, token) {
        if (items === undefined || items === null) {
            return items;
        }
        return async.map(items, asDiagnostic, token);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
        let label;
        let labelDetails;
        if (Is.string(item.label)) {
            label = item.label;
        }
        else {
            label = item.label.label;
            if (labelDetailsSupport && (item.label.detail !== undefined || item.label.description !== undefined)) {
                labelDetails = { detail: item.label.detail, description: item.label.description };
            }
        }
        let result = { label: label };
        if (labelDetails !== undefined) {
            result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = proto.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    async function asCodeAction(item, token) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = await asDiagnostics(item.diagnostics, token);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    async function asCodeActionContext(context, token) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(await asDiagnostics(context.diagnostics, token), only, asCodeActionTriggerKind(context.triggerKind));
    }
    function asCodeActionTriggerKind(kind) {
        switch (kind) {
            case code.CodeActionTriggerKind.Invoke:
                return proto.CodeActionTriggerKind.Invoked;
            case code.CodeActionTriggerKind.Automatic:
                return proto.CodeActionTriggerKind.Automatic;
            default:
                return undefined;
        }
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asInlineValueContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        return proto.InlineValueContext.create(context.frameId, asRange(context.stoppedLocation));
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asTypeHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange),
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolTypeHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asWorkspaceSymbol(item) {
        const result = item instanceof protocolWorkspaceSymbol_1.default
            ? { name: item.name, kind: asSymbolKind(item.kind), location: item.hasRange ? asLocation(item.location) : { uri: _uriConverter(item.location.uri) }, data: item.data }
            : { name: item.name, kind: asSymbolKind(item.kind), location: asLocation(item.location) };
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        if (item.containerName !== '') {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asInlayHint(item) {
        const label = typeof item.label === 'string'
            ? item.label
            : item.label.map(asInlayHintLabelPart);
        const result = proto.InlayHint.create(asPosition(item.position), label);
        if (item.kind !== undefined) {
            result.kind = item.kind;
        }
        if (item.textEdits !== undefined) {
            result.textEdits = asTextEdits(item.textEdits);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        if (item.paddingLeft !== undefined) {
            result.paddingLeft = item.paddingLeft;
        }
        if (item.paddingRight !== undefined) {
            result.paddingRight = item.paddingRight;
        }
        if (item instanceof protocolInlayHint_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        return result;
    }
    function asInlayHintLabelPart(item) {
        const result = proto.InlayHintLabelPart.create(item.value);
        if (item.location !== undefined) {
            result.location = asLocation(item.location);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = asTooltip(item.tooltip);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        const result = {
            kind: proto.MarkupKind.Markdown,
            value: value.value
        };
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asTextDocumentItem,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asInlineValueContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem,
        asTypeHierarchyItem,
        asInlayHint,
        asWorkspaceSymbol
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=codeConverter.js.map

/***/ }),

/***/ 7711:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeLensFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
class CodeLensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCodeLenses(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return codeLens;
                            }
                            return client.protocol2CodeConverter.asCodeLens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token, error, codeLens);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
}
exports.CodeLensFeature = CodeLensFeature;
//# sourceMappingURL=codeLens.js.map

/***/ }),

/***/ 3069:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class ColorProviderFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorPresentations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return this._client.protocol2CodeConverter.asColorInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;
//# sourceMappingURL=colorProvider.js.map

/***/ }),

/***/ 1435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompletionItemFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
class CompletionItemFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = new Map();
    }
    fillClientCapabilities(capabilities) {
        let completion = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
                properties: ['documentation', 'detail', 'additionalTextEdits']
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
        completion.completionList = {
            itemDefaults: [
                'commitCharacters', 'editRange', 'insertTextFormat', 'insertTextMode'
            ]
        };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options, id) {
        this.labelDetailsSupport.set(id, !!options.completionItem?.labelDetailsSupport);
        const triggerCharacters = options.triggerCharacters ?? [];
        const defaultCommitCharacters = options.allCommitCharacters;
        const selector = options.documentSelector;
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asCompletionResult(result, defaultCommitCharacters, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token, error, null);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item, !!this.labelDetailsSupport.get(id)), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asCompletionItem(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, ...triggerCharacters), provider];
    }
}
exports.CompletionItemFeature = CompletionItemFeature;
//# sourceMappingURL=completion.js.map

/***/ }),

/***/ 6495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyncConfigurationFeature = exports.toJSONObject = exports.ConfigurationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const Is = __webpack_require__(9763);
const UUID = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
/**
 * Configuration pull model. From server to client.
 */
class ConfigurationFeature {
    constructor(client) {
        this._client = client;
    }
    getState() {
        return { kind: 'static' };
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = toJSONObject(vscode_1.workspace.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = toJSONObject(config.get(section.substr(index + 1)));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = toJSONObject(config.get(key));
                }
            }
        }
        if (result === undefined) {
            result = null;
        }
        return result;
    }
    dispose() {
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[key] = toJSONObject(obj[key]);
                }
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
class SyncConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize?.configurationSection;
        if (section !== undefined) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== undefined) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (const disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== undefined && event !== undefined) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        const didChangeConfiguration = async (sections) => {
            if (sections === undefined) {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
            }
            else {
                return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
            }
        };
        let middleware = this._client.middleware.workspace?.didChangeConfiguration;
        (middleware ? middleware(sections, didChangeConfiguration) : didChangeConfiguration(sections)).catch((error) => {
            this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type.method} failed`, error);
        });
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(undefined, resource).get(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = toJSONObject(config);
            }
        }
        return result;
    }
}
exports.SyncConfigurationFeature = SyncConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ 707:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class DeclarationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const declarationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDeclarationResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDeclarationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DeclarationFeature = DeclarationFeature;
//# sourceMappingURL=declaration.js.map

/***/ }),

/***/ 122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class DefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let definitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.DefinitionFeature = DefinitionFeature;
//# sourceMappingURL=definition.js.map

/***/ }),

/***/ 2570:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;
const minimatch = __webpack_require__(3415);
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const uuid_1 = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var vsdiag;
(function (vsdiag) {
    let DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind) {
        DocumentDiagnosticReportKind["full"] = "full";
        DocumentDiagnosticReportKind["unChanged"] = "unChanged";
    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));
})(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
var DiagnosticPullMode;
(function (DiagnosticPullMode) {
    DiagnosticPullMode["onType"] = "onType";
    DiagnosticPullMode["onSave"] = "onSave";
})(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
/**
 * Manages the open tabs. We don't directly use the tab API since for
 * diagnostics we need to de-dupe tabs that show the same resources since
 * we pull on the model not the UI.
 */
class Tabs {
    constructor() {
        this.open = new Set();
        this._onOpen = new vscode_1.EventEmitter();
        this._onClose = new vscode_1.EventEmitter();
        Tabs.fillTabResources(this.open);
        const openTabsHandler = (event) => {
            if (event.closed.length === 0 && event.opened.length === 0) {
                return;
            }
            const oldTabs = this.open;
            const currentTabs = new Set();
            Tabs.fillTabResources(currentTabs);
            const closed = new Set();
            const opened = new Set(currentTabs);
            for (const tab of oldTabs.values()) {
                if (currentTabs.has(tab)) {
                    opened.delete(tab);
                }
                else {
                    closed.add(tab);
                }
            }
            this.open = currentTabs;
            if (closed.size > 0) {
                const toFire = new Set();
                for (const item of closed) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onClose.fire(toFire);
            }
            if (opened.size > 0) {
                const toFire = new Set();
                for (const item of opened) {
                    toFire.add(vscode_1.Uri.parse(item));
                }
                this._onOpen.fire(toFire);
            }
        };
        if (vscode_1.window.tabGroups.onDidChangeTabs !== undefined) {
            this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);
        }
        else {
            this.disposable = { dispose: () => { } };
        }
    }
    get onClose() {
        return this._onClose.event;
    }
    get onOpen() {
        return this._onOpen.event;
    }
    dispose() {
        this.disposable.dispose();
    }
    isActive(document) {
        return document instanceof vscode_1.Uri
            ? vscode_1.window.activeTextEditor?.document.uri === document
            : vscode_1.window.activeTextEditor?.document === document;
    }
    isVisible(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        return this.open.has(uri.toString());
    }
    getTabResources() {
        const result = new Set();
        Tabs.fillTabResources(new Set(), result);
        return result;
    }
    static fillTabResources(strings, uris) {
        const seen = strings ?? new Set();
        for (const group of vscode_1.window.tabGroups.all) {
            for (const tab of group.tabs) {
                const input = tab.input;
                let uri;
                if (input instanceof vscode_1.TabInputText) {
                    uri = input.uri;
                }
                else if (input instanceof vscode_1.TabInputTextDiff) {
                    uri = input.modified;
                }
                if (uri !== undefined && !seen.has(uri.toString())) {
                    seen.add(uri.toString());
                    uris !== undefined && uris.add(uri);
                }
            }
        }
    }
}
var PullState;
(function (PullState) {
    PullState[PullState["document"] = 1] = "document";
    PullState[PullState["workspace"] = 2] = "workspace";
})(PullState || (PullState = {}));
class DocumentPullStateTracker {
    constructor() {
        this.documentPullStates = new Map();
        this.workspacePullStates = new Map();
    }
    track(kind, document, arg1) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1]
            : [document.uri.toString(), document.uri, document.version];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId: undefined };
            states.set(key, state);
        }
        return state;
    }
    update(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = document instanceof vscode_1.Uri
            ? [document.toString(), document, arg1, arg2]
            : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
        }
        else {
            state.pulledVersion = version;
            state.resultId = resultId;
        }
    }
    unTrack(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(key);
    }
    tracks(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
    }
    getResultId(kind, document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.get(key)?.resultId;
    }
    getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
                value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== undefined) {
                result.push({ uri, value: value.resultId });
            }
        }
        return result;
    }
}
class DiagnosticRequestor {
    constructor(client, tabs, options) {
        this.client = client;
        this.tabs = tabs;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
    }
    knows(kind, document) {
        return this.documentStates.tracks(kind, document);
    }
    forget(kind, document) {
        this.documentStates.unTrack(kind, document);
    }
    pull(document, cb) {
        if (this.isDisposed) {
            return;
        }
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        this.pullAsync(document).then(() => {
            if (cb) {
                cb();
            }
        }, (error) => {
            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);
        });
    }
    async pullAsync(document, version) {
        if (this.isDisposed) {
            return;
        }
        const isUri = document instanceof vscode_1.Uri;
        const uri = isUri ? document : document.uri;
        const key = uri.toString();
        version = isUri ? version : document.version;
        const currentRequestState = this.openRequests.get(key);
        const documentState = isUri
            ? this.documentStates.track(PullState.document, document, version)
            : this.documentStates.track(PullState.document, document);
        if (currentRequestState === undefined) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, document: document, version: version, tokenSource });
            let report;
            let afterState;
            try {
                report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            }
            catch (error) {
                if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, document };
                }
                if (afterState === undefined && error instanceof vscode_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, document };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState ?? this.openRequests.get(key);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
                this.diagnostics.delete(uri);
                return;
            }
            this.openRequests.delete(key);
            if (!this.tabs.isVisible(document)) {
                this.documentStates.unTrack(PullState.document, document);
                return;
            }
            if (afterState.state === RequestStateKind.outDated) {
                return;
            }
            // report is only undefined if the request has thrown.
            if (report !== undefined) {
                if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    this.diagnostics.set(uri, report.items);
                }
                documentState.pulledVersion = version;
                documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
                this.pull(document);
            }
        }
        else {
            if (currentRequestState.state === RequestStateKind.active) {
                // Cancel the current request and reschedule a new one when the old one returned.
                currentRequestState.tokenSource.cancel();
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
            else if (currentRequestState.state === RequestStateKind.outDated) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });
            }
        }
    }
    forgetDocument(document) {
        const uri = document instanceof vscode_1.Uri ? document : document.uri;
        const key = uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics) {
            // If we run workspace diagnostic pull a last time for the diagnostics
            // and the rely on getting them from the workspace result.
            if (request !== undefined) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document });
            }
            else {
                this.pull(document, () => {
                    this.forget(PullState.document, document);
                });
            }
        }
        else {
            // We have normal pull or inter file dependencies. In this case we
            // clear the diagnostics (to have the same start as after startup).
            // We also cancel outstanding requests.
            if (request !== undefined) {
                if (request.state === RequestStateKind.active) {
                    request.tokenSource.cancel();
                }
                this.openRequests.set(key, { state: RequestStateKind.outDated, document: document });
            }
            this.diagnostics.delete(uri);
            this.forget(PullState.document, document);
        }
    }
    pullWorkspace() {
        if (this.isDisposed) {
            return;
        }
        this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.pullWorkspace();
            }, 2000);
        }, (error) => {
            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {
                this.client.error(`Workspace diagnostic pull failed.`, error, false);
                this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
                this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                    this.pullWorkspace();
                }, 2000);
            }
        });
    }
    async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {
            return;
        }
        if (this.workspaceCancellation !== undefined) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = undefined;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
                uri: this.client.protocol2CodeConverter.asUri(item.uri),
                value: item.value
            };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            if (!chunk || this.isDisposed) {
                return;
            }
            for (const item of chunk.items) {
                if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    // Favour document pull result over workspace results. So skip if it is tracked
                    // as a document result.
                    if (!this.documentStates.tracks(PullState.document, item.uri)) {
                        this.diagnostics.set(item.uri, item.items);
                    }
                }
                this.documentStates.update(PullState.workspace, item.uri, item.version ?? undefined, item.resultId);
            }
        });
    }
    createProvider() {
        const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (document, previousResultId, token) => {
                const provideDiagnostics = (document, previousResultId, token) => {
                    const params = {
                        identifier: this.options.identifier,
                        textDocument: { uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri) },
                        previousResultId: previousResultId
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async (result) => {
                        if (result === undefined || result === null || this.isDisposed || token.isCancellationRequested) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                        }
                        if (result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token) };
                        }
                        else {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result.resultId };
                        }
                    }, (error) => {
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics)
                    : provideDiagnostics(document, previousResultId, token);
            }
        };
        if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
                const convertReport = async (report) => {
                    if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.full,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version,
                            items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)
                        };
                    }
                    else {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version
                        };
                    }
                };
                const convertPreviousResultIds = (resultIds) => {
                    const converted = [];
                    for (const item of resultIds) {
                        converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                    }
                    return converted;
                };
                const provideDiagnostics = (resultIds, token) => {
                    const partialResultToken = (0, uuid_1.generateUuid)();
                    const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {
                        if (partialResult === undefined || partialResult === null) {
                            resultReporter(null);
                            return;
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of partialResult.items) {
                            try {
                                converted.items.push(await convertReport(item));
                            }
                            catch (error) {
                                this.client.error(`Converting workspace diagnostics failed.`, error);
                            }
                        }
                        resultReporter(converted);
                    });
                    const params = {
                        identifier: this.options.identifier,
                        previousResultIds: convertPreviousResultIds(resultIds),
                        partialResultToken: partialResultToken
                    };
                    if (this.isDisposed === true || !this.client.isRunning()) {
                        return { items: [] };
                    }
                    return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async (result) => {
                        if (token.isCancellationRequested) {
                            return { items: [] };
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of result.items) {
                            converted.items.push(await convertReport(item));
                        }
                        disposable.dispose();
                        resultReporter(converted);
                        return { items: [] };
                    }, (error) => {
                        disposable.dispose();
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { items: [] });
                    });
                };
                const middleware = this.client.middleware;
                return middleware.provideWorkspaceDiagnostics
                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics)
                    : provideDiagnostics(resultIds, token, resultReporter);
            };
        }
        return result;
    }
    dispose() {
        this.isDisposed = true;
        // Cancel and clear workspace pull if present.
        this.workspaceCancellation?.cancel();
        this.workspaceTimeout?.dispose();
        // Cancel all request and mark open requests as outdated.
        for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });
        }
        // cleanup old diagnostics
        this.diagnostics.dispose();
    }
}
class BackgroundScheduler {
    constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
        this.isDisposed = false;
    }
    add(document) {
        if (this.isDisposed === true) {
            return;
        }
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        if (this.documents.has(key)) {
            return;
        }
        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
    }
    remove(document) {
        const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
        if (this.documents.has(key)) {
            this.documents.delete(key);
            // Do a last pull
            this.diagnosticRequestor.pull(document);
        }
        // No more documents. Stop background activity.
        if (this.documents.size === 0) {
            this.stop();
        }
        else if (document === this.endDocument) {
            // Make sure we have a correct last document. It could have
            this.endDocument = this.documents.last;
        }
    }
    trigger() {
        if (this.isDisposed === true) {
            return;
        }
        // We have a round running. So simply make sure we run up to the
        // last document
        if (this.intervalHandle !== undefined) {
            this.endDocument = this.documents.last;
            return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {
            const document = this.documents.first;
            if (document !== undefined) {
                const key = document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();
                this.diagnosticRequestor.pull(document);
                this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);
                if (document === this.endDocument) {
                    this.stop();
                }
            }
        }, 200);
    }
    dispose() {
        this.isDisposed = true;
        this.stop();
        this.documents.clear();
    }
    stop() {
        this.intervalHandle?.dispose();
        this.intervalHandle = undefined;
        this.endDocument = undefined;
    }
}
class DiagnosticFeatureProviderImpl {
    constructor(client, tabs, options) {
        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        const disposables = [];
        const matchResource = (resource) => {
            const selector = options.documentSelector;
            if (diagnosticPullOptions.match !== undefined) {
                return diagnosticPullOptions.match(selector, resource);
            }
            for (const filter of selector) {
                if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                    continue;
                }
                // The filter is a language id. We can't determine if it matches
                // so we return false.
                if (typeof filter === 'string') {
                    return false;
                }
                if (filter.language !== undefined && filter.language !== '*') {
                    return false;
                }
                if (filter.scheme !== undefined && filter.scheme !== '*' && filter.scheme !== resource.scheme) {
                    return false;
                }
                if (filter.pattern !== undefined) {
                    const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
                    if (!matcher.makeRe()) {
                        return false;
                    }
                    if (!matcher.match(resource.fsPath)) {
                        return false;
                    }
                }
            }
            return true;
        };
        const matches = (document) => {
            return document instanceof vscode_1.Uri
                ? matchResource(document)
                : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);
        };
        const isActiveDocument = (document) => {
            return document instanceof vscode_1.Uri
                ? this.activeTextDocument?.uri.toString() === document.toString()
                : this.activeTextDocument === document;
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (document) => {
            if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {
                return;
            }
            this.backgroundScheduler.add(document);
        };
        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor?.document;
            if (oldActive !== undefined) {
                addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== undefined) {
                this.backgroundScheduler.remove(this.activeTextDocument);
            }
        });
        // For pull model diagnostics we pull for documents visible in the UI.
        // From an eventing point of view we still rely on open document events
        // and filter the documents that are not visible in the UI instead of
        // listening to Tab events. Major reason is event timing since we need
        // to ensure that the pull is send after the document open has reached
        // the server.
        // We always pull on open.
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }));
        // Pull all diagnostics for documents that are already open
        const pulledTextDocuments = new Set();
        for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
                pulledTextDocuments.add(textDocument.uri.toString());
            }
        }
        // Pull all tabs if not already pulled as text document
        if (diagnosticPullOptions.onTabs === true) {
            for (const resource of tabs.getTabResources()) {
                if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {
                    this.diagnosticRequestor.pull(resource, () => { addToBackgroundIfNeeded(resource); });
                }
            }
        }
        tabs.onOpen((opened) => {
            for (const document of opened) {
                if (matches(document) && !this.diagnosticRequestor.knows(PullState.document, document)) {
                    this.diagnosticRequestor.pull(document, () => { addToBackgroundIfNeeded(document); });
                }
            }
        });
        if (diagnosticPullOptions.onChange === true) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
                const textDocument = event.original.document;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        if (diagnosticPullOptions.onSave === true) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
                const textDocument = event.original;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                    this.diagnosticRequestor.pull(event.original, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        // When the document closes clear things up
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
            this.cleanUpDocument(event.original);
        }));
        // Same when a tabs closes.
        tabs.onClose((closed) => {
            for (const document of closed) {
                this.cleanUpDocument(document);
            }
        });
        // We received a did change from the server.
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
                if (matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument);
                }
            }
        });
        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.
        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {
            this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
    }
    get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
    }
    get diagnostics() {
        return this.diagnosticRequestor.provider;
    }
    cleanUpDocument(document) {
        if (this.diagnosticRequestor.knows(PullState.document, document)) {
            this.diagnosticRequestor.forgetDocument(document);
            this.backgroundScheduler.remove(document);
        }
    }
}
class DiagnosticFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
        // We first need to decide how a UI will look with related documents.
        // An easy implementation would be to only show related diagnostics for
        // the active editor.
        capability.relatedDocumentSupport = false;
        ensure(ensure(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    dispose() {
        if (this.tabs !== undefined) {
            this.tabs.dispose();
            this.tabs = undefined;
        }
        super.dispose();
    }
    registerLanguageProvider(options) {
        if (this.tabs === undefined) {
            this.tabs = new Tabs();
        }
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);
        return [provider.disposable, provider];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=diagnostic.js.map

/***/ }),

/***/ 9959:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentHighlightFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class DocumentHighlightFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentHighlights(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentHighlightFeature = DocumentHighlightFeature;
//# sourceMappingURL=documentHighlight.js.map

/***/ }),

/***/ 3471:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class DocumentLinkFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDocumentLinks(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return link;
                            }
                            return client.protocol2CodeConverter.asDocumentLink(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token, error, link);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentLinkFeature = DocumentLinkFeature;
//# sourceMappingURL=documentLink.js.map

/***/ }),

/***/ 2483:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentSymbolFeature = exports.SupportedSymbolTags = exports.SupportedSymbolKinds = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
exports.SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
exports.SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
class DocumentSymbolFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: exports.SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: exports.SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then(async (data) => {
                        if (token.isCancellationRequested || data === undefined || data === null) {
                            return null;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            const first = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(first)) {
                                return await client.protocol2CodeConverter.asDocumentSymbols(data, token);
                            }
                            else {
                                return await client.protocol2CodeConverter.asSymbolInformations(data, token);
                            }
                        }
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        const metaData = options.label !== undefined ? { label: options.label } : undefined;
        return [vscode_1.languages.registerDocumentSymbolProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, metaData), provider];
    }
}
exports.DocumentSymbolFeature = DocumentSymbolFeature;
//# sourceMappingURL=documentSymbol.js.map

/***/ }),

/***/ 4849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecuteCommandFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
class ExecuteCommandFeature {
    constructor(client) {
        this._client = client;
        this._commands = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._commands.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, undefined, error, undefined);
            });
        };
        if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
exports.ExecuteCommandFeature = ExecuteCommandFeature;
//# sourceMappingURL=executeCommand.js.map

/***/ }),

/***/ 8909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFeature = exports.TextDocumentLanguageFeature = exports.TextDocumentEventFeature = exports.DynamicDocumentFeature = exports.DynamicFeature = exports.StaticFeature = exports.ensure = exports.LSPCancellationError = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const Is = __webpack_require__(9763);
const UUID = __webpack_require__(1980);
class LSPCancellationError extends vscode_1.CancellationError {
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.LSPCancellationError = LSPCancellationError;
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
exports.ensure = ensure;
var StaticFeature;
(function (StaticFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams));
    }
    StaticFeature.is = is;
})(StaticFeature = exports.StaticFeature || (exports.StaticFeature = {}));
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null &&
            Is.func(candidate.fillClientCapabilities) && Is.func(candidate.initialize) && Is.func(candidate.getState) && Is.func(candidate.dispose) &&
            (candidate.fillInitializeParams === undefined || Is.func(candidate.fillInitializeParams)) && Is.func(candidate.register) &&
            Is.func(candidate.unregister) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature = exports.DynamicFeature || (exports.DynamicFeature = {}));
/**
 * An abstract dynamic feature implementation that operates on documents (e.g. text
 * documents or notebooks).
 */
class DynamicDocumentFeature {
    constructor(client) {
        this._client = client;
    }
    /**
     * Returns the state the feature is in.
     */
    getState() {
        const selectors = this.getDocumentSelectors();
        let count = 0;
        for (const selector of selectors) {
            count++;
            for (const document of vscode_1.workspace.textDocuments) {
                if (vscode_1.languages.match(selector, document) > 0) {
                    return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
                }
            }
        }
        const registrations = count > 0;
        return { kind: 'document', id: this.registrationType.method, registrations, matches: false };
    }
}
exports.DynamicDocumentFeature = DynamicDocumentFeature;
/**
 * An abstract base class to implement features that react to events
 * emitted from text documents.
 */
class TextDocumentEventFeature extends DynamicDocumentFeature {
    constructor(client, event, type, middleware, createParams, textDocument, selectorFilter) {
        super(client);
        this._event = event;
        this._type = type;
        this._middleware = middleware;
        this._createParams = createParams;
        this._textDocument = textDocument;
        this._selectorFilter = selectorFilter;
        this._selectors = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument) > 0) {
                return true;
            }
        }
        return false;
    }
    getStateInfo() {
        return [this._selectors.values(), false];
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event((data) => {
                this.callback(data).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed.`, error);
                });
            });
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    async callback(data) {
        const doSend = async (data) => {
            const params = this._createParams(data);
            await this._client.sendNotification(this._type, params).catch();
            this.notificationSent(data, this._type, params);
        };
        if (this.matches(data)) {
            const middleware = this._middleware();
            return middleware ? middleware(data, (data) => doSend(data)) : doSend(data);
        }
    }
    matches(data) {
        if (this._client.hasDedicatedTextSynchronizationFeature(this._textDocument(data))) {
            return false;
        }
        return !this._selectorFilter || this._selectorFilter(this._selectors.values(), data);
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document) > 0) {
                return {
                    send: (data) => {
                        return this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.TextDocumentEventFeature = TextDocumentEventFeature;
/**
 * A abstract feature implementation that registers language providers
 * for text documents using a given document selector.
 */
class TextDocumentLanguageFeature extends DynamicDocumentFeature {
    constructor(client, registrationType) {
        super(client);
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    *getDocumentSelectors() {
        for (const registration of this._registrations.values()) {
            const selector = registration.data.registerOptions.documentSelector;
            if (selector === null) {
                continue;
            }
            yield this._client.protocol2CodeConverter.asDocumentSelector(selector);
        }
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(this._client.protocol2CodeConverter.asDocumentSelector(selector), textDocument) > 0) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentLanguageFeature = TextDocumentLanguageFeature;
class WorkspaceFeature {
    constructor(client, registrationType) {
        this._client = client;
        this._registrationType = registrationType;
        this._registrations = new Map();
    }
    getState() {
        const registrations = this._registrations.size > 0;
        return { kind: 'workspace', id: this._registrationType.method, registrations };
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
exports.WorkspaceFeature = WorkspaceFeature;
//# sourceMappingURL=features.js.map

/***/ }),

/***/ 8406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const code = __webpack_require__(9496);
const minimatch = __webpack_require__(3415);
const proto = __webpack_require__(273);
const UUID = __webpack_require__(1980);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
class FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
        this._filters = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this._registrationType.method, registrations: this._filters.size > 0 };
    }
    filterSize() {
        return this._filters.size;
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        const options = capabilities.workspace?.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if (capability?.filters !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters }
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getFileType(uri) {
        return FileOperationFeature.getFileType(uri);
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await this.getFileType(uri);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === proto.FileOperationPatternKind.folder) {
                        const fileType = await FileOperationFeature.getFileType(uri);
                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return { ...event, files };
    }
    static async getFileType(uri) {
        try {
            return (await code.workspace.fs.stat(uri)).type;
        }
        catch (e) {
            return undefined;
        }
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                return this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            return this.doSend(filteredEvent, next);
        }
    }
}
class CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {
    constructor() {
        super(...arguments);
        this._fsPathFileTypes = new Map();
    }
    async getFileType(uri) {
        const fsPath = uri.fsPath;
        if (this._fsPathFileTypes.has(fsPath)) {
            return this._fsPathFileTypes.get(fsPath);
        }
        const type = await FileOperationFeature.getFileType(uri);
        if (type) {
            this._fsPathFileTypes.set(fsPath, type);
        }
        return type;
    }
    async cacheFileTypes(event, prop) {
        // Calling filter will force the matching logic to run. For any item
        // that requires a getFileType lookup, the overriden getFileType will
        // be called that will cache the result so that when onDidRename fires,
        // it can still be checked even though the item no longer exists on disk
        // in its original location.
        await this.filter(event, prop);
    }
    clearFileTypeCache() {
        this._fsPathFileTypes.clear();
    }
    unregister(id) {
        super.unregister(id);
        if (this.filterSize() === 0 && this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
    dispose() {
        super.dispose();
        if (this._willListener) {
            this._willListener.dispose();
            this._willListener = undefined;
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.didCreateFiles
            ? middleware.didCreateFiles(event, next)
            : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);
        }
        super.register(data);
    }
    willRename(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didRenameFiles
            ? middleware.didRenameFiles(event, next)
            : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    register(data) {
        if (!this._willListener) {
            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);
        }
        super.register(data);
    }
    willDelete(e) {
        e.waitUntil(this.cacheFileTypes(e, (i) => i));
    }
    doSend(event, next) {
        this.clearFileTypeCache();
        const middleware = this._client.middleware.workspace;
        return middleware?.didDeleteFiles
            ? middleware.didDeleteFiles(event, next)
            : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this._client.sendRequest(this._requestType, this._createParams(event), event.token)
                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willCreateFiles
            ? middleware.willCreateFiles(event, next)
            : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willRenameFiles
            ? middleware.willRenameFiles(event, next)
            : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
        const middleware = this._client.middleware.workspace;
        return middleware?.willDeleteFiles
            ? middleware.willDeleteFiles(event, next)
            : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ 5338:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileSystemWatcherFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class FileSystemWatcherFeature {
    constructor(client, notifyFileEvent) {
        this._client = client;
        this._notifyFileEvent = notifyFileEvent;
        this._watchers = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._watchers.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'didChangeWatchedFiles').relativePatternSupport = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        const disposables = [];
        for (const watcher of data.registerOptions.watchers) {
            const globPattern = this._client.protocol2CodeConverter.asGlobPattern(watcher.globPattern);
            if (globPattern === undefined) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== undefined && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            const fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, disposables);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
exports.FileSystemWatcherFeature = FileSystemWatcherFeature;
//# sourceMappingURL=fileSystemWatcher.js.map

/***/ }),

/***/ 6454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class FoldingRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
        capability.foldingRangeKind = { valueSet: [vscode_languageserver_protocol_1.FoldingRangeKind.Comment, vscode_languageserver_protocol_1.FoldingRangeKind.Imports, vscode_languageserver_protocol_1.FoldingRangeKind.Region] };
        capability.foldingRange = { collapsedText: false };
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asFoldingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;
//# sourceMappingURL=foldingRange.js.map

/***/ }),

/***/ 6426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentOnTypeFormattingFeature = exports.DocumentRangeFormattingFeature = exports.DocumentFormattingFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const features_1 = __webpack_require__(8909);
var FileFormattingOptions;
(function (FileFormattingOptions) {
    function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    FileFormattingOptions.fromConfiguration = fromConfiguration;
})(FileFormattingOptions || (FileFormattingOptions = {}));
class DocumentFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentFormattingFeature = DocumentFormattingFeature;
class DocumentRangeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider), provider];
    }
}
exports.DocumentRangeFormattingFeature = DocumentRangeFormattingFeature;
class DocumentOnTypeFormattingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asTextEdits(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
exports.DocumentOnTypeFormattingFeature = DocumentOnTypeFormattingFeature;
//# sourceMappingURL=formatting.js.map

/***/ }),

/***/ 6782:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HoverFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class HoverFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const hoverCapability = ((0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asHover(result);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerHoverProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.HoverFeature = HoverFeature;
//# sourceMappingURL=hover.js.map

/***/ }),

/***/ 9889:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class ImplementationFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let implementationSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerImplementationProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ImplementationFeature = ImplementationFeature;
//# sourceMappingURL=implementation.js.map

/***/ }),

/***/ 6190:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintsFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class InlayHintsFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlayHintRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const inlayHint = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlayHint');
        inlayHint.dynamicRegistration = true;
        inlayHint.resolveSupport = {
            properties: ['tooltip', 'textEdits', 'label.tooltip', 'label.location', 'label.command']
        };
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlayHint').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlayHints.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlayHintProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlayHints: eventEmitter.event,
            provideInlayHints: (document, viewPort, token) => {
                const client = this._client;
                const provideInlayHints = async (document, viewPort, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort)
                    };
                    try {
                        const values = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, requestParams, token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlayHints(values, token);
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.provideInlayHints
                    ? middleware.provideInlayHints(document, viewPort, token, provideInlayHints)
                    : provideInlayHints(document, viewPort, token);
            }
        };
        provider.resolveInlayHint = options.resolveProvider === true
            ? (hint, token) => {
                const client = this._client;
                const resolveInlayHint = async (item, token) => {
                    try {
                        const value = await client.sendRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, client.code2ProtocolConverter.asInlayHint(item), token);
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        const result = client.protocol2CodeConverter.asInlayHint(value, token);
                        return token.isCancellationRequested ? null : result;
                    }
                    catch (error) {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, token, error, null);
                    }
                };
                const middleware = client.middleware;
                return middleware.resolveInlayHint
                    ? middleware.resolveInlayHint(hint, token, resolveInlayHint)
                    : resolveInlayHint(hint, token);
            }
            : undefined;
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlayHints: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlayHintsProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlayHintsFeature = InlayHintsFeature;
//# sourceMappingURL=inlayHint.js.map

/***/ }),

/***/ 5098:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class InlineValueFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.InlineValueRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'inlineValue').dynamicRegistration = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'inlineValue').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        this._client.onRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeInlineValues.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.inlineValueProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeInlineValues: eventEmitter.event,
            provideInlineValues: (document, viewPort, context, token) => {
                const client = this._client;
                const provideInlineValues = (document, viewPort, context, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(viewPort),
                        context: client.code2ProtocolConverter.asInlineValueContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, requestParams, token).then((values) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asInlineValues(values, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideInlineValues
                    ? middleware.provideInlineValues(document, viewPort, context, token, provideInlineValues)
                    : provideInlineValues(document, viewPort, context, token);
            }
        };
        return [this.registerProvider(selector, provider), { provider: provider, onDidChangeInlineValues: eventEmitter }];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerInlineValuesProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.InlineValueFeature = InlineValueFeature;
//# sourceMappingURL=inlineValue.js.map

/***/ }),

/***/ 3483:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingFeature = void 0;
const code = __webpack_require__(9496);
const proto = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class LinkedEditingFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const linkedEditingSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'linkedEditingRange');
        linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideLinkedEditingRanges: (document, position, token) => {
                const client = this._client;
                const provideLinkedEditing = (document, position, token) => {
                    return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asLinkedEditingRanges(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideLinkedEditingRange
                    ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing)
                    : provideLinkedEditing(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return code.languages.registerLinkedEditingRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.LinkedEditingFeature = LinkedEditingFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ 203:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NotebookDocumentSyncFeature = void 0;
const vscode = __webpack_require__(9496);
const minimatch = __webpack_require__(3415);
const proto = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const Is = __webpack_require__(9763);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var Converter;
(function (Converter) {
    let c2p;
    (function (c2p) {
        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {
            return {
                version: notebookDocument.version,
                uri: base.asUri(notebookDocument.uri)
            };
        }
        c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;
        function asNotebookDocument(notebookDocument, cells, base) {
            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));
            if (Object.keys(notebookDocument.metadata).length > 0) {
                result.metadata = asMetadata(notebookDocument.metadata);
            }
            return result;
        }
        c2p.asNotebookDocument = asNotebookDocument;
        function asNotebookCells(cells, base) {
            return cells.map(cell => asNotebookCell(cell, base));
        }
        c2p.asNotebookCells = asNotebookCells;
        function asMetadata(metadata) {
            const seen = new Set();
            return deepCopy(seen, metadata);
        }
        c2p.asMetadata = asMetadata;
        function asNotebookCell(cell, base) {
            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));
            if (Object.keys(cell.metadata).length > 0) {
                result.metadata = asMetadata(cell.metadata);
            }
            if (cell.executionSummary !== undefined && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {
                result.executionSummary = {
                    executionOrder: cell.executionSummary.executionOrder,
                    success: cell.executionSummary.success
                };
            }
            return result;
        }
        c2p.asNotebookCell = asNotebookCell;
        function asNotebookCellKind(kind) {
            switch (kind) {
                case vscode.NotebookCellKind.Markup:
                    return proto.NotebookCellKind.Markup;
                case vscode.NotebookCellKind.Code:
                    return proto.NotebookCellKind.Code;
            }
        }
        function deepCopy(seen, value) {
            if (seen.has(value)) {
                throw new Error(`Can't deep copy cyclic structures.`);
            }
            if (Array.isArray(value)) {
                const result = [];
                for (const elem of value) {
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result.push(deepCopy(seen, elem));
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result.push(elem);
                    }
                }
                return result;
            }
            else {
                const props = Object.keys(value);
                const result = Object.create(null);
                for (const prop of props) {
                    const elem = value[prop];
                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {
                        result[prop] = deepCopy(seen, elem);
                    }
                    else {
                        if (elem instanceof RegExp) {
                            throw new Error(`Can't transfer regular expressions to the server`);
                        }
                        result[prop] = elem;
                    }
                }
                return result;
            }
        }
        function asTextContentChange(event, base) {
            const params = base.asChangeTextDocumentParams(event);
            return { document: params.textDocument, changes: params.contentChanges };
        }
        c2p.asTextContentChange = asTextContentChange;
        function asNotebookDocumentChangeEvent(event, base) {
            const result = Object.create(null);
            if (event.metadata) {
                result.metadata = Converter.c2p.asMetadata(event.metadata);
            }
            if (event.cells !== undefined) {
                const cells = Object.create(null);
                const changedCells = event.cells;
                if (changedCells.structure) {
                    cells.structure = {
                        array: {
                            start: changedCells.structure.array.start,
                            deleteCount: changedCells.structure.array.deleteCount,
                            cells: changedCells.structure.array.cells !== undefined ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : undefined
                        },
                        didOpen: changedCells.structure.didOpen !== undefined
                            ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument)
                            : undefined,
                        didClose: changedCells.structure.didClose !== undefined
                            ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument)
                            : undefined
                    };
                }
                if (changedCells.data !== undefined) {
                    cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base));
                }
                if (changedCells.textContent !== undefined) {
                    cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base));
                }
                if (Object.keys(cells).length > 0) {
                    result.cells = cells;
                }
            }
            return result;
        }
        c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;
    })(c2p = Converter.c2p || (Converter.c2p = {}));
})(Converter || (Converter = {}));
var $NotebookCell;
(function ($NotebookCell) {
    function computeDiff(originalCells, modifiedCells, compareMetadata) {
        const originalLength = originalCells.length;
        const modifiedLength = modifiedCells.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            const deleteCount = (originalEndIndex + 1) - startIndex;
            const newCells = startIndex === modifiedEndIndex + 1 ? undefined : modifiedCells.slice(startIndex, modifiedEndIndex + 1);
            return newCells !== undefined ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };
        }
        else if (startIndex < modifiedLength) {
            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };
        }
        else if (startIndex < originalLength) {
            return { start: startIndex, deleteCount: originalLength - startIndex };
        }
        else {
            // The two arrays are the same.
            return undefined;
        }
    }
    $NotebookCell.computeDiff = computeDiff;
    /**
     * We only sync kind, document, execution and metadata to the server. So we only need to compare those.
     */
    function equals(one, other, compareMetaData = true) {
        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId ||
            !equalsExecution(one.executionSummary, other.executionSummary)) {
            return false;
        }
        return !compareMetaData || (compareMetaData && equalsMetadata(one.metadata, other.metadata));
    }
    function equalsExecution(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);
    }
    function equalsTiming(one, other) {
        if (one === other) {
            return true;
        }
        if (one === undefined || other === undefined) {
            return false;
        }
        return one.startTime === other.startTime && one.endTime === other.endTime;
    }
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (isObjectLiteral(one) && isObjectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }
    function isObjectLiteral(value) {
        return value !== null && typeof value === 'object';
    }
    $NotebookCell.isObjectLiteral = isObjectLiteral;
})($NotebookCell || ($NotebookCell = {}));
var $NotebookDocumentFilter;
(function ($NotebookDocumentFilter) {
    function matchNotebook(filter, notebookDocument) {
        if (typeof filter === 'string') {
            return filter === '*' || notebookDocument.notebookType === filter;
        }
        if (filter.notebookType !== undefined && filter.notebookType !== '*' && notebookDocument.notebookType !== filter.notebookType) {
            return false;
        }
        const uri = notebookDocument.uri;
        if (filter.scheme !== undefined && filter.scheme !== '*' && uri.scheme !== filter.scheme) {
            return false;
        }
        if (filter.pattern !== undefined) {
            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });
            if (!matcher.makeRe()) {
                return false;
            }
            if (!matcher.match(uri.fsPath)) {
                return false;
            }
        }
        return true;
    }
    $NotebookDocumentFilter.matchNotebook = matchNotebook;
})($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));
var $NotebookDocumentSyncOptions;
(function ($NotebookDocumentSyncOptions) {
    function asDocumentSelector(options) {
        const selector = options.notebookSelector;
        const result = [];
        for (const element of selector) {
            const notebookType = (typeof element.notebook === 'string' ? element.notebook : element.notebook?.notebookType) ?? '*';
            const scheme = (typeof element.notebook === 'string') ? undefined : element.notebook?.scheme;
            const pattern = (typeof element.notebook === 'string') ? undefined : element.notebook?.pattern;
            if (element.cells !== undefined) {
                for (const cell of element.cells) {
                    result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));
                }
            }
            else {
                result.push(asDocumentFilter(notebookType, scheme, pattern, undefined));
            }
        }
        return result;
    }
    $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;
    function asDocumentFilter(notebookType, scheme, pattern, language) {
        return scheme === undefined && pattern === undefined
            ? { notebook: notebookType, language }
            : { notebook: { notebookType, scheme, pattern }, language };
    }
})($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));
var SyncInfo;
(function (SyncInfo) {
    function create(cells) {
        return {
            cells,
            uris: new Set(cells.map(cell => cell.document.uri.toString()))
        };
    }
    SyncInfo.create = create;
})(SyncInfo || (SyncInfo = {}));
class NotebookDocumentSyncFeatureProvider {
    constructor(client, options) {
        this.client = client;
        this.options = options;
        this.notebookSyncInfo = new Map();
        this.notebookDidOpen = new Set();
        this.disposables = [];
        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
        // open
        vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }, undefined, this.disposables);
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            this.notebookDidOpen.add(notebookDocument.uri.toString());
            this.didOpen(notebookDocument);
        }
        // Notebook document changed.
        vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), undefined, this.disposables);
        //save
        if (this.options.save === true) {
            vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), undefined, this.disposables);
        }
        // close
        vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {
            this.didClose(notebookDocument);
            this.notebookDidOpen.delete(notebookDocument.uri.toString());
        }, undefined, this.disposables);
    }
    getState() {
        for (const notebook of vscode.workspace.notebookDocuments) {
            const matchingCells = this.getMatchingCells(notebook);
            if (matchingCells !== undefined) {
                return { kind: 'document', id: '$internal', registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: '$internal', registrations: true, matches: false };
    }
    get mode() {
        return 'notebook';
    }
    handles(textDocument) {
        return vscode.languages.match(this.selector, textDocument) > 0;
    }
    didOpenNotebookCellTextDocument(notebookDocument, cell) {
        if (vscode.languages.match(this.selector, cell.document) === 0) {
            return;
        }
        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {
            // We have never received an open notification for the notebook document.
            // VS Code guarantees that we first get cell document open and then
            // notebook open. So simply wait for the notebook open.
            return;
        }
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        // In VS Code we receive a notebook open before a cell document open.
        // The document and the cell is synced.
        const cellMatches = this.cellMatches(notebookDocument, cell);
        if (syncInfo !== undefined) {
            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());
            if ((cellMatches && cellIsSynced) || (!cellMatches && !cellIsSynced)) {
                // The cell doesn't match and was not synced or it matches and is synced.
                // In both cases nothing to do.
                //
                // Note that if the language mode of a document changes we remove the
                // cell and add it back to update the language mode on the server side.
                return;
            }
            if (cellMatches) {
                // don't use cells from above since there might be more matching cells in the notebook
                // Since we had a matching cell above we will have matching cells now.
                const matchingCells = this.getMatchingCells(notebookDocument);
                if (matchingCells !== undefined) {
                    const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                    if (event !== undefined) {
                        this.doSendChange(event, matchingCells).catch(() => { });
                    }
                }
            }
        }
        else {
            // No sync info. But we have a open event for the notebook document
            // itself. If the cell matches then we need to send an open with
            // exactly that cell.
            if (cellMatches) {
                this.doSendOpen(notebookDocument, [cell]).catch(() => { });
            }
        }
    }
    didChangeNotebookCellTextDocument(notebookDocument, event) {
        // No match with the selector
        if (vscode.languages.match(this.selector, event.document) === 0) {
            return;
        }
        this.doSendChange({
            notebook: notebookDocument,
            cells: { textContent: [event] }
        }, undefined).catch(() => { });
    }
    didCloseNotebookCellTextDocument(notebookDocument, cell) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // The notebook document got never synced. So it doesn't matter if a cell
            // document closes.
            return;
        }
        const cellUri = cell.document.uri;
        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());
        if (index === -1) {
            // The cell never got synced or it got deleted and we now received the document
            // close event.
            return;
        }
        if (index === 0 && syncInfo.cells.length === 1) {
            // The last cell. Close the notebook document in the server.
            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => { });
        }
        else {
            const newCells = syncInfo.cells.slice();
            const deleted = newCells.splice(index, 1);
            this.doSendChange({
                notebook: notebookDocument,
                cells: {
                    structure: {
                        array: { start: index, deleteCount: 1 },
                        didClose: deleted
                    }
                }
            }, newCells).catch(() => { });
        }
    }
    dispose() {
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
    }
    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo !== undefined) {
            if (matchingCells !== undefined) {
                const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);
                if (event !== undefined) {
                    this.doSendChange(event, matchingCells).catch(() => { });
                }
            }
            else {
                this.doSendClose(notebookDocument, []).catch(() => { });
            }
        }
        else {
            // Check if we need to sync the notebook document.
            if (matchingCells === undefined) {
                return;
            }
            this.doSendOpen(notebookDocument, matchingCells).catch(() => { });
        }
    }
    didChangeNotebookDocument(event) {
        const notebookDocument = event.notebook;
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            // We have no changes to the cells. Since the notebook wasn't synced
            // it will not be synced now.
            if (event.contentChanges.length === 0) {
                return;
            }
            // Check if we have new matching cells.
            const cells = this.getMatchingCells(notebookDocument);
            // No matching cells and the notebook never synced. So still no need
            // to sync it.
            if (cells === undefined) {
                return;
            }
            // Open the notebook document and ignore the rest of the changes
            // this the notebooks will be synced with the correct settings.
            this.didOpen(notebookDocument, cells, syncInfo);
        }
        else {
            // The notebook is synced. First check if we have no matching
            // cells anymore and if so close the notebook
            const cells = this.getMatchingCells(notebookDocument);
            if (cells === undefined) {
                this.didClose(notebookDocument, syncInfo);
                return;
            }
            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);
            if (newEvent !== undefined) {
                this.doSendChange(newEvent, cells).catch(() => { });
            }
        }
    }
    didSave(notebookDocument) {
        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());
        if (syncInfo === undefined) {
            return;
        }
        this.doSendSave(notebookDocument).catch(() => { });
    }
    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {
        if (syncInfo === undefined) {
            return;
        }
        const syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));
        this.doSendClose(notebookDocument, syncedCells).catch(() => { });
    }
    async sendDidOpenNotebookDocument(notebookDocument) {
        const cells = this.getMatchingCells(notebookDocument);
        if (cells === undefined) {
            return;
        }
        return this.doSendOpen(notebookDocument, cells);
    }
    async doSendOpen(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            const nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter);
            const cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));
            try {
                await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {
                    notebookDocument: nb,
                    cellTextDocuments: cellDocuments
                });
            }
            catch (error) {
                this.client.error('Sending DidOpenNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));
        return middleware?.didOpen !== undefined ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    async sendDidChangeNotebookDocument(event) {
        return this.doSendChange(event, undefined);
    }
    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {
        const send = async (event) => {
            try {
                await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {
                    notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),
                    change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)
                });
            }
            catch (error) {
                this.client.error('Sending DidChangeNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        if (event.cells?.structure !== undefined) {
            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));
        }
        return middleware?.didChange !== undefined ? middleware?.didChange(event, send) : send(event);
    }
    async sendDidSaveNotebookDocument(notebookDocument) {
        return this.doSendSave(notebookDocument);
    }
    async doSendSave(notebookDocument) {
        const send = async (notebookDocument) => {
            try {
                await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) }
                });
            }
            catch (error) {
                this.client.error('Sending DidSaveNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        return middleware?.didSave !== undefined ? middleware.didSave(notebookDocument, send) : send(notebookDocument);
    }
    async sendDidCloseNotebookDocument(notebookDocument) {
        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);
    }
    async doSendClose(notebookDocument, cells) {
        const send = async (notebookDocument, cells) => {
            try {
                await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {
                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) },
                    cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))
                });
            }
            catch (error) {
                this.client.error('Sending DidCloseNotebookDocumentNotification failed', error);
                throw error;
            }
        };
        const middleware = this.client.middleware?.notebooks;
        this.notebookSyncInfo.delete(notebookDocument.uri.toString());
        return middleware?.didClose !== undefined ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);
    }
    asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {
        if (event !== undefined && event.notebook !== notebook) {
            throw new Error('Notebook must be identical');
        }
        const result = {
            notebook: notebook
        };
        if (event?.metadata !== undefined) {
            result.metadata = Converter.c2p.asMetadata(event.metadata);
        }
        let matchingCellsSet;
        if (event?.cellChanges !== undefined && event.cellChanges.length > 0) {
            const data = [];
            // Only consider the new matching cells.
            matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));
            for (const cellChange of event.cellChanges) {
                if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== undefined || cellChange.metadata !== undefined)) {
                    data.push(cellChange.cell);
                }
            }
            if (data.length > 0) {
                result.cells = result.cells ?? {};
                result.cells.data = data;
            }
        }
        if (((event?.contentChanges !== undefined && event.contentChanges.length > 0) || event === undefined) && syncInfo !== undefined && matchingCells !== undefined) {
            // We still have matching cells. Check if the cell changes
            // affect the notebook on the server side.
            const oldCells = syncInfo.cells;
            const newCells = matchingCells;
            // meta data changes are reported using on the cell itself. So we can ignore comparing
            // it which has a positive effect on performance.
            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);
            let addedCells;
            let removedCells;
            if (diff !== undefined) {
                addedCells = diff.cells === undefined
                    ? new Map()
                    : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell]));
                removedCells = diff.deleteCount === 0
                    ? new Map()
                    : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));
                // Remove the onces that got deleted and inserted again.
                for (const key of Array.from(removedCells.keys())) {
                    if (addedCells.has(key)) {
                        removedCells.delete(key);
                        addedCells.delete(key);
                    }
                }
                result.cells = result.cells ?? {};
                const didOpen = [];
                const didClose = [];
                if (addedCells.size > 0 || removedCells.size > 0) {
                    for (const cell of addedCells.values()) {
                        didOpen.push(cell);
                    }
                    for (const cell of removedCells.values()) {
                        didClose.push(cell);
                    }
                }
                result.cells.structure = {
                    array: diff,
                    didOpen,
                    didClose
                };
            }
        }
        // The notebook is a property as well.
        return Object.keys(result).length > 1 ? result : undefined;
    }
    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {
        if (this.options.notebookSelector === undefined) {
            return undefined;
        }
        for (const item of this.options.notebookSelector) {
            if (item.notebook === undefined || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {
                const filtered = this.filterCells(notebookDocument, cells, item.cells);
                return filtered.length === 0 ? undefined : filtered;
            }
        }
        return undefined;
    }
    cellMatches(notebookDocument, cell) {
        const cells = this.getMatchingCells(notebookDocument, [cell]);
        return cells !== undefined && cells[0] === cell;
    }
    filterCells(notebookDocument, cells, cellSelector) {
        const filtered = cellSelector !== undefined ? cells.filter((cell) => {
            const cellLanguage = cell.document.languageId;
            return cellSelector.some((filter => (filter.language === '*' || cellLanguage === filter.language)));
        }) : cells;
        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === 'function'
            ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered)
            : filtered;
    }
}
class NotebookDocumentSyncFeature {
    constructor(client) {
        this.client = client;
        this.registrations = new Map();
        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;
        // We don't receive an event for cells where the document changes its language mode
        // Since we allow servers to filter on the language mode we fire such an event ourselves.
        vscode.workspace.onDidOpenTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
        vscode.workspace.onDidChangeTextDocument((event) => {
            if (event.contentChanges.length === 0) {
                return;
            }
            const textDocument = event.document;
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            const [notebookDocument,] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didChangeNotebookCellTextDocument(notebookDocument, event);
                }
            }
        });
        vscode.workspace.onDidCloseTextDocument((textDocument) => {
            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
                return;
            }
            // There are two cases when we receive a close for a text document
            // 1: the cell got removed. This is handled in `onDidChangeNotebookCells`
            // 2: the language mode of a cell changed. This keeps the URI stable so
            //    we will still find the cell and the notebook document.
            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);
            if (notebookDocument === undefined || notebookCell === undefined) {
                return;
            }
            for (const provider of this.registrations.values()) {
                if (provider instanceof NotebookDocumentSyncFeatureProvider) {
                    provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);
                }
            }
        });
    }
    getState() {
        if (this.registrations.size === 0) {
            return { kind: 'document', id: this.registrationType.method, registrations: false, matches: false };
        }
        for (const provider of this.registrations.values()) {
            const state = provider.getState();
            if (state.kind === 'document' && state.registrations === true && state.matches === true) {
                return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };
            }
        }
        return { kind: 'document', id: this.registrationType.method, registrations: true, matches: false };
    }
    fillClientCapabilities(capabilities) {
        const synchronization = ensure(ensure(capabilities, 'notebookDocument'), 'synchronization');
        synchronization.dynamicRegistration = true;
        synchronization.executionSummarySupport = true;
    }
    preInitialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));
    }
    initialize(capabilities) {
        const options = capabilities.notebookDocumentSync;
        if (options === undefined) {
            return;
        }
        const id = options.id ?? UUID.generateUuid();
        this.register({ id, registerOptions: options });
    }
    register(data) {
        const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);
        this.registrations.set(data.id, provider);
    }
    unregister(id) {
        const provider = this.registrations.get(id);
        provider && provider.dispose();
    }
    dispose() {
        for (const provider of this.registrations.values()) {
            provider.dispose();
        }
        this.registrations.clear();
    }
    handles(textDocument) {
        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {
            return false;
        }
        if (this.dedicatedChannel !== undefined && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {
            return true;
        }
        for (const provider of this.registrations.values()) {
            if (provider.handles(textDocument)) {
                return true;
            }
        }
        return false;
    }
    getProvider(notebookCell) {
        for (const provider of this.registrations.values()) {
            if (provider.handles(notebookCell.document)) {
                return provider;
            }
        }
        return undefined;
    }
    findNotebookDocumentAndCell(textDocument) {
        const uri = textDocument.uri.toString();
        for (const notebookDocument of vscode.workspace.notebookDocuments) {
            for (const cell of notebookDocument.getCells()) {
                if (cell.document.uri.toString() === uri) {
                    return [notebookDocument, cell];
                }
            }
        }
        return [undefined, undefined];
    }
}
exports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;
NotebookDocumentSyncFeature.CellScheme = 'vscode-notebook-cell';
//# sourceMappingURL=notebook.js.map

/***/ }),

/***/ 3603:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const progressPart_1 = __webpack_require__(8071);
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
    }
    getState() {
        return { kind: 'window', id: vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.method, registrations: this.activeParts.size > 0 };
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
            this.activeParts.delete(part);
        };
        const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
        for (const part of this.activeParts) {
            part.done();
        }
        this.activeParts.clear();
    }
}
exports.ProgressFeature = ProgressFeature;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ 8071:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressPart = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const Is = __webpack_require__(9763);
class ProgressPart {
    constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._infinite = false;
        this._lspProgressDisposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    done && done(this);
                    break;
            }
        });
    }
    begin(params) {
        this._infinite = params.percentage === undefined;
        // the progress as already been marked as done / canceled. Ignore begin call
        if (this._lspProgressDisposable === undefined) {
            return;
        }
        // Since we don't use commands this will be a silent window progress with a hidden notification.
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            // the progress as already been marked as done / canceled. Ignore begin call
            if (this._lspProgressDisposable === undefined) {
                return;
            }
            this._progress = progress;
            this._cancellationToken = cancellationToken;
            this._tokenDisposable = this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress !== undefined && this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            const percentage = Math.max(0, Math.min(params.percentage, 100));
            const delta = Math.max(0, percentage - this._reported);
            this._reported += delta;
            this._progress !== undefined && this._progress.report({ message: params.message, increment: delta });
        }
    }
    cancel() {
        this.cleanup();
        if (this._reject !== undefined) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        this.cleanup();
        if (this._resolve !== undefined) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    cleanup() {
        if (this._lspProgressDisposable !== undefined) {
            this._lspProgressDisposable.dispose();
            this._lspProgressDisposable = undefined;
        }
        if (this._tokenDisposable !== undefined) {
            this._tokenDisposable.dispose();
            this._tokenDisposable = undefined;
        }
        this._progress = undefined;
        this._cancellationToken = undefined;
    }
}
exports.ProgressPart = ProgressPart;
//# sourceMappingURL=progressPart.js.map

/***/ }),

/***/ 8714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;
//# sourceMappingURL=protocolCallHierarchyItem.js.map

/***/ }),

/***/ 6434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(9496);
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;
//# sourceMappingURL=protocolCodeAction.js.map

/***/ }),

/***/ 583:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;
//# sourceMappingURL=protocolCodeLens.js.map

/***/ }),

/***/ 1807:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;
//# sourceMappingURL=protocolCompletionItem.js.map

/***/ }),

/***/ 8785:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(9496);
const ls = __webpack_require__(273);
const Is = __webpack_require__(9763);
const async = __webpack_require__(4904);
const protocolCompletionItem_1 = __webpack_require__(1807);
const protocolCodeLens_1 = __webpack_require__(583);
const protocolDocumentLink_1 = __webpack_require__(8705);
const protocolCodeAction_1 = __webpack_require__(6434);
const protocolDiagnostic_1 = __webpack_require__(6640);
const protocolCallHierarchyItem_1 = __webpack_require__(8714);
const protocolTypeHierarchyItem_1 = __webpack_require__(1365);
const protocolWorkspaceSymbol_1 = __webpack_require__(3912);
const protocolInlayHint_1 = __webpack_require__(1065);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown, supportHtml) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDocumentSelector(selector) {
        const result = [];
        for (const filter of selector) {
            if (typeof filter === 'string') {
                result.push(filter);
            }
            else if (vscode_languageserver_protocol_1.NotebookCellTextDocumentFilter.is(filter)) {
                // We first need to check for the notebook cell filter since a TextDocumentFilter would
                // match both (e.g. the notebook is optional).
                if (typeof filter.notebook === 'string') {
                    result.push({ notebookType: filter.notebook, language: filter.language });
                }
                else {
                    const notebookType = filter.notebook.notebookType ?? '*';
                    result.push({ notebookType: notebookType, scheme: filter.notebook.scheme, pattern: filter.notebook.pattern, language: filter.language });
                }
            }
            else if (vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {
                result.push({ language: filter.language, scheme: filter.scheme, pattern: filter.pattern });
            }
        }
        return result;
    }
    async function asDiagnostics(diagnostics, token) {
        return async.map(diagnostics, asDiagnostic, token);
    }
    function asDiagnosticsSync(diagnostics) {
        const result = new Array(diagnostics.length);
        for (let i = 0; i < diagnostics.length; i++) {
            result[i] = asDiagnostic(diagnostics[i]);
        }
        return result;
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (typeof diagnostic.code === 'string' || typeof diagnostic.code === 'number') {
                if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                    result.code = {
                        value: diagnostic.code,
                        target: asUri(diagnostic.codeDescription.href)
                    };
                }
                else {
                    result.code = diagnostic.code;
                }
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                // This is for backwards compatibility of a proposed API.
                // We should remove this at some point.
                result.hasDiagnosticCode = true;
                const diagnosticCode = diagnostic.code;
                result.code = {
                    value: diagnosticCode.value,
                    target: asUri(diagnosticCode.target)
                };
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        const result = new Array(relatedInformation.length);
        for (let i = 0; i < relatedInformation.length; i++) {
            const info = relatedInformation[i];
            result[i] = new code.DiagnosticRelatedInformation(asLocation(info.location), info.message);
        }
        return result;
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        return value ? new code.Position(value.line, value.character) : undefined;
    }
    function asRange(value) {
        return value ? new code.Range(value.start.line, value.start.character, value.end.line, value.end.character) : undefined;
    }
    async function asRanges(items, token) {
        return async.map(items, (range) => {
            return new code.Range(range.start.line, range.start.character, range.end.line, range.end.character);
        }, token);
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            return asMarkdownString(value);
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        let result;
        if (value === undefined || typeof value === 'string') {
            result = new code.MarkdownString(value);
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    result = new code.MarkdownString(value.value);
                    break;
                case ls.MarkupKind.PlainText:
                    result = new code.MarkdownString();
                    result.appendText(value.value);
                    break;
                default:
                    result = new code.MarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    break;
            }
        }
        result.isTrusted = trustMarkdown;
        result.supportHtml = supportHtml;
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    async function asCompletionResult(value, allCommitCharacters, token) {
        if (!value) {
            return undefined;
        }
        if (Array.isArray(value)) {
            return async.map(value, (item) => asCompletionItem(item, allCommitCharacters), token);
        }
        const list = value;
        const { defaultRange, commitCharacters } = getCompletionItemDefaults(list, allCommitCharacters);
        const converted = await async.map(list.items, (item) => {
            return asCompletionItem(item, commitCharacters, defaultRange, list.itemDefaults?.insertTextMode, list.itemDefaults?.insertTextFormat, list.itemDefaults?.data);
        }, token);
        return new code.CompletionList(converted, list.isIncomplete);
    }
    function getCompletionItemDefaults(list, allCommitCharacters) {
        const rangeDefaults = list.itemDefaults?.editRange;
        const commitCharacters = list.itemDefaults?.commitCharacters ?? allCommitCharacters;
        return ls.Range.is(rangeDefaults)
            ? { defaultRange: asRange(rangeDefaults), commitCharacters }
            : rangeDefaults !== undefined
                ? { defaultRange: { inserting: asRange(rangeDefaults.insert), replacing: asRange(rangeDefaults.replace) }, commitCharacters }
                : { defaultRange: undefined, commitCharacters };
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item, defaultCommitCharacters, defaultRange, defaultInsertTextMode, defaultInsertTextFormat, defaultData) {
        const tags = asCompletionItemTags(item.tags);
        const label = asCompletionItemLabel(item);
        const result = new protocolCompletionItem_1.default(label);
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item, defaultRange, defaultInsertTextFormat);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEditsSync(item.additionalTextEdits);
        }
        const commitCharacters = item.commitCharacters !== undefined
            ? Is.stringArray(item.commitCharacters) ? item.commitCharacters : undefined
            : defaultCommitCharacters;
        if (commitCharacters) {
            result.commitCharacters = commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const data = item.data ?? defaultData;
        if (data !== undefined) {
            result.data = data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        const insertTextMode = item.insertTextMode ?? defaultInsertTextMode;
        if (insertTextMode !== undefined) {
            result.insertTextMode = insertTextMode;
            if (insertTextMode === ls.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionItemLabel(item) {
        if (ls.CompletionItemLabelDetails.is(item.labelDetails)) {
            return {
                label: item.label,
                detail: item.labelDetails.detail,
                description: item.labelDetails.description
            };
        }
        else {
            return item.label;
        }
    }
    function asCompletionInsertText(item, defaultRange, defaultInsertTextFormat) {
        const insertTextFormat = item.insertTextFormat ?? defaultInsertTextFormat;
        if (item.textEdit !== undefined || defaultRange !== undefined) {
            const [range, newText] = item.textEdit !== undefined
                ? getCompletionRangeAndText(item.textEdit)
                : [defaultRange, item.textEditText ?? item.label];
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(newText), range: range, fromEdit: true };
            }
            else {
                return { text: newText, range: range, fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function getCompletionRangeAndText(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return [{ inserting: asRange(value.insert), replacing: asRange(value.replace) }, value.newText];
        }
        else {
            return [asRange(value.range), value.newText];
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    async function asTextEdits(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asTextEdit, token);
    }
    function asTextEditsSync(items) {
        if (!items) {
            return undefined;
        }
        const result = new Array(items.length);
        for (let i = 0; i < items.length; i++) {
            result[i] = asTextEdit(items[i]);
        }
        return result;
    }
    async function asSignatureHelp(item, token) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = await asSignatureInformations(item.signatures, token);
        }
        return result;
    }
    async function asSignatureInformations(items, token) {
        return async.mapAsync(items, asSignatureInformation, token);
    }
    async function asSignatureInformation(item, token) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = await asParameterInformations(item.parameters, token);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(items, token) {
        return async.map(items, asParameterInformation, token);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        return item ? new code.Location(_uriConverter(item.uri), asRange(item.range)) : undefined;
    }
    async function asDeclarationResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    async function asDefinitionResult(item, token) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item, token);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    async function asLocationResult(item, token) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                const links = item;
                return async.map(links, asLocationLink, token);
            }
            else {
                const locations = item;
                return async.map(locations, asLocation, token);
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    async function asReferences(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asLocation, token);
    }
    async function asDocumentHighlights(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asDocumentHighlight, token);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    async function asSymbolInformations(values, token) {
        if (!values) {
            return undefined;
        }
        return async.map(values, asSymbolInformation, token);
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item) {
        const data = item.data;
        const location = item.location;
        const result = location.range === undefined || data !== undefined
            ? new protocolWorkspaceSymbol_1.default(item.name, asSymbolKind(item.kind), item.containerName ?? '', location.range === undefined ? _uriConverter(location.uri) : new code.Location(_uriConverter(item.location.uri), asRange(location.range)), data)
            : new code.SymbolInformation(item.name, asSymbolKind(item.kind), item.containerName ?? '', new code.Location(_uriConverter(item.location.uri), asRange(location.range)));
        fillTags(result, item);
        return result;
    }
    async function asDocumentSymbols(values, token) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return async.map(values, asDocumentSymbol, token);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    async function asCommands(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCommand, token);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    async function asCodeAction(item, token) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnosticsSync(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = await asWorkspaceEdit(item.edit, token);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionResult(items, token) {
        return async.mapAsync(items, async (item) => {
            if (ls.Command.is(item)) {
                return asCommand(item);
            }
            else {
                return asCodeAction(item, token);
            }
        }, token);
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    async function asCodeLenses(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asCodeLens, token);
    }
    async function asWorkspaceEdit(item, token) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            const changeAnnotations = item.changeAnnotations;
            await async.forEach(Object.keys(changeAnnotations), (key) => {
                const metaData = asWorkspaceEditEntryMetadata(changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }, token);
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            const documentChanges = item.documentChanges;
            await async.forEach(documentChanges, (change) => {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (ls.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }, token);
        }
        else if (item.changes) {
            const changes = item.changes;
            await async.forEach(Object.keys(changes), (key) => {
                result.set(_uriConverter(key), asTextEditsSync(changes[key]));
            }, token);
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    async function asDocumentLinks(items, token) {
        if (!items) {
            return undefined;
        }
        return async.map(items, asDocumentLink, token);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    async function asColorInformations(colorInformation, token) {
        if (!colorInformation) {
            return undefined;
        }
        return async.map(colorInformation, asColorInformation, token);
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEditsSync(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    async function asColorPresentations(colorPresentations, token) {
        if (!colorPresentations) {
            return undefined;
        }
        return async.map(colorPresentations, asColorPresentation, token);
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    async function asFoldingRanges(foldingRanges, token) {
        if (!foldingRanges) {
            return undefined;
        }
        return async.map(foldingRanges, asFoldingRange, token);
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    async function asSelectionRanges(selectionRanges, token) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        return async.map(selectionRanges, asSelectionRange, token);
    }
    function asInlineValue(inlineValue) {
        if (ls.InlineValueText.is(inlineValue)) {
            return new code.InlineValueText(asRange(inlineValue.range), inlineValue.text);
        }
        else if (ls.InlineValueVariableLookup.is(inlineValue)) {
            return new code.InlineValueVariableLookup(asRange(inlineValue.range), inlineValue.variableName, inlineValue.caseSensitiveLookup);
        }
        else {
            return new code.InlineValueEvaluatableExpression(asRange(inlineValue.range), inlineValue.expression);
        }
    }
    async function asInlineValues(inlineValues, token) {
        if (!Array.isArray(inlineValues)) {
            return [];
        }
        return async.map(inlineValues, asInlineValue, token);
    }
    async function asInlayHint(value, token) {
        const label = typeof value.label === 'string'
            ? value.label
            : await async.map(value.label, asInlayHintLabelPart, token);
        const result = new protocolInlayHint_1.default(asPosition(value.position), label);
        if (value.kind !== undefined) {
            result.kind = value.kind;
        }
        if (value.textEdits !== undefined) {
            result.textEdits = await asTextEdits(value.textEdits, token);
        }
        if (value.tooltip !== undefined) {
            result.tooltip = asTooltip(value.tooltip);
        }
        if (value.paddingLeft !== undefined) {
            result.paddingLeft = value.paddingLeft;
        }
        if (value.paddingRight !== undefined) {
            result.paddingRight = value.paddingRight;
        }
        if (value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    function asInlayHintLabelPart(part) {
        const result = new code.InlayHintLabelPart(part.value);
        if (part.location !== undefined) {
            result.location = asLocation(part.location);
        }
        if (part.tooltip !== undefined) {
            result.tooltip = asTooltip(part.tooltip);
        }
        if (part.command !== undefined) {
            result.command = asCommand(part.command);
        }
        return result;
    }
    function asTooltip(value) {
        if (typeof value === 'string') {
            return value;
        }
        return asMarkdownString(value);
    }
    async function asInlayHints(values, token) {
        if (!Array.isArray(values)) {
            return undefined;
        }
        return async.mapAsync(values, asInlayHint, token);
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        const result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asCallHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asCallHierarchyItem, token);
    }
    async function asCallHierarchyIncomingCall(item, token) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyIncomingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyIncomingCall, token);
    }
    async function asCallHierarchyOutgoingCall(item, token) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), await asRanges(item.fromRanges, token));
    }
    async function asCallHierarchyOutgoingCalls(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.mapAsync(items, asCallHierarchyOutgoingCall, token);
    }
    async function asSemanticTokens(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    async function asSemanticTokensEdits(value, _token) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    async function asLinkedEditingRanges(value, token) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(await asRanges(value.ranges, token), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    function asTypeHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolTypeHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    async function asTypeHierarchyItems(items, token) {
        if (items === null) {
            return undefined;
        }
        return async.map(items, asTypeHierarchyItem, token);
    }
    function asGlobPattern(pattern) {
        if (Is.string(pattern)) {
            return pattern;
        }
        if (ls.RelativePattern.is(pattern)) {
            if (ls.URI.is(pattern.baseUri)) {
                return new code.RelativePattern(asUri(pattern.baseUri), pattern.pattern);
            }
            else if (ls.WorkspaceFolder.is(pattern.baseUri)) {
                const workspaceFolder = code.workspace.getWorkspaceFolder(asUri(pattern.baseUri.uri));
                return workspaceFolder !== undefined ? new code.RelativePattern(workspaceFolder, pattern.pattern) : undefined;
            }
        }
        return undefined;
    }
    return {
        asUri,
        asDocumentSelector,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeActionResult,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asInlineValue,
        asInlineValues,
        asInlayHint,
        asInlayHints,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges,
        asTypeHierarchyItem,
        asTypeHierarchyItems,
        asGlobPattern
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=protocolConverter.js.map

/***/ }),

/***/ 6640:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(9496);
const Is = __webpack_require__(9763);
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;
//# sourceMappingURL=protocolDiagnostic.js.map

/***/ }),

/***/ 8705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;
//# sourceMappingURL=protocolDocumentLink.js.map

/***/ }),

/***/ 1065:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolInlayHint extends code.InlayHint {
    constructor(position, label, kind) {
        super(position, label, kind);
    }
}
exports["default"] = ProtocolInlayHint;
//# sourceMappingURL=protocolInlayHint.js.map

/***/ }),

/***/ 1365:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class ProtocolTypeHierarchyItem extends code.TypeHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolTypeHierarchyItem;
//# sourceMappingURL=protocolTypeHierarchyItem.js.map

/***/ }),

/***/ 3912:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(9496);
class WorkspaceSymbol extends code.SymbolInformation {
    constructor(name, kind, containerName, locationOrUri, data) {
        const hasRange = !(locationOrUri instanceof code.Uri);
        super(name, kind, containerName, hasRange ? locationOrUri : new code.Location(locationOrUri, new code.Range(0, 0, 0, 0)));
        this.hasRange = hasRange;
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = WorkspaceSymbol;
//# sourceMappingURL=protocolWorkspaceSymbol.js.map

/***/ }),

/***/ 8480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferencesFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class ReferencesFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asReferences(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerReferenceProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.ReferencesFeature = ReferencesFeature;
//# sourceMappingURL=reference.js.map

/***/ }),

/***/ 6458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const UUID = __webpack_require__(1980);
const Is = __webpack_require__(9763);
const features_1 = __webpack_require__(8909);
class RenameFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let rename = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asWorkspaceEdit(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token, error, null, false);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (this.isDefaultBehavior(result)) {
                                return result.defaultBehavior === true
                                    ? null
                                    : Promise.reject(new Error(`The element can't be renamed.`));
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            if (typeof error.message === 'string') {
                                throw new Error(error.message);
                            }
                            else {
                                throw new Error(`The element can't be renamed.`);
                            }
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerRenameProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
    isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
    }
}
exports.RenameFeature = RenameFeature;
//# sourceMappingURL=rename.js.map

/***/ }),

/***/ 750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class SelectionRangeFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = async (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: await client.code2ProtocolConverter.asPositions(positions, token)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSelectionRanges(ranges, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerSelectionRangeProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;
//# sourceMappingURL=selectionRange.js.map

/***/ }),

/***/ 8961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensFeature = void 0;
const vscode = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const Is = __webpack_require__(9763);
class SemanticTokensFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator,
            vscode_languageserver_protocol_1.SemanticTokenTypes.decorator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        capability.serverCancelSupport = true;
        capability.augmentsSyntaxTokens = true;
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then(async (result) => {
                                if (token.isCancellationRequested) {
                                    return null;
                                }
                                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                                    return await client.protocol2CodeConverter.asSemanticTokens(result, token);
                                }
                                else {
                                    return await client.protocol2CodeConverter.asSemanticTokensEdits(result, token);
                                }
                            }, (error) => {
                                return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token, error, null);
                            });
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSemanticTokens(result, token);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(selector);
        if (documentProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ 2908:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SignatureHelpFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const UUID = __webpack_require__(1980);
class SignatureHelpFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let config = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSignatureHelp(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        return [this.registerProvider(options, provider), provider];
    }
    registerProvider(options, provider) {
        const selector = this._client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            return vscode_1.languages.registerSignatureHelpProvider(selector, provider, metaData);
        }
    }
}
exports.SignatureHelpFeature = SignatureHelpFeature;
//# sourceMappingURL=signatureHelp.js.map

/***/ }),

/***/ 743:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidSaveTextDocumentFeature = exports.WillSaveWaitUntilFeature = exports.WillSaveFeature = exports.DidChangeTextDocumentFeature = exports.DidCloseTextDocumentFeature = exports.DidOpenTextDocumentFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const async_1 = __webpack_require__(4904);
const UUID = __webpack_require__(1980);
class DidOpenTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, () => client.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
    }
    get openDocuments() {
        return this._syncedDocuments.values();
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        const documentSelector = this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector);
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            const uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                const middleware = this._client.middleware;
                const didOpen = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                (middleware.didOpen ? middleware.didOpen(textDocument, didOpen) : didOpen(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
exports.DidOpenTextDocumentFeature = DidOpenTextDocumentFeature;
class DidCloseTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client, syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, () => client.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._syncedDocuments = syncedDocuments;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        const selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        const selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) > 0 && !this._selectorFilter(selectors, textDocument) && !this._client.hasDedicatedTextSynchronizationFeature(textDocument)) {
                let middleware = this._client.middleware;
                let didClose = (textDocument) => {
                    return this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                (middleware.didClose ? middleware.didClose(textDocument, didClose) : didClose(textDocument)).catch((error) => {
                    this._client.error(`Sending document notification ${this._type.method} failed`, error);
                });
            }
        });
    }
}
exports.DidCloseTextDocumentFeature = DidCloseTextDocumentFeature;
class DidChangeTextDocumentFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._forcingDelivery = false;
        this._changeData = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== undefined && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            syncKind: data.registerOptions.syncKind,
            documentSelector: this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector),
        });
    }
    *getDocumentSelectors() {
        for (const data of this._changeData.values()) {
            yield data.documentSelector;
        }
    }
    async callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / un-dirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        const promises = [];
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document) > 0 && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
                const middleware = this._client.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    const didChange = async (event) => {
                        const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                        await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    const didChange = async (event) => {
                        const doSend = async (event) => {
                            const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document);
                            await this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                            this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        };
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                await this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            // Usually we return the promise that signals that the data has been
                            // handed of to the network. With delayed change notification we can't
                            // do that since it would make the sendNotification call wait until the
                            // change delayer resolves and would therefore defeat the purpose. We
                            // instead return the change delayer and ensure via forceDocumentSync
                            // that before sending other notification / request the document sync
                            // has actually happened.
                            return this._changeDelayer.delayer.trigger(() => doSend(event));
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            // See comment above.
                            return this._changeDelayer.delayer.trigger(() => doSend(event), -1);
                        }
                    };
                    promises.push(middleware.didChange ? middleware.didChange(event, event => didChange(event)) : didChange(event));
                }
            }
        }
        return Promise.all(promises).then(undefined, (error) => {
            this._client.error(`Sending document notification ${vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method} failed`, error);
            throw error;
        });
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        if (this._changeDelayer !== undefined) {
            this._changeDelayer.delayer.cancel();
        }
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    async forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            return this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document) > 0) {
                return {
                    send: (event) => {
                        return this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
}
exports.DidChangeTextDocumentFeature = DidChangeTextDocumentFeature;
class WillSaveFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, () => client.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (event) => event.document, (selectors, willSaveEvent) => features_1.TextDocumentEventFeature.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
exports.WillSaveFeature = WillSaveFeature;
class WillSaveWaitUntilFeature extends features_1.DynamicDocumentFeature {
    constructor(client) {
        super(client);
        this._selectors = new Map();
    }
    getDocumentSelectors() {
        return this._selectors.values();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, this._client.protocol2CodeConverter.asDocumentSelector(data.registerOptions.documentSelector));
    }
    callback(event) {
        if (features_1.TextDocumentEventFeature.textDocumentFilter(this._selectors.values(), event.document) && !this._client.hasDedicatedTextSynchronizationFeature(event.document)) {
            let middleware = this._client.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then(async (edits) => {
                    let vEdits = await this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === undefined ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
exports.WillSaveWaitUntilFeature = WillSaveWaitUntilFeature;
class DidSaveTextDocumentFeature extends features_1.TextDocumentEventFeature {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, () => client.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), (data) => data, features_1.TextDocumentEventFeature.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
exports.DidSaveTextDocumentFeature = DidSaveTextDocumentFeature;
//# sourceMappingURL=textSynchronization.js.map

/***/ }),

/***/ 328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class TypeDefinitionFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const selector = options.documentSelector;
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asDefinitionResult(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [this.registerProvider(selector, provider), provider];
    }
    registerProvider(selector, provider) {
        return vscode_1.languages.registerTypeDefinitionProvider(this._client.protocol2CodeConverter.asDocumentSelector(selector), provider);
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;
//# sourceMappingURL=typeDefinition.js.map

/***/ }),

/***/ 4175:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
class TypeHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.middleware;
    }
    prepareTypeHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareTypeHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareTypeHierarchy
            ? middleware.prepareTypeHierarchy(document, position, token, prepareTypeHierarchy)
            : prepareTypeHierarchy(document, position, token);
    }
    provideTypeHierarchySupertypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySupertypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySupertypes
            ? middleware.provideTypeHierarchySupertypes(item, token, provideTypeHierarchySupertypes)
            : provideTypeHierarchySupertypes(item, token);
    }
    provideTypeHierarchySubtypes(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideTypeHierarchySubtypes = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asTypeHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, params, token).then((result) => {
                if (token.isCancellationRequested) {
                    return null;
                }
                return client.protocol2CodeConverter.asTypeHierarchyItems(result, token);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type, token, error, null);
            });
        };
        return middleware.provideTypeHierarchySubtypes
            ? middleware.provideTypeHierarchySubtypes(item, token, provideTypeHierarchySubtypes)
            : provideTypeHierarchySubtypes(item, token);
    }
}
class TypeHierarchyFeature extends features_1.TextDocumentLanguageFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'textDocument'), 'typeHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.typeHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new TypeHierarchyProvider(client);
        return [vscode_1.languages.registerTypeHierarchyProvider(client.protocol2CodeConverter.asDocumentSelector(options.documentSelector), provider), provider];
    }
}
exports.TypeHierarchyFeature = TypeHierarchyFeature;
//# sourceMappingURL=typeHierarchy.js.map

/***/ }),

/***/ 4904:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(273);
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== undefined;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== undefined) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
let $test = false;
function setTestMode() {
    $test = true;
}
exports.setTestMode = setTestMode;
function clearTestMode() {
    $test = false;
}
exports.clearTestMode = clearTestMode;
const defaultYieldTimeout = 15 /*ms*/;
class Timer {
    constructor(yieldAfter = defaultYieldTimeout) {
        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);
        this.startTime = Date.now();
        this.counter = 0;
        this.total = 0;
        // start with a counter interval of 1.
        this.counterInterval = 1;
    }
    start() {
        this.counter = 0;
        this.total = 0;
        this.counterInterval = 1;
        this.startTime = Date.now();
    }
    shouldYield() {
        if (++this.counter >= this.counterInterval) {
            const timeTaken = Date.now() - this.startTime;
            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);
            this.total += this.counter;
            this.counter = 0;
            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {
                // Yield also if time left <= 1 since we compute the counter
                // for max < 2 ms.
                // Start with interval 1 again. We could do some calculation
                // with using 80% of the last counter however other things (GC)
                // affect the timing heavily since we have small timings (1 - 15ms).
                this.counterInterval = 1;
                this.total = 0;
                return true;
            }
            else {
                // Only increase the counter until we have spent <= 2 ms. Increasing
                // the counter further is very fragile since timing is influenced
                // by other things and can increase the counter too much. This will result
                // that we yield in average after [14 - 16]ms.
                switch (timeTaken) {
                    case 0:
                    case 1:
                        this.counterInterval = this.total * 2;
                        break;
                }
            }
        }
        return false;
    }
}
async function map(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.map = map;
async function mapAsync(items, func, token, options) {
    if (items.length === 0) {
        return [];
    }
    const result = new Array(items.length);
    const timer = new Timer(options?.yieldAfter);
    async function convertBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            result[i] = await func(items[i], token);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    let index = await convertBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(convertBatch(index));
            });
        });
    }
    return result;
}
exports.mapAsync = mapAsync;
async function forEach(items, func, token, options) {
    if (items.length === 0) {
        return;
    }
    const timer = new Timer(options?.yieldAfter);
    function runBatch(start) {
        timer.start();
        for (let i = start; i < items.length; i++) {
            func(items[i]);
            if (timer.shouldYield()) {
                options?.yieldCallback && options.yieldCallback();
                return i + 1;
            }
        }
        return -1;
    }
    // Convert the first batch sync on the same frame.
    let index = runBatch(0);
    while (index !== -1) {
        if (token !== undefined && token.isCancellationRequested) {
            break;
        }
        index = await new Promise((resolve) => {
            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {
                resolve(runBatch(index));
            });
        });
    }
}
exports.forEach = forEach;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ 9763:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 1980:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ 5941:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
const UUID = __webpack_require__(1980);
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(client) {
        this._client = client;
        this._listeners = new Map();
    }
    getState() {
        return { kind: 'workspace', id: this.registrationType.method, registrations: this._listeners.size > 0 };
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
                const folders = vscode_1.workspace.workspaceFolders;
                if (folders === undefined) {
                    return null;
                }
                const result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            const middleware = client.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({ id: id, registerOptions: undefined });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        let promise;
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                promise = this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            promise = this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            promise = this.doSendEvent(currentWorkspaceFolders, []);
        }
        if (promise !== undefined) {
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        return this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                return this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.middleware.workspace;
            const promise = middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
            promise.catch((error) => {
                this._client.error(`Sending notification ${vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type.method} failed`, error);
            });
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolder.js.map

/***/ }),

/***/ 3051:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolFeature = void 0;
const vscode_1 = __webpack_require__(9496);
const vscode_languageserver_protocol_1 = __webpack_require__(273);
const features_1 = __webpack_require__(8909);
const documentSymbol_1 = __webpack_require__(2483);
const UUID = __webpack_require__(1980);
class WorkspaceSymbolFeature extends features_1.WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = (0, features_1.ensure)((0, features_1.ensure)(capabilities, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: documentSymbol_1.SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: documentSymbol_1.SupportedSymbolTags
        };
        symbolCapabilities.resolveSupport = { properties: ['location.range'] };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then((result) => {
                        if (token.isCancellationRequested) {
                            return null;
                        }
                        return client.protocol2CodeConverter.asSymbolInformations(result, token);
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            },
            resolveWorkspaceSymbol: options.resolveProvider === true
                ? (item, token) => {
                    const client = this._client;
                    const resolveWorkspaceSymbol = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, client.code2ProtocolConverter.asWorkspaceSymbol(item), token).then((result) => {
                            if (token.isCancellationRequested) {
                                return null;
                            }
                            return client.protocol2CodeConverter.asSymbolInformation(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, token, error, null);
                        });
                    };
                    const middleware = client.middleware;
                    return middleware.resolveWorkspaceSymbol
                        ? middleware.resolveWorkspaceSymbol(item, token, resolveWorkspaceSymbol)
                        : resolveWorkspaceSymbol(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
exports.WorkspaceSymbolFeature = WorkspaceSymbolFeature;
//# sourceMappingURL=workspaceSymbol.js.map

/***/ }),

/***/ 2850:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const cp = __webpack_require__(2081);
const fs = __webpack_require__(7147);
const path = __webpack_require__(1017);
const vscode_1 = __webpack_require__(9496);
const Is = __webpack_require__(9763);
const client_1 = __webpack_require__(4384);
const processes_1 = __webpack_require__(794);
const node_1 = __webpack_require__(6560);
// Import SemVer functions individually to avoid circular dependencies in SemVer
const semverParse = __webpack_require__(3959);
const semverSatisfies = __webpack_require__(5712);
__exportStar(__webpack_require__(6560), exports);
__exportStar(__webpack_require__(5734), exports);
const REQUIRED_VSCODE_VERSION = '^1.67.0'; // do not change format, updated by `updateVSCode` script
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        const candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== undefined && candidate.reader !== undefined;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== undefined && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends client_1.BaseLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === undefined) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        const codeVersion = semverParse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!semverSatisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    get isInDebugMode() {
        return this._isInDebugMode;
    }
    async restart() {
        await this.stop();
        // We are in debug mode. Wait a little before we restart
        // so that the debug port can be freed. We can safely ignore
        // the disposable returned from start since it will call
        // stop on the same client instance.
        if (this.isInDebugMode) {
            await new Promise((resolve) => setTimeout(resolve, 1000));
            await this.start();
        }
        else {
            await this.start();
        }
    }
    stop(timeout = 2000) {
        return super.stop(timeout).finally(() => {
            if (this._serverProcess) {
                const toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === undefined || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess || childProcess.pid === undefined) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                if (childProcess.pid !== undefined) {
                    process.kill(childProcess.pid, 0);
                    (0, processes_1.terminate)(childProcess);
                }
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
            params.processId = process.pid;
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            const result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        const server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new node_1.StreamMessageReader(cp.stdout), writer: new node_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
                this._isInDebugMode = true;
            }
            else {
                json = runDebug.run;
                this._isInDebugMode = false;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    const args = [];
                    const options = node.options ?? Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    const execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = (0, node_1.generateRandomPipeName)();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        const serverProcess = cp.spawn(runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using runtime ${runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                            const process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return handleChildProcessStartError(process, `Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, reject) => {
                        const args = (node.args && node.args.slice()) ?? [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = (0, node_1.generateRandomPipeName)();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        const options = node.options ?? Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            const sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                        else if (Transport.isSocket(transport)) {
                            (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                                const sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                const command = json;
                const args = json.args !== undefined ? json.args.slice(0) : [];
                let pipeName = undefined;
                const transport = json.transport;
                if (transport === TransportKind.stdio) {
                    args.push('--stdio');
                }
                else if (transport === TransportKind.pipe) {
                    pipeName = (0, node_1.generateRandomPipeName)();
                    args.push(`--pipe=${pipeName}`);
                }
                else if (Transport.isSocket(transport)) {
                    args.push(`--socket=${transport.port}`);
                }
                else if (transport === TransportKind.ipc) {
                    throw new Error(`Transport kind ipc is not support for command executable`);
                }
                const options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                if (transport === undefined || transport === TransportKind.stdio) {
                    const serverProcess = cp.spawn(command.command, args, options);
                    if (!serverProcess || !serverProcess.pid) {
                        return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                    }
                    serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    this._serverProcess = serverProcess;
                    this._isDetached = !!options.detached;
                    return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                }
                else if (transport === TransportKind.pipe) {
                    return (0, node_1.createClientPipeTransport)(pipeName).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
                else if (Transport.isSocket(transport)) {
                    return (0, node_1.createClientSocketTransport)(transport.port).then((transport) => {
                        const serverProcess = cp.spawn(command.command, args, options);
                        if (!serverProcess || !serverProcess.pid) {
                            return handleChildProcessStartError(serverProcess, `Launching server using command ${command.command} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        this._isDetached = !!options.detached;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        return transport.onConnected().then((protocol) => {
                            return { reader: protocol[0], writer: protocol[1] };
                        });
                    });
                }
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
            return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== undefined) {
            const result = path.join(mainRootPath, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        if (serverWorkingDirectory !== undefined) {
            const result = path.join(serverWorkingDirectory, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        return runtime;
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    getLocale() {
        const envValue = process.env['VSCODE_NLS_CONFIG'];
        if (envValue === undefined) {
            return 'en';
        }
        let config = undefined;
        try {
            config = JSON.parse(envValue);
        }
        catch (err) {
        }
        if (config === undefined || typeof config.locale !== 'string') {
            return 'en';
        }
        return config.locale;
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                void this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start().catch((error) => this._client.error('Start failed after configuration change', error, 'force'));
        }
        else if (!enabled && this._client.needsStop()) {
            void this._client.stop().catch((error) => this._client.error('Stop failed after configuration change', error, 'force'));
        }
    }
}
exports.SettingMonitor = SettingMonitor;
function handleChildProcessStartError(process, message) {
    if (process === null) {
        return Promise.reject(message);
    }
    return new Promise((_, reject) => {
        process.on('error', (err) => {
            reject(`${message} ${err}`);
        });
        // the error event should always be run immediately,
        // but race on it just in case
        setImmediate(() => reject(message));
    });
}
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminate = void 0;
const cp = __webpack_require__(2081);
const path_1 = __webpack_require__(1017);
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = (0, path_1.join)(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map

/***/ }),

/***/ 2847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(2850);

/***/ }),

/***/ 7256:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(1048);
var balanced = __webpack_require__(5623);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ 3415:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __webpack_require__(1017) } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(7256)

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ 1661:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(4389), exports);
__exportStar(__webpack_require__(1674), exports);
__exportStar(__webpack_require__(6140), exports);
__exportStar(__webpack_require__(542), exports);
var connection_1 = __webpack_require__(3767);
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * A request failed but it was syntactically correct, e.g the
     * method name was known and the parameters were valid. The error
     * message should contain human readable information about why
     * the request failed.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.RequestFailed = -32803;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 3767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ 6140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
var MessageDirection;
(function (MessageDirection) {
    MessageDirection["clientToServer"] = "clientToServer";
    MessageDirection["serverToClient"] = "serverToClient";
    MessageDirection["both"] = "both";
})(MessageDirection = exports.MessageDirection || (exports.MessageDirection = {}));
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 2918:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to an incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ 9891:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.method = 'textDocument/colorPresentation';
    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ 5934:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(6140);
//---- Get Configuration request ----
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.method = 'workspace/configuration';
    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ 764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ 9824:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
const Is = __webpack_require__(9533);
const messages_1 = __webpack_require__(6140);
/**
 * @since 3.17.0
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind.Full = 'full';
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind.Unchanged = 'unchanged';
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
//# sourceMappingURL=protocol.diagnostic.js.map

/***/ }),

/***/ 7846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ 3394:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ 2122:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositionParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ 9999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide inlay hints in a document. The request's parameter is of
 * type [InlayHintsParams](#InlayHintsParams), the response is of type
 * [InlayHint[]](#InlayHint[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintRequest;
(function (InlayHintRequest) {
    InlayHintRequest.method = 'textDocument/inlayHint';
    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);
})(InlayHintRequest = exports.InlayHintRequest || (exports.InlayHintRequest = {}));
/**
 * A request to resolve additional properties for an inlay hint.
 * The request's parameter is of type [InlayHint](#InlayHint), the response is
 * of type [InlayHint](#InlayHint) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlayHintResolveRequest;
(function (InlayHintResolveRequest) {
    InlayHintResolveRequest.method = 'inlayHint/resolve';
    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);
})(InlayHintResolveRequest = exports.InlayHintResolveRequest || (exports.InlayHintResolveRequest = {}));
/**
 * @since 3.17.0
 */
var InlayHintRefreshRequest;
(function (InlayHintRefreshRequest) {
    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;
    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);
})(InlayHintRefreshRequest = exports.InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = {}));
//# sourceMappingURL=protocol.inlayHint.js.map

/***/ }),

/***/ 5246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide inline values in a document. The request's parameter is of
 * type [InlineValueParams](#InlineValueParams), the response is of type
 * [InlineValue[]](#InlineValue[]) or a Thenable that resolves to such.
 *
 * @since 3.17.0
 */
var InlineValueRequest;
(function (InlineValueRequest) {
    InlineValueRequest.method = 'textDocument/inlineValue';
    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);
})(InlineValueRequest = exports.InlineValueRequest || (exports.InlineValueRequest = {}));
/**
 * @since 3.17.0
 */
var InlineValueRefreshRequest;
(function (InlineValueRefreshRequest) {
    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;
    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);
})(InlineValueRefreshRequest = exports.InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = {}));
//# sourceMappingURL=protocol.inlineValue.js.map

/***/ }),

/***/ 542:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = void 0;
const messages_1 = __webpack_require__(6140);
const vscode_languageserver_types_1 = __webpack_require__(1674);
const Is = __webpack_require__(9533);
const protocol_implementation_1 = __webpack_require__(2122);
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(1589);
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolder_1 = __webpack_require__(8744);
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(5934);
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(9891);
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(3394);
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(764);
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(5206);
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(1862);
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(2918);
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(9434);
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(5726);
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(6305);
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(7846);
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(3443);
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
const protocol_typeHierarchy_1 = __webpack_require__(3693);
Object.defineProperty(exports, "TypeHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } }));
Object.defineProperty(exports, "TypeHierarchySubtypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } }));
Object.defineProperty(exports, "TypeHierarchySupertypesRequest", ({ enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } }));
const protocol_inlineValue_1 = __webpack_require__(5246);
Object.defineProperty(exports, "InlineValueRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } }));
Object.defineProperty(exports, "InlineValueRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } }));
const protocol_inlayHint_1 = __webpack_require__(9999);
Object.defineProperty(exports, "InlayHintRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } }));
Object.defineProperty(exports, "InlayHintResolveRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } }));
Object.defineProperty(exports, "InlayHintRefreshRequest", ({ enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } }));
const protocol_diagnostic_1 = __webpack_require__(9824);
Object.defineProperty(exports, "DiagnosticServerCancellationData", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } }));
Object.defineProperty(exports, "DocumentDiagnosticReportKind", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } }));
Object.defineProperty(exports, "DocumentDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } }));
Object.defineProperty(exports, "WorkspaceDiagnosticRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } }));
Object.defineProperty(exports, "DiagnosticRefreshRequest", ({ enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } }));
const protocol_notebook_1 = __webpack_require__(7169);
Object.defineProperty(exports, "NotebookCellKind", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } }));
Object.defineProperty(exports, "ExecutionSummary", ({ enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } }));
Object.defineProperty(exports, "NotebookCell", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } }));
Object.defineProperty(exports, "NotebookDocument", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } }));
Object.defineProperty(exports, "NotebookDocumentSyncRegistrationType", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } }));
Object.defineProperty(exports, "DidOpenNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } }));
Object.defineProperty(exports, "NotebookCellArrayChange", ({ enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } }));
Object.defineProperty(exports, "DidChangeNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidSaveNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } }));
Object.defineProperty(exports, "DidCloseNotebookDocumentNotification", ({ enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The TextDocumentFilter namespace provides helper functions to work with
 * [TextDocumentFilter](#TextDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var TextDocumentFilter;
(function (TextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    TextDocumentFilter.is = is;
})(TextDocumentFilter = exports.TextDocumentFilter || (exports.TextDocumentFilter = {}));
/**
 * The NotebookDocumentFilter namespace provides helper functions to work with
 * [NotebookDocumentFilter](#NotebookDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var NotebookDocumentFilter;
(function (NotebookDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
    }
    NotebookDocumentFilter.is = is;
})(NotebookDocumentFilter = exports.NotebookDocumentFilter || (exports.NotebookDocumentFilter = {}));
/**
 * The NotebookCellTextDocumentFilter namespace provides helper functions to work with
 * [NotebookCellTextDocumentFilter](#NotebookCellTextDocumentFilter) literals.
 *
 * @since 3.17.0
 */
var NotebookCellTextDocumentFilter;
(function (NotebookCellTextDocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))
            && (candidate.language === undefined || Is.string(candidate.language));
    }
    NotebookCellTextDocumentFilter.is = is;
})(NotebookCellTextDocumentFilter = exports.NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.method = 'client/registerCapability';
    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.method = 'client/unregisterCapability';
    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * A set of predefined position encoding kinds.
 *
 * @since 3.17.0
 */
var PositionEncodingKind;
(function (PositionEncodingKind) {
    /**
     * Character offsets count UTF-8 code units.
     */
    PositionEncodingKind.UTF8 = 'utf-8';
    /**
     * Character offsets count UTF-16 code units.
     *
     * This is the default and must always be supported
     * by servers
     */
    PositionEncodingKind.UTF16 = 'utf-16';
    /**
     * Character offsets count UTF-32 code units.
     *
     * Implementation note: these are the same as Unicode code points,
     * so this `PositionEncodingKind` may also be used for an
     * encoding-agnostic representation of character offsets.
     */
    PositionEncodingKind.UTF32 = 'utf-32';
})(PositionEncodingKind = exports.PositionEncodingKind || (exports.PositionEncodingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.method = 'initialize';
    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeErrorCodes`;
 */
var InitializeErrorCodes;
(function (InitializeErrorCodes) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     *
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeErrorCodes.unknownProtocolVersion = 1;
})(InitializeErrorCodes = exports.InitializeErrorCodes || (exports.InitializeErrorCodes = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.method = 'initialized';
    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.method = 'shutdown';
    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.method = 'exit';
    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';
    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.method = 'window/showMessage';
    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.method = 'window/showMessageRequest';
    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.method = 'window/logMessage';
    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.method = 'telemetry/event';
    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';
    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var RelativePattern;
(function (RelativePattern) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
    }
    RelativePattern.is = is;
})(RelativePattern = exports.RelativePattern || (exports.RelativePattern = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';
    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 *
 * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients
 *  need to advertise support for WorkspaceSymbols via the client capability
 *  `workspace.symbol.resolveSupport`.
 *
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to resolve the range inside the workspace
 * symbol's location.
 *
 * @since 3.17.0
 */
var WorkspaceSymbolResolveRequest;
(function (WorkspaceSymbolResolveRequest) {
    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';
    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);
})(WorkspaceSymbolResolveRequest = exports.WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.method = 'workspace/executeCommand';
    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';
    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ 6305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ 3443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel.document = 'document';
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel.project = 'project';
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel.group = 'group';
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel.scheme = 'scheme';
    /**
     * The moniker is globally unique
     */
    UniquenessLevel.global = 'global';
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind.$import = 'import';
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind.$export = 'export';
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind.local = 'local';
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ 7169:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;
const vscode_languageserver_types_1 = __webpack_require__(1674);
const Is = __webpack_require__(9533);
const messages_1 = __webpack_require__(6140);
/**
 * A notebook cell kind.
 *
 * @since 3.17.0
 */
var NotebookCellKind;
(function (NotebookCellKind) {
    /**
     * A markup-cell is formatted source that is used for display.
     */
    NotebookCellKind.Markup = 1;
    /**
     * A code-cell is source code.
     */
    NotebookCellKind.Code = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    NotebookCellKind.is = is;
})(NotebookCellKind = exports.NotebookCellKind || (exports.NotebookCellKind = {}));
var ExecutionSummary;
(function (ExecutionSummary) {
    function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
            result.success = success;
        }
        return result;
    }
    ExecutionSummary.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));
    }
    ExecutionSummary.is = is;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
    }
    ExecutionSummary.equals = equals;
})(ExecutionSummary = exports.ExecutionSummary || (exports.ExecutionSummary = {}));
var NotebookCell;
(function (NotebookCell) {
    function create(kind, document) {
        return { kind, document };
    }
    NotebookCell.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&
            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));
    }
    NotebookCell.is = is;
    function diff(one, two) {
        const result = new Set();
        if (one.document !== two.document) {
            result.add('document');
        }
        if (one.kind !== two.kind) {
            result.add('kind');
        }
        if (one.executionSummary !== two.executionSummary) {
            result.add('executionSummary');
        }
        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {
            result.add('metadata');
        }
        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
            result.add('executionSummary');
        }
        return result;
    }
    NotebookCell.diff = diff;
    function equalsMetadata(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
            return false;
        }
        if (oneArray && otherArray) {
            if (one.length !== other.length) {
                return false;
            }
            for (let i = 0; i < one.length; i++) {
                if (!equalsMetadata(one[i], other[i])) {
                    return false;
                }
            }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
            const oneKeys = Object.keys(one);
            const otherKeys = Object.keys(other);
            if (oneKeys.length !== otherKeys.length) {
                return false;
            }
            oneKeys.sort();
            otherKeys.sort();
            if (!equalsMetadata(oneKeys, otherKeys)) {
                return false;
            }
            for (let i = 0; i < oneKeys.length; i++) {
                const prop = oneKeys[i];
                if (!equalsMetadata(one[prop], other[prop])) {
                    return false;
                }
            }
        }
        return true;
    }
})(NotebookCell = exports.NotebookCell || (exports.NotebookCell = {}));
var NotebookDocument;
(function (NotebookDocument) {
    function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
    }
    NotebookDocument.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
    }
    NotebookDocument.is = is;
})(NotebookDocument = exports.NotebookDocument || (exports.NotebookDocument = {}));
var NotebookDocumentSyncRegistrationType;
(function (NotebookDocumentSyncRegistrationType) {
    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';
    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;
    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);
})(NotebookDocumentSyncRegistrationType = exports.NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = {}));
/**
 * A notification sent when a notebook opens.
 *
 * @since 3.17.0
 */
var DidOpenNotebookDocumentNotification;
(function (DidOpenNotebookDocumentNotification) {
    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';
    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);
    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidOpenNotebookDocumentNotification = exports.DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = {}));
var NotebookCellArrayChange;
(function (NotebookCellArrayChange) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));
    }
    NotebookCellArrayChange.is = is;
    function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== undefined) {
            result.cells = cells;
        }
        return result;
    }
    NotebookCellArrayChange.create = create;
})(NotebookCellArrayChange = exports.NotebookCellArrayChange || (exports.NotebookCellArrayChange = {}));
var DidChangeNotebookDocumentNotification;
(function (DidChangeNotebookDocumentNotification) {
    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';
    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);
    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidChangeNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook document is saved.
 *
 * @since 3.17.0
 */
var DidSaveNotebookDocumentNotification;
(function (DidSaveNotebookDocumentNotification) {
    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';
    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);
    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidSaveNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = {}));
/**
 * A notification sent when a notebook closes.
 *
 * @since 3.17.0
 */
var DidCloseNotebookDocumentNotification;
(function (DidCloseNotebookDocumentNotification) {
    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';
    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);
    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;
})(DidCloseNotebookDocumentNotification = exports.DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = {}));
//# sourceMappingURL=protocol.notebook.js.map

/***/ }),

/***/ 1862:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(4389);
const messages_1 = __webpack_require__(6140);
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';
    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';
    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ 5206:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ 9434:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(6140);
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ 5726:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ 1589:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(6140);
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ 3693:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * A request to result a `TypeHierarchyItem` in a document at a given position.
 * Can be used as an input to a subtypes or supertypes type hierarchy.
 *
 * @since 3.17.0
 */
var TypeHierarchyPrepareRequest;
(function (TypeHierarchyPrepareRequest) {
    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';
    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);
})(TypeHierarchyPrepareRequest = exports.TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = {}));
/**
 * A request to resolve the supertypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySupertypesRequest;
(function (TypeHierarchySupertypesRequest) {
    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';
    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);
})(TypeHierarchySupertypesRequest = exports.TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = {}));
/**
 * A request to resolve the subtypes for a given `TypeHierarchyItem`.
 *
 * @since 3.17.0
 */
var TypeHierarchySubtypesRequest;
(function (TypeHierarchySubtypesRequest) {
    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';
    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;
    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);
})(TypeHierarchySubtypesRequest = exports.TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = {}));
//# sourceMappingURL=protocol.typeHierarchy.js.map

/***/ }),

/***/ 8744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(6140);
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';
    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';
    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolder.js.map

/***/ }),

/***/ 9533:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ 273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(5028);
__exportStar(__webpack_require__(5028), exports);
__exportStar(__webpack_require__(1661), exports);
function createProtocolConnection(input, output, logger, options) {
    return (0, node_1.createMessageConnection)(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ 6560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(273);

/***/ }),

/***/ 1674:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeActionTriggerKind": () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemLabelDetails": () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "DocumentUri": () => (/* binding */ DocumentUri),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "InlayHint": () => (/* binding */ InlayHint),
/* harmony export */   "InlayHintKind": () => (/* binding */ InlayHintKind),
/* harmony export */   "InlayHintLabelPart": () => (/* binding */ InlayHintLabelPart),
/* harmony export */   "InlineValueContext": () => (/* binding */ InlineValueContext),
/* harmony export */   "InlineValueEvaluatableExpression": () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   "InlineValueText": () => (/* binding */ InlineValueText),
/* harmony export */   "InlineValueVariableLookup": () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "SemanticTokenModifiers": () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   "SemanticTokenTypes": () => (/* binding */ SemanticTokenTypes),
/* harmony export */   "SemanticTokens": () => (/* binding */ SemanticTokens),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "URI": () => (/* binding */ URI),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "WorkspaceFolder": () => (/* binding */ WorkspaceFolder),
/* harmony export */   "WorkspaceSymbol": () => (/* binding */ WorkspaceSymbol),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id ".concat(id, " is already in use."));
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id ".concat(id));
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name: name, kind: kind, location: { uri: uri, range: range } }
            : { name: name, kind: kind, location: { uri: uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range: range, text: text };
    }
    InlineValueText.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range: range, expression: expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * [InlineValueContext](#InlineValueContext) literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId: frameId, stoppedLocation: stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the [InlineValueContext](#InlineValueContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value: value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        var result = { position: position, label: label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ 9602:
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ 4411:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(9602)(Yallist)
} catch (er) {}


/***/ }),

/***/ 9496:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 2081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 2361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 7147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 3685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 5687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 1808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 2037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 1017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 3477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 2781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 7310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 3837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 4139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);
var resolveBlockMap = __webpack_require__(6933);
var resolveBlockSeq = __webpack_require__(3179);
var resolveFlowCollection = __webpack_require__(4658);

function composeCollection(CN, ctx, token, tagToken, onError) {
    let coll;
    switch (token.type) {
        case 'block-map': {
            coll = resolveBlockMap.resolveBlockMap(CN, ctx, token, onError);
            break;
        }
        case 'block-seq': {
            coll = resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError);
            break;
        }
        case 'flow-collection': {
            coll = resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError);
            break;
        }
    }
    if (!tagToken)
        return coll;
    const tagName = ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (!tagName)
        return coll;
    // Cast needed due to: https://github.com/Microsoft/TypeScript/issues/3841
    const Coll = coll.constructor;
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    const expType = Node.isMap(coll) ? 'map' : 'seq';
    let tag = ctx.schema.tags.find(t => t.collection === expType && t.tag === tagName);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            coll.tag = tagName;
            return coll;
        }
    }
    const res = tag.resolve(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options);
    const node = Node.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),

/***/ 3138:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Document = __webpack_require__(6068);
var composeNode = __webpack_require__(81);
var resolveEnd = __webpack_require__(7655);
var resolveProps = __webpack_require__(5920);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),

/***/ 81:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(2055);
var composeCollection = __webpack_require__(4139);
var composeScalar = __webpack_require__(6548);
var resolveEnd = __webpack_require__(7655);
var utilEmptyScalarPosition = __webpack_require__(7154);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment)
        node.comment = comment;
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),

/***/ 6548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);
var resolveBlockScalar = __webpack_require__(1328);
var resolveFlowScalar = __webpack_require__(7876);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(token, ctx.options.strict, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    const tag = tagToken && tagName
        ? findScalarTagByName(ctx.schema, value, tagName, tagToken, onError)
        : token.type === 'scalar'
            ? findScalarTagByTest(ctx, value, token, onError)
            : ctx.schema[Node.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = Node.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[Node.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[Node.SCALAR];
}
function findScalarTagByTest({ directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => tag.default && tag.test?.test(value)) || schema[Node.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[Node.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),

/***/ 5281:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var directives = __webpack_require__(9226);
var Document = __webpack_require__(6068);
var errors = __webpack_require__(2394);
var Node = __webpack_require__(466);
var composeDoc = __webpack_require__(3138);
var resolveEnd = __webpack_require__(7655);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (Node.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (Node.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),

/***/ 6933:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Pair = __webpack_require__(394);
var YAMLMap = __webpack_require__(6575);
var resolveProps = __webpack_require__(5920);
var utilContainsNewline = __webpack_require__(3094);
var utilFlowIndentCheck = __webpack_require__(2566);
var utilMapIncludes = __webpack_require__(6493);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError) {
    const map = new YAMLMap.YAMLMap(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                // TODO: assert being at last item?
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.hasNewlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    map.range = [bm.offset, offset, offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),

/***/ 1328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);

function resolveBlockScalar(scalar, strict, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),

/***/ 3179:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(3798);
var resolveProps = __webpack_require__(5920);
var utilFlowIndentCheck = __webpack_require__(2566);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError) {
    const seq = new YAMLSeq.YAMLSeq(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bs.offset;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            startOnNewline: true
        });
        offset = props.end;
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(offset, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                // TODO: assert being at last item?
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, offset, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),

/***/ 7655:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),

/***/ 4658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var YAMLMap = __webpack_require__(6575);
var YAMLSeq = __webpack_require__(3798);
var resolveEnd = __webpack_require__(7655);
var resolveProps = __webpack_require__(5920);
var utilContainsNewline = __webpack_require__(3094);
var utilMapIncludes = __webpack_require__(6493);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const coll = isMap
        ? new YAMLMap.YAMLMap(ctx.schema)
        : new YAMLSeq.YAMLSeq(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (Node.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),

/***/ 7876:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var resolveEnd = __webpack_require__(7655);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch (_) {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0',
    a: '\x07',
    b: '\b',
    e: '\x1b',
    f: '\f',
    n: '\n',
    r: '\r',
    t: '\t',
    v: '\v',
    N: '\u0085',
    _: '\u00a0',
    L: '\u2028',
    P: '\u2029',
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),

/***/ 5920:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let hasNewlineAfterProp = false;
    let reqSpace = false;
    let anchor = null;
    let tag = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    atNewline &&
                    indicator !== 'doc-start' &&
                    token.source[0] === '\t')
                    onError(token, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    hasNewlineAfterProp = true;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                if (start === null)
                    start = token.offset;
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline = false;
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== ''))
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        hasNewlineAfterProp,
        anchor,
        tag,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),

/***/ 3094:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),

/***/ 7154:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        if (pos === null)
            pos = before.length;
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),

/***/ 2566:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utilContainsNewline = __webpack_require__(3094);

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),

/***/ 6493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b ||
            (Node.isScalar(a) &&
                Node.isScalar(b) &&
                a.value === b.value &&
                !(a.value === '<<' && ctx.schema.merge));
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),

/***/ 6068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(2055);
var Collection = __webpack_require__(3365);
var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var toJS = __webpack_require__(3257);
var Schema = __webpack_require__(3673);
var stringify = __webpack_require__(611);
var stringifyDocument = __webpack_require__(9957);
var anchors = __webpack_require__(1903);
var applyReviver = __webpack_require__(3085);
var createNode = __webpack_require__(7581);
var directives = __webpack_require__(9226);

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        if (value === undefined)
            this.contents = null;
        else {
            this.contents = this.createNode(value, _replacer, options);
        }
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [Node.NODE_TYPE]: { value: Node.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = Node.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && Node.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return Node.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && Node.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return Node.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return Node.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return Node.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path))
            this.contents = value;
        else if (this.contents == null) {
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { merge: true, resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { merge: false, resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
            stringify: stringify.stringify
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (Node.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),

/***/ 1903:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var visit = __webpack_require__(1381);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (Node.isScalar(ref.node) || Node.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),

/***/ 3085:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),

/***/ 7581:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(2055);
var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (Node.isDocument(value))
        value = value.contents;
    if (Node.isNode(value))
        return value;
    if (Node.isPair(value)) {
        const map = ctx.schema[Node.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt === 'function' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            if (!ref.anchor)
                ref.anchor = onAnchor(value);
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[Node.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[Node.SEQ]
                    : schema[Node.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),

/***/ 9226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var visit = __webpack_require__(1381);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix)
            return prefix + decodeURIComponent(suffix);
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && Node.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (Node.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),

/***/ 2394:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.min(end.col - col, 80 - ci);
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),

/***/ 3419:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(5281);
var Document = __webpack_require__(6068);
var Schema = __webpack_require__(3673);
var errors = __webpack_require__(2394);
var Alias = __webpack_require__(2055);
var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var Scalar = __webpack_require__(8844);
var YAMLMap = __webpack_require__(6575);
var YAMLSeq = __webpack_require__(3798);
var cst = __webpack_require__(5208);
var lexer = __webpack_require__(7135);
var lineCounter = __webpack_require__(4708);
var parser = __webpack_require__(9369);
var publicApi = __webpack_require__(8011);
var visit = __webpack_require__(1381);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = Node.isAlias;
exports.isCollection = Node.isCollection;
exports.isDocument = Node.isDocument;
exports.isMap = Node.isMap;
exports.isNode = Node.isNode;
exports.isPair = Node.isPair;
exports.isScalar = Node.isScalar;
exports.isSeq = Node.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),

/***/ 5441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof process !== 'undefined' && process.emitWarning)
            process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),

/***/ 2055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(1903);
var visit = __webpack_require__(1381);
var Node = __webpack_require__(466);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(Node.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            }
        });
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        const data = anchors.get(source);
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (Node.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (Node.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (Node.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),

/***/ 3365:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(7581);
var Node = __webpack_require__(466);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => Node.isNode(it) || Node.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (Node.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && Node.isScalar(node) ? node.value : node;
        else
            return Node.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!Node.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    Node.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return Node.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (Node.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}
Collection.maxFlowStringSingleLineLength = 60;

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),

/***/ 466:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
class NodeBase {
    constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
}

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.NodeBase = NodeBase;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),

/***/ 394:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(7581);
var stringifyPair = __webpack_require__(8843);
var addPairToJSMap = __webpack_require__(3567);
var Node = __webpack_require__(466);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, Node.NODE_TYPE, { value: Node.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (Node.isNode(key))
            key = key.clone(schema);
        if (Node.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),

/***/ 8844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var toJS = __webpack_require__(3257);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(Node.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),

/***/ 6575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(240);
var addPairToJSMap = __webpack_require__(3567);
var Collection = __webpack_require__(3365);
var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var Scalar = __webpack_require__(8844);

function findPair(items, key) {
    const k = Node.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (Node.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (Node.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    constructor(schema) {
        super(Node.MAP, schema);
        this.items = [];
    }
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (Node.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (Node.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && Node.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!Node.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),

/***/ 3798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(240);
var Collection = __webpack_require__(3365);
var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);
var toJS = __webpack_require__(3257);

class YAMLSeq extends Collection.Collection {
    constructor(schema) {
        super(Node.SEQ, schema);
        this.items = [];
    }
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && Node.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (Node.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
}
function asItemIndex(key) {
    let idx = Node.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),

/***/ 3567:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(5441);
var stringify = __webpack_require__(611);
var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);
var toJS = __webpack_require__(3257);

const MERGE_KEY = '<<';
function addPairToJSMap(ctx, map, { key, value }) {
    if (ctx?.doc.schema.merge && isMergeKey(key)) {
        value = Node.isAlias(value) ? value.resolve(ctx.doc) : value;
        if (Node.isSeq(value))
            for (const it of value.items)
                mergeToJSMap(ctx, map, it);
        else if (Array.isArray(value))
            for (const it of value)
                mergeToJSMap(ctx, map, it);
        else
            mergeToJSMap(ctx, map, value);
    }
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
const isMergeKey = (key) => key === MERGE_KEY ||
    (Node.isScalar(key) &&
        key.value === MERGE_KEY &&
        (!key.type || key.type === Scalar.Scalar.PLAIN));
// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
function mergeToJSMap(ctx, map, value) {
    const source = ctx && Node.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!Node.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (Node.isNode(key) && ctx && ctx.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),

/***/ 3257:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !Node.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),

/***/ 7084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var resolveBlockScalar = __webpack_require__(1328);
var resolveFlowScalar = __webpack_require__(7876);
var errors = __webpack_require__(2394);
var stringifyString = __webpack_require__(8431);

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar(token, strict, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),

/***/ 4453:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),

/***/ 8318:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),

/***/ 5208:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cstScalar = __webpack_require__(7084);
var cstStringify = __webpack_require__(4453);
var cstVisit = __webpack_require__(8318);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),

/***/ 7135:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(5208);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if (s === '---' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return 'doc';
            }
            else if (s === '...' && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                return 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else
                this.indentNext += this.blockScalarIndent;
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ' || ch === '\t')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && next === ','))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && invalidFlowScalarChars.includes(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && invalidFlowScalarChars.includes(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && invalidFlowScalarChars.includes(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.includes(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.includes(this.buffer[i + 1]) &&
                    hexDigits.includes(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),

/***/ 4708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),

/***/ 9369:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(5208);
var lexer = __webpack_require__(7135);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atNextItem = !this.onKeyLine && this.indent === map.indent && it.sep;
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !includesToken(it.start, 'explicit-key-ind')) {
                        it.start.push(this.sourceToken);
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken] }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (includesToken(it.start, 'explicit-key-ind')) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key, delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (atNextItem &&
                            bv.type !== 'block-seq' &&
                            includesToken(it.start, 'explicit-key-ind')) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),

/***/ 8011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(5281);
var Document = __webpack_require__(6068);
var errors = __webpack_require__(2394);
var log = __webpack_require__(5441);
var lineCounter = __webpack_require__(4708);
var parser = __webpack_require__(9369);

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),

/***/ 3673:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var map = __webpack_require__(2744);
var seq = __webpack_require__(2360);
var string = __webpack_require__(3042);
var tags = __webpack_require__(6524);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.merge = !!merge;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, Node.MAP, { value: map.map });
        Object.defineProperty(this, Node.SCALAR, { value: string.string });
        Object.defineProperty(this, Node.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),

/***/ 2744:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var YAMLMap = __webpack_require__(6575);

function createMap(schema, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map = new YAMLMap.YAMLMap(schema);
    const add = (key, value) => {
        if (typeof replacer === 'function')
            value = replacer.call(obj, key, value);
        else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
        if (value !== undefined || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
        for (const [key, value] of obj)
            add(key, value);
    }
    else if (obj && typeof obj === 'object') {
        for (const key of Object.keys(obj))
            add(key, obj[key]);
    }
    if (typeof schema.sortMapEntries === 'function') {
        map.items.sort(schema.sortMapEntries);
    }
    return map;
}
const map = {
    collection: 'map',
    createNode: createMap,
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!Node.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.map = map;


/***/ }),

/***/ 5397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),

/***/ 2360:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(7581);
var Node = __webpack_require__(466);
var YAMLSeq = __webpack_require__(3798);

function createSeq(schema, obj, ctx) {
    const { replacer } = ctx;
    const seq = new YAMLSeq.YAMLSeq(schema);
    if (obj && Symbol.iterator in Object(obj)) {
        let i = 0;
        for (let it of obj) {
            if (typeof replacer === 'function') {
                const key = obj instanceof Set ? it : String(i++);
                it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, undefined, ctx));
        }
    }
    return seq;
}
const seq = {
    collection: 'seq',
    createNode: createSeq,
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!Node.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    }
};

exports.seq = seq;


/***/ }),

/***/ 3042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyString = __webpack_require__(8431);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),

/***/ 976:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),

/***/ 3398:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var stringifyNumber = __webpack_require__(5260);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN))$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 4723:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(5260);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 3305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(2744);
var _null = __webpack_require__(5397);
var seq = __webpack_require__(2360);
var string = __webpack_require__(3042);
var bool = __webpack_require__(976);
var float = __webpack_require__(3398);
var int = __webpack_require__(4723);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),

/***/ 7854:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var map = __webpack_require__(2744);
var seq = __webpack_require__(2360);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true|false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),

/***/ 6524:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(2744);
var _null = __webpack_require__(5397);
var seq = __webpack_require__(2360);
var string = __webpack_require__(3042);
var bool = __webpack_require__(976);
var float = __webpack_require__(3398);
var int = __webpack_require__(4723);
var schema = __webpack_require__(3305);
var schema$1 = __webpack_require__(7854);
var binary = __webpack_require__(8798);
var omap = __webpack_require__(1367);
var pairs = __webpack_require__(3879);
var schema$2 = __webpack_require__(163);
var set = __webpack_require__(9160);
var timestamp = __webpack_require__(7714);

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName) {
    let tags = schemas.get(schemaName);
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    return tags.map(tag => {
        if (typeof tag !== 'string')
            return tag;
        const tagObj = tagsByName[tag];
        if (tagObj)
            return tagObj;
        const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
        throw new Error(`Unknown custom tag "${tag}"; use one of ${keys}`);
    });
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),

/***/ 8798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var stringifyString = __webpack_require__(8431);

const binary = {
    identify: value => value instanceof Uint8Array,
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof Buffer === 'function') {
            return Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof Buffer === 'function') {
            str =
                buf instanceof Buffer
                    ? buf.toString('base64')
                    : Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        if (!type)
            type = Scalar.Scalar.BLOCK_LITERAL;
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),

/***/ 9466:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),

/***/ 3922:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var stringifyNumber = __webpack_require__(5260);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?\.(?:inf|Inf|INF|nan|NaN|NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),

/***/ 5563:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(5260);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),

/***/ 1367:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(3798);
var toJS = __webpack_require__(3257);
var Node = __webpack_require__(466);
var YAMLMap = __webpack_require__(6575);
var pairs = __webpack_require__(3879);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (Node.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (Node.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new YAMLOMap();
        omap.items = pairs$1.items;
        return omap;
    }
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),

/***/ 3879:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var Scalar = __webpack_require__(8844);
var YAMLSeq = __webpack_require__(3798);

function resolvePairs(seq, onError) {
    if (Node.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (Node.isPair(item))
                continue;
            else if (Node.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = Node.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else
                    throw new TypeError(`Expected { key: value } tuple: ${it}`);
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),

/***/ 163:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(2744);
var _null = __webpack_require__(5397);
var seq = __webpack_require__(2360);
var string = __webpack_require__(3042);
var binary = __webpack_require__(8798);
var bool = __webpack_require__(9466);
var float = __webpack_require__(3922);
var int = __webpack_require__(5563);
var omap = __webpack_require__(1367);
var pairs = __webpack_require__(3879);
var set = __webpack_require__(9160);
var timestamp = __webpack_require__(7714);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),

/***/ 9160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Pair = __webpack_require__(394);
var YAMLMap = __webpack_require__(6575);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (Node.isPair(key))
            pair = key;
        else if (typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && Node.isPair(pair)
            ? Node.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    resolve(map, onError) {
        if (Node.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new YAMLSet(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),

/***/ 7714:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(5260);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => (n < 10 ? '0' + String(n) : String(n)))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value.toISOString().replace(/((T00:00)?:00)?\.000Z$/, '')
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),

/***/ 4112:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i);
            end = i + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i) {
    let ch = text[i + 1];
    while (ch === ' ' || ch === '\t') {
        do {
            ch = text[(i += 1)];
        } while (ch && ch !== '\n');
        ch = text[i + 1];
    }
    return i;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),

/***/ 611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(1903);
var Node = __webpack_require__(466);
var stringifyComment = __webpack_require__(8463);
var stringifyString = __webpack_require__(8431);

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (Node.isScalar(item)) {
        obj = item.value;
        const match = tags.filter(t => t.identify?.(obj));
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? typeof obj;
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (Node.isScalar(node) || Node.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ? node.tag : tagObj.default ? null : tagObj.tag;
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (Node.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (Node.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = Node.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    if (!tagObj)
        tagObj = getTagObject(ctx.doc.schema.tags, node);
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : Node.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return Node.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),

/***/ 240:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Collection = __webpack_require__(3365);
var Node = __webpack_require__(466);
var stringify = __webpack_require__(611);
var stringifyComment = __webpack_require__(8463);

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (Node.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (Node.isPair(item)) {
            const ik = Node.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ comment, items }, ctx, { flowChars, itemIndent, onComment }) {
    const { indent, indentStep, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (Node.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (Node.isPair(item)) {
            const ik = Node.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = Node.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik && ik.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    let str;
    const { start, end } = flowChars;
    if (lines.length === 0) {
        str = start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = len > Collection.Collection.maxFlowStringSingleLineLength;
        }
        if (reqNewline) {
            str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            str += `\n${indent}${end}`;
        }
        else {
            str = `${start} ${lines.join(' ')} ${end}`;
        }
    }
    if (comment) {
        str += stringifyComment.lineComment(str, commentString(comment), indent);
        if (onComment)
            onComment();
    }
    return str;
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),

/***/ 8463:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),

/***/ 9957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var stringify = __webpack_require__(611);
var stringifyComment = __webpack_require__(8463);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (Node.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),

/***/ 5260:
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),

/***/ 8843:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);
var Scalar = __webpack_require__(8844);
var stringify = __webpack_require__(611);
var stringifyComment = __webpack_require__(8463);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (Node.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (Node.isCollection(key)) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            Node.isCollection(key) ||
            (Node.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vcb = '';
    let valueComment = null;
    if (Node.isNode(value)) {
        if (value.spaceBefore)
            vcb = '\n';
        if (value.commentBefore) {
            const cs = commentString(value.commentBefore);
            vcb += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        valueComment = value.comment;
    }
    else if (value && typeof value === 'object') {
        value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && Node.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        Node.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substr(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (vcb || keyComment) {
        if (valueStr === '' && !ctx.inFlow)
            ws = vcb === '\n' ? '\n\n' : vcb;
        else
            ws = `${vcb}\n${ctx.indent}`;
    }
    else if (!explicitKey && Node.isCollection(value)) {
        const flow = valueStr[0] === '[' || valueStr[0] === '{';
        if (!flow || valueStr.includes('\n'))
            ws = `\n${ctx.indent}`;
    }
    else if (valueStr === '' || valueStr[0] === '\n')
        ws = '';
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),

/***/ 8431:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(8844);
var foldFlowLines = __webpack_require__(4112);

const getFoldOptions = (ctx) => ({
    indentAtStart: ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(/\n+(?!\n|$)/g, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    let header = (literal ? '|' : '>') + (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (literal) {
        value = value.replace(/\n+/g, `$&${indent}`);
        return `${header}\n${indent}${start}${value}${end}`;
    }
    value = value
        .replace(/\n+/g, '\n$&')
        .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
        //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
        .replace(/\n+/g, `$&${indent}`);
    const body = foldFlowLines.foldFlowLines(`${start}${value}${end}`, indent, foldFlowLines.FOLD_BLOCK, getFoldOptions(ctx));
    return `${header}\n${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, inFlow } = ctx;
    if ((implicitKey && /[\n[\]{},]/.test(value)) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (!value ||
        /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - empty string, '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (indent === '' && containsDocumentMarker(value)) {
        ctx.forceBlockIndent = true;
        return blockString(item, ctx, onComment, onChompKeep);
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),

/***/ 1381:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Node = __webpack_require__(466);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (Node.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (Node.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (Node.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (Node.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (Node.isNode(ctrl) || Node.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (Node.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (Node.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (Node.isMap(node))
        return visitor.Map?.(key, node, path);
    if (Node.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (Node.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (Node.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (Node.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (Node.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (Node.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (Node.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = Node.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(1892);
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map