/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/@alipay/monitor-stack/dist/index.esm.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@alipay/monitor-stack/dist/index.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorStack": () => (/* binding */ ErrorStack),
/* harmony export */   "compressStack": () => (/* binding */ compressStack),
/* harmony export */   "uncompressStack": () => (/* binding */ uncompressStack)
/* harmony export */ });
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var checkEnv = function (window) {
  return function () {
    if (!window || !window.navigator || !window.navigator.userAgent) {
      return '';
    }

    var ua = window.navigator.userAgent;
    var isIos = !!ua.match(/iphone|ipad|iPod/gi);
    var isAndroid = !!ua.match(/android/gi);
    var isFirefox = !!ua.match(/Firefox/gi);
    var isChrome = !!ua.match(/Chrome/gi);
    var isSafari = !ua.match(/Chrome/gi) && !!ua.match(/Safari/gi);
    var isOpera = !!ua.match(/Opera/gi);
    var isIe = !!ua.match(/MSIE/gi);
    var env = '';

    if (isIos) {
      env = 'iOS';
    }

    if (isAndroid) {
      env = 'Android';
    }

    if (isFirefox) {
      env = 'Firefox';
    }

    if (isChrome) {
      env = 'Chrome';
    }

    if (isSafari) {
      env = 'Safari';
    }

    if (isOpera) {
      env = 'Opera';
    }

    if (isIe) {
      env = 'IE';
    }

    return env;
  };
}(undefined);

function checkAndriodSpecial() {
  // todo by white list or else
  return true;
}

var generateHandler = function generateHandler(env) {
  switch (env) {
    case 'iOS':
      return {
        filter: function filter(line) {
          return line.indexOf('[native code]') < 0 && line.indexOf('@') >= 0;
        }
      };

    case 'Android':
      return {
        filter: function filter(line, index) {
          return index && line.indexOf('nonymous') < 0 && checkAndriodSpecial();
        }
      };

    default:
      return {
        filter: function filter() {
          return true;
        }
      };
  }
};

/**
 * copy from blueimp-md5@2.10.0
 * 由于bigfish rollup 打包问题，引入
 */

/*
* Add integers, wrapping at 2^32. This uses 16-bit operations internally
* to work around bugs in some JS interpreters.
*/
function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xffff;
}
/*
* Bitwise rotate a 32-bit number to the left.
*/


function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
* These functions implement the four basic operations the algorithm uses.
*/


function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}

function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}

function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}

function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}

function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
/*
* Calculate the MD5 of an array of little-endian words, and a bit length.
*/


function binlMD5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << len % 32;
  x[(len + 64 >>> 9 << 4) + 14] = len;
  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }

  return [a, b, c, d];
}
/*
* Convert an array of little-endian words to a string
*/


function binl2rstr(input) {
  var i;
  var output = '';
  var length32 = input.length * 32;

  for (i = 0; i < length32; i += 8) {
    output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xff);
  }

  return output;
}
/*
* Convert a raw string to an array of little-endian words
* Characters >255 have their high-byte silently ignored.
*/


function rstr2binl(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;

  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }

  var length8 = input.length * 8;

  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << i % 32;
  }

  return output;
}
/*
* Calculate the MD5 of a raw string
*/


function rstrMD5(s) {
  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
}
/*
* Calculate the HMAC-MD5, of a key and some data (raw strings)
*/


function rstrHMACMD5(key, data) {
  var i;
  var bkey = rstr2binl(key);
  var ipad = [];
  var opad = [];
  var hash;
  ipad[15] = opad[15] = undefined;

  if (bkey.length > 16) {
    bkey = binlMD5(bkey, key.length * 8);
  }

  for (i = 0; i < 16; i += 1) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }

  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
}
/*
* Convert a raw string to a hex string
*/


function rstr2hex(input) {
  var hexTab = '0123456789abcdef';
  var output = '';
  var x;
  var i;

  for (i = 0; i < input.length; i += 1) {
    x = input.charCodeAt(i);
    output += hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f);
  }

  return output;
}
/*
* Encode a string as utf-8
*/


function str2rstrUTF8(input) {
  return unescape(encodeURIComponent(input));
}
/*
* Take string arguments and return either raw or hex encoded strings
*/


function rawMD5(s) {
  return rstrMD5(str2rstrUTF8(s));
}

function hexMD5(s) {
  return rstr2hex(rawMD5(s));
}

function rawHMACMD5(k, d) {
  return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
}

function hexHMACMD5(k, d) {
  return rstr2hex(rawHMACMD5(k, d));
}

function md5(string, key, raw) {
  if (!key) {
    if (!raw) {
      return hexMD5(string);
    }

    return rawMD5(string);
  }

  if (!raw) {
    return hexHMACMD5(key, string);
  }

  return rawHMACMD5(key, string);
}

var ErrorStack = /*#__PURE__*/function () {
  function ErrorStack(env) {
    _classCallCheck(this, ErrorStack);

    this.env = env || checkEnv();
    this.stackFilter = generateHandler(this.env).filter;
  }

  _createClass(ErrorStack, [{
    key: "makeReg",
    value: function makeReg() {
      switch (this.env) {
        case 'iOS':
          return new RegExp('(?:\\s*)\\w+(?=@)|(?:@).*?(?=:\\d*:)|(?::)\\d*(?=:)|(?::)\\d*$', 'g');
        // case 'Android':
        //   return new RegExp('(?<=\\s*)\\w+(?=@)|(?<=@).*?(?=:\\d*:)|(?<=:)\\d*(?=:)|(?<=:)\\d*$', 'g');

        default:
          return null;
      }
    }
  }, {
    key: "stackFormatter",
    value: function stackFormatter(error) {
      var message = error.message,
          stack = error.stack;
      var stackList = [];
      var isAndroid = this.env === 'Android';
      var isIOS = this.env === 'iOS';
      var filterList = stack.split('\n').filter(this.stackFilter);
      filterList.shift();
      var stackStr = filterList.join('\n');
      var reg = this.makeReg();

      if (reg) {
        filterList.map(function (line) {
          var res = line.match(reg);

          if (res) {
            var _res = _slicedToArray(res, 4),
                _res$ = _res[0],
                func = _res$ === void 0 ? '' : _res$,
                _res$2 = _res[1],
                filePath = _res$2 === void 0 ? '' : _res$2,
                _res$3 = _res[2],
                lineNumber = _res$3 === void 0 ? '' : _res$3,
                _res$4 = _res[3],
                locationNumebr = _res$4 === void 0 ? '' : _res$4;

            var funcName = isAndroid ? func.split('.').reverse()[0] : func;
            var gap = isIOS ? 1 : 0;
            stackList.push("at ".concat(funcName, " (").concat(filePath.substr(gap), ":").concat(lineNumber.substr(gap), ":").concat(locationNumebr.substr(gap), ")"));
          } else {
            stackList.push(line);
          }

          return null;
        });
      } else {
        stackList = filterList;
      }

      var hash = this.encryptStack(message, stackList);
      return {
        hash: hash,
        message: message,
        stackList: stackList,
        stackStr: stackStr
      };
    } // eslint-disable-next-line class-methods-use-this

  }, {
    key: "encryptStack",
    value: function encryptStack(message, stackList) {
      // 抽样取最多10行日志，靠前的取的密
      var stackSampleList = [].concat(_toConsumableArray(stackList.slice(0, 6)), _toConsumableArray(stackList.slice(7, 8)), _toConsumableArray(stackList.slice(9, 10)), _toConsumableArray(stackList.slice(11, 12)), _toConsumableArray(stackList.slice(13, 14)));
      var stackStr = stackSampleList.join(';');
      return md5("".concat(message, ":").concat(stackStr));
    }
  }]);

  return ErrorStack;
}();

/**
 * 解析错误对象中的 stack，并尝试压缩 js
 *
 * 压缩逻辑
 * 1. 提取 stack 中所有的 js 名，并为其附一个简化的标识符，形如 #1#
 * 2. 将 stack 中所有的 xxx.js 替换为对应的标识符
 * 3. 所有的标识符通过 `js名@标识符` 的形式保存，多个组合用 ; 隔开，保存为字段中的 c1
 * 4. 客户端读到 stack 后再按照原规则解析
 *
 * @param  {Object} errorObj 原生 Error
 * @return {string}
 */
var STACK_LENGTH_LIMIT = 20; // regex borrowed from https://github.com/getsentry/raven-js/blob/master/vendor/TraceKit/tracekit.js

var ChromeREGEX = /^\s*at .*? ?\(((?:file|https?|blob|chrome-extension|native|eval|<anonymous>).*?)(?::\d+)?(?::\d+)?\)?\s*$/i;
var GeckoREGEX = /^\s*.*?(?:\(.*?\))?(?:^|@)((?:file|https?|blob|chrome|resource|\[native).*?)(?::\d+)?(?::\d+)?\s*$/i;
var WinJSREGEX = /^\s*at (?:(?:\[object object\])?.+ )?\(?((?:file|ms-appx|https?|blob):.*?):\d+(?::\d+)?\)?\s*$/i; // for test

if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && "development" === 'test') {}

function parseStack(arrList) {
  var arr = arrList.slice(0, STACK_LENGTH_LIMIT);
  var result = ['', '']; // 由于 stack 中 js 地址很长，压缩同名的 js，以获得更多的 stack 捕获

  var jsObj = {};
  var identifierIndex = 1;

  for (var i = 0; i < arr.length; i += 1) {
    var matchRegex = ChromeREGEX;
    var matches = (arr[i] || '').match(matchRegex);

    if (matches === null) {
      matchRegex = GeckoREGEX;
      matches = (arr[i] || '').match(matchRegex);
    }

    if (matches === null) {
      matchRegex = WinJSREGEX;
      matches = (arr[i] || '').match(matchRegex);
    }

    if (matches !== null) {
      var jsFile = matches[1];
      var identifier = jsObj[jsFile];

      if (identifier === undefined) {
        jsObj[jsFile] = "#".concat(identifierIndex, "#");
        identifierIndex += 1;
        identifier = jsObj[jsFile];
      }

      arr[i] = arr[i].replace(jsFile, identifier);
    }
  }

  if (arr.length > 0) {
    result[1] = arr.map(function (line) {
      return line.trim();
    }).join("\x03");
  }

  var identifiers = '';

  for (var _jsFile in jsObj) {
    if (jsObj.hasOwnProperty(_jsFile)) {
      identifiers += "".concat(_jsFile, "@").concat(jsObj[_jsFile], ";");
    }
  }

  identifiers = identifiers.replace(/;$/, '');
  result[0] = identifiers;
  return result.join("\x10").replace(/\^/g, "\x04").replace(/=/g, "\x05").replace(/,/g, "\x06");
}

function unParseStack(stackStr) {
  var stack = stackStr && stackStr.split("\x10") || [];

  if (!stack[0] || !stack[1]) {
    return stackStr;
  }

  var jsObj = {};
  var jsFiles = stack[0].split(';');

  for (var i = 0; i < jsFiles.length; i += 1) {
    var files = jsFiles[i] && jsFiles[i].split('@#');
    jsObj["#".concat(files[1])] = files[0];
  }

  return stack[1].replace(/#[0-9]+#/g, function (reg) {
    return jsObj[reg] || '';
  }).replace(/\u0004/g, '^').replace(/\u0005/g, '=').replace(/\u0006/g, ',').split("\x03");
}

var helper = {
  compressStack: function compressStack(stackList) {
    return parseStack(stackList);
  },
  uncompressStack: function uncompressStack(stackStr) {
    return unParseStack(stackStr);
  }
};

var compressStack = helper.compressStack,
    uncompressStack = helper.uncompressStack;




/***/ }),

/***/ "../../node_modules/@alipay/yuyan-monitor-utils/dist/index.esm.js":
/*!************************************************************************!*\
  !*** ../../node_modules/@alipay/yuyan-monitor-utils/dist/index.esm.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OptionsDefaulter": () => (/* binding */ OptionsDefaulter),
/* harmony export */   "allFieldsReady": () => (/* binding */ allFieldsReady),
/* harmony export */   "codeEquals": () => (/* binding */ codeEquals),
/* harmony export */   "createOptionsDefaulter": () => (/* binding */ createOptionsDefaulter),
/* harmony export */   "enums": () => (/* binding */ enums),
/* harmony export */   "getOptionsDefaulter": () => (/* binding */ getOptionsDefaulter),
/* harmony export */   "logError": () => (/* binding */ logError),
/* harmony export */   "objectAssign": () => (/* binding */ objectAssign),
/* harmony export */   "preProcess": () => (/* binding */ preProcess),
/* harmony export */   "shallowMerge": () => (/* binding */ shallowMerge)
/* harmony export */ });
/* harmony import */ var _alipay_monitor_stack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @alipay/monitor-stack */ "../../node_modules/@alipay/monitor-stack/dist/index.esm.js");


function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function allFieldsReady(logItem) {
  var requiredFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var logger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};

  if (!requiredFields.length) {
    return true;
  }

  for (var i = 0; i < requiredFields.length; i++) {
    var field = requiredFields[i];

    if (logItem[field] === null || logItem[field] === undefined) {
      if (logger) {
        logger('Field is required. Log cached.');
      }

      return false;
    }
  }

  return true;
}
/**
 * 浅拷贝对象，将对象 b 中所有 a 不存在的 kv 拷贝给 a
 *
 * @export
 * @param {object} a
 * @param {object} b
 */

function shallowMerge(a, b) {
  for (var key in b) {
    if (b.hasOwnProperty(key)) {
      a[key] = b[key];
    }
  }
}
function objectAssign(target, obj) {
  if (!obj || _typeof(obj) !== 'object') {
    return target;
  }

  var tar = target || {};

  for (var key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== undefined) {
      tar[key] = obj[key];
    }
  }

  return tar;
}

/**
 * Gets the value at path of object
 * @param {object} obj object to query
 * @param {string} path query path
 * @returns {any} - if {@param path} requests element from array, then `undefined` will be returned
 */

function getProperty(obj, path) {
  var name = path.split('.');

  for (var i = 0; i < name.length - 1; i++) {
    obj = obj[name[i]];

    if (_typeof(obj) !== 'object' || !obj || Array.isArray(obj)) {
      return '';
    }
  }

  return obj[name.pop()];
}
/**
 * Sets the value at path of object. Stops execution, if {@param path} requests element from array to be set
 * @param {object} obj object to query
 * @param {string} path query path
 * @param {any} value value to be set
 * @returns {void}
 */

function setProperty(obj, path, value) {
  var name = path.split('.');

  for (var i = 0; i < name.length - 1; i++) {
    if (_typeof(obj[name[i]]) !== 'object' && obj[name[i]] !== undefined) {
      return;
    }

    if (Array.isArray(obj[name[i]])) {
      return;
    }

    if (!obj[name[i]]) {
      obj[name[i]] = {};
    }

    obj = obj[name[i]];
  }

  obj[name.pop()] = value;
}
/**
 * A Options Defaulter for Monitor Sdks
 * - Inspired by webpack optionsDefaulter
 * @export
 * @class OptionsDefaulter
 */

var OptionsDefaulter = /*#__PURE__*/function () {
  function OptionsDefaulter() {
    _classCallCheck(this, OptionsDefaulter);

    this.defaults = {};
    this.configs = {};
  }
  /**
   * build up default values
   *
   * @param {string} name option path
   * @param {ConfigType} config config if define is provided, then only config is allowed
   * @param {Define} [define] defaults
   * @memberof OptionsDefaulter
   */


  _createClass(OptionsDefaulter, [{
    key: "set",
    value: function set(name, config, define) {
      if (define !== undefined) {
        this.defaults[name] = define;
        this.configs[name] = config;
      } else {
        this.defaults[name] = config;
        delete this.configs[name];
      }
    }
    /**
     * executing values with default values
     *
     * @param {{}} options options provide by user
     * @memberof OptionsDefaulter
     */

  }, {
    key: "process",
    value: function process(options) {
      var _oldValue;

      options = objectAssign({}, options);

      for (var name in this.defaults) {
        if (this.defaults.hasOwnProperty(name)) {
          switch (this.configs[name]) {
            case 'call':
              setProperty(options, name, this.defaults[name].call(this, getProperty(options, name), options));
              break;

            case 'make':
              if (getProperty(options, name) === undefined) {
                setProperty(options, name, this.defaults[name].call(this, options));
              }

              break;

            case 'append':
              var oldValue = getProperty(options, name);

              if (!Array.isArray(oldValue)) {
                oldValue = [];
              }

              (_oldValue = oldValue).push.apply(_oldValue, _toConsumableArray(this.defaults[name]));

              setProperty(options, name, oldValue);
              break;

            default:
              if (getProperty(options, name) === undefined) {
                setProperty(options, name, this.defaults[name]);
              }

          }
        }
      }

      return options;
    }
  }]);

  return OptionsDefaulter;
}();

// 将dom转化为Array
function nodeListToArray(nodes) {
  var arr;
  var length;

  try {
    arr = [].slice.call(nodes);
    return arr;
  } catch (err) {
    arr = []; // eslint-disable-next-line prefer-destructuring

    length = nodes.length;

    for (var i = 0; i < length; i++) {
      arr.push(nodes[i]);
    }

    return arr;
  }
}
function getAttr(element, attrName) {
  return element && element.getAttribute ? element.getAttribute(attrName) || '' : '';
}

/* eslint-disable no-console */
var warnCache = {};

function safeWarn(src) {
  if (!console || !console.warn) {
    return;
  }

  console.warn(src);
}

function warnDeprecated(property, suggestion) {
  if (warnCache[property]) {
    return;
  }

  warnCache[property] = 1;
  safeWarn("\u914D\u7F6E\u9879 [".concat(property, "] \u5DF2\u4E0D\u63A8\u8350\u4F7F\u7528\u3002\u8BF7\u4F7F\u7528 [").concat(suggestion, "]\u3002"));
}

var defaulterSingleton;

function getGlobal() {
  if (!eval) {
    return global || window;
  }

  return (0, eval)('this');
}

function getOptionsDefaulter() {
  if (!defaulterSingleton) {
    defaulterSingleton = createOptionsDefaulter();
  }

  return defaulterSingleton;
}

var getMetaInfo = function (win) {
  return function (metaKey) {
    var _win$document;

    if (!(win === null || win === void 0 ? void 0 : (_win$document = win.document) === null || _win$document === void 0 ? void 0 : _win$document.querySelectorAll)) {
      return '';
    }

    var metas = nodeListToArray(win.document.querySelectorAll('meta'));

    for (var i = 0; i < metas.length; i++) {
      var m = metas[i];

      if (getAttr(m, 'name') === metaKey) {
        return getAttr(m, 'content');
      }
    }

    return null;
  };
}(getGlobal());

var metaMap = {
  _appId: 'bm_app_id',
  yuyanId: 'yuyan_id',
  sprintId: 'bm_sprint_id'
};

function getMetaOptions() {
  var options = {};

  for (var key in metaMap) {
    if (metaMap.hasOwnProperty(key)) {
      var metaContent = getMetaInfo(metaMap[key]);

      if (metaContent) {
        options[key] = metaContent;
      }
    }
  }

  return options;
}

function createOptionsDefaulter() {
  var defaulter = new OptionsDefaulter();
  var metaOptions = getMetaOptions(); // 优先取 yuyanId

  defaulter.set('yuyanId', 'call', function (value) {
    return value || metaOptions.yuyanId;
  }); // bmAppid 的兼容获取逻辑

  defaulter.set('bmAppid', 'call', function (value, options) {
    // 如果已经设置了 yuyanId，则 appId 不生效
    if (options.yuyanId) {
      safeWarn('已设置yuyanId，其他 id 将不生效');
      return null;
    } // 如果显式设置了 bmAppid，则直接取值


    if (value) {
      warnDeprecated('bmAppid', '_appId');
      return value;
    } // appid: 1.x appx 和 node 的接口rol


    if (options.appid) {
      warnDeprecated('appid', '_appId');
      return options.appid;
    } // _appId: 2.0 新增的建议 fallback 接口


    return options._appId || metaOptions._appId;
  });
  defaulter.set('userId', 'call', function (value, options) {
    if (options.roleId) {
      warnDeprecated('roleId', 'userId');
      return options.roleId;
    }

    return value;
  });
  defaulter.set('disableInterface', 'call', function (value) {
    return value || false;
  });
  defaulter.set('oncePerSession', 'call', function (value) {
    return value || false;
  });
  defaulter.set('autoCapture', 'call', function (_, options) {
    // 如果传入的属性里有写 autoCapture, 则用 Boolean 后的 autoCapture
    if (options.hasOwnProperty('autoCapture')) {
      return Boolean(options.autoCapture);
    }

    return true;
  });
  defaulter.set('defaults', 'call', function (value) {
    return objectAssign({}, value);
  });
  defaulter.set('sprintId', 'call', function (value) {
    return value || metaOptions.sprintId;
  }); // 只是做一下强转。。
  // 兼容一下用户只写一个字段的情况。。

  defaulter.set('requiredFields', 'call', function (value) {
    if (!Array.isArray(value)) {
      return typeof value === 'string' ? [value] : [];
    }

    return value;
  });
  defaulter.set('eventId', 'call', function (_, options) {
    return options.appType === 'PC' ? '102022' : '102023';
  });
  defaulter.set('beforeLog', 'call', function (value) {
    if (typeof value === 'function') {
      return value;
    }
  });
  defaulter.set('callBridge', 'call', function (value) {
    if (typeof value === 'function') {
      return value;
    }
  });
  defaulter.set('plugins', 'call', function (value) {
    return Array.isArray(value) ? value : ['tracert', 'performance', 'buc'];
  });
  defaulter.set('forceHttpReport', 'call', function (value) {
    return !!value;
  });
  return defaulter;
}

var ErrorCodeEnums = {
  JS: 1,
  REQUEST: 2,
  PROMISEREJECTION: 3,
  ASSETS: 4
};
var CodeLevelEnums = {
  B: '禁用',
  L: '低',
  M: '中',
  H: '高'
};

var enums = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ErrorCodeEnums: ErrorCodeEnums,
  CodeLevelEnums: CodeLevelEnums
});

var es = new _alipay_monitor_stack__WEBPACK_IMPORTED_MODULE_0__.ErrorStack();
function logError(err, hashDetect, _ref) {
  var log = _ref.log,
      _warn = _ref._warn;
  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  try {
    var code = (options === null || options === void 0 ? void 0 : options.code) || ErrorCodeEnums.JS; // 监控项code

    var hashValue = '';

    if (err) {
      if (err.stack) {
        var _es$stackFormatter = es.stackFormatter(err),
            hash = _es$stackFormatter.hash,
            stackList = _es$stackFormatter.stackList;

        hashValue = hash; // 判断堆栈是否上报过

        if (hash && stackList && stackList.length) {
          hashDetect(hash, function (error, detect) {
            if (error) {
              return _warn('hash检测失败', error);
            }

            if (!detect) {
              log(_objectSpread2(_objectSpread2({}, options), {}, {
                code: ErrorCodeEnums.JS,
                s1: hash,
                s2: (0,_alipay_monitor_stack__WEBPACK_IMPORTED_MODULE_0__.compressStack)(stackList),
                s3: 1
              }));
            }
          });
        } // 上报日志信息


        log(_objectSpread2({
          code: code,
          msg: err.message,
          s10: hashValue
        }, options));
      } else {
        log(_objectSpread2({
          code: code,
          msg: err.message || err
        }, options));
      }
    }
  } catch (e) {
    _warn('异常上报失败:', e);
  }
}

function codeEquals(code, otherCode) {
  return String(code) === String(otherCode);
}
var trackedLogs = {};
var PERFORMACE_RESERVED_CODE = '32767';
/**
 * 前置处理抽取到 utils 里统一维护
 *
 * @export
 * @param {LogItem} logItem
 * @param {MonitorOption[]} monitorConfig
 */

function preProcess(logItem, monitorInstance) {
  var _logItem$oncePerSessi;

  var destroyed = monitorInstance.destroyed,
      beforeLog = monitorInstance.beforeLog,
      _warn = monitorInstance._warn,
      tenant = monitorInstance.tenant;

  if (destroyed) {
    _warn('destroyed');

    return;
  }

  if (typeof beforeLog === 'function') {
    try {
      logItem = beforeLog(logItem);
    } catch (e) {
      _warn('beforeLog 失败：', e);
    }
  }

  if (!logItem || _typeof(logItem) !== 'object' && Array.isArray(logItem)) {
    _warn('beforeLog返回值不是对象，不进行上报');

    return;
  }

  var msgIdentify = [logItem.code, logItem.msg || '', logItem.uid].join('_');
  var trackedFlag = trackedLogs[msgIdentify];
  var finalOncePerSession = (_logItem$oncePerSessi = logItem.oncePerSession) !== null && _logItem$oncePerSessi !== void 0 ? _logItem$oncePerSessi : monitorInstance.oncePerSession;

  if (finalOncePerSession && trackedFlag) {
    monitorInstance._warn('当前由于 OncePerSession 策略，未被采集');

    return;
  }

  var bmAppid = logItem.bmAppid || monitorInstance.bmAppid;

  if (bmAppid === monitorInstance.bmAppid) {
    // 如果是性能监控项或非主站租户，直接放行
    if (codeEquals(logItem.code, PERFORMACE_RESERVED_CODE) || tenant !== 'MAIN_SITE') {
      return logItem;
    } // 判断下配置项下发


    var monitorConfig = monitorInstance.monitorOptionMap[Number(logItem.code)] || monitorInstance.monitorOptionMap["".concat(logItem.code)];

    if (!monitorInstance.monitorConfigFailed && !monitorConfig) {
      monitorInstance._warn("\u76D1\u63A7\u5E73\u53F0\u6CA1\u6709\u8BE5\u76D1\u63A7\u9879\u7684\u914D\u7F6E: ".concat(logItem.code));

      return;
    }

    if (monitorConfig) {
      var sampleRate = monitorConfig.sampleRate || logItem.sampleRate || 1;

      if (Math.random() > Number(sampleRate)) {
        _warn("\u5F53\u524D\u5DF2\u8BBE\u7F6E\u91C7\u6837\u7387 ".concat(sampleRate, "\uFF0C\u672A\u88AB\u91C7\u96C6"));

        return;
      }

      objectAssign(logItem, {
        sampleRate: sampleRate
      });

      if (monitorConfig.level) {
        objectAssign(logItem, {
          level: monitorConfig.level
        });
      }

      var fields = {};
      var configFields = monitorConfig.fields || [];

      for (var i = 0; i < configFields.length; i++) {
        fields[configFields[i]] = true;
      }

      for (var key in logItem) {
        if (!fields[key] && /^[dmc]\d+$/.test(key)) {
          delete logItem[key];
        }
      }
    }
  }

  trackedLogs[msgIdentify] = 1;
  return logItem;
}




/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/disposable.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/disposable.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefCountedDisposable = exports.MutableDisposable = exports.DisposableCollection = exports.Disposable = exports.toDisposable = exports.combinedDisposable = exports.dispose = exports.isDisposable = exports.DisposableStore = void 0;
const event_1 = __webpack_require__(/*! ./event */ "../../node_modules/@opensumi/ide-utils/lib/event.js");
// DisposableStore 是从 vscode lifecycle 中复制而来
class DisposableStore {
    constructor() {
        this.toDispose = new Set();
        this._isDisposed = false;
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        markTracked(this);
        this._isDisposed = true;
        this.clear();
    }
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    clear() {
        this.toDispose.forEach((item) => item.dispose());
        this.toDispose.clear();
    }
    add(t) {
        if (!t) {
            return t;
        }
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        markTracked(t);
        if (this._isDisposed) {
            // eslint-disable-next-line no-console
            console.warn(new Error('Registering disposable on object that has already been disposed of').stack);
            t.dispose();
        }
        else {
            this.toDispose.add(t);
        }
        return t;
    }
}
exports.DisposableStore = DisposableStore;
function isDisposable(thing) {
    return typeof thing.dispose === 'function' && thing.dispose.length === 0;
}
exports.isDisposable = isDisposable;
function dispose(first, ...rest) {
    if (Array.isArray(first)) {
        first.forEach((d) => {
            if (d) {
                markTracked(d);
                d.dispose();
            }
        });
        return [];
    }
    else if (rest.length === 0) {
        if (first) {
            markTracked(first);
            first.dispose();
            return first;
        }
        return undefined;
    }
    else {
        dispose(first);
        dispose(rest);
        return [];
    }
}
exports.dispose = dispose;
function combinedDisposable(disposables) {
    disposables.forEach(markTracked);
    return trackDisposable({ dispose: () => dispose(disposables) });
}
exports.combinedDisposable = combinedDisposable;
function toDisposable(fn) {
    return {
        dispose() {
            fn();
        },
    };
}
exports.toDisposable = toDisposable;
class Disposable {
    constructor(...toDispose) {
        this.disposables = [];
        this.onDisposeEmitter = new event_1.Emitter();
        this.disposingElements = false;
        toDispose.forEach((d) => this.addDispose(d));
    }
    static create(func) {
        return {
            dispose: func,
        };
    }
    get onDispose() {
        return this.onDisposeEmitter.event;
    }
    checkDisposed() {
        if (this.disposed && !this.disposingElements) {
            this.onDisposeEmitter.fire(undefined);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    dispose() {
        if (this.disposed || this.disposingElements) {
            return;
        }
        this.disposingElements = true;
        while (!this.disposed) {
            try {
                this.disposables.pop().dispose();
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error(e);
            }
        }
        this.disposingElements = false;
        this.checkDisposed();
    }
    addDispose(disposable) {
        if (Array.isArray(disposable)) {
            const disposables = disposable;
            return disposables.map((disposable) => this.addDispose(disposable));
        }
        else {
            return this.add(disposable);
        }
    }
    registerDispose(disposable) {
        if (disposable === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        this.add(disposable);
        return disposable;
    }
    add(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        const originalDispose = disposable.dispose.bind(disposable);
        const toRemove = Disposable.create(() => {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
                disposables.splice(index, 1);
            }
            this.checkDisposed();
        });
        disposable.dispose = () => {
            toRemove.dispose();
            originalDispose();
        };
        return toRemove;
    }
}
exports.Disposable = Disposable;
Disposable.NULL = Disposable.create(() => { });
Disposable.None = Object.freeze({ dispose() { } });
class DisposableCollection {
    constructor(...toDispose) {
        this.disposables = [];
        this.onDisposeEmitter = new event_1.Emitter();
        this.disposingElements = false;
        toDispose.forEach((d) => this.push(d));
    }
    get onDispose() {
        return this.onDisposeEmitter.event;
    }
    checkDisposed() {
        if (this.disposed && !this.disposingElements) {
            this.onDisposeEmitter.fire(undefined);
        }
    }
    get disposed() {
        return this.disposables.length === 0;
    }
    dispose() {
        if (this.disposed || this.disposingElements) {
            return;
        }
        const toPromise = [];
        this.disposingElements = true;
        while (!this.disposed) {
            try {
                const maybePromise = this.disposables.pop().dispose();
                if (maybePromise) {
                    toPromise.push(maybePromise);
                }
            }
            catch (e) {
                // eslint-disable-next-line no-console
                console.error('DisposableCollection.dispose error', e);
            }
        }
        this.disposingElements = false;
        this.checkDisposed();
        return Promise.all(toPromise);
    }
    push(disposable) {
        const disposables = this.disposables;
        disposables.push(disposable);
        const originalDispose = disposable.dispose.bind(disposable);
        const toRemove = Disposable.create(() => {
            const index = disposables.indexOf(disposable);
            if (index !== -1) {
                disposables.splice(index, 1);
            }
            this.checkDisposed();
        });
        disposable.dispose = () => {
            toRemove.dispose();
            originalDispose();
        };
        return toRemove;
    }
    pushAll(disposables) {
        return disposables.map((disposable) => this.push(disposable));
    }
}
exports.DisposableCollection = DisposableCollection;
/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
const TRACK_DISPOSABLES = false;
const __is_disposable_tracked__ = '__is_disposable_tracked__';
function markTracked(x) {
    if (!TRACK_DISPOSABLES) {
        return;
    }
    if (x && x !== Disposable.None) {
        try {
            x[__is_disposable_tracked__] = true;
        }
        catch (_e) {
            // noop
        }
    }
}
function trackDisposable(x) {
    if (!TRACK_DISPOSABLES) {
        return x;
    }
    const stack = new Error('Potentially leaked disposable').stack;
    setTimeout(() => {
        if (!x[__is_disposable_tracked__]) {
            // eslint-disable-next-line no-console
            console.log(stack);
        }
    }, 3000);
    return x;
}
/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
class MutableDisposable {
    constructor() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    get value() {
        return this._isDisposed ? undefined : this._value;
    }
    set value(value) {
        if (this._isDisposed || value === this._value) {
            return;
        }
        if (this._value) {
            this._value.dispose();
        }
        if (value) {
            markTracked(value);
        }
        this._value = value;
    }
    clear() {
        this.value = undefined;
    }
    dispose() {
        this._isDisposed = true;
        markTracked(this);
        if (this._value) {
            this._value.dispose();
        }
        this._value = undefined;
    }
}
exports.MutableDisposable = MutableDisposable;
class RefCountedDisposable {
    constructor(_disposable) {
        this._disposable = _disposable;
        this._counter = 1;
    }
    acquire() {
        this._counter++;
        return this;
    }
    release() {
        if (--this._counter === 0) {
            this._disposable.dispose();
        }
        return this;
    }
}
exports.RefCountedDisposable = RefCountedDisposable;
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/errors.js":
/*!************************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/errors.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Some code copied and modified from https://github.com/microsoft/vscode/blob/1.44.0/src/vs/base/common/errors.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getErrorMessage = exports.disposed = exports.readonly = exports.illegalState = exports.illegalArgument = exports.canceled = exports.isPromiseCanceledError = exports.transformErrorForSerialization = exports.onUnexpectedExternalError = exports.onUnexpectedError = exports.setUnexpectedErrorHandler = exports.errorHandler = exports.ErrorHandler = void 0;
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
class ErrorHandler {
    constructor() {
        this.listeners = [];
        this.unexpectedErrorHandler = function (e) {
            setTimeout(() => {
                if (e.stack) {
                    throw new Error(e.message + '\n\n' + e.stack);
                }
                throw e;
            }, 0);
        };
    }
    addListener(listener) {
        this.listeners.push(listener);
        return () => {
            this._removeListener(listener);
        };
    }
    emit(e) {
        this.listeners.forEach((listener) => {
            listener(e);
        });
    }
    _removeListener(listener) {
        this.listeners.splice(this.listeners.indexOf(listener), 1);
    }
    setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        this.unexpectedErrorHandler = newUnexpectedErrorHandler;
    }
    getUnexpectedErrorHandler() {
        return this.unexpectedErrorHandler;
    }
    onUnexpectedError(e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
    }
    // For external errors, we don't want the listeners to be called
    onUnexpectedExternalError(e) {
        this.unexpectedErrorHandler(e);
    }
}
exports.ErrorHandler = ErrorHandler;
exports.errorHandler = new ErrorHandler();
function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
    exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
}
exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
function onUnexpectedError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        exports.errorHandler.onUnexpectedError(e);
    }
    return undefined;
}
exports.onUnexpectedError = onUnexpectedError;
function onUnexpectedExternalError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        exports.errorHandler.onUnexpectedExternalError(e);
    }
    return undefined;
}
exports.onUnexpectedExternalError = onUnexpectedExternalError;
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        const { name, message } = error;
        const stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name,
            message,
            stack,
        };
    }
    // return as is
    return error;
}
exports.transformErrorForSerialization = transformErrorForSerialization;
const canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
function isPromiseCanceledError(error) {
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
exports.isPromiseCanceledError = isPromiseCanceledError;
/**
 * Returns an error that signals cancellation.
 */
function canceled() {
    const error = new Error(canceledName);
    error.name = error.message;
    return error;
}
exports.canceled = canceled;
function illegalArgument(name) {
    if (name) {
        return new Error(`Illegal argument: ${name}`);
    }
    else {
        return new Error('Illegal argument');
    }
}
exports.illegalArgument = illegalArgument;
function illegalState(name) {
    if (name) {
        return new Error(`Illegal state: ${name}`);
    }
    else {
        return new Error('Illegal state');
    }
}
exports.illegalState = illegalState;
function readonly(name) {
    return name
        ? new Error(`readonly property '${name} cannot be changed'`)
        : new Error('readonly property cannot be changed');
}
exports.readonly = readonly;
function disposed(what) {
    const result = new Error(`${what} has been disposed`);
    result.name = 'DISPOSED';
    return result;
}
exports.disposed = disposed;
function getErrorMessage(err) {
    if (!err) {
        return 'Error';
    }
    if (err.message) {
        return err.message;
    }
    if (err.stack) {
        return err.stack.split('\n')[0];
    }
    return String(err);
}
exports.getErrorMessage = getErrorMessage;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/event.js":
/*!***********************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/event.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Some code copied and modified from https://github.com/microsoft/vscode/blob/1.44.0/src/vs/base/common/event.ts
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadyEvent = exports.Relay = exports.EventBufferer = exports.EventMultiplexer = exports.AsyncEmitter = exports.WaitUntilEvent = exports.PauseableEmitter = exports.Emitter = exports.setGlobalLeakWarningThreshold = exports.Event = void 0;
const disposable_1 = __webpack_require__(/*! ./disposable */ "../../node_modules/@opensumi/ide-utils/lib/disposable.js");
const errors_1 = __webpack_require__(/*! ./errors */ "../../node_modules/@opensumi/ide-utils/lib/errors.js");
const functional_1 = __webpack_require__(/*! ./functional */ "../../node_modules/@opensumi/ide-utils/lib/functional.js");
const linked_list_1 = __webpack_require__(/*! ./linked-list */ "../../node_modules/@opensumi/ide-utils/lib/linked-list.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () {
        return _disposable;
    };
    /**
     * Given an event, returns another event which only fires once.
     */
    function once(event) {
        return (listener, thisArgs = null, disposables) => {
            // we need this, in case the event fires during the listener call
            let didFire = false;
            const result = event((e) => {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    Event.once = once;
    /**
     * Given an event and a `map` function, returns another event which maps each element
     * throught the mapping function.
     */
    function map(event, map) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map(i)), null, disposables));
    }
    Event.map = map;
    /**
     * Given an event and an `each` function, returns another identical event and calls
     * the `each` function per each element.
     */
    function forEach(event, each) {
        return snapshot((listener, thisArgs = null, disposables) => event((i) => {
            each(i);
            listener.call(thisArgs, i);
        }, null, disposables));
    }
    Event.forEach = forEach;
    function filter(event, filter) {
        return snapshot((listener, thisArgs = null, disposables) => event((e) => filter(e) && listener.call(thisArgs, e), null, disposables));
    }
    Event.filter = filter;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal(event) {
        return event;
    }
    Event.signal = signal;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any(...events) {
        return (listener, thisArgs = null, disposables) => (0, disposable_1.combinedDisposable)(events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
    }
    Event.any = any;
    /**
     * Given an event and a `merge` function, returns another event which maps each element
     * and the cummulative result throught the `merge` function. Similar to `map`, but with memory.
     */
    function reduce(event, merge, initial) {
        let output = initial;
        return map(event, (e) => {
            output = merge(output, e);
            return output;
        });
    }
    Event.reduce = reduce;
    /**
     * Given a chain of event processing functions (filter, map, etc), each
     * function will be invoked per event & per listener. Snapshotting an event
     * chain allows each function to be invoked just once per event.
     */
    function snapshot(event) {
        let listener;
        const emitter = new Emitter({
            onFirstListenerAdd() {
                listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove() {
                listener.dispose();
            },
        });
        return emitter.event;
    }
    Event.snapshot = snapshot;
    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold) {
        let subscription;
        let output;
        let handle;
        let numDebouncedCalls = 0;
        const emitter = new Emitter({
            leakWarningThreshold,
            onFirstListenerAdd() {
                subscription = event((cur) => {
                    numDebouncedCalls++;
                    output = merge(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                    }
                    clearTimeout(handle);
                    handle = setTimeout(() => {
                        const _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove() {
                subscription.dispose();
            },
        });
        return emitter.event;
    }
    Event.debounce = debounce;
    /**
     * Given an event, it returns another event which fires only once and as soon as
     * the input event emits. The event data is the number of millis it took for the
     * event to fire.
     */
    function stopwatch(event) {
        const start = new Date().getTime();
        return map(once(event), (_) => new Date().getTime() - start);
    }
    Event.stopwatch = stopwatch;
    /**
     * Given an event, it returns another event which fires only when the event
     * element changes.
     */
    function latch(event) {
        let firstCall = true;
        let cache;
        return filter(event, (value) => {
            const shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    Event.latch = latch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick = false, _buffer = []) {
        let buffer = _buffer.slice();
        let listener = event((e) => {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        const flush = () => {
            if (buffer) {
                buffer.forEach((e) => emitter.fire(e));
            }
            buffer = null;
        };
        const emitter = new Emitter({
            onFirstListenerAdd() {
                if (!listener) {
                    listener = event((e) => emitter.fire(e));
                }
            },
            onFirstListenerDidAdd() {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove() {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            },
        });
        return emitter.event;
    }
    Event.buffer = buffer;
    class ChainableEvent {
        constructor(event) {
            this.event = event;
        }
        map(fn) {
            return new ChainableEvent(map(this.event, fn));
        }
        forEach(fn) {
            return new ChainableEvent(forEach(this.event, fn));
        }
        filter(fn) {
            return new ChainableEvent(filter(this.event, fn));
        }
        reduce(merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
        }
        latch() {
            return new ChainableEvent(latch(this.event));
        }
        on(listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
        }
        once(listener, thisArgs, disposables) {
            return once(this.event)(listener, thisArgs, disposables);
        }
    }
    function chain(event) {
        return new ChainableEvent(event);
    }
    Event.chain = chain;
    function fromNodeEventEmitter(emitter, eventName, map = (id) => id) {
        const fn = (...args) => result.fire(map(...args));
        const onFirstListenerAdd = () => emitter.on(eventName, fn);
        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });
        return result.event;
    }
    Event.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromPromise(promise) {
        const emitter = new Emitter();
        let shouldEmit = false;
        promise
            .then(undefined, () => null)
            .then(() => {
            if (!shouldEmit) {
                setTimeout(() => emitter.fire(undefined), 0);
            }
            else {
                emitter.fire(undefined);
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    Event.fromPromise = fromPromise;
    function toPromise(event) {
        return new Promise((c) => once(event)(c));
    }
    Event.toPromise = toPromise;
})(Event = exports.Event || (exports.Event = {}));
let _globalLeakWarningThreshold = -1;
function setGlobalLeakWarningThreshold(n) {
    const oldValue = _globalLeakWarningThreshold;
    _globalLeakWarningThreshold = n;
    return {
        dispose() {
            _globalLeakWarningThreshold = oldValue;
        },
    };
}
exports.setGlobalLeakWarningThreshold = setGlobalLeakWarningThreshold;
class LeakageMonitor {
    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
        this.customThreshold = customThreshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    dispose() {
        if (this._stacks) {
            this._stacks.clear();
        }
    }
    check(listenerCount) {
        let threshold = _globalLeakWarningThreshold;
        if (typeof this.customThreshold === 'number') {
            threshold = this.customThreshold;
        }
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = new Map();
        }
        const stack = new Error().stack.split('\n').slice(3).join('\n');
        const count = this._stacks.get(stack) || 0;
        this._stacks.set(stack, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            // only warn on first exceed and then every time the limit
            // is exceeded by 50% again
            this._warnCountdown = threshold * 0.5;
            // find most frequent listener and print warning
            let topStack = '';
            let topCount = 0;
            this._stacks.forEach((count, stack) => {
                if (!topStack || topCount < count) {
                    topStack = stack;
                    topCount = count;
                }
            });
            // eslint-disable-next-line no-console
            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
            // eslint-disable-next-line no-console
            console.warn(topStack);
        }
        return () => {
            const count = this._stacks.get(stack) || 0;
            this._stacks.set(stack, count - 1);
        };
    }
}
class Emitter {
    constructor(options) {
        this._disposed = false;
        this._options = options;
        this._leakageMon =
            _globalLeakWarningThreshold > 0
                ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)
                : undefined;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._listeners) {
                    this._listeners = new linked_list_1.LinkedList();
                }
                const firstListener = this._listeners.isEmpty();
                if (firstListener && this._options && this._options.onFirstListenerAdd) {
                    this._options.onFirstListenerAdd(this);
                }
                const remove = this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                if (firstListener && this._options && this._options.onFirstListenerDidAdd) {
                    this._options.onFirstListenerDidAdd(this);
                }
                if (this._options && this._options.onListenerDidAdd) {
                    this._options.onListenerDidAdd(this, listener, thisArgs);
                }
                // check and record this emitter for potential leakage
                let removeMonitor;
                if (this._leakageMon) {
                    removeMonitor = this._leakageMon.check(this._listeners.size);
                }
                let result;
                result = {
                    dispose: () => {
                        if (removeMonitor) {
                            removeMonitor();
                        }
                        result.dispose = Emitter._noop;
                        if (!this._disposed) {
                            remove();
                            if (this._options && this._options.onLastListenerRemove) {
                                const hasListeners = this._listeners && !this._listeners.isEmpty();
                                if (!hasListeners) {
                                    this._options.onLastListenerRemove(this);
                                }
                            }
                        }
                    },
                };
                if (disposables instanceof disposable_1.DisposableStore) {
                    disposables.add(result);
                }
                else if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._listeners) {
            // put all [listener,event]-pairs into delivery queue
            // then emit all event. an inner/nested event might be
            // the driver of this
            if (!this._deliveryQueue) {
                this._deliveryQueue = new linked_list_1.LinkedList();
            }
            for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                this._deliveryQueue.push([e.value, event]);
            }
            while (this._deliveryQueue.size > 0) {
                const [listener, event] = this._deliveryQueue.shift();
                try {
                    if (typeof listener === 'function') {
                        listener.call(undefined, event);
                    }
                    else {
                        listener[0].call(listener[1], event);
                    }
                }
                catch (e) {
                    (0, errors_1.onUnexpectedError)(e);
                }
            }
        }
    }
    /**
     * 发送一个异步事件，等待所有监听器返回，并收集返回值
     * @param e
     * @param timeout
     */
    async fireAndAwait(event, timeout = 2000) {
        if (this._listeners) {
            if (!this._deliveryQueue) {
                this._deliveryQueue = new linked_list_1.LinkedList();
            }
            for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                this._deliveryQueue.push([e.value, event]);
            }
            const promises = [];
            const timeoutPromise = new Promise((resolve) => {
                setTimeout(() => {
                    resolve({
                        err: new Error('timeout'),
                    });
                }, timeout);
            });
            while (this._deliveryQueue.size > 0) {
                const [listener, event] = this._deliveryQueue.shift();
                try {
                    const promise = (async () => {
                        try {
                            if (typeof listener === 'function') {
                                return {
                                    result: (await listener.call(undefined, event)),
                                };
                            }
                            else {
                                return {
                                    result: (await listener[0].call(listener[1], event)),
                                };
                            }
                        }
                        catch (e) {
                            return {
                                err: e,
                            };
                        }
                    })();
                    promises.push(Promise.race([timeoutPromise, promise]));
                }
                catch (e) {
                    (0, errors_1.onUnexpectedError)(e);
                }
            }
            return Promise.all(promises);
        }
        else {
            return [];
        }
    }
    get listenerSize() {
        return this._listeners ? this._listeners.size : 0;
    }
    dispose() {
        if (this._listeners) {
            this._listeners.clear();
        }
        if (this._deliveryQueue) {
            this._deliveryQueue.clear();
        }
        if (this._leakageMon) {
            this._leakageMon.dispose();
        }
        this._disposed = true;
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
class PauseableEmitter extends Emitter {
    constructor(options) {
        super(options);
        this._isPaused = 0;
        this._eventQueue = new linked_list_1.LinkedList();
        this._mergeFn = options && options.merge;
    }
    pause() {
        this._isPaused++;
    }
    resume() {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
            if (this._mergeFn) {
                // use the merge function to create a single composite
                // event. make a copy in case firing pauses this emitter
                const events = this._eventQueue.toArray();
                this._eventQueue.clear();
                super.fire(this._mergeFn(events));
            }
            else {
                // no merging, fire each event individually and test
                // that this emitter isn't paused halfway through
                while (!this._isPaused && this._eventQueue.size !== 0) {
                    super.fire(this._eventQueue.shift());
                }
            }
        }
    }
    fire(event) {
        if (this._listeners) {
            if (this._isPaused !== 0) {
                this._eventQueue.push(event);
            }
            else {
                super.fire(event);
            }
        }
    }
}
exports.PauseableEmitter = PauseableEmitter;
var WaitUntilEvent;
(function (WaitUntilEvent) {
    async function fire(emitter, event, timeout = undefined) {
        const waitables = [];
        const asyncEvent = Object.assign(event, {
            waitUntil: (thenable) => {
                if (Object.isFrozen(waitables)) {
                    throw new Error('waitUntil cannot be called asynchronously.');
                }
                waitables.push(thenable);
            },
        });
        emitter.fire(asyncEvent);
        // Asynchronous calls to `waitUntil` should fail.
        Object.freeze(waitables);
        // ts 要求 delete 的属性是 optional
        delete asyncEvent.waitUntil;
        if (!waitables.length) {
            return;
        }
        if (timeout !== undefined) {
            await Promise.race([Promise.all(waitables), new Promise((resolve) => setTimeout(resolve, timeout))]);
        }
        else {
            await Promise.all(waitables);
        }
    }
    WaitUntilEvent.fire = fire;
})(WaitUntilEvent = exports.WaitUntilEvent || (exports.WaitUntilEvent = {}));
class AsyncEmitter extends Emitter {
    async fireAsync(data, token, promiseJoin) {
        if (!this._listeners) {
            return;
        }
        if (!this._asyncDeliveryQueue) {
            this._asyncDeliveryQueue = new linked_list_1.LinkedList();
        }
        for (let iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
            this._asyncDeliveryQueue.push([e.value, data]);
        }
        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {
            const [listener, data] = this._asyncDeliveryQueue.shift();
            const thenables = [];
            const event = Object.assign(Object.assign({}, data), { waitUntil: (p) => {
                    if (Object.isFrozen(thenables)) {
                        throw new Error('waitUntil can NOT be called asynchronous');
                    }
                    if (promiseJoin) {
                        p = promiseJoin(p, typeof listener === 'function' ? listener : listener[0]);
                    }
                    thenables.push(p);
                } });
            try {
                if (typeof listener === 'function') {
                    listener.call(undefined, event);
                }
                else {
                    listener[0].call(listener[1], event);
                }
            }
            catch (e) {
                (0, errors_1.onUnexpectedError)(e);
                continue;
            }
            // freeze thenables-collection to enforce sync-calls to
            // wait until and then wait for all thenables to resolve
            Object.freeze(thenables);
            await Promise.all(
            // Promise.allSettled 只有 core-js3 才支持，先手动加 catch 处理下
            thenables.map((thenable) => thenable.catch((e) => e))).catch((e) => (0, errors_1.onUnexpectedError)(e));
        }
    }
}
exports.AsyncEmitter = AsyncEmitter;
class EventMultiplexer {
    constructor() {
        this.hasListeners = false;
        this.events = [];
        this.emitter = new Emitter({
            onFirstListenerAdd: () => this.onFirstListenerAdd(),
            onLastListenerRemove: () => this.onLastListenerRemove(),
        });
    }
    get event() {
        return this.emitter.event;
    }
    add(event) {
        const e = { event, listener: null };
        this.events.push(e);
        if (this.hasListeners) {
            this.hook(e);
        }
        const dispose = () => {
            if (this.hasListeners) {
                this.unhook(e);
            }
            const idx = this.events.indexOf(e);
            this.events.splice(idx, 1);
        };
        return (0, disposable_1.toDisposable)((0, functional_1.once)(dispose));
    }
    onFirstListenerAdd() {
        this.hasListeners = true;
        this.events.forEach((e) => this.hook(e));
    }
    onLastListenerRemove() {
        this.hasListeners = false;
        this.events.forEach((e) => this.unhook(e));
    }
    hook(e) {
        e.listener = e.event((r) => this.emitter.fire(r));
    }
    unhook(e) {
        if (e.listener) {
            e.listener.dispose();
        }
        e.listener = null;
    }
    dispose() {
        this.emitter.dispose();
    }
}
exports.EventMultiplexer = EventMultiplexer;
/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */
class EventBufferer {
    constructor() {
        this.buffers = [];
    }
    wrapEvent(event) {
        return (listener, thisArgs, disposables) => event((i) => {
            const buffer = this.buffers[this.buffers.length - 1];
            if (buffer) {
                buffer.push(() => listener.call(thisArgs, i));
            }
            else {
                listener.call(thisArgs, i);
            }
        }, undefined, disposables);
    }
    bufferEvents(fn) {
        const buffer = [];
        this.buffers.push(buffer);
        const r = fn();
        this.buffers.pop();
        buffer.forEach((flush) => flush());
        return r;
    }
}
exports.EventBufferer = EventBufferer;
/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */
class Relay {
    constructor() {
        this.listening = false;
        this.inputEvent = Event.None;
        this.inputEventListener = disposable_1.Disposable.None;
        this.emitter = new Emitter({
            onFirstListenerDidAdd: () => {
                this.listening = true;
                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
            },
            onLastListenerRemove: () => {
                this.listening = false;
                this.inputEventListener.dispose();
            },
        });
        this.event = this.emitter.event;
    }
    set input(event) {
        this.inputEvent = event;
        if (this.listening) {
            this.inputEventListener.dispose();
            this.inputEventListener = event(this.emitter.fire, this.emitter);
        }
    }
    dispose() {
        this.inputEventListener.dispose();
        this.emitter.dispose();
    }
}
exports.Relay = Relay;
/**
 * 同步执行的 Ready， 对 ready 的实时响应比 promise 快，多用在需要快速响应初始化回调的场景
 */
class ReadyEvent {
    constructor() {
        this._isReady = false;
        this._param = undefined;
        this._emitter = new Emitter();
    }
    onceReady(cb) {
        if (this._isReady) {
            try {
                return Promise.resolve(cb(this._param));
            }
            catch (e) {
                return Promise.reject(e);
            }
        }
        else {
            return new Promise((resolve, reject) => {
                this._emitter.event((param) => {
                    try {
                        resolve(cb(param));
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        }
    }
    ready(param) {
        if (!this._isReady) {
            this._isReady = true;
            this._param = param;
        }
        this._emitter.fire(param);
        this._emitter.dispose();
        this._emitter = null;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
        }
    }
}
exports.ReadyEvent = ReadyEvent;
//# sourceMappingURL=event.js.map

/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/functional.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/functional.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeObjectFromArray = exports.makeRandomHexString = exports.once = void 0;
function once(fn) {
    const _this = this;
    let didCall = false;
    let result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}
exports.once = once;
function makeRandomHexString(length) {
    const chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
    let result = '';
    for (let i = 0; i < length; i++) {
        const idx = Math.floor(chars.length * Math.random());
        result += chars[idx];
    }
    return result;
}
exports.makeRandomHexString = makeRandomHexString;
function removeObjectFromArray(array, object, comparator) {
    let index = -1;
    if (comparator) {
        index = array.findIndex((o) => comparator(o, object));
    }
    else {
        index = array.indexOf(object);
    }
    if (index !== -1) {
        array.splice(index, 1);
    }
}
exports.removeObjectFromArray = removeObjectFromArray;
//# sourceMappingURL=functional.js.map

/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/iterator.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/iterator.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* ---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.map = exports.filter = exports.FIN = void 0;
exports.FIN = { done: true, value: undefined };
function* filter(iterable, predicate) {
    for (const element of iterable) {
        if (predicate(element)) {
            yield element;
        }
    }
}
exports.filter = filter;
function* map(iterable, fn) {
    let index = 0;
    for (const element of iterable) {
        yield fn(element, index++);
    }
}
exports.map = map;
//# sourceMappingURL=iterator.js.map

/***/ }),

/***/ "../../node_modules/@opensumi/ide-utils/lib/linked-list.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@opensumi/ide-utils/lib/linked-list.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedList = void 0;
const iterator_1 = __webpack_require__(/*! ./iterator */ "../../node_modules/@opensumi/ide-utils/lib/iterator.js");
class Node {
    constructor(element) {
        this.element = element;
        this.next = Node.Undefined;
        this.prev = Node.Undefined;
    }
}
Node.Undefined = new Node(undefined);
class LinkedList {
    constructor() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    get size() {
        return this._size;
    }
    isEmpty() {
        return this._first === Node.Undefined;
    }
    clear() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    unshift(element) {
        return this._insert(element, false);
    }
    push(element) {
        return this._insert(element, true);
    }
    _insert(element, atTheEnd) {
        const newNode = new Node(element);
        if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
        }
        else if (atTheEnd) {
            // push
            const oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
        }
        else {
            // unshift
            const oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
        }
        this._size += 1;
        let didRemove = false;
        return () => {
            if (!didRemove) {
                didRemove = true;
                this._remove(newNode);
            }
        };
    }
    shift() {
        if (this._first === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._first.element;
            this._remove(this._first);
            return res;
        }
    }
    pop() {
        if (this._last === Node.Undefined) {
            return undefined;
        }
        else {
            const res = this._last.element;
            this._remove(this._last);
            return res;
        }
    }
    _remove(node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            // middle
            const anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
        }
        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            // only node
            this._first = Node.Undefined;
            this._last = Node.Undefined;
        }
        else if (node.next === Node.Undefined) {
            // last
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
        }
        else if (node.prev === Node.Undefined) {
            // first
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
        }
        // done
        this._size -= 1;
    }
    iterator() {
        let element;
        let node = this._first;
        return {
            next() {
                if (node === Node.Undefined) {
                    return iterator_1.FIN;
                }
                if (!element) {
                    element = { done: false, value: node.element };
                }
                else {
                    element.value = node.element;
                }
                node = node.next;
                return element;
            },
        };
    }
    toArray() {
        const result = [];
        for (let node = this._first; node !== Node.Undefined; node = node.next) {
            result.push(node.element);
        }
        return result;
    }
}
exports.LinkedList = LinkedList;
//# sourceMappingURL=linked-list.js.map

/***/ }),

/***/ "../../node_modules/default-user-agent/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/default-user-agent/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/**!
 * default-user-agent - index.js
 *
 * Copyright(c) fengmk2 and other contributors.
 * MIT Licensed
 *
 * Authors:
 *   fengmk2 <fengmk2@gmail.com> (http://fengmk2.com)
 */



/**
 * Module dependencies.
 */

var osName = __webpack_require__(/*! os-name */ "../../node_modules/os-name/index.js");

var USER_AGENT = 'Node.js/' + process.version.slice(1)
  + ' (' + osName() + '; ' + process.arch + ')';

module.exports = function ua(name, version) {
  if (arguments.length !== 2) {
    return USER_AGENT;
  }
  return name + '/' + version + ' ' + USER_AGENT;
};


/***/ }),

/***/ "../../node_modules/end-of-stream/index.js":
/*!*************************************************!*\
  !*** ../../node_modules/end-of-stream/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "../../node_modules/once/once.js");

var noop = function() {};

var isRequest = function(stream) {
	return stream.setHeader && typeof stream.abort === 'function';
};

var isChildProcess = function(stream) {
	return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3
};

var eos = function(stream, opts, callback) {
	if (typeof opts === 'function') return eos(stream, null, opts);
	if (!opts) opts = {};

	callback = once(callback || noop);

	var ws = stream._writableState;
	var rs = stream._readableState;
	var readable = opts.readable || (opts.readable !== false && stream.readable);
	var writable = opts.writable || (opts.writable !== false && stream.writable);
	var cancelled = false;

	var onlegacyfinish = function() {
		if (!stream.writable) onfinish();
	};

	var onfinish = function() {
		writable = false;
		if (!readable) callback.call(stream);
	};

	var onend = function() {
		readable = false;
		if (!writable) callback.call(stream);
	};

	var onexit = function(exitCode) {
		callback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);
	};

	var onerror = function(err) {
		callback.call(stream, err);
	};

	var onclose = function() {
		process.nextTick(onclosenexttick);
	};

	var onclosenexttick = function() {
		if (cancelled) return;
		if (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));
		if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));
	};

	var onrequest = function() {
		stream.req.on('finish', onfinish);
	};

	if (isRequest(stream)) {
		stream.on('complete', onfinish);
		stream.on('abort', onclose);
		if (stream.req) onrequest();
		else stream.on('request', onrequest);
	} else if (writable && !ws) { // legacy streams
		stream.on('end', onlegacyfinish);
		stream.on('close', onlegacyfinish);
	}

	if (isChildProcess(stream)) stream.on('exit', onexit);

	stream.on('end', onend);
	stream.on('finish', onfinish);
	if (opts.error !== false) stream.on('error', onerror);
	stream.on('close', onclose);

	return function() {
		cancelled = true;
		stream.removeListener('complete', onfinish);
		stream.removeListener('abort', onclose);
		stream.removeListener('request', onrequest);
		if (stream.req) stream.req.removeListener('finish', onfinish);
		stream.removeListener('end', onlegacyfinish);
		stream.removeListener('close', onlegacyfinish);
		stream.removeListener('finish', onfinish);
		stream.removeListener('exit', onexit);
		stream.removeListener('end', onend);
		stream.removeListener('error', onerror);
		stream.removeListener('close', onclose);
	};
};

module.exports = eos;


/***/ }),

/***/ "../../node_modules/lodash.debounce/index.js":
/*!***************************************************!*\
  !*** ../../node_modules/lodash.debounce/index.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = debounce;


/***/ }),

/***/ "../../node_modules/once/once.js":
/*!***************************************!*\
  !*** ../../node_modules/once/once.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "../../node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "../../node_modules/os-name/index.js":
/*!*******************************************!*\
  !*** ../../node_modules/os-name/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");
var osxRelease = __webpack_require__(/*! osx-release */ "../../node_modules/osx-release/index.js");
var winRelease = __webpack_require__(/*! win-release */ "../../node_modules/win-release/index.js");

module.exports = function (platform, release) {
	if (!platform && release) {
		throw new Error('You can\'t specify a `release` without specfying `platform`');
	}

	platform = platform || os.platform();
	release = release || os.release();

	var id;

	if (platform === 'darwin') {
		id = osxRelease(release).name;
		return 'OS X' + (id ? ' ' + id : '');
	}

	if (platform === 'linux') {
		id = release.replace(/^(\d+\.\d+).*/, '$1');
		return 'Linux' + (id ? ' ' + id : '');
	}

	if (platform === 'win32') {
		id = winRelease(release);
		return 'Windows' + (id ? ' ' + id : '');
	}

	return platform;
};


/***/ }),

/***/ "../../node_modules/osx-release/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/osx-release/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");

var nameMap = {
	'15': 'El Capitan',
	'14': 'Yosemite',
	'13': 'Mavericks',
	'12': 'Mountain Lion',
	'11': 'Lion',
	'10': 'Snow Leopard',
	'9': 'Leopard',
	'8': 'Tiger',
	'7': 'Panther',
	'6': 'Jaguar',
	'5': 'Puma'
};

module.exports = function (release) {
	release = (release || os.release()).split('.')[0];
	return {
		name: nameMap[release],
		version: '10.' + (Number(release) - 4)
	};
};


/***/ }),

/***/ "../../node_modules/pump/index.js":
/*!****************************************!*\
  !*** ../../node_modules/pump/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var once = __webpack_require__(/*! once */ "../../node_modules/once/once.js")
var eos = __webpack_require__(/*! end-of-stream */ "../../node_modules/end-of-stream/index.js")
var fs = __webpack_require__(/*! fs */ "fs") // we only need fs to get the ReadStream and WriteStream prototypes

var noop = function () {}
var ancient = /^v?\.0/.test(process.version)

var isFn = function (fn) {
  return typeof fn === 'function'
}

var isFS = function (stream) {
  if (!ancient) return false // newer node version do not need to care about fs is a special way
  if (!fs) return false // browser
  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)
}

var isRequest = function (stream) {
  return stream.setHeader && isFn(stream.abort)
}

var destroyer = function (stream, reading, writing, callback) {
  callback = once(callback)

  var closed = false
  stream.on('close', function () {
    closed = true
  })

  eos(stream, {readable: reading, writable: writing}, function (err) {
    if (err) return callback(err)
    closed = true
    callback()
  })

  var destroyed = false
  return function (err) {
    if (closed) return
    if (destroyed) return
    destroyed = true

    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks
    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want

    if (isFn(stream.destroy)) return stream.destroy()

    callback(err || new Error('stream was destroyed'))
  }
}

var call = function (fn) {
  fn()
}

var pipe = function (from, to) {
  return from.pipe(to)
}

var pump = function () {
  var streams = Array.prototype.slice.call(arguments)
  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop

  if (Array.isArray(streams[0])) streams = streams[0]
  if (streams.length < 2) throw new Error('pump requires two streams per minimum')

  var error
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1
    var writing = i > 0
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err
      if (err) destroys.forEach(call)
      if (reading) return
      destroys.forEach(call)
      callback(error)
    })
  })

  return streams.reduce(pipe)
}

module.exports = pump


/***/ }),

/***/ "../../node_modules/strip-json-comments/index.js":
/*!*******************************************************!*\
  !*** ../../node_modules/strip-json-comments/index.js ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";

const singleComment = Symbol('singleComment');
const multiComment = Symbol('multiComment');
const stripWithoutWhitespace = () => '';
const stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, ' ');

const isEscaped = (jsonString, quotePosition) => {
	let index = quotePosition - 1;
	let backslashCount = 0;

	while (jsonString[index] === '\\') {
		index -= 1;
		backslashCount += 1;
	}

	return Boolean(backslashCount % 2);
};

module.exports = (jsonString, options = {}) => {
	if (typeof jsonString !== 'string') {
		throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
	}

	const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;

	let insideString = false;
	let insideComment = false;
	let offset = 0;
	let result = '';

	for (let i = 0; i < jsonString.length; i++) {
		const currentCharacter = jsonString[i];
		const nextCharacter = jsonString[i + 1];

		if (!insideComment && currentCharacter === '"') {
			const escaped = isEscaped(jsonString, i);
			if (!escaped) {
				insideString = !insideString;
			}
		}

		if (insideString) {
			continue;
		}

		if (!insideComment && currentCharacter + nextCharacter === '//') {
			result += jsonString.slice(offset, i);
			offset = i;
			insideComment = singleComment;
			i++;
		} else if (insideComment === singleComment && currentCharacter + nextCharacter === '\r\n') {
			i++;
			insideComment = false;
			result += strip(jsonString, offset, i);
			offset = i;
			continue;
		} else if (insideComment === singleComment && currentCharacter === '\n') {
			insideComment = false;
			result += strip(jsonString, offset, i);
			offset = i;
		} else if (!insideComment && currentCharacter + nextCharacter === '/*') {
			result += jsonString.slice(offset, i);
			offset = i;
			insideComment = multiComment;
			i++;
			continue;
		} else if (insideComment === multiComment && currentCharacter + nextCharacter === '*/') {
			i++;
			insideComment = false;
			result += strip(jsonString, offset, i + 1);
			offset = i + 1;
			continue;
		}
	}

	return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
};


/***/ }),

/***/ "./src/command.ts":
/*!************************!*\
  !*** ./src/command.ts ***!
  \************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = exports.setRefreshOpenedDiagnoseCommand = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const extension_1 = __webpack_require__(/*! ./extension */ "./src/extension.ts");
const meta_data_1 = __webpack_require__(/*! ./meta-data */ "./src/meta-data.ts");
const mini_extensions_shared_1 = __webpack_require__(/*! @alipay/mini-extensions-shared */ "../shared/lib/index.js");
const yuyanConfig_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/node/yuyanConfig */ "../shared/lib/node/yuyanConfig/index.js");
const disposable_1 = __webpack_require__(/*! @opensumi/ide-utils/lib/disposable */ "../../node_modules/@opensumi/ide-utils/lib/disposable.js");
function openUrl(url) {
    if (!url) {
        return;
    }
    const u = (0, mini_extensions_shared_1.appendUTM)(url);
    vscode.env.openExternal(vscode.Uri.parse(u));
}
function restartAppxLSP(client, context) {
    return {
        id: "appx.restartLanguageServer" /* restartServer */,
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                (0, extension_1.restartLanguageServer)(context);
            });
        },
    };
}
function setRefreshOpenedDiagnoseCommand(client, context) {
    return {
        id: "appx.updateVisibleTextEditorsDiagnose" /* updateVisibleTextEditorsDiagnose */,
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                const editors = vscode.window.visibleTextEditors;
                const uris = editors.map((v) => v.document.uri);
                client.onReady().then(() => {
                    client.sendNotification("appx/updateVisibleTextEditorsDiagnose" /* updateVisibleTextEditorsDiagnose */, {
                        uris: uris,
                    });
                });
            });
        },
    };
}
exports.setRefreshOpenedDiagnoseCommand = setRefreshOpenedDiagnoseCommand;
// Receive data for reference from external
function setDataRefCommand(client, context) {
    return {
        id: "axmlLanguageServer.setDataRef" /* setAXMLMetaData */,
        execute(data) {
            return __awaiter(this, void 0, void 0, function* () {
                (0, meta_data_1.setDataReference)(context, data);
                client.onReady().then(() => {
                    client.sendNotification("appx/updateReference" /* updateMetaData */, [data]);
                });
            });
        },
    };
}
function downloadTyping(client, context) {
    return {
        id: "appx.downloadApiTyping" /* downloadApiTyping */,
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                client.onReady().then(() => {
                    client.sendNotification("appx/downloadTyping" /* downloadTyping */);
                });
            });
        },
    };
}
function downloadResources(client, context) {
    return {
        id: "appx.downloadLatestMiniResources" /* downloadLatestMiniResources */,
        execute() {
            return __awaiter(this, void 0, void 0, function* () {
                client.onReady().then(() => {
                    client.sendNotification("appx/downloadLatestMiniResources" /* downloadLatestMiniResources */);
                });
            });
        },
    };
}
function getJsonMapping() {
    return __awaiter(this, void 0, void 0, function* () {
        const data = (yield (0, yuyanConfig_1.fetchPriorityCache)('mconfig_config-docs-mapping', {
            autoCache: true,
            env: yuyanConfig_1.EnvEnum.prod,
        }));
        const result = {};
        if (Array.isArray(data)) {
            data.forEach((v) => {
                result[v.jsonType] = v.content.docUrl;
            });
        }
        return result;
    });
}
function openOpenDocs(client, context) {
    return {
        execute: (jsonType) => __awaiter(this, void 0, void 0, function* () {
            try {
                const mapping = yield getJsonMapping();
                const url = mapping[jsonType] || mini_extensions_shared_1.JSONFileDocs[jsonType];
                if (url) {
                    openUrl(url);
                }
            }
            catch (error) {
                // TODO: 记录 error
                const url = mini_extensions_shared_1.JSONFileDocs[jsonType];
                if (url) {
                    openUrl(url);
                }
            }
        }),
        id: "minicode.codelens.open.docs" /* openOpenDocs */,
    };
}
function readPluginDeprecatedAnnounce(client, context) {
    return {
        execute: (config) => __awaiter(this, void 0, void 0, function* () {
            if (config && config.href) {
                openUrl(config.href);
            }
        }),
        id: "minicode.codelens.open-plugin-announce" /* openPluginAnnounce */,
    };
}
function openDocument(client, context) {
    return {
        execute: (fsPath) => __awaiter(this, void 0, void 0, function* () {
            vscode.workspace.openTextDocument(vscode.Uri.file(fsPath));
        }),
        id: "mini-program.openDocument" /* openDocument */,
    };
}
function showDocument(client, context) {
    return {
        execute: (fsPath) => __awaiter(this, void 0, void 0, function* () {
            vscode.window.showTextDocument(vscode.Uri.file(fsPath));
        }),
        id: "mini-program.showDocument" /* showDocument */,
    };
}
function registerCommands(client, context) {
    const toDispose = new disposable_1.DisposableCollection();
    const commands = [
        restartAppxLSP,
        setDataRefCommand,
        setRefreshOpenedDiagnoseCommand,
        downloadTyping,
        openOpenDocs,
        downloadResources,
        readPluginDeprecatedAnnounce,
        openDocument,
        showDocument,
    ].map((v) => v(client, context));
    for (const command of commands) {
        toDispose.push(vscode.commands.registerCommand(command.id, command.execute));
    }
    return toDispose;
}
exports.registerCommands = registerCommands;


/***/ }),

/***/ "./src/completion/JsApiCompletion.ts":
/*!*******************************************!*\
  !*** ./src/completion/JsApiCompletion.ts ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JsApiCompletion = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const log_1 = __webpack_require__(/*! ../util/log */ "./src/util/log.ts");
const configuration_1 = __webpack_require__(/*! ../constants/configuration */ "./src/constants/configuration.ts");
const generate_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/jsapi/generate */ "../shared/lib/jsapi/generate.js");
const service_1 = __webpack_require__(/*! ../service */ "./src/service/index.ts");
const index_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/node/index */ "../shared/lib/node/index.js");
const NativeAPI_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/data/NativeAPI */ "../shared/lib/data/NativeAPI.js");
const mySingleApi = /my\.?$/i;
const myScopeApi = /my\.([a-zA-Z]*).?$/i;
const extractMyCallApiName = /my\.call\(("[^"]*"|'[^']*')/i;
const isInsideUser = (0, index_1.checkIsInsideUserSync)();
class JsApiCompletion {
    constructor(client, context) {
        this.client = client;
        this.context = context;
        this._init = false;
        this.configs = [];
        this.completionScopes = new Map();
        this.completionScopeMaps = new Map();
        this.completionSwitch = true;
        this.provideHover = (document, position) => __awaiter(this, void 0, void 0, function* () {
            if (!this.ready) {
                return;
            }
            // my. 的hover
            const word = document.getWordRangeAtPosition(position, /my[\w.]*/);
            if (word) {
                const wordText = document.getText(word) || '';
                const hoverContent = (0, generate_1.provideHover4Miniapi)(wordText, this.rawCompletionScopeMaps);
                return this.client.protocol2CodeConverter.asHover(hoverContent);
            }
            if (isInsideUser) {
                // my.call() 的 hover
                const beforeTextRange = new vscode.Range(position.with({ line: position.line - 2 }), position.with({ line: position.line + 1 }));
                const beforeText = document.getText(beforeTextRange).trimStart();
                const extractApiName = beforeText
                    .replace(/\s/g, '')
                    .match(extractMyCallApiName);
                if (extractApiName && extractApiName.length > 1) {
                    const hoverContent = (0, generate_1.provideHover4NativeApi)(NativeAPI_1.NativeAPI, extractApiName[1]);
                    return this.client.protocol2CodeConverter.asHover(hoverContent);
                }
            }
        });
        this.provideHover4RuntimeData = {
            provideHover: (document, position) => __awaiter(this, void 0, void 0, function* () {
                if (!this.ready) {
                    return;
                }
                const beforeTextRange = new vscode.Range(position.with({ line: position.line - 2 }), position.with({ line: position.line + 1 }));
                const beforeText = document.getText(beforeTextRange).trimStart();
                const extractApiName = beforeText
                    .replace(/\s/g, '')
                    .match(extractMyCallApiName);
                if (extractApiName && extractApiName.length > 1) {
                    const targetName = extractApiName[1].replace(/'|"/g, '');
                    const hoverContent = yield (0, generate_1.getApiRuntimeData)(targetName);
                    return this.client.protocol2CodeConverter.asHover(hoverContent);
                }
            }),
        };
        this.service = new service_1.CompleteService(context);
        const updateData = (jsapis) => {
            const { configs, completionScopes, completionScopeMaps } = (0, generate_1.generateJSSnippets)(jsapis);
            this.rawConfigs = configs;
            this.rawCompletionScopes = completionScopes;
            this.rawCompletionScopeMaps = completionScopeMaps;
            this.configs = configs.map((v) => {
                return this.client.protocol2CodeConverter.asCompletionItem(v);
            });
            for (const [k, vs] of completionScopes.entries()) {
                this.completionScopes.set(k, vs.map((v) => this.client.protocol2CodeConverter.asCompletionItem(v)));
            }
            for (const [k, vs] of completionScopeMaps.entries()) {
                const scopes = new Map();
                for (const [_k, _v] of vs.entries()) {
                    scopes.set(_k, this.client.protocol2CodeConverter.asCompletionItem(_v));
                }
                this.completionScopeMaps.set(k, scopes);
            }
        };
        this.service.ready.then(() => {
            this._init = true;
            updateData(this.service.jsApis);
        });
        const config = vscode.workspace.getConfiguration(configuration_1.MainSection);
        this.completionSwitch = config.enabledJSAPIComplete;
        (0, log_1.log)('enabledJSAPIComplete:' + config.enabledJSAPIComplete);
        vscode.workspace.onDidChangeConfiguration(() => {
            const config = vscode.workspace.getConfiguration(configuration_1.MainSection);
            this.completionSwitch = config.enabledJSAPIComplete;
        });
    }
    static activate(client, context) {
        const jsApiCompletion = new JsApiCompletion(client, context);
        context.subscriptions.push(
        // language 自动补全
        vscode.languages.registerCompletionItemProvider(
        // DocumentSelector 在哪些文件中提工补全
        [
            { scheme: 'file', language: 'javascript' },
            { scheme: 'file', language: 'typescript' },
        ], 
        // 至少包含这个函数 provideCompletionItems(document: TextDocument, position: Position, token: CancellationToken, context: CompletionContext): ProviderResult<CompletionItem[] | CompletionList>;
        jsApiCompletion, '.'));
        context.subscriptions.push(vscode.languages.registerHoverProvider([
            { scheme: 'file', language: 'javascript' },
            { scheme: 'file', language: 'typescript' },
        ], jsApiCompletion));
        // native api 的超时、错误信息等
        if (isInsideUser) {
            context.subscriptions.push(vscode.languages.registerHoverProvider([
                { scheme: 'file', language: 'javascript' },
                { scheme: 'file', language: 'typescript' },
            ], jsApiCompletion.provideHover4RuntimeData));
        }
    }
    get ready() {
        return this._init && this.completionSwitch;
    }
    provideCompletionItems(
    // 当前的文档
    document, 
    // 光标所在位置
    position, 
    // 用于监测用户取消建议操作
    token, 
    // 当前补全项的上下文
    context) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.ready) {
                return;
            }
            const beforeTextRange = new vscode.Range(position.with({ character: 0 }), position);
            const beforeText = document.getText(beforeTextRange).trimStart();
            if (!/^my\./g.test(beforeText)) {
                return [];
            }
            // 这种情况不处理： my.canIUse('ap.')
            if (/^my\..+?\(/g.test(beforeText)) {
                return [];
            }
            // my.
            if (mySingleApi.test(beforeText)) {
                return this.configs;
            }
            // my.x
            const strArray = beforeText.match(myScopeApi);
            if (strArray) {
                const scope = strArray[1];
                // scope为当前输入关键字，get无值可能性较高
                const completionsInfo = this.completionScopes.get(scope);
                if (completionsInfo) {
                    return completionsInfo;
                }
            }
            const keys = [...this.completionScopes.keys()];
            const stripedText = beforeText.replace(/^my\./g, '');
            let completionInfo = this.configs.filter((item) => stripedText &&
                item.label
                    .toLowerCase()
                    .startsWith(stripedText.toLowerCase()));
            keys.forEach((key) => {
                const regex = new RegExp(key + '\\..*$');
                if (regex.test(beforeText)) {
                    completionInfo = completionInfo.concat(this.completionScopes.get(key) || []);
                }
            });
            return completionInfo;
        });
    }
}
exports.JsApiCompletion = JsApiCompletion;


/***/ }),

/***/ "./src/completion/index.ts":
/*!*********************************!*\
  !*** ./src/completion/index.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./JsApiCompletion */ "./src/completion/JsApiCompletion.ts"), exports);


/***/ }),

/***/ "./src/constants/configuration.ts":
/*!****************************************!*\
  !*** ./src/constants/configuration.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Configuration = exports.MainSection = void 0;
exports.MainSection = 'Mini-Program';
var Configuration;
(function (Configuration) {
    Configuration["MiniProjectJsonPath"] = "Mini-Program.miniProjectJsonPath";
    Configuration["AutoGeneratePageWhenAppJsonChanged"] = "Mini-Program.autoGeneratePageWhenAppJsonChanged";
    Configuration["CreateTs"] = "Mini-Program.scaffold.createTs";
    Configuration["CreateLess"] = "Mini-Program.scaffold.createLess";
    Configuration["ScaffoldPath"] = "Mini-Program.scaffold.path";
})(Configuration = exports.Configuration || (exports.Configuration = {}));


/***/ }),

/***/ "./src/constants/index.ts":
/*!********************************!*\
  !*** ./src/constants/index.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configurationSection = exports.tsPluginId = exports.TEMPLATE_NAME = void 0;
var TEMPLATE_NAME;
(function (TEMPLATE_NAME) {
    TEMPLATE_NAME[TEMPLATE_NAME["page"] = 0] = "page";
    TEMPLATE_NAME[TEMPLATE_NAME["component"] = 1] = "component";
})(TEMPLATE_NAME = exports.TEMPLATE_NAME || (exports.TEMPLATE_NAME = {}));
__exportStar(__webpack_require__(/*! ./configuration */ "./src/constants/configuration.ts"), exports);
__exportStar(__webpack_require__(/*! ./state */ "./src/constants/state.ts"), exports);
exports.tsPluginId = "@alipay/mini-ts-plugin" /* TSPluginId */;
exports.configurationSection = "Mini-Program" /* MiniProgramLanguageServer */;


/***/ }),

/***/ "./src/constants/state.ts":
/*!********************************!*\
  !*** ./src/constants/state.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.State = void 0;
var State;
(function (State) {
    State["FirstLaunchAskIfAutoGeneratePage"] = "state.firstLaunchAskIfAutoGeneratePage";
})(State = exports.State || (exports.State = {}));


/***/ }),

/***/ "./src/create/config.ts":
/*!******************************!*\
  !*** ./src/create/config.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultExts = exports.extConfig = void 0;
exports.extConfig = {
    'ts-less': [
        ".axml" /* AXML */,
        ".ts" /* TS */,
        ".less" /* LESS */,
        ".json" /* JSON */,
    ],
    'ts-acss': [
        ".axml" /* AXML */,
        ".ts" /* TS */,
        ".acss" /* ACSS */,
        ".json" /* JSON */,
    ],
    'js-less': [
        ".axml" /* AXML */,
        ".js" /* JS */,
        ".less" /* LESS */,
        ".json" /* JSON */,
    ],
    'js-acss': [
        ".axml" /* AXML */,
        ".js" /* JS */,
        ".acss" /* ACSS */,
        ".json" /* JSON */,
    ],
};
exports.defaultExts = exports.extConfig['js-acss'];


/***/ }),

/***/ "./src/create/index.ts":
/*!*****************************!*\
  !*** ./src/create/index.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.copyTemplate = exports.createFolderFromTemplate = exports.parseUserInput = exports.doCreateFolderFromTemplate = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const fs_extra_1 = __webpack_require__(/*! fs-extra */ "./node_modules/fs-extra/lib/index.js");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants/index.ts");
const config_1 = __webpack_require__(/*! ./config */ "./src/create/config.ts");
const appInfo_1 = __webpack_require__(/*! ../service/appInfo */ "./src/service/appInfo.ts");
const log_1 = __webpack_require__(/*! ../util/log */ "./src/util/log.ts");
const global_1 = __webpack_require__(/*! ../util/global */ "./src/util/global.ts");
const i18n_1 = __webpack_require__(/*! ../util/i18n */ "./src/util/i18n.ts");
const url_1 = __webpack_require__(/*! ../util/url */ "./src/util/url.ts");
// 要创建一个页面，${rootUri}/${folder}/${name}.{js,axml}
function doCreateFolderFromTemplate(templateType, rootUri, folder, name, writeToJson = true) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return __awaiter(this, void 0, void 0, function* () {
        yield (0, fs_extra_1.ensureDir)(rootUri.fsPath);
        const miniService = appInfo_1.MiniProgramAppInfoService.get();
        const workspaceMiniService = miniService.getMiniProgramInfo(rootUri);
        if (!workspaceMiniService) {
            vscode_1.window.showErrorMessage((0, i18n_1.localize)('create.miniService.unavailable'));
            return;
        }
        const createKey = yield workspaceMiniService.getCurrentCreateKey();
        const exts = (_a = config_1.extConfig[createKey]) !== null && _a !== void 0 ? _a : config_1.defaultExts;
        const project = workspaceMiniService.getProject(rootUri);
        (0, log_1.log)(`create ${templateType} in ${rootUri}/${folder}/${name}`);
        const defaultTemplatePath = path_1.default.join(global_1.globalData.context.extensionPath, './templates');
        let templateRoot = vscode_1.workspace
            .getConfiguration(constants_1.MainSection)
            .get(constants_1.Configuration.ScaffoldPath) || defaultTemplatePath;
        let templatePath = '';
        if (!path_1.default.isAbsolute(templateRoot)) {
            const workspacePath = (_b = vscode_1.workspace.getWorkspaceFolder(rootUri)) === null || _b === void 0 ? void 0 : _b.uri.fsPath;
            if (workspacePath) {
                templateRoot = path_1.default.resolve(workspacePath, templateRoot);
            }
        }
        switch (templateType) {
            case constants_1.TEMPLATE_NAME.page:
                templatePath = path_1.default.join(templateRoot, 'page');
                break;
            case constants_1.TEMPLATE_NAME.component:
                templatePath = path_1.default.join(templateRoot, 'component');
                break;
            default:
                vscode_1.window.showErrorMessage((0, i18n_1.localize)('create.template.empty'));
                return;
        }
        if (!templateRoot || !templatePath) {
            return;
        }
        if (!(yield (0, fs_extra_1.pathExists)(templatePath))) {
            vscode_1.window.showErrorMessage((0, i18n_1.localize)('fileTree.valid.template') + templatePath);
            return;
        }
        const destURIWithoutExt = yield copyTemplate(rootUri, folder, templatePath, exts, name);
        // 是否要在 app.json 或者 plugin 里新增这个页面
        if (writeToJson === true) {
            if (templateType !== constants_1.TEMPLATE_NAME.page) {
                return;
            }
            if (!project) {
                return;
            }
            if ((project === null || project === void 0 ? void 0 : project.projectType) === appInfo_1.MiniProjectType.Plugin &&
                project.pluginJson &&
                ((_c = project.pluginJson) === null || _c === void 0 ? void 0 : _c.currentPath)) {
                const pluginJson = project.pluginJson.getContent();
                if (!pluginJson) {
                    return;
                }
                const page = path_1.default
                    .relative(path_1.default.dirname(vscode_1.Uri.file(project.pluginJson.currentPath).path), destURIWithoutExt.path)
                    .replace(/\\/g, '/')
                    .replace(/\/$/g, '');
                if (!pluginJson.pages) {
                    pluginJson.pages = [];
                }
                (_d = pluginJson.pages) === null || _d === void 0 ? void 0 : _d.push(page);
                yield project.pluginJson.write(pluginJson);
            }
            else if (project.appJson && ((_e = project.appJson) === null || _e === void 0 ? void 0 : _e.currentPath)) {
                const appJsonPath = ((_f = project.appJson) === null || _f === void 0 ? void 0 : _f.currentPath) || '';
                const appJson = workspaceMiniService.AppJson.getContent();
                if (!appJson) {
                    return;
                }
                const page = path_1.default
                    .relative(path_1.default.dirname(vscode_1.Uri.file(appJsonPath).path), destURIWithoutExt.path)
                    .replace(/\\/g, '/')
                    .replace(/\/$/g, '');
                const subPackages = appJson.subPackages || [];
                const targetSubPackage = subPackages.find((sub) => sub.root && page.indexOf(sub.root) === 0);
                if (targetSubPackage && targetSubPackage.pages) {
                    targetSubPackage.pages = [
                        ...(targetSubPackage.pages || []),
                        page.replace(targetSubPackage.root || '', '').replace(/^\//, ''),
                    ];
                }
                else {
                    if (!appJson.pages) {
                        appJson.pages = [];
                    }
                    if (((_g = appJson.pages) === null || _g === void 0 ? void 0 : _g.indexOf(page)) === -1) {
                        (_h = appJson.pages) === null || _h === void 0 ? void 0 : _h.push(page);
                    }
                }
                yield project.appJson.write(appJson);
            }
        }
        return destURIWithoutExt;
    });
}
exports.doCreateFolderFromTemplate = doCreateFolderFromTemplate;
/**
 * 如果用户输入 a/b/c，他想创建的是 a/b/c.axml
 * 如果用户输入 a/b/c/，他想创建的是 a/b/c/index.axml
 * asdasd -> asdasd/asdasd.axml
 * asdasd/ -> asdasd/index.axml
 * asdasd/asd -> asdasd/asd.axml
 * asdasd/asd. -> asdasd/asd.axml
 * asdasd/asd/ -> asdasd/asd/index.axml
 */
function parseUserInput(userInput) {
    if (userInput.endsWith('.')) {
        userInput = userInput.substring(0, userInput.length - 1);
    }
    if (userInput.endsWith('/')) {
        return {
            folder: userInput,
            name: 'index',
        };
    }
    if (!userInput.includes('/')) {
        return {
            folder: userInput,
            name: userInput,
        };
    }
    const [base, folder, name] = (0, url_1.getPageSegment)(userInput);
    return {
        folder: path_1.default.join(base, folder),
        name,
    };
}
exports.parseUserInput = parseUserInput;
function showInputBox(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const disposables = [];
        try {
            return yield new Promise((resolve, reject) => {
                var _a;
                const input = vscode_1.window.createInputBox();
                input.prompt = options.prompt;
                input.placeholder = options.placeholder;
                input.value = (_a = options.init) !== null && _a !== void 0 ? _a : '';
                disposables.push(input.onDidHide(() => {
                    resolve(undefined);
                }), input.onDidAccept(() => __awaiter(this, void 0, void 0, function* () {
                    const value = input.value;
                    if (!(yield options.validate(value))) {
                        resolve(value);
                    }
                })), input.onDidChangeValue((text) => __awaiter(this, void 0, void 0, function* () {
                    const current = options.validate(text);
                    const validationMessage = yield current;
                    input.validationMessage = validationMessage;
                    const prom = yield options.renderPrompt(text);
                    if (prom) {
                        input.prompt = prom;
                    }
                    else {
                        input.prompt = options.prompt;
                    }
                })));
                input.show();
            });
        }
        finally {
            disposables.forEach((d) => d.dispose());
        }
    });
}
function createFolderFromTemplate(templateType, rootUri) {
    return __awaiter(this, void 0, void 0, function* () {
        const rootPath = rootUri.fsPath;
        if (rootPath.length <= 0) {
            vscode_1.window.showErrorMessage((0, i18n_1.localize)('create.input.tips'));
            return;
        }
        const miniService = appInfo_1.MiniProgramAppInfoService.get();
        const workspaceMiniService = miniService.getMiniProgramInfo(rootUri);
        if (!workspaceMiniService) {
            vscode_1.window.showErrorMessage((0, i18n_1.localize)('create.miniService.unavailable'));
            return;
        }
        const project = workspaceMiniService.getProject(rootUri);
        if (!project) {
            vscode_1.window.showWarningMessage((0, i18n_1.localize)('fileTree.valid.mustInProject'));
        }
        const createKey = yield workspaceMiniService.getCurrentCreateKey();
        const [script, style] = createKey.split('-');
        const userInput = yield showInputBox({
            prompt: (0, i18n_1.localize)('fileTree.placeholder.createDirectory', 'Create a directory contains .{axml,{0},{1},json} files', script, style) + (0, i18n_1.localize)('fileTree.placeholder.createDirectory.info'),
            placeholder: (0, i18n_1.localize)('fileTree.placeholder.createDirectory.new'),
            validate: (input) => __awaiter(this, void 0, void 0, function* () {
                if (!input) {
                    return (0, i18n_1.localize)('fileTree.valid.nonEmpty');
                }
                const rootStat = yield (0, fs_extra_1.stat)(rootUri.fsPath);
                if (rootUri.scheme !== 'file' || !fs_extra_1.stat) {
                    return (0, i18n_1.localize)('fileTree.valid.brokenTarget');
                }
                const data = parseUserInput(input);
                const targetFsPath = rootUri.fsPath;
                const targetParentDir = rootStat.isDirectory()
                    ? targetFsPath
                    : path_1.default.dirname(targetFsPath);
                const destURI = vscode_1.Uri.file(path_1.default.join(targetParentDir, data.folder, data.name + ".axml" /* AXML */));
                if (yield (0, fs_extra_1.pathExists)(destURI.fsPath)) {
                    return (0, i18n_1.localize)('fileTree.valid.destExists');
                }
                return '';
            }),
            renderPrompt: (input) => __awaiter(this, void 0, void 0, function* () {
                const data = parseUserInput(input);
                return (0, i18n_1.localize)('fileTree.info.createInfo', 'Will create {0} files，add a `/` at the end of the path to create a folder', miniService.getRelativePath(vscode_1.Uri.joinPath(rootUri, data.folder, data.name + `.{axml,${script},${style},json}`)));
            }),
        });
        if (userInput === undefined) {
            // user press esc, do nothing.
            return;
        }
        const data = parseUserInput(userInput);
        const destURIWithoutExt = yield doCreateFolderFromTemplate(templateType, rootUri, data.folder, data.name);
        if (destURIWithoutExt) {
            vscode_1.window.showTextDocument(vscode_1.Uri.from(Object.assign(Object.assign({}, destURIWithoutExt), { path: destURIWithoutExt.path + ".axml" /* AXML */ })), { preview: false });
        }
    });
}
exports.createFolderFromTemplate = createFolderFromTemplate;
/**
 *
 * @param targetURI 用户右键触发的文件夹
 * @param folder 用户需要创建的文件夹名称
 * @param templatePath 复制文件夹的源头
 * @param name 小程序页面名称
 * @returns
 */
function copyTemplate(targetURI, folder, templatePath, exts, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const targetStat = yield (0, fs_extra_1.stat)(targetURI.fsPath);
        if (targetURI.scheme !== 'file' || !targetStat) {
            throw new Error((0, i18n_1.localize)('fileTree.valid.brokenTarget'));
        }
        const targetFsPath = targetURI.fsPath;
        const targetParentDir = targetStat.isDirectory()
            ? targetFsPath
            : path_1.default.dirname(targetFsPath);
        const target = vscode_1.Uri.file(path_1.default.join(targetParentDir, folder));
        const targetDir = target.fsPath;
        const source = vscode_1.Uri.file(templatePath);
        yield (0, fs_extra_1.ensureDir)(targetDir);
        const sourceStat = yield (0, fs_extra_1.stat)(source.fsPath);
        const edits = [];
        // 这里是判断复制来源是否是一个文件夹，如果是文件夹，则遍历这个文件夹中的所有文件，复制到 target 中
        // 如果来源不是文件夹，那就是用户在设置中设置了一个单文件，就复制这个单文件即可。
        if (sourceStat.isDirectory()) {
            const children = yield (0, fs_extra_1.readdir)(source.fsPath);
            const copyTasks = children.map((file) => __awaiter(this, void 0, void 0, function* () {
                // 我们要在这个文件夹中只复制选中的，比如说 ts 项目中只复制 .ts 后缀。
                const ext = path_1.default.extname(file);
                if (!exts.includes(ext)) {
                    // 如果这个文件的后缀我们不复制，那就直接退出了
                    return;
                }
                const childrenPath = path_1.default.join(source.fsPath, file);
                const targetPath = yield copyTemplateFile(childrenPath, targetDir, fileName);
                if (path_1.default.extname(targetPath) === '.js' ||
                    path_1.default.extname(targetPath) === '.ts') {
                    edits.push(targetPath);
                }
            }));
            yield Promise.all(copyTasks);
        }
        else {
            const targetPath = yield copyTemplateFile(source.fsPath, targetDir, fileName);
            edits.push(targetPath);
        }
        const destURIWithoutExt = vscode_1.Uri.file(path_1.default.join(targetParentDir, folder, fileName));
        return destURIWithoutExt;
    });
}
exports.copyTemplate = copyTemplate;
// 单文件复制
// source: a/b/c.js -> target/index.js
function copyTemplateFile(source, target, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const extname = path_1.default.extname(source);
        const targetPath = path_1.default.join(target, `${fileName}${extname}`);
        yield (0, fs_extra_1.copy)(source, targetPath);
        return targetPath;
    });
}
function implementCreateCommand(context) {
    // 如果用户输入的是：
    //   pages/a/b/c 则会在根目录下的 pages/a/b/c 的文件夹中创建 index.axml
    const newPageDispose = vscode_1.commands.registerCommand("mini-program.newPage" /* newPage */, (args) => __awaiter(this, void 0, void 0, function* () {
        yield doCreate(constants_1.TEMPLATE_NAME.page, args);
    }));
    const newComponentDispose = vscode_1.commands.registerCommand("mini-program.newComponent" /* newComponent */, (args) => __awaiter(this, void 0, void 0, function* () {
        yield doCreate(constants_1.TEMPLATE_NAME.component, args);
    }));
    const createPage = vscode_1.commands.registerCommand("mini-program.createPage" /* createPage */, (path, rootUri) => __awaiter(this, void 0, void 0, function* () {
        if (vscode_1.workspace
            .getConfiguration()
            .get(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged)) {
            vscode_1.window.showWarningMessage('Please save file to create new page because you have enabled `auto generate new pages` option, ');
            return;
        }
        const data = parseUserInput(path);
        yield doCreateFolderFromTemplate(constants_1.TEMPLATE_NAME.page, vscode_1.Uri.parse(rootUri), data.folder, data.name, false);
    }));
    context.subscriptions.push(newPageDispose, newComponentDispose, createPage);
    function doCreate(templateType, rootUri) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield createFolderFromTemplate(templateType, rootUri);
            }
            catch (err) {
                const type = templateType === constants_1.TEMPLATE_NAME.component ? 'component' : 'page';
                (0, log_1.log)(`Error occurred when creating new ${type}: ` + err.message);
                (0, log_1.log)(err.stack);
                vscode_1.window.showErrorMessage(`Error occurred when creating new ${type}: ` + err.message);
            }
        });
    }
}
exports["default"] = implementCreateCommand;


/***/ }),

/***/ "./src/extension.ts":
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.restartLanguageServer = exports.setupLanguageServer = exports.setUpLSMonitor = exports.setUpDecorations = exports.deactivate = exports.activate = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const completion_1 = __webpack_require__(/*! ./completion */ "./src/completion/index.ts");
const log_1 = __webpack_require__(/*! ./util/log */ "./src/util/log.ts");
const global_1 = __webpack_require__(/*! ./util/global */ "./src/util/global.ts");
const sitemap_1 = __webpack_require__(/*! ./sitemap */ "./src/sitemap/index.ts");
const util_1 = __webpack_require__(/*! ./util/util */ "./src/util/util.ts");
const create_1 = __importDefault(__webpack_require__(/*! ./create */ "./src/create/index.ts"));
const monitor_1 = __webpack_require__(/*! ./util/monitor */ "./src/util/monitor.ts");
const appInfo_1 = __webpack_require__(/*! ./service/appInfo */ "./src/service/appInfo.ts");
const path = __importStar(__webpack_require__(/*! path */ "path"));
const node_1 = __webpack_require__(/*! vscode-languageclient/node */ "./node_modules/vscode-languageclient/node.js");
const command_1 = __webpack_require__(/*! ./command */ "./src/command.ts");
const lsp_1 = __webpack_require__(/*! ./lsp */ "./src/lsp/index.ts");
const set_config_1 = __webpack_require__(/*! ./set-config */ "./src/set-config.ts");
const lodash_debounce_1 = __importDefault(__webpack_require__(/*! lodash.debounce */ "../../node_modules/lodash.debounce/index.js"));
const mac_address_1 = __webpack_require__(/*! @alipay/mac-address */ "./node_modules/@alipay/mac-address/lib/index.js");
const constants_1 = __webpack_require__(/*! ./constants */ "./src/constants/index.ts");
const tsPlugin_1 = __importDefault(__webpack_require__(/*! ./tsPlugin */ "./src/tsPlugin/index.ts"));
const output_1 = __webpack_require__(/*! ./util/output */ "./src/util/output.ts");
const nodeRequire_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/utils/nodeRequire */ "../shared/lib/utils/nodeRequire.js");
const disposable_1 = __webpack_require__(/*! @opensumi/ide-utils/lib/disposable */ "../../node_modules/@opensumi/ide-utils/lib/disposable.js");
let appInfoService;
let client;
let disposables;
let userId;
let monitor;
let restartCount = 0;
function createClient(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!userId) {
            userId = yield (0, mac_address_1.getMacAddress)();
        }
        appInfoService = appInfo_1.MiniProgramAppInfoService.get();
        (0, set_config_1.setVSCodeConfig)(context);
        const serverLibPath = process.env.AXML_EXTENSION_MODE === 'dev' ? 'out' : 'dist';
        const lsPath = global_1.globalData.lsPath;
        const serverModule = path.join(lsPath, serverLibPath, 'serverNode.js');
        const serverOptions = {
            debug: {
                module: serverModule,
                transport: node_1.TransportKind.ipc,
                options: {
                    execArgv: ['--nolazy', '--inspect=6999'],
                    env: {
                        AXML_EXTENSION_MODE: 'dev',
                        AXML_EXTENSION_USER_ID: userId,
                    },
                },
            },
            run: {
                module: serverModule,
                args: [],
                transport: node_1.TransportKind.ipc,
                options: {
                    env: {
                        AXML_EXTENSION_USER_ID: userId,
                    },
                },
            },
        };
        // Register the server for AppX files
        const documentSelector = [
            // 允许非 *.axml 文件能够使用 AXML 语言的语法服务
            // 非 AXML 语言之外的语言，必须限制后缀名
            'axml',
            { scheme: 'file', language: 'axml' },
            'sjs',
            { scheme: 'file', language: 'sjs' },
            { scheme: 'file', language: 'json', pattern: '**/*.{json}' },
            { scheme: 'file', language: 'javascript' },
            { scheme: 'file', language: 'typescript' },
        ];
        const axmlConfig = vscode_1.workspace.getConfiguration("Mini-Program" /* MiniProgramLanguageServer */ +
            '.' +
            "axml" /* AXML */);
        const disableRpxCompletion = axmlConfig.get("disableRpxCompletion" /* DisableRpxCompletion */);
        const disableImportCompletion = axmlConfig.get("disableImportCompletion" /* DisableImportCompletion */);
        if (!disableRpxCompletion || !disableImportCompletion) {
            documentSelector.push({
                scheme: 'file',
                language: 'css',
                pattern: '**/*.{acss}',
            });
        }
        const clientOptions = {
            documentSelector,
            synchronize: {
                configurationSection: [constants_1.configurationSection],
                fileEvents: vscode_1.workspace.createFileSystemWatcher('**/*.{json}'),
            },
            initializationOptions: {
                config: vscode_1.workspace.getConfiguration()[constants_1.configurationSection],
                globalStorageFsPath: context.globalStorageUri.fsPath,
            },
            outputChannel: output_1.lsOutputChannel,
            errorHandler: {
                error: (error, message, count) => {
                    (0, log_1.log)('message' + error.message);
                    (0, log_1.log)('stack' + error.stack);
                    (0, log_1.log)('jsonrpc' + message.jsonrpc);
                    (0, log_1.log)('error count: ' + count);
                    return node_1.ErrorAction.Shutdown;
                },
                closed: () => {
                    if (restartCount < 5) {
                        restartCount++;
                        return node_1.CloseAction.Restart;
                    }
                    vscode.window.showErrorMessage('Mini Program Language Server has failed 5 times, will not restart');
                    return node_1.CloseAction.DoNotRestart;
                },
            },
        };
        const client = new node_1.LanguageClient('mini-language-server', 'Mini Program Language Server', serverOptions, clientOptions, process.env.AXML_EXTENSION_MODE === 'dev' ? true : false);
        if (disposables) {
            disposables.dispose();
        }
        disposables = new disposable_1.DisposableCollection();
        disposables.push((0, lsp_1.registerLspProvider)(() => client));
        disposables.push((0, command_1.registerCommands)(client, context));
        setUpLSMonitor(disposables, client);
        setUpDecorations(disposables, client);
        setupLanguageServer(disposables, client, context);
        client.onReady().then(() => {
            disposables.push(vscode.window.onDidChangeActiveTextEditor((0, lodash_debounce_1.default)((e) => __awaiter(this, void 0, void 0, function* () {
                if (e && e.document && e.document.uri) {
                    const documentUri = e.document.uri;
                    client.sendRequest("appx/doDiagnose" /* doDiagnose */, {
                        uri: documentUri.toString(),
                    });
                }
            }), 200)));
        });
        return client;
    });
}
function getFirstFolder() {
    const folders = vscode_1.workspace.workspaceFolders;
    if (!folders || folders.length < 1) {
        return;
    }
    const folder = folders[0];
    return folder;
}
function activate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        global_1.globalData.context = context;
        const lsPath = path.dirname((0, nodeRequire_1.nodeResolve)('@alipay/mini-language-server/package.json'));
        const typesPath = path.dirname((0, nodeRequire_1.nodeResolve)('@alipay/mini-types-alipay/package.json'));
        const tsPluginPath = path.dirname((0, nodeRequire_1.nodeResolve)(`${constants_1.tsPluginId}/package.json`));
        const currentPath = path.dirname((0, nodeRequire_1.nodeResolve)(`../package.json`));
        log_1.outputChannel.appendLine(`globalStoragePath ` + context.globalStoragePath);
        log_1.outputChannel.appendLine(`current path ` + currentPath);
        log_1.outputChannel.appendLine(`language server path ` + lsPath);
        log_1.outputChannel.appendLine(`ts plugin path ` + tsPluginPath);
        log_1.outputChannel.appendLine('process current working directory: ' + process.cwd());
        global_1.globalData.currentPath = currentPath;
        global_1.globalData.lsPath = lsPath;
        global_1.globalData.tsPluginPath = tsPluginPath;
        global_1.globalData.typesPath = typesPath;
        global_1.globalData.globalStoragePath = context.globalStoragePath;
        global_1.globalData.isInsideUser = false;
        monitor = new monitor_1.YuYanMonitorImpl();
        yield monitor.init();
        const folder = getFirstFolder();
        if (!folder) {
            return;
        }
        if (!(0, util_1.isVol)() &&
            vscode.extensions.getExtension('alipay.minicode-completion')) {
            (0, log_1.log)('旧版插件已安装，请先手动卸载插件「alipay.minicode-completion」后再使用本插件，否则会造成冲突');
        }
        appInfoService = appInfo_1.MiniProgramAppInfoService.get();
        const miniProgramInfo = appInfoService.getMiniProgramInfo(folder.uri);
        if (!miniProgramInfo) {
            (0, log_1.log)('无法获取 mini.project.json 的信息');
        }
        (0, create_1.default)(context);
        // 各配置文件变动监测
        context.subscriptions.push(appInfoService);
        if (!(0, util_1.isVol)()) {
            monitor.logReady();
        }
        /**
         * 响应 mini.project.json 文件变化，目前就是重新初始化
         */
        context.subscriptions.push(miniProgramInfo.MiniProjectJson.onDidChanged(
        // 降低一下更新频率，防止一直修改 mini.project.json ，导致重启太频繁
        (0, lodash_debounce_1.default)(({ newRawValue, oldRawValue, isFirstLoad }) => __awaiter(this, void 0, void 0, function* () {
            // 防止第一次加载内容就重启了
            if (!isFirstLoad && oldRawValue && newRawValue) {
                (0, log_1.log)('mini.project.json 文件变化，重新初始化插件');
                yield restartLanguageServer(context);
            }
        }), 600)));
        try {
            client = yield createClient(context);
        }
        catch (err) {
            (0, log_1.log)('Error occurred when Launch Language Server: ' + err.message);
            (0, log_1.log)(err.stack);
            vscode.window.showErrorMessage('Error occurred when Launch Language Server: ' + err.message);
        }
        try {
            completion_1.JsApiCompletion.activate(client, context);
            sitemap_1.SiteMapService.activate(context);
        }
        catch (e) {
            (0, log_1.log)('注册部分command失败', e);
        }
        try {
            yield (0, tsPlugin_1.default)(context);
        }
        catch (err) {
            (0, log_1.log)('Error occurred when set up ts plugin: ' + err.message);
            (0, log_1.log)(err.stack);
        }
    });
}
exports.activate = activate;
function deactivate() {
    if (client) {
        client.stop();
    }
    return;
}
exports.deactivate = deactivate;
const underlineDecoration = vscode.window.createTextEditorDecorationType({
    textDecoration: 'underline',
    // vscode 还不支持，先在 opensumi 支持了。
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    //@ts-ignore
    textUnderlinePosition: 'under',
});
function setUpDecorations(disposables, client) {
    client.onReady().then(() => {
        disposables.push(client.onNotification('applyDecorations', (data) => {
            const editor = vscode.window.visibleTextEditors.find((v) => v.document.uri.toString() === data.uri);
            if (editor) {
                editor.setDecorations(underlineDecoration, data.ranges.map((v) => new vscode.Range(new vscode.Position(v.start.line, v.start.character), new vscode.Position(v.end.line, v.end.character))));
            }
        }));
    });
}
exports.setUpDecorations = setUpDecorations;
function setUpLSMonitor(disposables, client) {
    client.onReady().then(() => {
        disposables.push(client.onRequest('monitor.logError', (error) => {
            monitor === null || monitor === void 0 ? void 0 : monitor.logError(error);
        }));
        disposables.push(client.onRequest('monitor.log', (params) => {
            monitor === null || monitor === void 0 ? void 0 : monitor.log(params);
        }));
    });
}
exports.setUpLSMonitor = setUpLSMonitor;
function registerNotification(client, method, handler) {
    return client.onNotification(method, handler);
}
function registerRequest(client, method, handler) {
    return client.onRequest(method, handler);
}
function setupLanguageServer(disposables, client, context) {
    return __awaiter(this, void 0, void 0, function* () {
        disposables.push(client.start());
        client.onReady().then(() => {
            // 注册和 server 通讯的消息
            disposables.push(registerNotification(client, "appx/restartServer" /* restartServer */, () => {
                setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    restartLanguageServer(context);
                }), 100);
            }));
            disposables.push(registerRequest(client, "appx/openTextDocument" /* openTextDocument */, ({ uri }) => __awaiter(this, void 0, void 0, function* () {
                yield vscode.workspace.openTextDocument(vscode.Uri.parse(uri));
            })));
        });
    });
}
exports.setupLanguageServer = setupLanguageServer;
function restartLanguageServer(context) {
    return __awaiter(this, void 0, void 0, function* () {
        if (client) {
            (0, log_1.log)('Restarting Language Server');
            try {
                yield client.onReady();
                yield client.stop();
                disposables && disposables.dispose();
                client = yield createClient(context);
            }
            catch (error) {
                (0, log_1.log)(`restartLanguageServer ~ error`, error);
            }
            (0, log_1.log)('Restart Language Server completed');
        }
    });
}
exports.restartLanguageServer = restartLanguageServer;


/***/ }),

/***/ "./src/lsp/converter.ts":
/*!******************************!*\
  !*** ./src/lsp/converter.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Formatting = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
var Formatting;
(function (Formatting) {
    function getFileFormatConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    Formatting.getFileFormatConfiguration = getFileFormatConfiguration;
})(Formatting = exports.Formatting || (exports.Formatting = {}));


/***/ }),

/***/ "./src/lsp/format.ts":
/*!***************************!*\
  !*** ./src/lsp/format.ts ***!
  \***************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormattingEditProvider = void 0;
const converter_1 = __webpack_require__(/*! ./converter */ "./src/lsp/converter.ts");
class FormattingEditProvider {
    constructor(getClient) {
        this.getClient = getClient;
    }
    provideDocumentFormattingEdits(document, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = this.getClient();
            if (client) {
                try {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, converter_1.Formatting.getFileFormatConfiguration(document)),
                    };
                    const request = {
                        type: "format" /* format */,
                        data: params,
                    };
                    const result = yield client.sendRequest("appx/lspMethod" /* lspMethod */, request);
                    if (result &&
                        result.data &&
                        result.data.type !== 'error') {
                        return result.data;
                    }
                }
                catch (error) {
                    return [];
                }
            }
            return [];
        });
    }
    provideDocumentRangeFormattingEdits(document, range, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = this.getClient();
            if (client) {
                try {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, converter_1.Formatting.getFileFormatConfiguration(document)),
                    };
                    const request = {
                        type: "rangeFormat" /* rangeFormat */,
                        data: params,
                    };
                    const result = yield client.sendRequest("appx/lspMethod" /* lspMethod */, request);
                    if (result &&
                        result.data &&
                        result.data.type !== 'error') {
                        return result.data;
                    }
                }
                catch (error) {
                    return [];
                }
            }
            return [];
        });
    }
}
exports.FormattingEditProvider = FormattingEditProvider;


/***/ }),

/***/ "./src/lsp/index.ts":
/*!**************************!*\
  !*** ./src/lsp/index.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerLspProvider = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const format_1 = __webpack_require__(/*! ./format */ "./src/lsp/format.ts");
function registerLspProvider(getClient) {
    const formattingEditProvider = new format_1.FormattingEditProvider(getClient);
    // format 不能给 json 文件注册，因为 server 无法区分文件，所以用插件的方式在 client 侧注册 acss、axml、sjs 的格式化
    return vscode_1.languages.registerDocumentRangeFormattingEditProvider({ scheme: 'file', language: 'axml' }, formattingEditProvider);
}
exports.registerLspProvider = registerLspProvider;


/***/ }),

/***/ "./src/meta-data.ts":
/*!**************************!*\
  !*** ./src/meta-data.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDataReference = exports.setDataReference = void 0;
const AXML_TAG_META = 'dataRef';
function setDataReference(context, data) {
    context.globalState.update(AXML_TAG_META, data);
}
exports.setDataReference = setDataReference;
function getDataReference(context) {
    const tagEntries = context.globalState.get(AXML_TAG_META, []);
    return tagEntries;
}
exports.getDataReference = getDataReference;


/***/ }),

/***/ "./src/service/appInfo.ts":
/*!********************************!*\
  !*** ./src/service/appInfo.ts ***!
  \********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniProgramAppInfo = exports.MiniProgramAppInfoService = exports.MiniProjectType = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const path_1 = __webpack_require__(/*! path */ "path");
const jsonFile_1 = __webpack_require__(/*! ./jsonFile */ "./src/service/jsonFile.ts");
const create_1 = __webpack_require__(/*! ../create */ "./src/create/index.ts");
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants/index.ts");
const url_1 = __webpack_require__(/*! ../util/url */ "./src/util/url.ts");
const i18n_1 = __webpack_require__(/*! ../util/i18n */ "./src/util/i18n.ts");
const global_1 = __webpack_require__(/*! ../util/global */ "./src/util/global.ts");
const dispose_1 = __webpack_require__(/*! ../util/dispose */ "./src/util/dispose.ts");
const util_1 = __webpack_require__(/*! ../util/util */ "./src/util/util.ts");
const mini_program_config_loader_1 = __webpack_require__(/*! @alipay/mini-program-config-loader */ "./node_modules/@alipay/mini-program-config-loader/lib/index.js");
const log_1 = __webpack_require__(/*! ../util/log */ "./src/util/log.ts");
var MiniProjectType;
(function (MiniProjectType) {
    MiniProjectType["MiniProgram"] = "MiniProgram";
    MiniProjectType["Plugin"] = "Plugin";
})(MiniProjectType = exports.MiniProjectType || (exports.MiniProjectType = {}));
/**
 * 整个单例服务
 */
class MiniProgramAppInfoService extends vscode_1.Disposable {
    constructor() {
        super(() => {
            this._dispose();
        });
        this.infoForWorkspace = new Map();
        this.init();
    }
    static get() {
        if (!MiniProgramAppInfoService._instance) {
            MiniProgramAppInfoService._instance = new MiniProgramAppInfoService();
        }
        return MiniProgramAppInfoService._instance;
    }
    _dispose() {
        this.infoForWorkspace.forEach((info) => {
            info.dispose();
        });
        this.infoForWorkspace.clear();
    }
    init() {
        const previous = this.infoForWorkspace;
        this.infoForWorkspace = new Map();
        if (vscode_1.workspace.workspaceFolders) {
            vscode_1.workspace.workspaceFolders.forEach((w) => {
                const uriString = w.uri.toString();
                if (previous.has(w.uri.toString())) {
                    this.infoForWorkspace.set(uriString, previous.get(uriString));
                }
                else {
                    this.infoForWorkspace.set(uriString, new MiniProgramAppInfo(w.uri));
                }
            });
        }
    }
    // 获取相对根目录的 path
    getRelativePath(uri) {
        for (const info of this.infoForWorkspace.values()) {
            if (isChildOrEqualOf(info.root.fsPath, uri.fsPath)) {
                return uri.fsPath.substring(info.root.fsPath.length + 1);
            }
        }
        return null;
    }
    /**
     * 获取对应uri所在的MiniProgramApp
     * @param uri
     */
    getMiniProgramInfo(uri) {
        for (const info of this.infoForWorkspace.values()) {
            if (isChildOrEqualOf(info.root.fsPath, uri.fsPath)) {
                return info;
            }
        }
        return null;
    }
}
exports.MiniProgramAppInfoService = MiniProgramAppInfoService;
MiniProgramAppInfoService._instance = undefined;
/**
 * 指向单个workspace
 */
class MiniProgramAppInfo extends vscode_1.Disposable {
    constructor(root) {
        super(() => {
            this._dispose();
        });
        this.root = root;
        this.MiniProjectJson = new jsonFile_1.JSONConfigFile();
        this.AppJson = new jsonFile_1.JSONConfigFile();
        this.SiteMapJson = new jsonFile_1.JSONConfigFile();
        this.PluginJson = new jsonFile_1.JSONConfigFile();
        this.miniProjectType = MiniProjectType.MiniProgram;
        this.miniprogramRoot = '';
        this.pluginRoot = '';
        this.dc = new dispose_1.DisposeCollection();
        this._config = vscode_1.workspace.getConfiguration(constants_1.MainSection, this.root);
        this.MiniProjectJson.updatePath(this.getMiniProjectJsonPath()).then(() => {
            this.updateProjectInfo();
            this.SiteMapJson.updatePath(this.getMiniSitemapJsonPath());
            this.AppJson.updatePath(this.getAppJsonPath());
            if (this.miniProjectType === MiniProjectType.Plugin) {
                this.PluginJson.updatePath(this.getPluginJsonPath());
            }
        });
        this.updateProjectInfo();
        vscode_1.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration(constants_1.Configuration.MiniProjectJsonPath)) {
                this.MiniProjectJson.updatePath(this.getMiniProjectJsonPath());
            }
        });
        this.MiniProjectJson.onDidChanged(() => {
            this.updateProjectInfo();
            this.AppJson.updatePath(this.getAppJsonPath());
            this.SiteMapJson.updatePath(this.getMiniSitemapJsonPath());
            if (this.miniProjectType === MiniProjectType.Plugin) {
                this.PluginJson.updatePath(this.getPluginJsonPath());
            }
        });
        this.setupGeneratePageByAppJson();
        if (!global_1.globalData.context.globalState.get(constants_1.State.FirstLaunchAskIfAutoGeneratePage) &&
            !vscode_1.workspace
                .getConfiguration()
                .get(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged)) {
            // 如果用户没有点击过右下角的询问弹窗 && 选项没开时弹出这个询问
            this.askIfAutoGeneratePage();
        }
    }
    _dispose() {
        this.dc.clear();
        this.AppJson.dispose();
        this.MiniProjectJson.dispose();
        this.PluginJson.dispose();
        this.SiteMapJson.dispose();
    }
    setupGeneratePageByAppJson() {
        vscode_1.workspace.onWillSaveTextDocument((event) => {
            const doc = event.document;
            const appJsonPath = this.getAppJsonPath();
            if (doc.uri.fsPath !== appJsonPath) {
                return;
            }
            event.waitUntil(jsonFile_1.JSONConfigFile.parseContent(doc.getText()).then((v) => {
                this.autoGeneratePage({
                    oldValue: this.AppJson.getContent(),
                    newValue: v,
                });
            }));
        });
    }
    askIfAutoGeneratePage() {
        return __awaiter(this, void 0, void 0, function* () {
            const dispose = vscode_1.workspace.onDidSaveTextDocument((doc) => __awaiter(this, void 0, void 0, function* () {
                if (vscode_1.workspace
                    .getConfiguration()
                    .get(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged)) {
                    // 如果用户没有点击右下角，反而是在设置里开了这个选项
                    // 那以后就不弹窗了
                    dispose.dispose();
                    global_1.globalData.context.globalState.update(constants_1.State.FirstLaunchAskIfAutoGeneratePage, '1');
                    return;
                }
                const appJsonPath = this.getAppJsonPath();
                if (doc.uri.fsPath === appJsonPath) {
                    let buttons = ['yes', 'no'];
                    if ((0, util_1.isVol)()) {
                        buttons = ['no', 'yes'];
                    }
                    const result = yield vscode_1.window.showInformationMessage((0, i18n_1.localize)('extension.configuration.askAutoGeneratePage'), ...buttons.map((v) => (0, i18n_1.localize)(v)));
                    if (result === (0, i18n_1.localize)('yes')) {
                        vscode_1.workspace
                            .getConfiguration()
                            .update(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged, true, true);
                    }
                    else if (result === (0, i18n_1.localize)('no')) {
                        vscode_1.workspace
                            .getConfiguration()
                            .update(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged, false, true);
                    }
                    if (result) {
                        global_1.globalData.context.globalState.update(constants_1.State.FirstLaunchAskIfAutoGeneratePage, '1');
                        dispose.dispose();
                    }
                }
            }));
            this.dc.push(dispose);
        });
    }
    autoGeneratePage({ oldValue, newValue, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!vscode_1.workspace
                .getConfiguration()
                .get(constants_1.Configuration.AutoGeneratePageWhenAppJsonChanged)) {
                return;
            }
            if (!oldValue) {
                return;
            }
            if (!(newValue === null || newValue === void 0 ? void 0 : newValue.pages)) {
                return;
            }
            if (!newValue.pages.length) {
                return;
            }
            const newPages = newValue.pages;
            const promises = [];
            const createdPages = [];
            for (const page of newPages) {
                if (!page) {
                    continue;
                }
                const [base, folder, name] = (0, url_1.getPageSegment)(page);
                const _baseUri = (0, path_1.join)(this.miniprogramRoot, base);
                promises.push((() => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield vscode_1.workspace.fs.stat(vscode_1.Uri.file((0, path_1.join)(_baseUri, folder, name + ".axml" /* AXML */)));
                        console.log(`文件已经存在`, (0, path_1.join)(_baseUri, folder));
                    }
                    catch (error) {
                        try {
                            console.log('creating ', page);
                            yield (0, create_1.doCreateFolderFromTemplate)(constants_1.TEMPLATE_NAME.page, vscode_1.Uri.file(_baseUri), folder, name, false);
                            createdPages.push(page);
                        }
                        catch (error) {
                            console.log(`create ${page} error`, error);
                        }
                    }
                }))());
            }
            yield Promise.all(promises);
            if (createdPages.length) {
                vscode_1.window.showInformationMessage(`Created ${createdPages.length} new pages: ${createdPages.join(', ')}`);
            }
        });
    }
    getMiniProjectJsonPath() {
        const fileRoot = this.root.fsPath;
        const relativeMiniProjectJsonPath = this._config.get('miniProjectJsonPath');
        return (0, path_1.resolve)(fileRoot, relativeMiniProjectJsonPath);
    }
    getCurrentCreateKey() {
        return __awaiter(this, void 0, void 0, function* () {
            let jsExt = 'js';
            let styleExt = 'acss';
            const createTsConfig = vscode_1.workspace
                .getConfiguration()
                .get(constants_1.Configuration.CreateTs);
            const createLessConfig = vscode_1.workspace
                .getConfiguration()
                .get(constants_1.Configuration.CreateLess);
            if (createTsConfig) {
                jsExt = 'ts';
            }
            if (createLessConfig) {
                styleExt = 'less';
            }
            const config = yield (0, mini_program_config_loader_1.loadMiniProjectJson)(this.root.fsPath);
            if (config.format === 2) {
                log_1.outputChannel.appendLine('user has mini.project.json v2');
                // 说明是 v2 版本的设置
                if (config.compileOptionsTypescript) {
                    log_1.outputChannel.appendLine('compileOptions Typescript is true, create ts file');
                    jsExt = 'ts';
                }
                if (config.compileOptionsLess) {
                    log_1.outputChannel.appendLine('compileOptions Less is true, create less file');
                    styleExt = 'less';
                }
            }
            return `${jsExt}-${styleExt}`;
        });
    }
    getAppJsonPath() {
        const fileRoot = this.root.fsPath;
        const relativePath = (0, path_1.join)((this.MiniProjectJson.getContent() || {}).miniprogramRoot || './', './app.json');
        return (0, path_1.resolve)(fileRoot, relativePath);
    }
    getMiniSitemapJsonPath() {
        const fileRoot = this.root.fsPath;
        const relativePath = (0, path_1.join)((this.MiniProjectJson.getContent() || {}).miniprogramRoot || './', './sitemap.json');
        return (0, path_1.resolve)(fileRoot, relativePath);
    }
    getPluginJsonPath() {
        const fileRoot = this.root.fsPath;
        const relativePath = (0, path_1.join)((this.MiniProjectJson.getContent() || {}).pluginRoot || './', './plugin.json');
        return (0, path_1.resolve)(fileRoot, relativePath);
    }
    updateProjectInfo() {
        const fileRoot = this.root.fsPath;
        const miniprogramInfo = this.MiniProjectJson.getContent() || {};
        this.miniProjectType =
            miniprogramInfo.compileType === 'plugin'
                ? MiniProjectType.Plugin
                : MiniProjectType.MiniProgram;
        this.miniprogramRoot = (0, path_1.resolve)(fileRoot, miniprogramInfo.miniprogramRoot || './');
        this.pluginRoot = (0, path_1.resolve)(fileRoot, miniprogramInfo.pluginRoot || './');
    }
    getProject(uri) {
        if (this.miniProjectType === MiniProjectType.Plugin &&
            isChildOrEqualOf(this.pluginRoot, uri.fsPath)) {
            return {
                projectType: MiniProjectType.Plugin,
                root: this.pluginRoot,
                pluginJson: this.PluginJson,
            };
        }
        if (isChildOrEqualOf(this.miniprogramRoot, uri.fsPath)) {
            return {
                projectType: MiniProjectType.MiniProgram,
                root: this.miniprogramRoot,
                appJson: this.AppJson,
            };
        }
    }
}
exports.MiniProgramAppInfo = MiniProgramAppInfo;
function isChildOrEqualOf(parent, dir) {
    const r = (0, path_1.relative)(parent, dir);
    if (r === '') {
        return true;
    }
    return !r.startsWith('..') && !(0, path_1.isAbsolute)(r);
}


/***/ }),

/***/ "./src/service/index.ts":
/*!******************************!*\
  !*** ./src/service/index.ts ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompleteService = void 0;
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const fs_extra_1 = __webpack_require__(/*! fs-extra */ "./node_modules/fs-extra/lib/index.js");
const installer_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/node/installer */ "../shared/lib/node/installer/index.js");
const log_1 = __webpack_require__(/*! ../util/log */ "./src/util/log.ts");
class CompleteService {
    constructor(context) {
        this.context = context;
        this._jsApis = [];
        this.ready = this.init().catch((e) => {
            (0, log_1.log)(`service init error: ${JSON.stringify(e)}`);
            this._jsApis = [];
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield (0, installer_1.getValidResource)(this.context.globalStoragePath, installer_1.ResourceName.MiniResources, installer_1.MiniResources.MiniAPIJSON);
            if (data) {
                this._jsApis = data;
                (0, log_1.log)('use remote resource', installer_1.MiniResources.MiniAPIJSON);
                return;
            }
            return this.initDefault();
        });
    }
    initDefault() {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPath = path_1.default.join(__dirname, '../config/mini-api.json');
            this._jsApis = (yield (0, fs_extra_1.readJSON)(defaultPath));
        });
    }
    get jsApis() {
        return this._jsApis;
    }
}
exports.CompleteService = CompleteService;


/***/ }),

/***/ "./src/service/jsonFile.ts":
/*!*********************************!*\
  !*** ./src/service/jsonFile.ts ***!
  \*********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONConfigFile = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const fs_extra_1 = __webpack_require__(/*! fs-extra */ "./node_modules/fs-extra/lib/index.js");
const json_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/utils/json */ "../shared/lib/utils/json.js");
class JSONConfigFile {
    constructor(path) {
        this._path = null;
        this._content = null;
        this._rawContent = null;
        this.isFirstLoad = true;
        this._onDidChanged = new vscode_1.EventEmitter();
        this.onDidChanged = this._onDidChanged.event;
        this._onDispose = new vscode_1.EventEmitter();
        this.onDispose = this._onDispose.event;
        this._symbols = [];
        this.toDispose = [];
        if (path) {
            this.updatePath(path);
        }
    }
    get currentPath() {
        return this._path;
    }
    createWatcher() {
        if (this.watcher) {
            this.disposeWatcher();
            this.watcher = undefined;
        }
        if (this._path) {
            this.watcher = vscode_1.workspace.createFileSystemWatcher(this._path);
            const callback = (e) => {
                if (e.fsPath === this._path) {
                    this.update();
                }
            };
            this.toDispose.push(this.watcher.onDidChange(callback));
            this.toDispose.push(this.watcher.onDidCreate(callback));
            this.toDispose.push(this.watcher.onDidDelete(callback));
        }
    }
    updatePath(path) {
        if (this._path !== path) {
            this._path = path;
            this.createWatcher();
            return this.update();
        }
    }
    getContent() {
        return this._content;
    }
    getRawContent() {
        return this._rawContent;
    }
    static parseFile(path) {
        return __awaiter(this, void 0, void 0, function* () {
            const content = yield (0, fs_extra_1.readFile)(path, 'utf8');
            const json = yield this.parseContent(content);
            return {
                json,
                content,
            };
        });
    }
    static parseContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            let json = null;
            try {
                json = (0, json_1.parseJson)(content);
            }
            catch (error) { }
            return json;
        });
    }
    update() {
        return __awaiter(this, void 0, void 0, function* () {
            const previousContent = this._content;
            const previousRawContent = this._rawContent;
            try {
                if (!this._path) {
                    this._content = null;
                    this._symbols = [];
                }
                else {
                    yield Promise.all([
                        (() => __awaiter(this, void 0, void 0, function* () {
                            try {
                                const { json, content } = yield JSONConfigFile.parseFile(this._path);
                                this._rawContent = content;
                                this._content = json;
                            }
                            catch (error) {
                                this._content = null;
                            }
                            this.isFirstLoad = false;
                        }))(),
                        this.updateSymbols(),
                    ]);
                }
            }
            catch (_a) {
                this._rawContent = null;
                this._symbols = [];
            }
            if (previousRawContent !== this._rawContent) {
                this._onDidChanged.fire({
                    oldValue: previousContent,
                    newValue: this._content,
                    oldRawValue: previousRawContent,
                    newRawValue: this._rawContent,
                    isFirstLoad: this.isFirstLoad,
                });
            }
        });
    }
    write(content) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._path) {
                try {
                    yield (0, fs_extra_1.writeFile)(this._path, JSON.stringify(content, undefined, 2));
                }
                catch (_a) {
                    console.error('writeFile error');
                }
            }
        });
    }
    get symbols() {
        return this._symbols;
    }
    updateSymbols() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!vscode_1.workspace.textDocuments.find((t) => t.uri.fsPath === this.currentPath)) {
                    yield vscode_1.workspace.openTextDocument(vscode_1.Uri.file(this.currentPath));
                }
                const JSONExt = vscode_1.extensions.getExtension('vscode.json-language-features');
                if (JSONExt) {
                    yield JSONExt.activate();
                }
                const res = yield vscode_1.commands.executeCommand('vscode.executeDocumentSymbolProvider', vscode_1.Uri.file(this.currentPath));
                this._symbols = res || [];
            }
            catch (e) {
                this._symbols = [];
            }
        });
    }
    disposeWatcher() {
        if (this.watcher) {
            this.watcher.dispose();
        }
        if (this.toDispose) {
            this.toDispose.forEach((d) => d.dispose());
            this.toDispose = [];
        }
    }
    dispose() {
        this.disposeWatcher();
        this._onDispose.fire();
    }
}
exports.JSONConfigFile = JSONConfigFile;


/***/ }),

/***/ "./src/set-config.ts":
/*!***************************!*\
  !*** ./src/set-config.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setVSCodeConfig = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const SET_CONFIG_VERSION = 'setConfigVersion';
const configCurrentVersion = 1;
const vscIconsConfigAssociationsFiles = 'vsicons.associations.files';
const vscEmmetIncludeLanguages = 'emmet.includeLanguages';
// 这里修改 VSCode 的工作区配置，当前仅对插件相关图标做相关配置做修改
// 目前 axml 受众较小，给 seti-ui 提交 MR 被拒绝概率较大，因此先扩展 vsicons。通过其 associations.files 配置，扩展图标
function setVSCodeConfig(context) {
    let setConfigVersion = context.globalState.get(SET_CONFIG_VERSION);
    setConfigVersion =
        typeof setConfigVersion === 'number' ? setConfigVersion : 0;
    setConfigVersion = 0;
    if (setConfigVersion < configCurrentVersion) {
        const config = vscode_1.workspace.getConfiguration();
        if (config.has(vscIconsConfigAssociationsFiles)) {
            const vsiconsAssociationsFiles = config.get(vscIconsConfigAssociationsFiles, []);
            const associationsFiles = {
                axml: { icon: 'xml', extensions: ['axml'], format: 'svg' },
                acss: { icon: 'css', extensions: ['acss'], format: 'svg' },
            };
            const needExtendingExtension = [];
            if (Array.isArray(vsiconsAssociationsFiles)) {
                extension: for (const extension of Object.keys(associationsFiles)) {
                    for (const item of vsiconsAssociationsFiles) {
                        if (item.extensions.indexOf(extension) > -1 &&
                            item.icon === associationsFiles[extension].icon) {
                            continue extension;
                        }
                    }
                    needExtendingExtension.push(extension);
                }
                if (needExtendingExtension.length) {
                    const newVsiconsAssociationsFiles = [...vsiconsAssociationsFiles];
                    needExtendingExtension.forEach((extension) => {
                        newVsiconsAssociationsFiles.push(associationsFiles[extension]);
                    });
                    config.update(vscIconsConfigAssociationsFiles, newVsiconsAssociationsFiles, true);
                }
            }
        }
        // 通过配置 Emmet 插件，让 axml 具备简单的 emmet 功能
        if (config.has(vscEmmetIncludeLanguages)) {
            const vscEmmetIncludeLanguagesValue = Object.assign({}, config.get(vscEmmetIncludeLanguages, {}));
            if (typeof vscEmmetIncludeLanguagesValue === 'object') {
                if (!vscEmmetIncludeLanguagesValue.axml) {
                    vscEmmetIncludeLanguagesValue.axml = 'xml';
                    config.update(vscEmmetIncludeLanguages, vscEmmetIncludeLanguagesValue, true);
                }
            }
        }
        context.globalState.update(SET_CONFIG_VERSION, configCurrentVersion);
    }
}
exports.setVSCodeConfig = setVSCodeConfig;


/***/ }),

/***/ "./src/sitemap/index.ts":
/*!******************************!*\
  !*** ./src/sitemap/index.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SiteMapService = void 0;
const appInfo_1 = __webpack_require__(/*! ../service/appInfo */ "./src/service/appInfo.ts");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const path_1 = __webpack_require__(/*! path */ "path");
const i18n_1 = __webpack_require__(/*! ../util/i18n */ "./src/util/i18n.ts");
class SiteMapService {
    constructor() {
        this.miniProgramInfoService = appInfo_1.MiniProgramAppInfoService.get();
        this.diagnostic = vscode_1.languages.createDiagnosticCollection('mini-program-sitemap');
        if (vscode_1.window.activeTextEditor) {
            this.hintForAxml(vscode_1.window.activeTextEditor.document.uri);
        }
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            if (editor === null || editor === void 0 ? void 0 : editor.document.uri) {
                this.hintForAxml(editor.document.uri);
            }
        });
    }
    static activate(context) {
        const siteMapService = new SiteMapService();
        context.subscriptions.push(siteMapService);
    }
    hintForAxml(uri) {
        if (this.watcherDisposables) {
            this.watcherDisposables.dispose();
        }
        this.diagnostic.clear();
        if (/\.axml$/i.test(uri.fsPath)) {
            this.doHintForAxml(uri);
            const info = this.miniProgramInfoService.getMiniProgramInfo(uri);
            if (info) {
                this.watcherDisposables = vscode_1.Disposable.from(info.AppJson.onDidChanged(() => this.doHintForAxml(uri)), info.SiteMapJson.onDidChanged(() => this.doHintForAxml(uri)));
            }
        }
    }
    doHintForAxml(uri) {
        const indexStat = this.isIndexed(uri);
        if (indexStat) {
            this.diagnostic.set(uri, [
                {
                    range: new vscode_1.Range(new vscode_1.Position(0, 0), new vscode_1.Position(0, 0)),
                    message: (0, i18n_1.localize)('extension.sitemap.isIndexed', '', indexStat.index),
                    severity: vscode_1.DiagnosticSeverity.Information,
                    relatedInformation: [
                        new vscode_1.DiagnosticRelatedInformation(new vscode_1.Location(vscode_1.Uri.file(indexStat.siteMapJson.currentPath), indexStat.range || new vscode_1.Position(0, 0)), JSON.stringify(indexStat.rule)),
                    ],
                },
            ]);
        }
    }
    isIndexed(uri) {
        const info = this.miniProgramInfoService.getMiniProgramInfo(uri);
        if (info) {
            // 只处理在appJson中的page
            const pages = (info.AppJson.getContent() || {}).pages || [];
            const pagePath = (0, path_1.relative)((0, path_1.dirname)(info.AppJson.currentPath || info.root.fsPath), uri.fsPath)
                .replace(/\.axml$/i, '')
                .split((0, path_1.normalize)('/')) // 对于windows，此处是反斜杠，需要重新变为正斜杠
                .join('/');
            if (pages.indexOf(pagePath) === -1) {
                return false;
            }
            const rules = ((info.SiteMapJson.getContent() || {}).rules || []).slice();
            if (!Array.isArray(rules)) {
                return false;
            }
            const originalRules = rules.slice();
            // 从大到小排列
            rules.sort((a, b) => {
                return (b.priority || 0) - (a.priority || 0);
            });
            for (const rule of rules) {
                if (rule.action !== 'disallow') {
                    // allow 规则
                    if (rule.page === '*' || rule.page === pagePath) {
                        const index = originalRules.indexOf(rule);
                        return {
                            siteMapJson: info.SiteMapJson,
                            index,
                            range: findRuleRangeInSymbols(info.SiteMapJson.symbols, index),
                            rule,
                        };
                    }
                }
                else {
                    // disallow 规则
                    if (rule.page === '*' || rule.page === pagePath) {
                        return false;
                    }
                }
            }
        }
        return false;
    }
    dispose() {
        // do something
    }
}
exports.SiteMapService = SiteMapService;
function findRuleRangeInSymbols(symbols, index) {
    var _a;
    const rules = symbols.find((s) => s.name === 'rules');
    if (!rules) {
        return undefined;
    }
    return (_a = rules.children[index]) === null || _a === void 0 ? void 0 : _a.range;
}


/***/ }),

/***/ "./src/tsPlugin/index.ts":
/*!*******************************!*\
  !*** ./src/tsPlugin/index.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const log_1 = __webpack_require__(/*! ../util/log */ "./src/util/log.ts");
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const constants_1 = __webpack_require__(/*! ../constants */ "./src/constants/index.ts");
const global_1 = __webpack_require__(/*! ../util/global */ "./src/util/global.ts");
function withConfigValue(config, key) {
    const configSetting = config.inspect(key);
    if (!configSetting) {
        return;
    }
    // Make sure the user has actually set the value.
    // VS Code will return the default values instead of `undefined`, even if user has not don't set anything.
    if (typeof configSetting.globalValue === 'undefined' &&
        typeof configSetting.workspaceFolderValue === 'undefined' &&
        typeof configSetting.workspaceValue === 'undefined') {
        return;
    }
    const value = config.get(key, undefined);
    return value;
}
function setTsPlugin(context) {
    return __awaiter(this, void 0, void 0, function* () {
        // Get the TS extension
        const tsExtension = vscode.extensions.getExtension('vscode.typescript-language-features');
        if (!tsExtension) {
            return;
        }
        yield tsExtension.activate();
        // Get the API from the TS extension
        if (!tsExtension.exports || !tsExtension.exports.getAPI) {
            return;
        }
        const api = tsExtension.exports.getAPI(0);
        if (!api) {
            return;
        }
        vscode.workspace.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration(constants_1.configurationSection)) {
                synchronizeConfiguration(api);
            }
        }, undefined, context.subscriptions);
        synchronizeConfiguration(api);
    });
}
exports["default"] = setTsPlugin;
function getConfiguration() {
    const config = vscode.workspace.getConfiguration(constants_1.configurationSection);
    const outConfig = {};
    const v = withConfigValue(config, 'js.disableTyping');
    if (v) {
        outConfig['disableTyping'] = v;
    }
    outConfig['vscodeExtensionPath'] = global_1.globalData.currentPath;
    outConfig['tsPluginPath'] = global_1.globalData.tsPluginPath;
    outConfig['lsPath'] = global_1.globalData.lsPath;
    outConfig['typesPath'] = global_1.globalData.typesPath;
    outConfig['globalStoragePath'] = global_1.globalData.globalStoragePath;
    log_1.outputChannel.appendLine(`outConfig ${JSON.stringify(outConfig)}`);
    return outConfig;
}
function synchronizeConfiguration(api) {
    api.configurePlugin(constants_1.tsPluginId, getConfiguration());
}


/***/ }),

/***/ "./src/util/dispose.ts":
/*!*****************************!*\
  !*** ./src/util/dispose.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DisposeCollection = void 0;
class DisposeCollection {
    constructor() {
        this._disposables = [];
    }
    dispose() {
        this.clear();
    }
    clear() {
        var _a;
        while (this._disposables.length > 0) {
            (_a = this._disposables.pop()) === null || _a === void 0 ? void 0 : _a.dispose();
        }
    }
    push(disposable) {
        this._disposables.push(disposable);
    }
    pop() {
        return this._disposables.pop();
    }
}
exports.DisposeCollection = DisposeCollection;


/***/ }),

/***/ "./src/util/global.ts":
/*!****************************!*\
  !*** ./src/util/global.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globalData = void 0;
exports.globalData = {};


/***/ }),

/***/ "./src/util/i18n.ts":
/*!**************************!*\
  !*** ./src/util/i18n.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.format = exports.localize = exports.switchText = exports.get = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const supportedLngs = ['en', 'zh-cn'];
const lng = getLng();
const configs = {
    en: {
        summary: 'Summary',
        name: 'Attribute',
        type: 'Type',
        required: 'Required',
        description: 'Description',
        yes: 'Yes',
        no: 'No',
        parameters: 'Parameters',
        returns: 'Return',
        callback: 'Callback',
        result: 'Result',
        attributesList: ', attributes follows:',
        'N/A': 'N/A',
        openInBrowser: 'Open Online Docs',
        clientVer: 'Alipay APP compatibility ',
        'extension.sitemap.isIndexed': 'This page will be indexed due to rule [{0}] in sitemap.json',
        'create.input.tips': 'Please right click on the file tree',
        'create.template.empty': 'No templates available',
        'create.miniService.unavailable': "Current workspace's service is unavailable, you can try to refresh",
        'fileTree.placeholder.createDirectory': 'Create mini program files: axml/{0}/{1}/json',
        'fileTree.placeholder.createDirectory.info': ', add a `/` at the end of the path to create a folder',
        'fileTree.placeholder.createDirectory.new': 'Please input the path',
        'fileTree.valid.nonEmpty': 'The directory name entered cannot be empty',
        'fileTree.valid.brokenTarget': 'Target path became invalid, please retry.',
        'fileTree.valid.destExists': 'File or folder in the path address already exists',
        'fileTree.valid.mustInProject': 'Path not inside your project root directory',
        'fileTree.valid.template': 'Template files are broken: ',
        'fileTree.info.createInfo': 'Will create files: {0}, add a `/` at the end of the path to create a folder',
        'service.appInfo.generatingPage': 'Generating Page...',
        'completion.detail.my': 'MiniProgram API',
        'extension.configuration.askAutoGeneratePage': 'Enable "Automatically create the corresponding code file when a new page is added in app.json"? (You can modify it in settings)',
    },
    'zh-cn': {
        summary: '摘要',
        name: '属性',
        type: '类型',
        required: '必填',
        description: '描述',
        yes: '是',
        no: '否',
        parameters: '入参',
        returns: '返回值',
        callback: '回调函数',
        result: '结果',
        attributesList: '，属性如下：',
        'N/A': '无',
        openInBrowser: '打开在线文档',
        clientVer: '支付宝版本兼容性',
        'extension.sitemap.isIndexed': '根据 sitemap.json 中的规则[{0}], 该页面将会被索引',
        'create.input.tips': '请在需要新建的地方右键选择',
        'create.template.empty': '没有可用的模板',
        'create.miniService.unavailable': '当前文件夹的语言服务暂时不可用，请刷新重试',
        'fileTree.placeholder.createDirectory': '创建小程序文件：axml/{0}/{1}/json',
        'fileTree.placeholder.createDirectory.info': '，输入以 / 结尾的路径会创建一个文件夹',
        'fileTree.placeholder.createDirectory.new': '请输入路径',
        'fileTree.valid.nonEmpty': '输入目录名不能为空',
        'fileTree.valid.brokenTarget': '创建目标路径已被更改且不可用，请重试',
        'fileTree.valid.destExists': '该路径地址的文件或文件夹已存在',
        'fileTree.valid.mustInProject': '该路径不在插件根目录或小程序根目录内',
        'fileTree.valid.template': '模板文件已损坏',
        'fileTree.info.createInfo': '将会创建这些文件 {0}，输入以 / 结尾的路径会创建一个文件夹',
        'service.appInfo.generatingPage': '生成 Page 中...',
        'completion.detail.my': '小程序 API',
        'extension.configuration.askAutoGeneratePage': '需要开启『在 app.json 中新增小程序页面后自动创建对应代码文件』吗？(可在设置中修改)',
    },
};
function getLng() {
    let lng = '';
    if (process.env.VOL_NLS_CONFIG) {
        lng = process.env.VOL_NLS_CONFIG || 'en';
    }
    else if (vscode_1.env && vscode_1.env.language) {
        lng = vscode_1.env.language || 'en';
    }
    else if (process.env.VSCODE_NLS_CONFIG) {
        let nls;
        try {
            nls = JSON.parse(process.env.VSCODE_NLS_CONFIG);
        }
        catch (e) {
            nls = {};
        }
        lng = nls.locale || '';
    }
    if (lng) {
        lng = lng.toLowerCase();
        if (supportedLngs.indexOf(lng) < 0) {
            lng = supportedLngs[0];
        }
        return lng;
    }
    else {
        return 'en';
    }
}
function get(id, dm) {
    return configs[lng][id] || dm || id;
}
exports.get = get;
function switchText(zhText, enText) {
    if (lng !== 'zh' && enText) {
        return enText;
    }
    return zhText || '';
}
exports.switchText = switchText;
function localize(key, defaultMessage, ...args) {
    const m = get(key, defaultMessage || '');
    return format(m, args);
}
exports.localize = localize;
function format(message, args) {
    let result;
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            const index = rest[0];
            const arg = args[index];
            let replacement = match;
            if (typeof arg === 'string') {
                replacement = arg;
            }
            else if (typeof arg === 'number' ||
                typeof arg === 'boolean' ||
                arg === void 0 ||
                arg === null) {
                replacement = String(arg);
            }
            return replacement;
        });
    }
    return result;
}
exports.format = format;


/***/ }),

/***/ "./src/util/log.ts":
/*!*************************!*\
  !*** ./src/util/log.ts ***!
  \*************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.outputChannel = exports.log = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const outputChannel = vscode.window.createOutputChannel('Mini Program Support');
exports.outputChannel = outputChannel;
function log(...args) {
    return outputChannel.appendLine([].join.call(args, ' '));
}
exports.log = log;


/***/ }),

/***/ "./src/util/monitor.ts":
/*!*****************************!*\
  !*** ./src/util/monitor.ts ***!
  \*****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.YuYanMonitorImpl = void 0;
const mac_address_1 = __webpack_require__(/*! @alipay/mac-address */ "./node_modules/@alipay/mac-address/lib/index.js");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const yuyanMonitor_1 = __webpack_require__(/*! ./yuyanMonitor */ "./src/util/yuyanMonitor/index.ts");
const version = (__webpack_require__(/*! ../../package.json */ "./package.json").version);
class YuYanMonitorImpl {
    constructor() {
        this.monitor = null;
        this.isDev = false;
        this._logInfoCache = [];
        this._logErrorCache = [];
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.monitor = yield createYuYanMonitor();
            if (!this.monitor) {
                return;
            }
            if (this._logInfoCache.length > 0) {
                this._logInfoCache.forEach((info) => {
                    try {
                        this.monitor && this.monitor.log.apply(this.monitor, [info]);
                    }
                    catch (e) {
                        // do something
                    }
                });
            }
            if (this._logErrorCache.length > 0) {
                this._logErrorCache.forEach((error) => {
                    try {
                        this.monitor && this.monitor.logError.apply(this.monitor, error);
                    }
                    catch (e) {
                        // do something
                    }
                });
            }
        });
    }
    logError(error) {
        if (this.isDev) {
            return;
        }
        const errorInfo = [
            error,
            {
                code: 1,
                d1: version,
                d2: error.stack,
                d3: vscode_1.env.appName,
                d4: vscode_1.version,
            },
        ];
        const errorInfo2 = [
            error,
            {
                code: 15,
                d1: version,
                d2: vscode_1.env.appName,
                d3: vscode_1.version,
                c1: error.stack,
            },
        ];
        if (!this.monitor) {
            this._logErrorCache.push(errorInfo);
            return;
        }
        try {
            this.monitor.logError.apply(this.monitor, errorInfo);
            this.monitor.logError.apply(this.monitor, errorInfo2);
        }
        catch (error) {
            // do something
        }
    }
    log(params) {
        try {
            this.monitor.log(Object.assign(Object.assign({}, params), { code: 11, d1: version, d2: vscode_1.env.appName, d3: vscode_1.version }));
        }
        catch (error) {
            // do something
        }
    }
    logReady() {
        if (this.isDev) {
            return;
        }
        const info = {
            msg: 'Extension Ready Event',
        };
        if (!this.monitor) {
            this._logInfoCache.push(info);
            return;
        }
        this.log(info);
    }
}
exports.YuYanMonitorImpl = YuYanMonitorImpl;
function createYuYanMonitor() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const address = yield (0, mac_address_1.getMacAddress)();
        return new yuyanMonitor_1.YuYanMonitor({
            yuyanId: '180020010101196343',
            userId: address,
            env: (_a = process.env.AXML_EXTENSION_MODE) !== null && _a !== void 0 ? _a : 'prod',
        });
    });
}


/***/ }),

/***/ "./src/util/output.ts":
/*!****************************!*\
  !*** ./src/util/output.ts ***!
  \****************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lsOutputChannel = void 0;
const vscode = __importStar(__webpack_require__(/*! vscode */ "vscode"));
const lsOutputChannel = vscode.window.createOutputChannel('MiniProgram Language Server');
exports.lsOutputChannel = lsOutputChannel;


/***/ }),

/***/ "./src/util/url.ts":
/*!*************************!*\
  !*** ./src/util/url.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getPageSegment = exports.getUrlLastSegment = void 0;
/**
 * 将 /pages/home/home1/index 返回为 [/pages/home, home, index]
 */
function getUrlLastSegment(url) {
    const lastIndex = url.lastIndexOf('/');
    const [rest, last] = [
        url.substring(0, lastIndex),
        url.substring(lastIndex + 1),
    ];
    return [rest, last];
}
exports.getUrlLastSegment = getUrlLastSegment;
function getPageSegment(url) {
    const [rest, last] = getUrlLastSegment(url);
    const [newRest, lastTwo] = getUrlLastSegment(rest);
    return [newRest, lastTwo, last];
}
exports.getPageSegment = getPageSegment;


/***/ }),

/***/ "./src/util/util.ts":
/*!**************************!*\
  !*** ./src/util/util.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVol = void 0;
var isVol_1 = __webpack_require__(/*! @alipay/mini-extensions-shared/lib/node/isVol */ "../shared/lib/node/isVol.js");
Object.defineProperty(exports, "isVol", ({ enumerable: true, get: function () { return isVol_1.isVol; } }));


/***/ }),

/***/ "./src/util/yuyanMonitor/index.ts":
/*!****************************************!*\
  !*** ./src/util/yuyanMonitor/index.ts ***!
  \****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.YuYanMonitor = void 0;
/* eslint-disable @typescript-eslint/no-inferrable-types */
/* eslint-disable @typescript-eslint/ban-types */
const urllib = __importStar(__webpack_require__(/*! urllib */ "../../node_modules/urllib/src/cjs/index.js"));
const os = __importStar(__webpack_require__(/*! os */ "os"));
const yuyan_monitor_utils_1 = __webpack_require__(/*! @alipay/yuyan-monitor-utils */ "../../node_modules/@alipay/yuyan-monitor-utils/dist/index.esm.js");
const util_1 = __webpack_require__(/*! ./util */ "./src/util/yuyanMonitor/util.ts");
const default_user_agent_1 = __importDefault(__webpack_require__(/*! default-user-agent */ "../../node_modules/default-user-agent/index.js"));
const version = '4.1.6';
const UA = (0, default_user_agent_1.default)('@alipay/yuyan-monitor-node', version);
function getGlobal() {
    if (!eval) {
        return global;
    }
    return (0, eval)('this');
}
const serverUrl = 'https://collect.alipay.com/yuyan/';
class YuYanMonitor {
    constructor(_opts = {}) {
        this.eventId = '102022'; // PC 端监控事件
        this.logCache = [];
        this.userConfig = {};
        this._warn = (...args) => {
            const win = getGlobal();
            if (typeof win === 'object' &&
                win.console &&
                typeof win.console.warn === 'function' &&
                this.debug) {
                const params = Array.prototype.slice.call(args);
                win.console.warn.apply(null, [
                    `[Monitor Debug]${params[0]}`,
                    params.slice(1),
                ]);
            }
        };
        const opts = (0, yuyan_monitor_utils_1.getOptionsDefaulter)().process(_opts);
        this.userConfig = opts;
        this.appid = opts.bmAppid;
        this.debug = opts.debug;
        this.beforeLog = opts.beforeLog;
        this.defaults = opts.defaults || {};
        this.requiredFields = opts.requiredFields;
        this.httpclient = _opts.httpclient;
    }
    /**
     * 将缓存数据上报
     *
     * @private
     * @memberof MonitorAppx
     */
    executelogCache() {
        this.logCache.forEach((item) => {
            this._log(item);
        });
        this.logCache = [];
    }
    /**
     * 上报信息
     * @param logItem
     */
    log(logItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const itemList = Array.isArray(logItem) ? logItem : [logItem];
            return Promise.all(itemList.map((item) => this._log(item)));
        });
    }
    logError(error, logItem) {
        (0, yuyan_monitor_utils_1.logError)(error, util_1.detectHash, {
            log: this.log.bind(this),
            _warn: this._warn.bind(this),
        }, logItem);
    }
    config(configItem) {
        if (!configItem || typeof configItem !== 'object') {
            return;
        }
        (0, yuyan_monitor_utils_1.shallowMerge)(this.userConfig, configItem);
        if ((0, yuyan_monitor_utils_1.allFieldsReady)(this.userConfig, this.requiredFields, this._warn.bind(this))) {
            this.executelogCache();
        }
    }
    _log(logItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const level = logItem.level || 'L';
            const bizType = `yuyanmonitor${level.toLowerCase()}`;
            const logData = this.parseItem(logItem, bizType);
            if (!logData || !logData.length) {
                return;
            }
            return this.sendRequest(logData, bizType);
        });
    }
    /**
     * 将上报值添加上必要的参数，并转化为日志格式
     * @param item
     */
    parseItem(item, bizType) {
        if (!item || typeof item !== 'object') {
            return [];
        }
        const { env } = process;
        // 处理日期
        const dt = new Date();
        // 时间格式补零
        const fillDate = (num) => (num < 10 ? `0${num}` : `${num}`);
        // 处理用户ID
        const userId = item.userId ||
            item.roleId ||
            this.userConfig.userId ||
            env.USER ||
            env.LOGNAME ||
            '';
        delete item.roleId;
        delete item.userId;
        let param4 = Object.assign(Object.assign({}, this.defaults), item);
        if (this.appid) {
            param4.bm_appid = this.appid;
        }
        if (!(0, yuyan_monitor_utils_1.allFieldsReady)(this.userConfig, this.requiredFields, this._warn.bind(this))) {
            this.logCache.push(item);
            return null;
        }
        if (this.userConfig.sprintId)
            param4.bm_sid = this.userConfig.sprintId;
        if (!param4.env && this.userConfig.env)
            param4.env = this.userConfig.env;
        if (this.userConfig.yuyanId)
            param4.yuyan_id = this.userConfig.yuyanId;
        param4.monitor_ver = `nodesdk:${version}`;
        if (this.beforeLog && typeof this.beforeLog === 'function') {
            param4 = this.beforeLog(param4);
            if (!param4 || typeof param4 !== 'object') {
                this._warn('beforeLog返回值不是对象，不进行上报');
                return null;
            }
        }
        // https://github.com/sindresorhus/os-locale/blob/main/index.js#L15
        const envLocale = env.LC_ALL || env.LC_MESSAGES || env.LANG || env.LANGUAGE;
        const data = [
            'D-AE',
            `${dt.getFullYear()}-${fillDate(dt.getMonth() + 1)}-${fillDate(dt.getDate())} ${fillDate(dt.getHours())}:${fillDate(dt.getMinutes())}:${fillDate(dt.getSeconds())}:${dt.getMilliseconds()}`,
            '',
            '',
            '2',
            '',
            '',
            userId,
            '1000',
            this.eventId,
            bizType,
            '2',
            '',
            '',
            '',
            '',
            `${os.platform()}-${os.arch()}`,
            os.release(),
            '',
            '',
            '',
            '',
            '',
            envLocale,
            '',
            '',
            '',
            process.title,
            '',
            UA,
            '',
            '',
            '',
            '',
            '',
            '', // 36. 扩展3
        ];
        data.push((0, util_1.objToStr)(param4, '^', true));
        return data;
    }
    /**
     * 发送 post 请求
     * @param data 日志格式的数据
     */
    sendRequest(data, bizType) {
        return __awaiter(this, void 0, void 0, function* () {
            const sendData = `data=${encodeURIComponent(data.join())}&time=${new Date().getTime()}`;
            const options = {
                method: 'POST',
                content: sendData,
                headers: {
                    'Content-type': 'application/x-www-form-urlencoded',
                    Host: 'collect.alipay.com',
                },
            };
            if (this.httpclient) {
                return this.httpclient.request(serverUrl, options);
            }
            return urllib.request(`${serverUrl}?biztype=${bizType}`, options);
        });
    }
}
exports.YuYanMonitor = YuYanMonitor;


/***/ }),

/***/ "./src/util/yuyanMonitor/util.ts":
/*!***************************************!*\
  !*** ./src/util/yuyanMonitor/util.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detectHash = exports.objToStr = void 0;
const urllib = __importStar(__webpack_require__(/*! urllib */ "../../node_modules/urllib/src/cjs/index.js"));
function objToStr(obj, spliter = '^', encode = false) {
    let strArr = [];
    let prop;
    if (obj instanceof Array) {
        strArr = obj;
    }
    else if (obj instanceof Object) {
        const handleValue = encode
            ? (v) => encodeURIComponent(v).replace(/'/g, '%27') // encode + replace 单引号
            : (v) => v;
        for (prop in obj) {
            // eslint-disable-next-line no-prototype-builtins
            if (obj.hasOwnProperty(prop)) {
                const value = handleValue(obj[prop]);
                strArr.push(`${prop}=${value}`);
            }
        }
    }
    return strArr.join(spliter);
}
exports.objToStr = objToStr;
const hashMap = {};
function detectHash(hash) {
    return __awaiter(this, void 0, void 0, function* () {
        if (hashMap[hash]) {
            return Promise.resolve(true);
        }
        return urllib
            .request(`https://dataservice.alipayobjects.com/alertserver/hash/${hash}`)
            .then((res) => {
            if (res.status === 200 || res.status === 304) {
                hashMap[hash] = true;
                return true;
            }
            return false;
        });
    });
}
exports.detectHash = detectHash;


/***/ }),

/***/ "../../node_modules/tslib/tslib.es6.js":
/*!*********************************************!*\
  !*** ../../node_modules/tslib/tslib.es6.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldIn": () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__values": () => (/* binding */ __values)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
}


/***/ }),

/***/ "../../node_modules/undici/index.js":
/*!******************************************!*\
  !*** ../../node_modules/undici/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Client = __webpack_require__(/*! ./lib/client */ "../../node_modules/undici/lib/client.js")
const Dispatcher = __webpack_require__(/*! ./lib/dispatcher */ "../../node_modules/undici/lib/dispatcher.js")
const errors = __webpack_require__(/*! ./lib/core/errors */ "../../node_modules/undici/lib/core/errors.js")
const Pool = __webpack_require__(/*! ./lib/pool */ "../../node_modules/undici/lib/pool.js")
const BalancedPool = __webpack_require__(/*! ./lib/balanced-pool */ "../../node_modules/undici/lib/balanced-pool.js")
const Agent = __webpack_require__(/*! ./lib/agent */ "../../node_modules/undici/lib/agent.js")
const util = __webpack_require__(/*! ./lib/core/util */ "../../node_modules/undici/lib/core/util.js")
const { InvalidArgumentError } = errors
const api = __webpack_require__(/*! ./lib/api */ "../../node_modules/undici/lib/api/index.js")
const buildConnector = __webpack_require__(/*! ./lib/core/connect */ "../../node_modules/undici/lib/core/connect.js")
const MockClient = __webpack_require__(/*! ./lib/mock/mock-client */ "../../node_modules/undici/lib/mock/mock-client.js")
const MockAgent = __webpack_require__(/*! ./lib/mock/mock-agent */ "../../node_modules/undici/lib/mock/mock-agent.js")
const MockPool = __webpack_require__(/*! ./lib/mock/mock-pool */ "../../node_modules/undici/lib/mock/mock-pool.js")
const mockErrors = __webpack_require__(/*! ./lib/mock/mock-errors */ "../../node_modules/undici/lib/mock/mock-errors.js")
const ProxyAgent = __webpack_require__(/*! ./lib/proxy-agent */ "../../node_modules/undici/lib/proxy-agent.js")
const { getGlobalDispatcher, setGlobalDispatcher } = __webpack_require__(/*! ./lib/global */ "../../node_modules/undici/lib/global.js")

const nodeVersion = process.versions.node.split('.')
const nodeMajor = Number(nodeVersion[0])
const nodeMinor = Number(nodeVersion[1])

Object.assign(Dispatcher.prototype, api)

module.exports.Dispatcher = Dispatcher
module.exports.Client = Client
module.exports.Pool = Pool
module.exports.BalancedPool = BalancedPool
module.exports.Agent = Agent
module.exports.ProxyAgent = ProxyAgent

module.exports.buildConnector = buildConnector
module.exports.errors = errors

function makeDispatcher (fn) {
  return (url, opts, handler) => {
    if (typeof opts === 'function') {
      handler = opts
      opts = null
    }

    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
      throw new InvalidArgumentError('invalid url')
    }

    if (opts != null && typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (opts && opts.path != null) {
      if (typeof opts.path !== 'string') {
        throw new InvalidArgumentError('invalid opts.path')
      }

      url = new URL(opts.path, util.parseOrigin(url))
    } else {
      if (!opts) {
        opts = typeof url === 'object' ? url : {}
      }

      url = util.parseURL(url)
    }

    const { agent, dispatcher = getGlobalDispatcher() } = opts

    if (agent) {
      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')
    }

    return fn.call(dispatcher, {
      ...opts,
      origin: url.origin,
      path: url.search ? `${url.pathname}${url.search}` : url.pathname,
      method: opts.method || (opts.body ? 'PUT' : 'GET')
    }, handler)
  }
}

module.exports.setGlobalDispatcher = setGlobalDispatcher
module.exports.getGlobalDispatcher = getGlobalDispatcher

if (nodeMajor > 16 || (nodeMajor === 16 && nodeMinor >= 8)) {
  let fetchImpl = null
  module.exports.fetch = async function fetch (resource) {
    if (!fetchImpl) {
      fetchImpl = __webpack_require__(/*! ./lib/fetch */ "../../node_modules/undici/lib/fetch/index.js")
    }
    const dispatcher = (arguments[1] && arguments[1].dispatcher) || getGlobalDispatcher()
    return fetchImpl.apply(dispatcher, arguments)
  }
  module.exports.Headers = __webpack_require__(/*! ./lib/fetch/headers */ "../../node_modules/undici/lib/fetch/headers.js").Headers
  module.exports.Response = __webpack_require__(/*! ./lib/fetch/response */ "../../node_modules/undici/lib/fetch/response.js").Response
  module.exports.Request = __webpack_require__(/*! ./lib/fetch/request */ "../../node_modules/undici/lib/fetch/request.js").Request
  module.exports.FormData = __webpack_require__(/*! ./lib/fetch/formdata */ "../../node_modules/undici/lib/fetch/formdata.js").FormData
  module.exports.File = __webpack_require__(/*! ./lib/fetch/file */ "../../node_modules/undici/lib/fetch/file.js").File
}

module.exports.request = makeDispatcher(api.request)
module.exports.stream = makeDispatcher(api.stream)
module.exports.pipeline = makeDispatcher(api.pipeline)
module.exports.connect = makeDispatcher(api.connect)
module.exports.upgrade = makeDispatcher(api.upgrade)

module.exports.MockClient = MockClient
module.exports.MockPool = MockPool
module.exports.MockAgent = MockAgent
module.exports.mockErrors = mockErrors


/***/ }),

/***/ "../../node_modules/undici/lib/agent.js":
/*!**********************************************!*\
  !*** ../../node_modules/undici/lib/agent.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { kClients, kRunning, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "../../node_modules/undici/lib/dispatcher-base.js")
const Pool = __webpack_require__(/*! ./pool */ "../../node_modules/undici/lib/pool.js")
const Client = __webpack_require__(/*! ./client */ "../../node_modules/undici/lib/client.js")
const util = __webpack_require__(/*! ./core/util */ "../../node_modules/undici/lib/core/util.js")
const RedirectHandler = __webpack_require__(/*! ./handler/redirect */ "../../node_modules/undici/lib/handler/redirect.js")
const { WeakRef, FinalizationRegistry } = __webpack_require__(/*! ./compat/dispatcher-weakref */ "../../node_modules/undici/lib/compat/dispatcher-weakref.js")()

const kOnConnect = Symbol('onConnect')
const kOnDisconnect = Symbol('onDisconnect')
const kOnConnectionError = Symbol('onConnectionError')
const kMaxRedirections = Symbol('maxRedirections')
const kOnDrain = Symbol('onDrain')
const kFactory = Symbol('factory')
const kFinalizer = Symbol('finalizer')
const kOptions = Symbol('options')

function defaultFactory (origin, opts) {
  return opts && opts.connections === 1
    ? new Client(origin, opts)
    : new Pool(origin, opts)
}

class Agent extends DispatcherBase {
  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
    super()

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    if (connect && typeof connect !== 'function') {
      connect = { ...connect }
    }

    this[kOptions] = { ...util.deepClone(options), connect }
    this[kMaxRedirections] = maxRedirections
    this[kFactory] = factory
    this[kClients] = new Map()
    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {
      const ref = this[kClients].get(key)
      if (ref !== undefined && ref.deref() === undefined) {
        this[kClients].delete(key)
      }
    })

    const agent = this

    this[kOnDrain] = (origin, targets) => {
      agent.emit('drain', origin, [agent, ...targets])
    }

    this[kOnConnect] = (origin, targets) => {
      agent.emit('connect', origin, [agent, ...targets])
    }

    this[kOnDisconnect] = (origin, targets, err) => {
      agent.emit('disconnect', origin, [agent, ...targets], err)
    }

    this[kOnConnectionError] = (origin, targets, err) => {
      agent.emit('connectionError', origin, [agent, ...targets], err)
    }
  }

  get [kRunning] () {
    let ret = 0
    for (const ref of this[kClients].values()) {
      const client = ref.deref()
      /* istanbul ignore next: gc is undeterministic */
      if (client) {
        ret += client[kRunning]
      }
    }
    return ret
  }

  [kDispatch] (opts, handler) {
    let key
    if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
      key = String(opts.origin)
    } else {
      throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')
    }

    const ref = this[kClients].get(key)

    let dispatcher = ref ? ref.deref() : null
    if (!dispatcher) {
      dispatcher = this[kFactory](opts.origin, this[kOptions])
        .on('drain', this[kOnDrain])
        .on('connect', this[kOnConnect])
        .on('disconnect', this[kOnDisconnect])
        .on('connectionError', this[kOnConnectionError])

      this[kClients].set(key, new WeakRef(dispatcher))
      this[kFinalizer].register(dispatcher, key)
    }

    const { maxRedirections = this[kMaxRedirections] } = opts
    if (maxRedirections != null && maxRedirections !== 0) {
      opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.
      handler = new RedirectHandler(this, maxRedirections, opts, handler)
    }

    return dispatcher.dispatch(opts, handler)
  }

  async [kClose] () {
    const closePromises = []
    for (const ref of this[kClients].values()) {
      const client = ref.deref()
      /* istanbul ignore else: gc is undeterministic */
      if (client) {
        closePromises.push(client.close())
      }
    }

    await Promise.all(closePromises)
  }

  async [kDestroy] (err) {
    const destroyPromises = []
    for (const ref of this[kClients].values()) {
      const client = ref.deref()
      /* istanbul ignore else: gc is undeterministic */
      if (client) {
        destroyPromises.push(client.destroy(err))
      }
    }

    await Promise.all(destroyPromises)
  }
}

module.exports = Agent


/***/ }),

/***/ "../../node_modules/undici/lib/api/abort-signal.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/api/abort-signal.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { RequestAbortedError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")

const kListener = Symbol('kListener')
const kSignal = Symbol('kSignal')

function abort (self) {
  if (self.abort) {
    self.abort()
  } else {
    self.onError(new RequestAbortedError())
  }
}

function addSignal (self, signal) {
  self[kSignal] = null
  self[kListener] = null

  if (!signal) {
    return
  }

  if (signal.aborted) {
    abort(self)
    return
  }

  self[kSignal] = signal
  self[kListener] = () => {
    abort(self)
  }

  if ('addEventListener' in self[kSignal]) {
    self[kSignal].addEventListener('abort', self[kListener])
  } else {
    self[kSignal].addListener('abort', self[kListener])
  }
}

function removeSignal (self) {
  if (!self[kSignal]) {
    return
  }

  if ('removeEventListener' in self[kSignal]) {
    self[kSignal].removeEventListener('abort', self[kListener])
  } else {
    self[kSignal].removeListener('abort', self[kListener])
  }

  self[kSignal] = null
  self[kListener] = null
}

module.exports = {
  addSignal,
  removeSignal
}


/***/ }),

/***/ "../../node_modules/undici/lib/api/api-connect.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-connect.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "../../node_modules/undici/lib/api/abort-signal.js")

class ConnectHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    const { signal, opaque, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    super('UNDICI_CONNECT')

    this.opaque = opaque || null
    this.responseHeaders = responseHeaders || null
    this.callback = callback
    this.abort = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders () {
    throw new SocketError('bad connect', null)
  }

  onUpgrade (statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this

    removeSignal(this)

    this.callback = null
    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
    this.runInAsyncScope(callback, null, null, {
      statusCode,
      headers,
      socket,
      opaque,
      context
    })
  }

  onError (err) {
    const { callback, opaque } = this

    removeSignal(this)

    if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }
  }
}

function connect (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      connect.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    const connectHandler = new ConnectHandler(opts, callback)
    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts && opts.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = connect


/***/ }),

/***/ "../../node_modules/undici/lib/api/api-pipeline.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-pipeline.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  Readable,
  Duplex,
  PassThrough
} = __webpack_require__(/*! stream */ "stream")
const {
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError
} = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "../../node_modules/undici/lib/api/abort-signal.js")
const assert = __webpack_require__(/*! assert */ "assert")

const kResume = Symbol('resume')

class PipelineRequest extends Readable {
  constructor () {
    super({ autoDestroy: true })

    this[kResume] = null
  }

  _read () {
    const { [kResume]: resume } = this

    if (resume) {
      this[kResume] = null
      resume()
    }
  }

  _destroy (err, callback) {
    this._read()

    callback(err)
  }
}

class PipelineResponse extends Readable {
  constructor (resume) {
    super({ autoDestroy: true })
    this[kResume] = resume
  }

  _read () {
    this[kResume]()
  }

  _destroy (err, callback) {
    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError()
    }

    callback(err)
  }
}

class PipelineHandler extends AsyncResource {
  constructor (opts, handler) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof handler !== 'function') {
      throw new InvalidArgumentError('invalid handler')
    }

    const { signal, method, opaque, onInfo, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    if (method === 'CONNECT') {
      throw new InvalidArgumentError('invalid method')
    }

    if (onInfo && typeof onInfo !== 'function') {
      throw new InvalidArgumentError('invalid onInfo callback')
    }

    super('UNDICI_PIPELINE')

    this.opaque = opaque || null
    this.responseHeaders = responseHeaders || null
    this.handler = handler
    this.abort = null
    this.context = null
    this.onInfo = onInfo || null

    this.req = new PipelineRequest().on('error', util.nop)

    this.ret = new Duplex({
      readableObjectMode: opts.objectMode,
      autoDestroy: true,
      read: () => {
        const { body } = this

        if (body && body.resume) {
          body.resume()
        }
      },
      write: (chunk, encoding, callback) => {
        const { req } = this

        if (req.push(chunk, encoding) || req._readableState.destroyed) {
          callback()
        } else {
          req[kResume] = callback
        }
      },
      destroy: (err, callback) => {
        const { body, req, res, ret, abort } = this

        if (!err && !ret._readableState.endEmitted) {
          err = new RequestAbortedError()
        }

        if (abort && err) {
          abort()
        }

        util.destroy(body, err)
        util.destroy(req, err)
        util.destroy(res, err)

        removeSignal(this)

        callback(err)
      }
    }).on('prefinish', () => {
      const { req } = this

      // Node < 15 does not call _final in same tick.
      req.push(null)
    })

    this.res = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    const { ret, res } = this

    assert(!res, 'pipeline cannot be retried')

    if (ret.destroyed) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume) {
    const { opaque, handler, context } = this

    if (statusCode < 200) {
      if (this.onInfo) {
        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
        this.onInfo({ statusCode, headers })
      }
      return
    }

    this.res = new PipelineResponse(resume)

    let body
    try {
      this.handler = null
      const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
      body = this.runInAsyncScope(handler, null, {
        statusCode,
        headers,
        opaque,
        body: this.res,
        context
      })
    } catch (err) {
      this.res.on('error', util.nop)
      throw err
    }

    if (!body || typeof body.on !== 'function') {
      throw new InvalidReturnValueError('expected Readable')
    }

    body
      .on('data', (chunk) => {
        const { ret, body } = this

        if (!ret.push(chunk) && body.pause) {
          body.pause()
        }
      })
      .on('error', (err) => {
        const { ret } = this

        util.destroy(ret, err)
      })
      .on('end', () => {
        const { ret } = this

        ret.push(null)
      })
      .on('close', () => {
        const { ret } = this

        if (!ret._readableState.ended) {
          util.destroy(ret, new RequestAbortedError())
        }
      })

    this.body = body
  }

  onData (chunk) {
    const { res } = this
    return res.push(chunk)
  }

  onComplete (trailers) {
    const { res } = this
    res.push(null)
  }

  onError (err) {
    const { ret } = this
    this.handler = null
    util.destroy(ret, err)
  }
}

function pipeline (opts, handler) {
  try {
    const pipelineHandler = new PipelineHandler(opts, handler)
    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)
    return pipelineHandler.ret
  } catch (err) {
    return new PassThrough().destroy(err)
  }
}

module.exports = pipeline


/***/ }),

/***/ "../../node_modules/undici/lib/api/api-request.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-request.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Readable = __webpack_require__(/*! ./readable */ "../../node_modules/undici/lib/api/readable.js")
const {
  InvalidArgumentError,
  RequestAbortedError,
  ResponseStatusCodeError
} = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "../../node_modules/undici/lib/api/abort-signal.js")

class RequestHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts

    try {
      if (typeof callback !== 'function') {
        throw new InvalidArgumentError('invalid callback')
      }

      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
      }

      if (method === 'CONNECT') {
        throw new InvalidArgumentError('invalid method')
      }

      if (onInfo && typeof onInfo !== 'function') {
        throw new InvalidArgumentError('invalid onInfo callback')
      }

      super('UNDICI_REQUEST')
    } catch (err) {
      if (util.isStream(body)) {
        util.destroy(body.on('error', util.nop), err)
      }
      throw err
    }

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.callback = callback
    this.res = null
    this.abort = null
    this.body = body
    this.trailers = {}
    this.context = null
    this.onInfo = onInfo || null
    this.throwOnError = throwOnError

    if (util.isStream(body)) {
      body.on('error', (err) => {
        this.onError(err)
      })
    }

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume, statusMessage) {
    const { callback, opaque, abort, context } = this

    if (statusCode < 200) {
      if (this.onInfo) {
        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
        this.onInfo({ statusCode, headers })
      }
      return
    }

    const parsedHeaders = util.parseHeaders(rawHeaders)
    const contentType = parsedHeaders['content-type']
    const body = new Readable(resume, abort, contentType)

    this.callback = null
    this.res = body
    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)

    if (callback !== null) {
      if (this.throwOnError && statusCode >= 400) {
        this.runInAsyncScope(getResolveErrorBodyCallback, null,
          { callback, body, contentType, statusCode, statusMessage, headers }
        )
        return
      }

      this.runInAsyncScope(callback, null, null, {
        statusCode,
        headers,
        trailers: this.trailers,
        opaque,
        body,
        context
      })
    }
  }

  onData (chunk) {
    const { res } = this
    return res.push(chunk)
  }

  onComplete (trailers) {
    const { res } = this

    removeSignal(this)

    util.parseHeaders(trailers, this.trailers)

    res.push(null)
  }

  onError (err) {
    const { res, callback, body, opaque } = this

    removeSignal(this)

    if (callback) {
      // TODO: Does this need queueMicrotask?
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }

    if (res) {
      this.res = null
      // Ensure all queued handlers are invoked before destroying res.
      queueMicrotask(() => {
        util.destroy(res, err)
      })
    }

    if (body) {
      this.body = null
      util.destroy(body, err)
    }
  }
}

async function getResolveErrorBodyCallback ({ callback, body, contentType, statusCode, statusMessage, headers }) {
  if (statusCode === 204 || !contentType) {
    body.dump()
    process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))
    return
  }

  try {
    if (contentType.startsWith('application/json')) {
      const payload = await body.json()
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))
      return
    }

    if (contentType.startsWith('text/')) {
      const payload = await body.text()
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers, payload))
      return
    }
  } catch (err) {
    // Process in a fallback if error
  }

  body.dump()
  process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`, statusCode, headers))
}

function request (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      request.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    this.dispatch(opts, new RequestHandler(opts, callback))
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts && opts.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = request


/***/ }),

/***/ "../../node_modules/undici/lib/api/api-stream.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-stream.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { finished } = __webpack_require__(/*! stream */ "stream")
const {
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError
} = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "../../node_modules/undici/lib/api/abort-signal.js")

class StreamHandler extends AsyncResource {
  constructor (opts, factory, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    const { signal, method, opaque, body, onInfo, responseHeaders } = opts

    try {
      if (typeof callback !== 'function') {
        throw new InvalidArgumentError('invalid callback')
      }

      if (typeof factory !== 'function') {
        throw new InvalidArgumentError('invalid factory')
      }

      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
      }

      if (method === 'CONNECT') {
        throw new InvalidArgumentError('invalid method')
      }

      if (onInfo && typeof onInfo !== 'function') {
        throw new InvalidArgumentError('invalid onInfo callback')
      }

      super('UNDICI_STREAM')
    } catch (err) {
      if (util.isStream(body)) {
        util.destroy(body.on('error', util.nop), err)
      }
      throw err
    }

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.factory = factory
    this.callback = callback
    this.res = null
    this.abort = null
    this.context = null
    this.trailers = null
    this.body = body
    this.onInfo = onInfo || null

    if (util.isStream(body)) {
      body.on('error', (err) => {
        this.onError(err)
      })
    }

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = context
  }

  onHeaders (statusCode, rawHeaders, resume) {
    const { factory, opaque, context } = this

    if (statusCode < 200) {
      if (this.onInfo) {
        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
        this.onInfo({ statusCode, headers })
      }
      return
    }

    this.factory = null
    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
    const res = this.runInAsyncScope(factory, null, {
      statusCode,
      headers,
      opaque,
      context
    })

    if (
      !res ||
      typeof res.write !== 'function' ||
      typeof res.end !== 'function' ||
      typeof res.on !== 'function'
    ) {
      throw new InvalidReturnValueError('expected Writable')
    }

    res.on('drain', resume)
    // TODO: Avoid finished. It registers an unecessary amount of listeners.
    finished(res, { readable: false }, (err) => {
      const { callback, res, opaque, trailers, abort } = this

      this.res = null
      if (err || !res.readable) {
        util.destroy(res, err)
      }

      this.callback = null
      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })

      if (err) {
        abort()
      }
    })

    this.res = res

    const needDrain = res.writableNeedDrain !== undefined
      ? res.writableNeedDrain
      : res._writableState && res._writableState.needDrain

    return needDrain !== true
  }

  onData (chunk) {
    const { res } = this

    return res.write(chunk)
  }

  onComplete (trailers) {
    const { res } = this

    removeSignal(this)

    this.trailers = util.parseHeaders(trailers)

    res.end()
  }

  onError (err) {
    const { res, callback, opaque, body } = this

    removeSignal(this)

    this.factory = null

    if (res) {
      this.res = null
      util.destroy(res, err)
    } else if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }

    if (body) {
      this.body = null
      util.destroy(body, err)
    }
  }
}

function stream (opts, factory, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      stream.call(this, opts, factory, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    this.dispatch(opts, new StreamHandler(opts, factory, callback))
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts && opts.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = stream


/***/ }),

/***/ "../../node_modules/undici/lib/api/api-upgrade.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/api/api-upgrade.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { InvalidArgumentError, RequestAbortedError, SocketError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { AsyncResource } = __webpack_require__(/*! async_hooks */ "async_hooks")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { addSignal, removeSignal } = __webpack_require__(/*! ./abort-signal */ "../../node_modules/undici/lib/api/abort-signal.js")
const assert = __webpack_require__(/*! assert */ "assert")

class UpgradeHandler extends AsyncResource {
  constructor (opts, callback) {
    if (!opts || typeof opts !== 'object') {
      throw new InvalidArgumentError('invalid opts')
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    const { signal, opaque, responseHeaders } = opts

    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {
      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')
    }

    super('UNDICI_UPGRADE')

    this.responseHeaders = responseHeaders || null
    this.opaque = opaque || null
    this.callback = callback
    this.abort = null
    this.context = null

    addSignal(this, signal)
  }

  onConnect (abort, context) {
    if (!this.callback) {
      throw new RequestAbortedError()
    }

    this.abort = abort
    this.context = null
  }

  onHeaders () {
    throw new SocketError('bad upgrade', null)
  }

  onUpgrade (statusCode, rawHeaders, socket) {
    const { callback, opaque, context } = this

    assert.strictEqual(statusCode, 101)

    removeSignal(this)

    this.callback = null
    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)
    this.runInAsyncScope(callback, null, null, {
      headers,
      socket,
      opaque,
      context
    })
  }

  onError (err) {
    const { callback, opaque } = this

    removeSignal(this)

    if (callback) {
      this.callback = null
      queueMicrotask(() => {
        this.runInAsyncScope(callback, null, err, { opaque })
      })
    }
  }
}

function upgrade (opts, callback) {
  if (callback === undefined) {
    return new Promise((resolve, reject) => {
      upgrade.call(this, opts, (err, data) => {
        return err ? reject(err) : resolve(data)
      })
    })
  }

  try {
    const upgradeHandler = new UpgradeHandler(opts, callback)
    this.dispatch({
      ...opts,
      method: opts.method || 'GET',
      upgrade: opts.protocol || 'Websocket'
    }, upgradeHandler)
  } catch (err) {
    if (typeof callback !== 'function') {
      throw err
    }
    const opaque = opts && opts.opaque
    queueMicrotask(() => callback(err, { opaque }))
  }
}

module.exports = upgrade


/***/ }),

/***/ "../../node_modules/undici/lib/api/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/api/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports.request = __webpack_require__(/*! ./api-request */ "../../node_modules/undici/lib/api/api-request.js")
module.exports.stream = __webpack_require__(/*! ./api-stream */ "../../node_modules/undici/lib/api/api-stream.js")
module.exports.pipeline = __webpack_require__(/*! ./api-pipeline */ "../../node_modules/undici/lib/api/api-pipeline.js")
module.exports.upgrade = __webpack_require__(/*! ./api-upgrade */ "../../node_modules/undici/lib/api/api-upgrade.js")
module.exports.connect = __webpack_require__(/*! ./api-connect */ "../../node_modules/undici/lib/api/api-connect.js")


/***/ }),

/***/ "../../node_modules/undici/lib/api/readable.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/api/readable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Ported from https://github.com/nodejs/undici/pull/907



const assert = __webpack_require__(/*! assert */ "assert")
const { Readable } = __webpack_require__(/*! stream */ "stream")
const { RequestAbortedError, NotSupportedError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { ReadableStreamFrom, toUSVString } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")

let Blob

const kConsume = Symbol('kConsume')
const kReading = Symbol('kReading')
const kBody = Symbol('kBody')
const kAbort = Symbol('abort')
const kContentType = Symbol('kContentType')

module.exports = class BodyReadable extends Readable {
  constructor (resume, abort, contentType = '') {
    super({
      autoDestroy: true,
      read: resume,
      highWaterMark: 64 * 1024 // Same as nodejs fs streams.
    })

    this._readableState.dataEmitted = false

    this[kAbort] = abort
    this[kConsume] = null
    this[kBody] = null
    this[kContentType] = contentType

    // Is stream being consumed through Readable API?
    // This is an optimization so that we avoid checking
    // for 'data' and 'readable' listeners in the hot path
    // inside push().
    this[kReading] = false
  }

  destroy (err) {
    if (this.destroyed) {
      // Node < 16
      return this
    }

    if (!err && !this._readableState.endEmitted) {
      err = new RequestAbortedError()
    }

    if (err) {
      this[kAbort]()
    }

    return super.destroy(err)
  }

  emit (ev, ...args) {
    if (ev === 'data') {
      // Node < 16.7
      this._readableState.dataEmitted = true
    } else if (ev === 'error') {
      // Node < 16
      this._readableState.errorEmitted = true
    }
    return super.emit(ev, ...args)
  }

  on (ev, ...args) {
    if (ev === 'data' || ev === 'readable') {
      this[kReading] = true
    }
    return super.on(ev, ...args)
  }

  addListener (ev, ...args) {
    return this.on(ev, ...args)
  }

  off (ev, ...args) {
    const ret = super.off(ev, ...args)
    if (ev === 'data' || ev === 'readable') {
      this[kReading] = (
        this.listenerCount('data') > 0 ||
        this.listenerCount('readable') > 0
      )
    }
    return ret
  }

  removeListener (ev, ...args) {
    return this.off(ev, ...args)
  }

  push (chunk) {
    if (this[kConsume] && chunk !== null) {
      consumePush(this[kConsume], chunk)
      return this[kReading] ? super.push(chunk) : true
    }
    return super.push(chunk)
  }

  // https://fetch.spec.whatwg.org/#dom-body-text
  async text () {
    return consume(this, 'text')
  }

  // https://fetch.spec.whatwg.org/#dom-body-json
  async json () {
    return consume(this, 'json')
  }

  // https://fetch.spec.whatwg.org/#dom-body-blob
  async blob () {
    return consume(this, 'blob')
  }

  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
  async arrayBuffer () {
    return consume(this, 'arrayBuffer')
  }

  // https://fetch.spec.whatwg.org/#dom-body-formdata
  async formData () {
    // TODO: Implement.
    throw new NotSupportedError()
  }

  // https://fetch.spec.whatwg.org/#dom-body-bodyused
  get bodyUsed () {
    return util.isDisturbed(this)
  }

  // https://fetch.spec.whatwg.org/#dom-body-body
  get body () {
    if (!this[kBody]) {
      this[kBody] = ReadableStreamFrom(this)
      if (this[kConsume]) {
        // TODO: Is this the best way to force a lock?
        this[kBody].getReader() // Ensure stream is locked.
        assert(this[kBody].locked)
      }
    }
    return this[kBody]
  }

  async dump (opts) {
    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144
    try {
      for await (const chunk of this) {
        limit -= Buffer.byteLength(chunk)
        if (limit < 0) {
          return
        }
      }
    } catch {
      // Do nothing...
    }
  }
}

// https://streams.spec.whatwg.org/#readablestream-locked
function isLocked (self) {
  // Consume is an implicit lock.
  return (self[kBody] && self[kBody].locked === true) || self[kConsume]
}

// https://fetch.spec.whatwg.org/#body-unusable
function isUnusable (self) {
  return util.isDisturbed(self) || isLocked(self)
}

async function consume (stream, type) {
  if (isUnusable(stream)) {
    throw new TypeError('unusable')
  }

  assert(!stream[kConsume])

  return new Promise((resolve, reject) => {
    stream[kConsume] = {
      type,
      stream,
      resolve,
      reject,
      length: 0,
      body: []
    }

    stream
      .on('error', function (err) {
        consumeFinish(this[kConsume], err)
      })
      .on('close', function () {
        if (this[kConsume].body !== null) {
          consumeFinish(this[kConsume], new RequestAbortedError())
        }
      })

    process.nextTick(consumeStart, stream[kConsume])
  })
}

function consumeStart (consume) {
  if (consume.body === null) {
    return
  }

  const { _readableState: state } = consume.stream

  for (const chunk of state.buffer) {
    consumePush(consume, chunk)
  }

  if (state.endEmitted) {
    consumeEnd(this[kConsume])
  } else {
    consume.stream.on('end', function () {
      consumeEnd(this[kConsume])
    })
  }

  consume.stream.resume()

  while (consume.stream.read() != null) {
    // Loop
  }
}

function consumeEnd (consume) {
  const { type, body, resolve, stream, length } = consume

  try {
    if (type === 'text') {
      resolve(toUSVString(Buffer.concat(body)))
    } else if (type === 'json') {
      resolve(JSON.parse(Buffer.concat(body)))
    } else if (type === 'arrayBuffer') {
      const dst = new Uint8Array(length)

      let pos = 0
      for (const buf of body) {
        dst.set(buf, pos)
        pos += buf.byteLength
      }

      resolve(dst)
    } else if (type === 'blob') {
      if (!Blob) {
        Blob = (__webpack_require__(/*! buffer */ "buffer").Blob)
      }
      resolve(new Blob(body, { type: stream[kContentType] }))
    }

    consumeFinish(consume)
  } catch (err) {
    stream.destroy(err)
  }
}

function consumePush (consume, chunk) {
  consume.length += chunk.length
  consume.body.push(chunk)
}

function consumeFinish (consume, err) {
  if (consume.body === null) {
    return
  }

  if (err) {
    consume.reject(err)
  } else {
    consume.resolve()
  }

  consume.type = null
  consume.stream = null
  consume.resolve = null
  consume.reject = null
  consume.length = 0
  consume.body = null
}


/***/ }),

/***/ "../../node_modules/undici/lib/balanced-pool.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/balanced-pool.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  BalancedPoolMissingUpstreamError,
  InvalidArgumentError
} = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kRemoveClient,
  kGetDispatcher
} = __webpack_require__(/*! ./pool-base */ "../../node_modules/undici/lib/pool-base.js")
const Pool = __webpack_require__(/*! ./pool */ "../../node_modules/undici/lib/pool.js")
const { kUrl } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const { parseOrigin } = __webpack_require__(/*! ./core/util */ "../../node_modules/undici/lib/core/util.js")
const kFactory = Symbol('factory')

const kOptions = Symbol('options')
const kGreatestCommonDivisor = Symbol('kGreatestCommonDivisor')
const kCurrentWeight = Symbol('kCurrentWeight')
const kIndex = Symbol('kIndex')
const kWeight = Symbol('kWeight')
const kMaxWeightPerServer = Symbol('kMaxWeightPerServer')
const kErrorPenalty = Symbol('kErrorPenalty')

function getGreatestCommonDivisor (a, b) {
  if (b === 0) return a
  return getGreatestCommonDivisor(b, a % b)
}

function defaultFactory (origin, opts) {
  return new Pool(origin, opts)
}

class BalancedPool extends PoolBase {
  constructor (upstreams = [], { factory = defaultFactory, ...opts } = {}) {
    super()

    this[kOptions] = opts
    this[kIndex] = -1
    this[kCurrentWeight] = 0

    this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100
    this[kErrorPenalty] = this[kOptions].errorPenalty || 15

    if (!Array.isArray(upstreams)) {
      upstreams = [upstreams]
    }

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    this[kFactory] = factory

    for (const upstream of upstreams) {
      this.addUpstream(upstream)
    }
    this._updateBalancedPoolStats()
  }

  addUpstream (upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin

    if (this[kClients].find((pool) => (
      pool[kUrl].origin === upstreamOrigin &&
      pool.closed !== true &&
      pool.destroyed !== true
    ))) {
      return this
    }
    const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]))

    this[kAddClient](pool)
    pool.on('connect', () => {
      pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty])
    })

    pool.on('connectionError', () => {
      pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
      this._updateBalancedPoolStats()
    })

    pool.on('disconnect', (...args) => {
      const err = args[2]
      if (err && err.code === 'UND_ERR_SOCKET') {
        // decrease the weight of the pool.
        pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty])
        this._updateBalancedPoolStats()
      }
    })

    for (const client of this[kClients]) {
      client[kWeight] = this[kMaxWeightPerServer]
    }

    this._updateBalancedPoolStats()

    return this
  }

  _updateBalancedPoolStats () {
    this[kGreatestCommonDivisor] = this[kClients].map(p => p[kWeight]).reduce(getGreatestCommonDivisor, 0)
  }

  removeUpstream (upstream) {
    const upstreamOrigin = parseOrigin(upstream).origin

    const pool = this[kClients].find((pool) => (
      pool[kUrl].origin === upstreamOrigin &&
      pool.closed !== true &&
      pool.destroyed !== true
    ))

    if (pool) {
      this[kRemoveClient](pool)
    }

    return this
  }

  get upstreams () {
    return this[kClients]
      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)
      .map((p) => p[kUrl].origin)
  }

  [kGetDispatcher] () {
    // We validate that pools is greater than 0,
    // otherwise we would have to wait until an upstream
    // is added, which might never happen.
    if (this[kClients].length === 0) {
      throw new BalancedPoolMissingUpstreamError()
    }

    const dispatcher = this[kClients].find(dispatcher => (
      !dispatcher[kNeedDrain] &&
      dispatcher.closed !== true &&
      dispatcher.destroyed !== true
    ))

    if (!dispatcher) {
      return
    }

    const allClientsBusy = this[kClients].map(pool => pool[kNeedDrain]).reduce((a, b) => a && b, true)

    if (allClientsBusy) {
      return
    }

    let counter = 0

    let maxWeightIndex = this[kClients].findIndex(pool => !pool[kNeedDrain])

    while (counter++ < this[kClients].length) {
      this[kIndex] = (this[kIndex] + 1) % this[kClients].length
      const pool = this[kClients][this[kIndex]]

      // find pool index with the largest weight
      if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
        maxWeightIndex = this[kIndex]
      }

      // decrease the current weight every `this[kClients].length`.
      if (this[kIndex] === 0) {
        // Set the current weight to the next lower weight.
        this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor]

        if (this[kCurrentWeight] <= 0) {
          this[kCurrentWeight] = this[kMaxWeightPerServer]
        }
      }
      if (pool[kWeight] >= this[kCurrentWeight] && (!pool[kNeedDrain])) {
        return pool
      }
    }

    this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight]
    this[kIndex] = maxWeightIndex
    return this[kClients][maxWeightIndex]
  }
}

module.exports = BalancedPool


/***/ }),

/***/ "../../node_modules/undici/lib/client.js":
/*!***********************************************!*\
  !*** ../../node_modules/undici/lib/client.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* global WebAssembly */

const assert = __webpack_require__(/*! assert */ "assert")
const net = __webpack_require__(/*! net */ "net")
const util = __webpack_require__(/*! ./core/util */ "../../node_modules/undici/lib/core/util.js")
const Request = __webpack_require__(/*! ./core/request */ "../../node_modules/undici/lib/core/request.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "../../node_modules/undici/lib/dispatcher-base.js")
const RedirectHandler = __webpack_require__(/*! ./handler/redirect */ "../../node_modules/undici/lib/handler/redirect.js")
const {
  RequestContentLengthMismatchError,
  ResponseContentLengthMismatchError,
  InvalidArgumentError,
  RequestAbortedError,
  HeadersTimeoutError,
  HeadersOverflowError,
  SocketError,
  InformationalError,
  BodyTimeoutError,
  HTTPParserError
} = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const buildConnector = __webpack_require__(/*! ./core/connect */ "../../node_modules/undici/lib/core/connect.js")
const {
  kUrl,
  kReset,
  kServerName,
  kClient,
  kBusy,
  kParser,
  kConnect,
  kBlocking,
  kResuming,
  kRunning,
  kPending,
  kSize,
  kWriting,
  kQueue,
  kConnected,
  kConnecting,
  kNeedDrain,
  kNoRef,
  kKeepAliveDefaultTimeout,
  kHostHeader,
  kPendingIdx,
  kRunningIdx,
  kError,
  kPipelining,
  kSocket,
  kKeepAliveTimeoutValue,
  kMaxHeadersSize,
  kKeepAliveMaxTimeout,
  kKeepAliveTimeoutThreshold,
  kHeadersTimeout,
  kBodyTimeout,
  kStrictContentLength,
  kConnector,
  kMaxRedirections,
  kMaxRequests,
  kCounter,
  kClose,
  kDestroy,
  kDispatch
} = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")

const kClosedResolve = Symbol('kClosedResolve')

const channels = {}

try {
  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ "diagnostics_channel")
  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')
  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')
  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')
  channels.connected = diagnosticsChannel.channel('undici:client:connected')
} catch {
  channels.sendHeaders = { hasSubscribers: false }
  channels.beforeConnect = { hasSubscribers: false }
  channels.connectError = { hasSubscribers: false }
  channels.connected = { hasSubscribers: false }
}

class Client extends DispatcherBase {
  constructor (url, {
    maxHeaderSize,
    headersTimeout,
    socketTimeout,
    requestTimeout,
    connectTimeout,
    bodyTimeout,
    idleTimeout,
    keepAlive,
    keepAliveTimeout,
    maxKeepAliveTimeout,
    keepAliveMaxTimeout,
    keepAliveTimeoutThreshold,
    socketPath,
    pipelining,
    tls,
    strictContentLength,
    maxCachedSessions,
    maxRedirections,
    connect,
    maxRequestsPerClient
  } = {}) {
    super()

    if (keepAlive !== undefined) {
      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')
    }

    if (socketTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')
    }

    if (requestTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')
    }

    if (idleTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')
    }

    if (maxKeepAliveTimeout !== undefined) {
      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')
    }

    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
      throw new InvalidArgumentError('invalid maxHeaderSize')
    }

    if (socketPath != null && typeof socketPath !== 'string') {
      throw new InvalidArgumentError('invalid socketPath')
    }

    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
      throw new InvalidArgumentError('invalid connectTimeout')
    }

    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
      throw new InvalidArgumentError('invalid keepAliveTimeout')
    }

    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')
    }

    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')
    }

    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')
    }

    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')
    }

    if (typeof connect !== 'function') {
      connect = buildConnector({
        ...tls,
        maxCachedSessions,
        socketPath,
        timeout: connectTimeout,
        ...connect
      })
    }

    this[kUrl] = util.parseOrigin(url)
    this[kConnector] = connect
    this[kSocket] = null
    this[kPipelining] = pipelining != null ? pipelining : 1
    this[kMaxHeadersSize] = maxHeaderSize || 16384
    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout
    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout
    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold
    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]
    this[kServerName] = null
    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming
    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming
    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\r\n`
    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3
    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3
    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength
    this[kMaxRedirections] = maxRedirections
    this[kMaxRequests] = maxRequestsPerClient
    this[kClosedResolve] = null

    // kQueue is built up of 3 sections separated by
    // the kRunningIdx and kPendingIdx indices.
    // |   complete   |   running   |   pending   |
    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length
    // kRunningIdx points to the first running element.
    // kPendingIdx points to the first pending element.
    // This implements a fast queue with an amortized
    // time of O(1).

    this[kQueue] = []
    this[kRunningIdx] = 0
    this[kPendingIdx] = 0
  }

  get pipelining () {
    return this[kPipelining]
  }

  set pipelining (value) {
    this[kPipelining] = value
    resume(this, true)
  }

  get [kPending] () {
    return this[kQueue].length - this[kPendingIdx]
  }

  get [kRunning] () {
    return this[kPendingIdx] - this[kRunningIdx]
  }

  get [kSize] () {
    return this[kQueue].length - this[kRunningIdx]
  }

  get [kConnected] () {
    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed
  }

  get [kBusy] () {
    const socket = this[kSocket]
    return (
      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
      (this[kSize] >= (this[kPipelining] || 1)) ||
      this[kPending] > 0
    )
  }

  /* istanbul ignore: only used for test */
  [kConnect] (cb) {
    connect(this)
    this.once('connect', cb)
  }

  [kDispatch] (opts, handler) {
    const { maxRedirections = this[kMaxRedirections] } = opts
    if (maxRedirections) {
      handler = new RedirectHandler(this, maxRedirections, opts, handler)
    }

    const origin = opts.origin || this[kUrl].origin

    const request = new Request(origin, opts, handler)

    this[kQueue].push(request)
    if (this[kResuming]) {
      // Do nothing.
    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
      // Wait a tick in case stream/iterator is ended in the same tick.
      this[kResuming] = 1
      process.nextTick(resume, this)
    } else {
      resume(this, true)
    }

    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
      this[kNeedDrain] = 2
    }

    return this[kNeedDrain] < 2
  }

  async [kClose] () {
    return new Promise((resolve) => {
      if (!this[kSize]) {
        this.destroy(resolve)
      } else {
        this[kClosedResolve] = resolve
      }
    })
  }

  async [kDestroy] (err) {
    return new Promise((resolve) => {
      const requests = this[kQueue].splice(this[kPendingIdx])
      for (let i = 0; i < requests.length; i++) {
        const request = requests[i]
        errorRequest(this, request, err)
      }

      const callback = () => {
        if (this[kClosedResolve]) {
          this[kClosedResolve]()
          this[kClosedResolve] = null
        }
        resolve()
      }

      if (!this[kSocket]) {
        queueMicrotask(callback)
      } else {
        util.destroy(this[kSocket].on('close', callback), err)
      }

      resume(this)
    })
  }
}

const constants = __webpack_require__(/*! ./llhttp/constants */ "../../node_modules/undici/lib/llhttp/constants.js")
const EMPTY_BUF = Buffer.alloc(0)

async function lazyllhttp () {
  const llhttpWasmData = process.env.JEST_WORKER_ID ? __webpack_require__(/*! ./llhttp/llhttp.wasm.js */ "../../node_modules/undici/lib/llhttp/llhttp.wasm.js") : undefined

  let mod
  try {
    mod = await WebAssembly.compile(Buffer.from(__webpack_require__(/*! ./llhttp/llhttp_simd.wasm.js */ "../../node_modules/undici/lib/llhttp/llhttp_simd.wasm.js"), 'base64'))
  } catch (e) {
    /* istanbul ignore next */

    // We could check if the error was caused by the simd option not
    // being enabled, but the occurring of this other error
    // * https://github.com/emscripten-core/emscripten/issues/11495
    // got me to remove that check to avoid breaking Node 12.
    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || __webpack_require__(/*! ./llhttp/llhttp.wasm.js */ "../../node_modules/undici/lib/llhttp/llhttp.wasm.js"), 'base64'))
  }

  return await WebAssembly.instantiate(mod, {
    env: {
      /* eslint-disable camelcase */

      wasm_on_url: (p, at, len) => {
        /* istanbul ignore next */
        return 0
      },
      wasm_on_status: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr
        const end = start + len
        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0
      },
      wasm_on_message_begin: (p) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onMessageBegin() || 0
      },
      wasm_on_header_field: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr
        const end = start + len
        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0
      },
      wasm_on_header_value: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr
        const end = start + len
        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0
      },
      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0
      },
      wasm_on_body: (p, at, len) => {
        assert.strictEqual(currentParser.ptr, p)
        const start = at - currentBufferPtr
        const end = start + len
        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0
      },
      wasm_on_message_complete: (p) => {
        assert.strictEqual(currentParser.ptr, p)
        return currentParser.onMessageComplete() || 0
      }

      /* eslint-enable camelcase */
    }
  })
}

let llhttpInstance = null
let llhttpPromise = lazyllhttp()
  .catch(() => {
  })

let currentParser = null
let currentBufferRef = null
let currentBufferSize = 0
let currentBufferPtr = null

const TIMEOUT_HEADERS = 1
const TIMEOUT_BODY = 2
const TIMEOUT_IDLE = 3

class Parser {
  constructor (client, socket, { exports }) {
    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)

    this.llhttp = exports
    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)
    this.client = client
    this.socket = socket
    this.timeout = null
    this.timeoutValue = null
    this.timeoutType = null
    this.statusCode = null
    this.statusText = ''
    this.upgrade = false
    this.headers = []
    this.headersSize = 0
    this.headersMaxSize = client[kMaxHeadersSize]
    this.shouldKeepAlive = false
    this.paused = false
    this.resume = this.resume.bind(this)

    this.bytesRead = 0

    this.keepAlive = ''
    this.contentLength = ''
  }

  setTimeout (value, type) {
    this.timeoutType = type
    if (value !== this.timeoutValue) {
      clearTimeout(this.timeout)
      if (value) {
        this.timeout = setTimeout(onParserTimeout, value, this)
        // istanbul ignore else: only for jest
        if (this.timeout.unref) {
          this.timeout.unref()
        }
      } else {
        this.timeout = null
      }
      this.timeoutValue = value
    } else if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }
  }

  resume () {
    if (this.socket.destroyed || !this.paused) {
      return
    }

    assert(this.ptr != null)
    assert(currentParser == null)

    this.llhttp.llhttp_resume(this.ptr)

    assert(this.timeoutType === TIMEOUT_BODY)
    if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    this.paused = false
    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.
    this.readMore()
  }

  readMore () {
    while (!this.paused && this.ptr) {
      const chunk = this.socket.read()
      if (chunk === null) {
        break
      }
      this.execute(chunk)
    }
  }

  execute (data) {
    assert(this.ptr != null)
    assert(currentParser == null)
    assert(!this.paused)

    const { socket, llhttp } = this

    if (data.length > currentBufferSize) {
      if (currentBufferPtr) {
        llhttp.free(currentBufferPtr)
      }
      currentBufferSize = Math.ceil(data.length / 4096) * 4096
      currentBufferPtr = llhttp.malloc(currentBufferSize)
    }

    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)

    // Call `execute` on the wasm parser.
    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,
    // and finally the length of bytes to parse.
    // The return value is an error code or `constants.ERROR.OK`.
    try {
      let ret

      try {
        currentBufferRef = data
        currentParser = this
        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)
        /* eslint-disable-next-line no-useless-catch */
      } catch (err) {
        /* istanbul ignore next: difficult to make a test case for */
        throw err
      } finally {
        currentParser = null
        currentBufferRef = null
      }

      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr

      if (ret === constants.ERROR.PAUSED_UPGRADE) {
        this.onUpgrade(data.slice(offset))
      } else if (ret === constants.ERROR.PAUSED) {
        this.paused = true
        socket.unshift(data.slice(offset))
      } else if (ret !== constants.ERROR.OK) {
        const ptr = llhttp.llhttp_get_error_reason(this.ptr)
        let message = ''
        /* istanbul ignore else: difficult to make a test case for */
        if (ptr) {
          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)
          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()
        }
        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))
      }
    } catch (err) {
      util.destroy(socket, err)
    }
  }

  finish () {
    try {
      try {
        currentParser = this
      } finally {
        currentParser = null
      }
    } catch (err) {
      /* istanbul ignore next: difficult to make a test case for */
      util.destroy(this.socket, err)
    }
  }

  destroy () {
    assert(this.ptr != null)
    assert(currentParser == null)

    this.llhttp.llhttp_free(this.ptr)
    this.ptr = null

    clearTimeout(this.timeout)
    this.timeout = null
    this.timeoutValue = null
    this.timeoutType = null

    this.paused = false
  }

  onStatus (buf) {
    this.statusText = buf.toString()
  }

  onMessageBegin () {
    const { socket, client } = this

    /* istanbul ignore next: difficult to make a test case for */
    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]
    if (!request) {
      return -1
    }
  }

  onHeaderField (buf) {
    const len = this.headers.length

    if ((len & 1) === 0) {
      this.headers.push(buf)
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
    }

    this.trackHeader(buf.length)
  }

  onHeaderValue (buf) {
    let len = this.headers.length

    if ((len & 1) === 1) {
      this.headers.push(buf)
      len += 1
    } else {
      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])
    }

    const key = this.headers[len - 2]
    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {
      this.keepAlive += buf.toString()
    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {
      this.contentLength += buf.toString()
    }

    this.trackHeader(buf.length)
  }

  trackHeader (len) {
    this.headersSize += len
    if (this.headersSize >= this.headersMaxSize) {
      util.destroy(this.socket, new HeadersOverflowError())
    }
  }

  onUpgrade (head) {
    const { upgrade, client, socket, headers, statusCode } = this

    assert(upgrade)

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert(!socket.destroyed)
    assert(socket === client[kSocket])
    assert(!this.paused)
    assert(request.upgrade || request.method === 'CONNECT')

    this.statusCode = null
    this.statusText = ''
    this.shouldKeepAlive = null

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    socket.unshift(head)

    socket[kParser].destroy()
    socket[kParser] = null

    socket[kClient] = null
    socket[kError] = null
    socket
      .removeListener('error', onSocketError)
      .removeListener('readable', onSocketReadable)
      .removeListener('end', onSocketEnd)
      .removeListener('close', onSocketClose)

    client[kSocket] = null
    client[kQueue][client[kRunningIdx]++] = null
    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))

    try {
      request.onUpgrade(statusCode, headers, socket)
    } catch (err) {
      util.destroy(socket, err)
    }

    resume(client)
  }

  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {
    const { client, socket, headers, statusText } = this

    /* istanbul ignore next: difficult to make a test case for */
    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]

    /* istanbul ignore next: difficult to make a test case for */
    if (!request) {
      return -1
    }

    assert(!this.upgrade)
    assert(this.statusCode < 200)

    if (statusCode === 100) {
      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))
      return -1
    }

    /* this can only happen if server is misbehaving */
    if (upgrade && !request.upgrade) {
      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))
      return -1
    }

    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)

    this.statusCode = statusCode
    this.shouldKeepAlive = shouldKeepAlive

    if (this.statusCode >= 200) {
      const bodyTimeout = request.bodyTimeout != null
        ? request.bodyTimeout
        : client[kBodyTimeout]
      this.setTimeout(bodyTimeout, TIMEOUT_BODY)
    } else if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    if (request.method === 'CONNECT') {
      assert(client[kRunning] === 1)
      this.upgrade = true
      return 2
    }

    if (upgrade) {
      assert(client[kRunning] === 1)
      this.upgrade = true
      return 2
    }

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    if (shouldKeepAlive && client[kPipelining]) {
      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null

      if (keepAliveTimeout != null) {
        const timeout = Math.min(
          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
          client[kKeepAliveMaxTimeout]
        )
        if (timeout <= 0) {
          socket[kReset] = true
        } else {
          client[kKeepAliveTimeoutValue] = timeout
        }
      } else {
        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]
      }
    } else {
      // Stop more requests from being dispatched.
      socket[kReset] = true
    }

    let pause
    try {
      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false
    } catch (err) {
      util.destroy(socket, err)
      return -1
    }

    if (request.method === 'HEAD') {
      assert(socket[kReset])
      return 1
    }

    if (statusCode < 200) {
      return 1
    }

    if (socket[kBlocking]) {
      socket[kBlocking] = false
      resume(client)
    }

    return pause ? constants.ERROR.PAUSED : 0
  }

  onBody (buf) {
    const { client, socket, statusCode } = this

    if (socket.destroyed) {
      return -1
    }

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)
    if (this.timeout) {
      // istanbul ignore else: only for jest
      if (this.timeout.refresh) {
        this.timeout.refresh()
      }
    }

    assert(statusCode >= 200)

    this.bytesRead += buf.length

    try {
      if (request.onData(buf) === false) {
        return constants.ERROR.PAUSED
      }
    } catch (err) {
      util.destroy(socket, err)
      return -1
    }
  }

  onMessageComplete () {
    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this

    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
      return -1
    }

    if (upgrade) {
      return
    }

    const request = client[kQueue][client[kRunningIdx]]
    assert(request)

    assert(statusCode >= 100)

    this.statusCode = null
    this.statusText = ''
    this.bytesRead = 0
    this.contentLength = ''
    this.keepAlive = ''

    assert(this.headers.length % 2 === 0)
    this.headers = []
    this.headersSize = 0

    if (statusCode < 200) {
      return
    }

    /* istanbul ignore next: should be handled by llhttp? */
    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
      util.destroy(socket, new ResponseContentLengthMismatchError())
      return -1
    }

    try {
      request.onComplete(headers)
    } catch (err) {
      errorRequest(client, request, err)
    }

    client[kQueue][client[kRunningIdx]++] = null

    if (socket[kWriting]) {
      assert.strictEqual(client[kRunning], 0)
      // Response completed before request.
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (!shouldKeepAlive) {
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (socket[kReset] && client[kRunning] === 0) {
      // Destroy socket once all requests have completed.
      // The request at the tail of the pipeline is the one
      // that requested reset and no further requests should
      // have been queued since then.
      util.destroy(socket, new InformationalError('reset'))
      return constants.ERROR.PAUSED
    } else if (client[kPipelining] === 1) {
      // We must wait a full event loop cycle to reuse this socket to make sure
      // that non-spec compliant servers are not closing the connection even if they
      // said they won't.
      setImmediate(resume, client)
    } else {
      resume(client)
    }
  }
}

function onParserTimeout (parser) {
  const { socket, timeoutType, client } = parser

  /* istanbul ignore else */
  if (timeoutType === TIMEOUT_HEADERS) {
    assert(!parser.paused, 'cannot be paused while waiting for headers')
    util.destroy(socket, new HeadersTimeoutError())
  } else if (timeoutType === TIMEOUT_BODY) {
    if (!parser.paused) {
      util.destroy(socket, new BodyTimeoutError())
    }
  } else if (timeoutType === TIMEOUT_IDLE) {
    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])
    util.destroy(socket, new InformationalError('socket idle timeout'))
  }
}

function onSocketReadable () {
  const { [kParser]: parser } = this
  parser.readMore()
}

function onSocketError (err) {
  const { [kParser]: parser } = this

  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')

  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded
  // to the user.
  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
    // We treat all incoming data so for as a valid response.
    parser.finish()
    return
  }

  this[kError] = err

  onError(this[kClient], err)
}

function onError (client, err) {
  if (
    client[kRunning] === 0 &&
    err.code !== 'UND_ERR_INFO' &&
    err.code !== 'UND_ERR_SOCKET'
  ) {
    // Error is not caused by running request and not a recoverable
    // socket error.

    assert(client[kPendingIdx] === client[kRunningIdx])

    const requests = client[kQueue].splice(client[kRunningIdx])
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i]
      errorRequest(client, request, err)
    }
    assert(client[kSize] === 0)
  }
}

function onSocketEnd () {
  const { [kParser]: parser } = this

  if (parser.statusCode && !parser.shouldKeepAlive) {
    // We treat all incoming data so far as a valid response.
    parser.finish()
    return
  }

  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))
}

function onSocketClose () {
  const { [kClient]: client } = this

  this[kParser].destroy()
  this[kParser] = null

  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))

  client[kSocket] = null

  if (client.destroyed) {
    assert(client[kPending] === 0)

    // Fail entire queue.
    const requests = client[kQueue].splice(client[kRunningIdx])
    for (let i = 0; i < requests.length; i++) {
      const request = requests[i]
      errorRequest(client, request, err)
    }
  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {
    // Fail head of pipeline.
    const request = client[kQueue][client[kRunningIdx]]
    client[kQueue][client[kRunningIdx]++] = null

    errorRequest(client, request, err)
  }

  client[kPendingIdx] = client[kRunningIdx]

  assert(client[kRunning] === 0)

  client.emit('disconnect', client[kUrl], [client], err)

  resume(client)
}

async function connect (client) {
  assert(!client[kConnecting])
  assert(!client[kSocket])

  let { host, hostname, protocol, port } = client[kUrl]

  // Resolve ipv6
  if (hostname[0] === '[') {
    const idx = hostname.indexOf(']')

    assert(idx !== -1)
    const ip = hostname.substr(1, idx - 1)

    assert(net.isIP(ip))
    hostname = ip
  }

  client[kConnecting] = true

  if (channels.beforeConnect.hasSubscribers) {
    channels.beforeConnect.publish({
      connectParams: {
        host,
        hostname,
        protocol,
        port,
        servername: client[kServerName]
      },
      connector: client[kConnector]
    })
  }

  try {
    const socket = await new Promise((resolve, reject) => {
      client[kConnector]({
        host,
        hostname,
        protocol,
        port,
        servername: client[kServerName]
      }, (err, socket) => {
        if (err) {
          reject(err)
        } else {
          resolve(socket)
        }
      })
    })

    if (!llhttpInstance) {
      llhttpInstance = await llhttpPromise
      llhttpPromise = null
    }

    client[kConnecting] = false

    assert(socket)

    client[kSocket] = socket

    socket[kNoRef] = false
    socket[kWriting] = false
    socket[kReset] = false
    socket[kBlocking] = false
    socket[kError] = null
    socket[kParser] = new Parser(client, socket, llhttpInstance)
    socket[kClient] = client
    socket[kCounter] = 0
    socket[kMaxRequests] = client[kMaxRequests]
    socket
      .on('error', onSocketError)
      .on('readable', onSocketReadable)
      .on('end', onSocketEnd)
      .on('close', onSocketClose)

    if (channels.connected.hasSubscribers) {
      channels.connected.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName]
        },
        connector: client[kConnector],
        socket
      })
    }
    client.emit('connect', client[kUrl], [client])
  } catch (err) {
    client[kConnecting] = false

    if (channels.connectError.hasSubscribers) {
      channels.connectError.publish({
        connectParams: {
          host,
          hostname,
          protocol,
          port,
          servername: client[kServerName]
        },
        connector: client[kConnector],
        error: err
      })
    }

    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
      assert(client[kRunning] === 0)
      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
        const request = client[kQueue][client[kPendingIdx]++]
        errorRequest(client, request, err)
      }
    } else {
      onError(client, err)
    }

    client.emit('connectionError', client[kUrl], [client], err)
  }

  resume(client)
}

function emitDrain (client) {
  client[kNeedDrain] = 0
  client.emit('drain', client[kUrl], [client])
}

function resume (client, sync) {
  if (client[kResuming] === 2) {
    return
  }

  client[kResuming] = 2

  _resume(client, sync)
  client[kResuming] = 0

  if (client[kRunningIdx] > 256) {
    client[kQueue].splice(0, client[kRunningIdx])
    client[kPendingIdx] -= client[kRunningIdx]
    client[kRunningIdx] = 0
  }
}

function _resume (client, sync) {
  while (true) {
    if (client.destroyed) {
      assert(client[kPending] === 0)
      return
    }

    if (client.closed && !client[kSize]) {
      client.destroy()
      return
    }

    const socket = client[kSocket]

    if (socket) {
      if (client[kSize] === 0) {
        if (!socket[kNoRef] && socket.unref) {
          socket.unref()
          socket[kNoRef] = true
        }
      } else if (socket[kNoRef] && socket.ref) {
        socket.ref()
        socket[kNoRef] = false
      }

      if (client[kSize] === 0) {
        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)
        }
      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
          const request = client[kQueue][client[kRunningIdx]]
          const headersTimeout = request.headersTimeout != null
            ? request.headersTimeout
            : client[kHeadersTimeout]
          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)
        }
      }
    }

    if (client[kBusy]) {
      client[kNeedDrain] = 2
    } else if (client[kNeedDrain] === 2) {
      if (sync) {
        client[kNeedDrain] = 1
        process.nextTick(emitDrain, client)
      } else {
        emitDrain(client)
      }
      continue
    }

    if (client[kPending] === 0) {
      return
    }

    if (client[kRunning] >= (client[kPipelining] || 1)) {
      return
    }

    const request = client[kQueue][client[kPendingIdx]]

    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {
      if (client[kRunning] > 0) {
        return
      }

      client[kServerName] = request.servername

      if (socket && socket.servername !== request.servername) {
        util.destroy(socket, new InformationalError('servername changed'))
        return
      }
    }

    if (client[kConnecting]) {
      return
    }

    if (!socket) {
      connect(client)
      continue
    }

    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
      return
    }

    if (client[kRunning] > 0 && !request.idempotent) {
      // Non-idempotent request cannot be retried.
      // Ensure that no other requests are inflight and
      // could cause failure.
      return
    }

    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {
      // Don't dispatch an upgrade until all preceding requests have completed.
      // A misbehaving server might upgrade the connection before all pipelined
      // request has completed.
      return
    }

    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {
      request.body
        .on('data', /* istanbul ignore next */ function () {
          /* istanbul ignore next */
          assert(false)
        })
        .on('error', function (err) {
          errorRequest(client, request, err)
        })
        .on('end', function () {
          util.destroy(this)
        })

      request.body = null
    }

    if (client[kRunning] > 0 &&
      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
      // Request with stream or iterator body can error while other requests
      // are inflight and indirectly error those as well.
      // Ensure this doesn't happen by waiting for inflight
      // to complete before dispatching.

      // Request with stream or iterator body cannot be retried.
      // Ensure that no other requests are inflight and
      // could cause failure.
      return
    }

    if (!request.aborted && write(client, request)) {
      client[kPendingIdx]++
    } else {
      client[kQueue].splice(client[kPendingIdx], 1)
    }
  }
}

function write (client, request) {
  const { body, method, path, host, upgrade, headers, blocking } = request

  // https://tools.ietf.org/html/rfc7231#section-4.3.1
  // https://tools.ietf.org/html/rfc7231#section-4.3.2
  // https://tools.ietf.org/html/rfc7231#section-4.3.5

  // Sending a payload body on a request that does not
  // expect it can cause undefined behavior on some
  // servers and corrupt connection state. Do not
  // re-use the connection for further requests.

  const expectsPayload = (
    method === 'PUT' ||
    method === 'POST' ||
    method === 'PATCH'
  )

  if (body && typeof body.read === 'function') {
    // Try to read EOF in order to get length.
    body.read(0)
  }

  let contentLength = util.bodyLength(body)

  if (contentLength === null) {
    contentLength = request.contentLength
  }

  if (contentLength === 0 && !expectsPayload) {
    // https://tools.ietf.org/html/rfc7230#section-3.3.2
    // A user agent SHOULD NOT send a Content-Length header field when
    // the request message does not contain a payload body and the method
    // semantics do not anticipate such a body.

    contentLength = null
  }

  if (request.contentLength !== null && request.contentLength !== contentLength) {
    if (client[kStrictContentLength]) {
      errorRequest(client, request, new RequestContentLengthMismatchError())
      return false
    }

    process.emitWarning(new RequestContentLengthMismatchError())
  }

  const socket = client[kSocket]

  try {
    request.onConnect((err) => {
      if (request.aborted || request.completed) {
        return
      }

      errorRequest(client, request, err || new RequestAbortedError())

      util.destroy(socket, new InformationalError('aborted'))
    })
  } catch (err) {
    errorRequest(client, request, err)
  }

  if (request.aborted) {
    return false
  }

  if (method === 'HEAD') {
    // https://github.com/mcollina/undici/issues/258

    // Close after a HEAD request to interop with misbehaving servers
    // that may send a body in the response.

    socket[kReset] = true
  }

  if (upgrade || method === 'CONNECT') {
    // On CONNECT or upgrade, block pipeline from dispatching further
    // requests on this connection.

    socket[kReset] = true
  }

  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
    socket[kReset] = true
  }

  if (blocking) {
    socket[kBlocking] = true
  }

  let header = `${method} ${path} HTTP/1.1\r\n`

  if (typeof host === 'string') {
    header += `host: ${host}\r\n`
  } else {
    header += client[kHostHeader]
  }

  if (upgrade) {
    header += `connection: upgrade\r\nupgrade: ${upgrade}\r\n`
  } else if (client[kPipelining]) {
    header += 'connection: keep-alive\r\n'
  } else {
    header += 'connection: close\r\n'
  }

  if (headers) {
    header += headers
  }

  if (channels.sendHeaders.hasSubscribers) {
    channels.sendHeaders.publish({ request, headers: header, socket })
  }

  /* istanbul ignore else: assertion */
  if (!body) {
    if (contentLength === 0) {
      socket.write(`${header}content-length: 0\r\n\r\n`, 'ascii')
    } else {
      assert(contentLength === null, 'no body must not have content length')
      socket.write(`${header}\r\n`, 'ascii')
    }
    request.onRequestSent()
  } else if (util.isBuffer(body)) {
    assert(contentLength === body.byteLength, 'buffer body must have content length')

    socket.cork()
    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'ascii')
    socket.write(body)
    socket.uncork()
    request.onBodySent(body)
    request.onRequestSent()
    if (!expectsPayload) {
      socket[kReset] = true
    }
  } else if (util.isBlobLike(body)) {
    if (typeof body.stream === 'function') {
      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })
    } else {
      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })
    }
  } else if (util.isStream(body)) {
    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })
  } else if (util.isIterable(body)) {
    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })
  } else {
    assert(false)
  }

  return true
}

function writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')

  let finished = false

  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })

  const onData = function (chunk) {
    try {
      assert(!finished)

      if (!writer.write(chunk) && this.pause) {
        this.pause()
      }
    } catch (err) {
      util.destroy(this, err)
    }
  }
  const onDrain = function () {
    assert(!finished)

    if (body.resume) {
      body.resume()
    }
  }
  const onAbort = function () {
    onFinished(new RequestAbortedError())
  }
  const onFinished = function (err) {
    if (finished) {
      return
    }

    finished = true

    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))

    socket
      .off('drain', onDrain)
      .off('error', onFinished)

    body
      .removeListener('data', onData)
      .removeListener('end', onFinished)
      .removeListener('error', onFinished)
      .removeListener('close', onAbort)

    if (!err) {
      try {
        writer.end()
      } catch (er) {
        err = er
      }
    }

    writer.destroy(err)

    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
      util.destroy(body, err)
    } else {
      util.destroy(body)
    }
  }

  body
    .on('data', onData)
    .on('end', onFinished)
    .on('error', onFinished)
    .on('close', onAbort)

  if (body.resume) {
    body.resume()
  }

  socket
    .on('drain', onDrain)
    .on('error', onFinished)
}

async function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength === body.size, 'blob body must have content length')

  try {
    if (contentLength != null && contentLength !== body.size) {
      throw new RequestContentLengthMismatchError()
    }

    const buffer = Buffer.from(await body.arrayBuffer())

    socket.cork()
    socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'ascii')
    socket.write(buffer)
    socket.uncork()

    request.onBodySent(buffer)
    request.onRequestSent()

    if (!expectsPayload) {
      socket[kReset] = true
    }

    resume(client)
  } catch (err) {
    util.destroy(socket, err)
  }
}

async function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {
  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')

  let callback = null
  function onDrain () {
    if (callback) {
      const cb = callback
      callback = null
      cb()
    }
  }

  const waitForDrain = () => new Promise((resolve, reject) => {
    assert(callback === null)

    if (socket[kError]) {
      reject(socket[kError])
    } else {
      callback = resolve
    }
  })

  socket
    .on('close', onDrain)
    .on('drain', onDrain)

  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })
  try {
    // It's up to the user to somehow abort the async iterable.
    for await (const chunk of body) {
      if (socket[kError]) {
        throw socket[kError]
      }

      if (!writer.write(chunk)) {
        await waitForDrain()
      }
    }

    writer.end()
  } catch (err) {
    writer.destroy(err)
  } finally {
    socket
      .off('close', onDrain)
      .off('drain', onDrain)
  }
}

class AsyncWriter {
  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {
    this.socket = socket
    this.request = request
    this.contentLength = contentLength
    this.client = client
    this.bytesWritten = 0
    this.expectsPayload = expectsPayload
    this.header = header

    socket[kWriting] = true
  }

  write (chunk) {
    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this

    if (socket[kError]) {
      throw socket[kError]
    }

    if (socket.destroyed) {
      return false
    }

    const len = Buffer.byteLength(chunk)
    if (!len) {
      return true
    }

    // We should defer writing chunks.
    if (contentLength !== null && bytesWritten + len > contentLength) {
      if (client[kStrictContentLength]) {
        throw new RequestContentLengthMismatchError()
      }

      process.emitWarning(new RequestContentLengthMismatchError())
    }

    if (bytesWritten === 0) {
      if (!expectsPayload) {
        socket[kReset] = true
      }

      if (contentLength === null) {
        socket.write(`${header}transfer-encoding: chunked\r\n`, 'ascii')
      } else {
        socket.write(`${header}content-length: ${contentLength}\r\n\r\n`, 'ascii')
      }
    }

    if (contentLength === null) {
      socket.write(`\r\n${len.toString(16)}\r\n`, 'ascii')
    }

    this.bytesWritten += len

    const ret = socket.write(chunk)
    request.onBodySent(chunk)
    return ret
  }

  end () {
    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this
    request.onRequestSent()

    socket[kWriting] = false

    if (socket[kError]) {
      throw socket[kError]
    }

    if (socket.destroyed) {
      return
    }

    if (bytesWritten === 0) {
      if (expectsPayload) {
        // https://tools.ietf.org/html/rfc7230#section-3.3.2
        // A user agent SHOULD send a Content-Length in a request message when
        // no Transfer-Encoding is sent and the request method defines a meaning
        // for an enclosed payload body.

        socket.write(`${header}content-length: 0\r\n\r\n`, 'ascii')
      } else {
        socket.write(`${header}\r\n`, 'ascii')
      }
    } else if (contentLength === null) {
      socket.write('\r\n0\r\n\r\n', 'ascii')
    }

    if (contentLength !== null && bytesWritten !== contentLength) {
      if (client[kStrictContentLength]) {
        throw new RequestContentLengthMismatchError()
      } else {
        process.emitWarning(new RequestContentLengthMismatchError())
      }
    }

    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
      // istanbul ignore else: only for jest
      if (socket[kParser].timeout.refresh) {
        socket[kParser].timeout.refresh()
      }
    }

    resume(client)
  }

  destroy (err) {
    const { socket, client } = this

    socket[kWriting] = false

    if (err) {
      assert(client[kRunning] <= 1, 'pipeline should only contain this request')
      util.destroy(socket, err)
    }
  }
}

function errorRequest (client, request, err) {
  try {
    request.onError(err)
    assert(request.aborted)
  } catch (err) {
    client.emit('error', err)
  }
}

module.exports = Client


/***/ }),

/***/ "../../node_modules/undici/lib/compat/dispatcher-weakref.js":
/*!******************************************************************!*\
  !*** ../../node_modules/undici/lib/compat/dispatcher-weakref.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore file: only for Node 12 */

const { kConnected, kSize } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")

class CompatWeakRef {
  constructor (value) {
    this.value = value
  }

  deref () {
    return this.value[kConnected] === 0 && this.value[kSize] === 0
      ? undefined
      : this.value
  }
}

class CompatFinalizer {
  constructor (finalizer) {
    this.finalizer = finalizer
  }

  register (dispatcher, key) {
    dispatcher.on('disconnect', () => {
      if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
        this.finalizer(key)
      }
    })
  }
}

module.exports = function () {
  return {
    WeakRef: global.WeakRef || CompatWeakRef,
    FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
  }
}


/***/ }),

/***/ "../../node_modules/undici/lib/core/connect.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/connect.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const net = __webpack_require__(/*! net */ "net")
const assert = __webpack_require__(/*! assert */ "assert")
const util = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/core/util.js")
const { InvalidArgumentError, ConnectTimeoutError } = __webpack_require__(/*! ./errors */ "../../node_modules/undici/lib/core/errors.js")
let tls // include tls conditionally since it is not always available

// TODO: session re-use does not wait for the first
// connection to resolve the session and might therefore
// resolve the same servername multiple times even when
// re-use is enabled.

function buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {
  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')
  }

  const options = { path: socketPath, ...opts }
  const sessionCache = new Map()
  timeout = timeout == null ? 10e3 : timeout
  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions

  return function connect ({ hostname, host, protocol, port, servername, httpSocket }, callback) {
    let socket
    if (protocol === 'https:') {
      if (!tls) {
        tls = __webpack_require__(/*! tls */ "tls")
      }
      servername = servername || options.servername || util.getServerName(host) || null

      const sessionKey = servername || hostname
      const session = sessionCache.get(sessionKey) || null

      assert(sessionKey)

      socket = tls.connect({
        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...
        ...options,
        servername,
        session,
        socket: httpSocket, // upgrade socket connection
        port: port || 443,
        host: hostname
      })

      socket
        .on('session', function (session) {
          // cache is disabled
          if (maxCachedSessions === 0) {
            return
          }

          if (sessionCache.size >= maxCachedSessions) {
            // remove the oldest session
            const { value: oldestKey } = sessionCache.keys().next()
            sessionCache.delete(oldestKey)
          }

          sessionCache.set(sessionKey, session)
        })
        .on('error', function (err) {
          if (sessionKey && err.code !== 'UND_ERR_INFO') {
            // TODO (fix): Only delete for session related errors.
            sessionCache.delete(sessionKey)
          }
        })
    } else {
      assert(!httpSocket, 'httpSocket can only be sent on TLS update')
      socket = net.connect({
        highWaterMark: 64 * 1024, // Same as nodejs fs streams.
        ...options,
        port: port || 80,
        host: hostname
      })
    }

    const timeoutId = timeout
      ? setTimeout(onConnectTimeout, timeout, socket)
      : null

    socket
      .setNoDelay(true)
      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
        clearTimeout(timeoutId)

        if (callback) {
          const cb = callback
          callback = null
          cb(null, this)
        }
      })
      .on('error', function (err) {
        clearTimeout(timeoutId)

        if (callback) {
          const cb = callback
          callback = null
          cb(err)
        }
      })

    return socket
  }
}

function onConnectTimeout (socket) {
  util.destroy(socket, new ConnectTimeoutError())
}

module.exports = buildConnector


/***/ }),

/***/ "../../node_modules/undici/lib/core/errors.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/core/errors.js ***!
  \****************************************************/
/***/ ((module) => {

"use strict";


class UndiciError extends Error {
  constructor (message) {
    super(message)
    this.name = 'UndiciError'
    this.code = 'UND_ERR'
  }
}

class ConnectTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, ConnectTimeoutError)
    this.name = 'ConnectTimeoutError'
    this.message = message || 'Connect Timeout Error'
    this.code = 'UND_ERR_CONNECT_TIMEOUT'
  }
}

class HeadersTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, HeadersTimeoutError)
    this.name = 'HeadersTimeoutError'
    this.message = message || 'Headers Timeout Error'
    this.code = 'UND_ERR_HEADERS_TIMEOUT'
  }
}

class HeadersOverflowError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, HeadersOverflowError)
    this.name = 'HeadersOverflowError'
    this.message = message || 'Headers Overflow Error'
    this.code = 'UND_ERR_HEADERS_OVERFLOW'
  }
}

class BodyTimeoutError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, BodyTimeoutError)
    this.name = 'BodyTimeoutError'
    this.message = message || 'Body Timeout Error'
    this.code = 'UND_ERR_BODY_TIMEOUT'
  }
}

class ResponseStatusCodeError extends UndiciError {
  constructor (message, statusCode, headers, body) {
    super(message)
    Error.captureStackTrace(this, ResponseStatusCodeError)
    this.name = 'ResponseStatusCodeError'
    this.message = message || 'Response Status Code Error'
    this.code = 'UND_ERR_RESPONSE_STATUS_CODE'
    this.body = body
    this.status = statusCode
    this.statusCode = statusCode
    this.headers = headers
  }
}

class InvalidArgumentError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, InvalidArgumentError)
    this.name = 'InvalidArgumentError'
    this.message = message || 'Invalid Argument Error'
    this.code = 'UND_ERR_INVALID_ARG'
  }
}

class InvalidReturnValueError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, InvalidReturnValueError)
    this.name = 'InvalidReturnValueError'
    this.message = message || 'Invalid Return Value Error'
    this.code = 'UND_ERR_INVALID_RETURN_VALUE'
  }
}

class RequestAbortedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, RequestAbortedError)
    this.name = 'AbortError'
    this.message = message || 'Request aborted'
    this.code = 'UND_ERR_ABORTED'
  }
}

class InformationalError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, InformationalError)
    this.name = 'InformationalError'
    this.message = message || 'Request information'
    this.code = 'UND_ERR_INFO'
  }
}

class RequestContentLengthMismatchError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, RequestContentLengthMismatchError)
    this.name = 'RequestContentLengthMismatchError'
    this.message = message || 'Request body length does not match content-length header'
    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'
  }
}

class ResponseContentLengthMismatchError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, ResponseContentLengthMismatchError)
    this.name = 'ResponseContentLengthMismatchError'
    this.message = message || 'Response body length does not match content-length header'
    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'
  }
}

class ClientDestroyedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, ClientDestroyedError)
    this.name = 'ClientDestroyedError'
    this.message = message || 'The client is destroyed'
    this.code = 'UND_ERR_DESTROYED'
  }
}

class ClientClosedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, ClientClosedError)
    this.name = 'ClientClosedError'
    this.message = message || 'The client is closed'
    this.code = 'UND_ERR_CLOSED'
  }
}

class SocketError extends UndiciError {
  constructor (message, socket) {
    super(message)
    Error.captureStackTrace(this, SocketError)
    this.name = 'SocketError'
    this.message = message || 'Socket error'
    this.code = 'UND_ERR_SOCKET'
    this.socket = socket
  }
}

class NotSupportedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, NotSupportedError)
    this.name = 'NotSupportedError'
    this.message = message || 'Not supported error'
    this.code = 'UND_ERR_NOT_SUPPORTED'
  }
}

class BalancedPoolMissingUpstreamError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, NotSupportedError)
    this.name = 'MissingUpstreamError'
    this.message = message || 'No upstream has been added to the BalancedPool'
    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'
  }
}

class HTTPParserError extends Error {
  constructor (message, code, data) {
    super(message)
    Error.captureStackTrace(this, HTTPParserError)
    this.name = 'HTTPParserError'
    this.code = code ? `HPE_${code}` : undefined
    this.data = data ? data.toString() : undefined
  }
}

module.exports = {
  HTTPParserError,
  UndiciError,
  HeadersTimeoutError,
  HeadersOverflowError,
  BodyTimeoutError,
  RequestContentLengthMismatchError,
  ConnectTimeoutError,
  ResponseStatusCodeError,
  InvalidArgumentError,
  InvalidReturnValueError,
  RequestAbortedError,
  ClientDestroyedError,
  ClientClosedError,
  InformationalError,
  SocketError,
  NotSupportedError,
  ResponseContentLengthMismatchError,
  BalancedPoolMissingUpstreamError
}


/***/ }),

/***/ "../../node_modules/undici/lib/core/request.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/request.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  InvalidArgumentError,
  NotSupportedError
} = __webpack_require__(/*! ./errors */ "../../node_modules/undici/lib/core/errors.js")
const assert = __webpack_require__(/*! assert */ "assert")
const util = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/core/util.js")

// tokenRegExp and headerCharRegex have been lifted from
// https://github.com/nodejs/node/blob/main/lib/_http_common.js

/**
 * Verifies that the given val is a valid HTTP token
 * per the rules defined in RFC 7230
 * See https://tools.ietf.org/html/rfc7230#section-3.2.6
 */
const tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/

/**
 * Matches if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 */
const headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/

// Verifies that a given path is valid does not contain control chars \x00 to \x20
const invalidPathRegex = /[^\u0021-\u00ff]/

const kHandler = Symbol('handler')

const channels = {}

let extractBody

const nodeVersion = process.versions.node.split('.')
const nodeMajor = Number(nodeVersion[0])
const nodeMinor = Number(nodeVersion[1])

try {
  const diagnosticsChannel = __webpack_require__(/*! diagnostics_channel */ "diagnostics_channel")
  channels.create = diagnosticsChannel.channel('undici:request:create')
  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent')
  channels.headers = diagnosticsChannel.channel('undici:request:headers')
  channels.trailers = diagnosticsChannel.channel('undici:request:trailers')
  channels.error = diagnosticsChannel.channel('undici:request:error')
} catch {
  channels.create = { hasSubscribers: false }
  channels.bodySent = { hasSubscribers: false }
  channels.headers = { hasSubscribers: false }
  channels.trailers = { hasSubscribers: false }
  channels.error = { hasSubscribers: false }
}

class Request {
  constructor (origin, {
    path,
    method,
    body,
    headers,
    query,
    idempotent,
    blocking,
    upgrade,
    headersTimeout,
    bodyTimeout,
    throwOnError
  }, handler) {
    if (typeof path !== 'string') {
      throw new InvalidArgumentError('path must be a string')
    } else if (
      path[0] !== '/' &&
      !(path.startsWith('http://') || path.startsWith('https://')) &&
      method !== 'CONNECT'
    ) {
      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')
    } else if (invalidPathRegex.exec(path) !== null) {
      throw new InvalidArgumentError('invalid request path')
    }

    if (typeof method !== 'string') {
      throw new InvalidArgumentError('method must be a string')
    } else if (tokenRegExp.exec(method) === null) {
      throw new InvalidArgumentError('invalid request method')
    }

    if (upgrade && typeof upgrade !== 'string') {
      throw new InvalidArgumentError('upgrade must be a string')
    }

    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
      throw new InvalidArgumentError('invalid headersTimeout')
    }

    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
      throw new InvalidArgumentError('invalid bodyTimeout')
    }

    this.headersTimeout = headersTimeout

    this.bodyTimeout = bodyTimeout

    this.throwOnError = throwOnError === true

    this.method = method

    if (body == null) {
      this.body = null
    } else if (util.isStream(body)) {
      this.body = body
    } else if (util.isBuffer(body)) {
      this.body = body.byteLength ? body : null
    } else if (ArrayBuffer.isView(body)) {
      this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null
    } else if (body instanceof ArrayBuffer) {
      this.body = body.byteLength ? Buffer.from(body) : null
    } else if (typeof body === 'string') {
      this.body = body.length ? Buffer.from(body) : null
    } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
      this.body = body
    } else {
      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')
    }

    this.completed = false

    this.aborted = false

    this.upgrade = upgrade || null

    this.path = query ? util.buildURL(path, query) : path

    this.origin = origin

    this.idempotent = idempotent == null
      ? method === 'HEAD' || method === 'GET'
      : idempotent

    this.blocking = blocking == null ? false : blocking

    this.host = null

    this.contentLength = null

    this.contentType = null

    this.headers = ''

    if (Array.isArray(headers)) {
      if (headers.length % 2 !== 0) {
        throw new InvalidArgumentError('headers array must be even')
      }
      for (let i = 0; i < headers.length; i += 2) {
        processHeader(this, headers[i], headers[i + 1])
      }
    } else if (headers && typeof headers === 'object') {
      const keys = Object.keys(headers)
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i]
        processHeader(this, key, headers[key])
      }
    } else if (headers != null) {
      throw new InvalidArgumentError('headers must be an object or an array')
    }

    if (util.isFormDataLike(this.body)) {
      if (nodeMajor < 16 || (nodeMajor === 16 && nodeMinor < 8)) {
        throw new InvalidArgumentError('Form-Data bodies are only supported in node v16.8 and newer.')
      }

      if (!extractBody) {
        extractBody = (__webpack_require__(/*! ../fetch/body.js */ "../../node_modules/undici/lib/fetch/body.js").extractBody)
      }

      const [bodyStream, contentType] = extractBody(body)
      if (this.contentType == null) {
        this.contentType = contentType
        this.headers += `content-type: ${contentType}\r\n`
      }
      this.body = bodyStream.stream
    } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
      this.contentType = body.type
      this.headers += `content-type: ${body.type}\r\n`
    }

    util.validateHandler(handler, method, upgrade)

    this.servername = util.getServerName(this.host)

    this[kHandler] = handler

    if (channels.create.hasSubscribers) {
      channels.create.publish({ request: this })
    }
  }

  onBodySent (chunk) {
    if (this[kHandler].onBodySent) {
      try {
        this[kHandler].onBodySent(chunk)
      } catch (err) {
        this.onError(err)
      }
    }
  }

  onRequestSent () {
    if (channels.bodySent.hasSubscribers) {
      channels.bodySent.publish({ request: this })
    }
  }

  onConnect (abort) {
    assert(!this.aborted)
    assert(!this.completed)

    return this[kHandler].onConnect(abort)
  }

  onHeaders (statusCode, headers, resume, statusText) {
    assert(!this.aborted)
    assert(!this.completed)

    if (channels.headers.hasSubscribers) {
      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })
    }

    return this[kHandler].onHeaders(statusCode, headers, resume, statusText)
  }

  onData (chunk) {
    assert(!this.aborted)
    assert(!this.completed)

    return this[kHandler].onData(chunk)
  }

  onUpgrade (statusCode, headers, socket) {
    assert(!this.aborted)
    assert(!this.completed)

    return this[kHandler].onUpgrade(statusCode, headers, socket)
  }

  onComplete (trailers) {
    assert(!this.aborted)

    this.completed = true
    if (channels.trailers.hasSubscribers) {
      channels.trailers.publish({ request: this, trailers })
    }
    return this[kHandler].onComplete(trailers)
  }

  onError (error) {
    if (channels.error.hasSubscribers) {
      channels.error.publish({ request: this, error })
    }

    if (this.aborted) {
      return
    }
    this.aborted = true
    return this[kHandler].onError(error)
  }

  addHeader (key, value) {
    processHeader(this, key, value)
    return this
  }
}

function processHeader (request, key, val) {
  if (val && typeof val === 'object') {
    throw new InvalidArgumentError(`invalid ${key} header`)
  } else if (val === undefined) {
    return
  }

  if (
    request.host === null &&
    key.length === 4 &&
    key.toLowerCase() === 'host'
  ) {
    // Consumed by Client
    request.host = val
  } else if (
    request.contentLength === null &&
    key.length === 14 &&
    key.toLowerCase() === 'content-length'
  ) {
    request.contentLength = parseInt(val, 10)
    if (!Number.isFinite(request.contentLength)) {
      throw new InvalidArgumentError('invalid content-length header')
    }
  } else if (
    request.contentType === null &&
    key.length === 12 &&
    key.toLowerCase() === 'content-type'
  ) {
    request.contentType = val
    request.headers += `${key}: ${val}\r\n`
  } else if (
    key.length === 17 &&
    key.toLowerCase() === 'transfer-encoding'
  ) {
    throw new InvalidArgumentError('invalid transfer-encoding header')
  } else if (
    key.length === 10 &&
    key.toLowerCase() === 'connection'
  ) {
    throw new InvalidArgumentError('invalid connection header')
  } else if (
    key.length === 10 &&
    key.toLowerCase() === 'keep-alive'
  ) {
    throw new InvalidArgumentError('invalid keep-alive header')
  } else if (
    key.length === 7 &&
    key.toLowerCase() === 'upgrade'
  ) {
    throw new InvalidArgumentError('invalid upgrade header')
  } else if (
    key.length === 6 &&
    key.toLowerCase() === 'expect'
  ) {
    throw new NotSupportedError('expect header not supported')
  } else if (tokenRegExp.exec(key) === null) {
    throw new InvalidArgumentError('invalid header key')
  } else if (headerCharRegex.exec(val) !== null) {
    throw new InvalidArgumentError(`invalid ${key} header`)
  } else {
    request.headers += `${key}: ${val}\r\n`
  }
}

module.exports = Request


/***/ }),

/***/ "../../node_modules/undici/lib/core/symbols.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/core/symbols.js ***!
  \*****************************************************/
/***/ ((module) => {

module.exports = {
  kClose: Symbol('close'),
  kDestroy: Symbol('destroy'),
  kDispatch: Symbol('dispatch'),
  kUrl: Symbol('url'),
  kWriting: Symbol('writing'),
  kResuming: Symbol('resuming'),
  kQueue: Symbol('queue'),
  kConnect: Symbol('connect'),
  kConnecting: Symbol('connecting'),
  kHeadersList: Symbol('headers list'),
  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
  kKeepAlive: Symbol('keep alive'),
  kHeadersTimeout: Symbol('headers timeout'),
  kBodyTimeout: Symbol('body timeout'),
  kServerName: Symbol('server name'),
  kHost: Symbol('host'),
  kNoRef: Symbol('no ref'),
  kBodyUsed: Symbol('used'),
  kRunning: Symbol('running'),
  kBlocking: Symbol('blocking'),
  kPending: Symbol('pending'),
  kSize: Symbol('size'),
  kBusy: Symbol('busy'),
  kQueued: Symbol('queued'),
  kFree: Symbol('free'),
  kConnected: Symbol('connected'),
  kClosed: Symbol('closed'),
  kNeedDrain: Symbol('need drain'),
  kReset: Symbol('reset'),
  kDestroyed: Symbol('destroyed'),
  kMaxHeadersSize: Symbol('max headers size'),
  kRunningIdx: Symbol('running index'),
  kPendingIdx: Symbol('pending index'),
  kError: Symbol('error'),
  kClients: Symbol('clients'),
  kClient: Symbol('client'),
  kParser: Symbol('parser'),
  kOnDestroyed: Symbol('destroy callbacks'),
  kPipelining: Symbol('pipelinig'),
  kSocket: Symbol('socket'),
  kHostHeader: Symbol('host header'),
  kConnector: Symbol('connector'),
  kStrictContentLength: Symbol('strict content length'),
  kMaxRedirections: Symbol('maxRedirections'),
  kMaxRequests: Symbol('maxRequestsPerClient'),
  kProxy: Symbol('proxy agent options'),
  kCounter: Symbol('socket request counter')
}


/***/ }),

/***/ "../../node_modules/undici/lib/core/util.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/core/util.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const assert = __webpack_require__(/*! assert */ "assert")
const { kDestroyed, kBodyUsed } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/core/symbols.js")
const { IncomingMessage } = __webpack_require__(/*! http */ "http")
const stream = __webpack_require__(/*! stream */ "stream")
const net = __webpack_require__(/*! net */ "net")
const { InvalidArgumentError } = __webpack_require__(/*! ./errors */ "../../node_modules/undici/lib/core/errors.js")
const { Blob } = __webpack_require__(/*! buffer */ "buffer")
const nodeUtil = __webpack_require__(/*! util */ "util")

function nop () {}

function isStream (obj) {
  return obj && typeof obj.pipe === 'function'
}

// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)
function isBlobLike (object) {
  return (Blob && object instanceof Blob) || (
    object &&
    typeof object === 'object' &&
    (typeof object.stream === 'function' ||
      typeof object.arrayBuffer === 'function') &&
    /^(Blob|File)$/.test(object[Symbol.toStringTag])
  )
}

function isObject (val) {
  return val !== null && typeof val === 'object'
}

// this escapes all non-uri friendly characters
function encode (val) {
  return encodeURIComponent(val)
}

// based on https://github.com/axios/axios/blob/63e559fa609c40a0a460ae5d5a18c3470ffc6c9e/lib/helpers/buildURL.js (MIT license)
function buildURL (url, queryParams) {
  if (url.includes('?') || url.includes('#')) {
    throw new Error('Query params cannot be passed when url already contains "?" or "#".')
  }
  if (!isObject(queryParams)) {
    throw new Error('Query params must be an object')
  }

  const parts = []
  for (let [key, val] of Object.entries(queryParams)) {
    if (val === null || typeof val === 'undefined') {
      continue
    }

    if (!Array.isArray(val)) {
      val = [val]
    }

    for (const v of val) {
      if (isObject(v)) {
        throw new Error('Passing object as a query param is not supported, please serialize to string up-front')
      }
      parts.push(encode(key) + '=' + encode(v))
    }
  }

  const serializedParams = parts.join('&')

  if (serializedParams) {
    url += '?' + serializedParams
  }

  return url
}

function parseURL (url) {
  if (typeof url === 'string') {
    url = new URL(url)
  }

  if (!url || typeof url !== 'object') {
    throw new InvalidArgumentError('invalid url')
  }

  if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
    throw new InvalidArgumentError('invalid port')
  }

  if (url.path != null && typeof url.path !== 'string') {
    throw new InvalidArgumentError('invalid path')
  }

  if (url.pathname != null && typeof url.pathname !== 'string') {
    throw new InvalidArgumentError('invalid pathname')
  }

  if (url.hostname != null && typeof url.hostname !== 'string') {
    throw new InvalidArgumentError('invalid hostname')
  }

  if (url.origin != null && typeof url.origin !== 'string') {
    throw new InvalidArgumentError('invalid origin')
  }

  if (!/^https?:/.test(url.origin || url.protocol)) {
    throw new InvalidArgumentError('invalid protocol')
  }

  if (!(url instanceof URL)) {
    const port = url.port != null
      ? url.port
      : (url.protocol === 'https:' ? 443 : 80)
    const origin = url.origin != null
      ? url.origin
      : `${url.protocol}//${url.hostname}:${port}`
    const path = url.path != null
      ? url.path
      : `${url.pathname || ''}${url.search || ''}`

    url = new URL(path, origin)
  }

  return url
}

function parseOrigin (url) {
  url = parseURL(url)

  if (url.pathname !== '/' || url.search || url.hash) {
    throw new InvalidArgumentError('invalid url')
  }

  return url
}

function getHostname (host) {
  if (host[0] === '[') {
    const idx = host.indexOf(']')

    assert(idx !== -1)
    return host.substr(1, idx - 1)
  }

  const idx = host.indexOf(':')
  if (idx === -1) return host

  return host.substr(0, idx)
}

// IP addresses are not valid server names per RFC6066
// > Currently, the only server names supported are DNS hostnames
function getServerName (host) {
  if (!host) {
    return null
  }

  assert.strictEqual(typeof host, 'string')

  const servername = getHostname(host)
  if (net.isIP(servername)) {
    return ''
  }

  return servername
}

function deepClone (obj) {
  return JSON.parse(JSON.stringify(obj))
}

function isAsyncIterable (obj) {
  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')
}

function isIterable (obj) {
  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))
}

function bodyLength (body) {
  if (body == null) {
    return 0
  } else if (isStream(body)) {
    const state = body._readableState
    return state && state.ended === true && Number.isFinite(state.length)
      ? state.length
      : null
  } else if (isBlobLike(body)) {
    return body.size != null ? body.size : null
  } else if (isBuffer(body)) {
    return body.byteLength
  }

  return null
}

function isDestroyed (stream) {
  return !stream || !!(stream.destroyed || stream[kDestroyed])
}

function isReadableAborted (stream) {
  const state = stream && stream._readableState
  return isDestroyed(stream) && state && !state.endEmitted
}

function destroy (stream, err) {
  if (!isStream(stream) || isDestroyed(stream)) {
    return
  }

  if (typeof stream.destroy === 'function') {
    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {
      // See: https://github.com/nodejs/node/pull/38505/files
      stream.socket = null
    }
    stream.destroy(err)
  } else if (err) {
    process.nextTick((stream, err) => {
      stream.emit('error', err)
    }, stream, err)
  }

  if (stream.destroyed !== true) {
    stream[kDestroyed] = true
  }
}

const KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/
function parseKeepAliveTimeout (val) {
  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)
  return m ? parseInt(m[1], 10) * 1000 : null
}

function parseHeaders (headers, obj = {}) {
  for (let i = 0; i < headers.length; i += 2) {
    const key = headers[i].toString().toLowerCase()
    let val = obj[key]
    if (!val) {
      obj[key] = headers[i + 1].toString()
    } else {
      if (!Array.isArray(val)) {
        val = [val]
        obj[key] = val
      }
      val.push(headers[i + 1].toString())
    }
  }
  return obj
}

function parseRawHeaders (headers) {
  return headers.map(header => header.toString())
}

function isBuffer (buffer) {
  // See, https://github.com/mcollina/undici/pull/319
  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)
}

function validateHandler (handler, method, upgrade) {
  if (!handler || typeof handler !== 'object') {
    throw new InvalidArgumentError('handler must be an object')
  }

  if (typeof handler.onConnect !== 'function') {
    throw new InvalidArgumentError('invalid onConnect method')
  }

  if (typeof handler.onError !== 'function') {
    throw new InvalidArgumentError('invalid onError method')
  }

  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {
    throw new InvalidArgumentError('invalid onBodySent method')
  }

  if (upgrade || method === 'CONNECT') {
    if (typeof handler.onUpgrade !== 'function') {
      throw new InvalidArgumentError('invalid onUpgrade method')
    }
  } else {
    if (typeof handler.onHeaders !== 'function') {
      throw new InvalidArgumentError('invalid onHeaders method')
    }

    if (typeof handler.onData !== 'function') {
      throw new InvalidArgumentError('invalid onData method')
    }

    if (typeof handler.onComplete !== 'function') {
      throw new InvalidArgumentError('invalid onComplete method')
    }
  }
}

// A body is disturbed if it has been read from and it cannot
// be re-used without losing state or data.
function isDisturbed (body) {
  return !!(body && (
    stream.isDisturbed
      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?
      : body[kBodyUsed] ||
        body.readableDidRead ||
        (body._readableState && body._readableState.dataEmitted) ||
        isReadableAborted(body)
  ))
}

function isErrored (body) {
  return !!(body && (
    stream.isErrored
      ? stream.isErrored(body)
      : /state: 'errored'/.test(nodeUtil.inspect(body)
      )))
}

function isReadable (body) {
  return !!(body && (
    stream.isReadable
      ? stream.isReadable(body)
      : /state: 'readable'/.test(nodeUtil.inspect(body)
      )))
}

function getSocketInfo (socket) {
  return {
    localAddress: socket.localAddress,
    localPort: socket.localPort,
    remoteAddress: socket.remoteAddress,
    remotePort: socket.remotePort,
    remoteFamily: socket.remoteFamily,
    timeout: socket.timeout,
    bytesWritten: socket.bytesWritten,
    bytesRead: socket.bytesRead
  }
}

let ReadableStream
function ReadableStreamFrom (iterable) {
  if (!ReadableStream) {
    ReadableStream = (__webpack_require__(/*! stream/web */ "stream/web").ReadableStream)
  }

  if (ReadableStream.from) {
    // https://github.com/whatwg/streams/pull/1083
    return ReadableStream.from(iterable)
  }

  let iterator
  return new ReadableStream(
    {
      async start () {
        iterator = iterable[Symbol.asyncIterator]()
      },
      async pull (controller) {
        const { done, value } = await iterator.next()
        if (done) {
          queueMicrotask(() => {
            controller.close()
          })
        } else {
          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)
          controller.enqueue(new Uint8Array(buf))
        }
        return controller.desiredSize > 0
      },
      async cancel (reason) {
        await iterator.return()
      }
    },
    0
  )
}

function isFormDataLike (chunk) {
  return chunk && chunk.constructor && chunk.constructor.name === 'FormData'
}

const kEnumerableProperty = Object.create(null)
kEnumerableProperty.enumerable = true

module.exports = {
  kEnumerableProperty,
  nop,
  isDisturbed,
  isErrored,
  isReadable,
  toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
  isReadableAborted,
  isBlobLike,
  parseOrigin,
  parseURL,
  getServerName,
  isStream,
  isIterable,
  isAsyncIterable,
  isDestroyed,
  parseRawHeaders,
  parseHeaders,
  parseKeepAliveTimeout,
  destroy,
  bodyLength,
  deepClone,
  ReadableStreamFrom,
  isBuffer,
  validateHandler,
  getSocketInfo,
  isFormDataLike,
  buildURL
}


/***/ }),

/***/ "../../node_modules/undici/lib/dispatcher-base.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/dispatcher-base.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const Dispatcher = __webpack_require__(/*! ./dispatcher */ "../../node_modules/undici/lib/dispatcher.js")
const {
  ClientDestroyedError,
  ClientClosedError,
  InvalidArgumentError
} = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { kDestroy, kClose, kDispatch } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")

const kDestroyed = Symbol('destroyed')
const kClosed = Symbol('closed')
const kOnDestroyed = Symbol('onDestroyed')
const kOnClosed = Symbol('onClosed')

class DispatcherBase extends Dispatcher {
  constructor () {
    super()

    this[kDestroyed] = false
    this[kOnDestroyed] = []
    this[kClosed] = false
    this[kOnClosed] = []
  }

  get destroyed () {
    return this[kDestroyed]
  }

  get closed () {
    return this[kClosed]
  }

  close (callback) {
    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        this.close((err, data) => {
          return err ? reject(err) : resolve(data)
        })
      })
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    if (this[kDestroyed]) {
      queueMicrotask(() => callback(new ClientDestroyedError(), null))
      return
    }

    if (this[kClosed]) {
      if (this[kOnClosed]) {
        this[kOnClosed].push(callback)
      } else {
        queueMicrotask(() => callback(null, null))
      }
      return
    }

    this[kClosed] = true
    this[kOnClosed].push(callback)

    const onClosed = () => {
      const callbacks = this[kOnClosed]
      this[kOnClosed] = null
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null)
      }
    }

    // Should not error.
    this[kClose]()
      .then(() => this.destroy())
      .then(() => {
        queueMicrotask(onClosed)
      })
  }

  destroy (err, callback) {
    if (typeof err === 'function') {
      callback = err
      err = null
    }

    if (callback === undefined) {
      return new Promise((resolve, reject) => {
        this.destroy(err, (err, data) => {
          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)
        })
      })
    }

    if (typeof callback !== 'function') {
      throw new InvalidArgumentError('invalid callback')
    }

    if (this[kDestroyed]) {
      if (this[kOnDestroyed]) {
        this[kOnDestroyed].push(callback)
      } else {
        queueMicrotask(() => callback(null, null))
      }
      return
    }

    if (!err) {
      err = new ClientDestroyedError()
    }

    this[kDestroyed] = true
    this[kOnDestroyed].push(callback)

    const onDestroyed = () => {
      const callbacks = this[kOnDestroyed]
      this[kOnDestroyed] = null
      for (let i = 0; i < callbacks.length; i++) {
        callbacks[i](null, null)
      }
    }

    // Should not error.
    this[kDestroy](err).then(() => {
      queueMicrotask(onDestroyed)
    })
  }

  dispatch (opts, handler) {
    if (!handler || typeof handler !== 'object') {
      throw new InvalidArgumentError('handler must be an object')
    }

    try {
      if (!opts || typeof opts !== 'object') {
        throw new InvalidArgumentError('opts must be an object.')
      }

      if (this[kDestroyed]) {
        throw new ClientDestroyedError()
      }

      if (this[kClosed]) {
        throw new ClientClosedError()
      }

      return this[kDispatch](opts, handler)
    } catch (err) {
      if (typeof handler.onError !== 'function') {
        throw new InvalidArgumentError('invalid onError method')
      }

      handler.onError(err)

      return false
    }
  }
}

module.exports = DispatcherBase


/***/ }),

/***/ "../../node_modules/undici/lib/dispatcher.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/dispatcher.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const EventEmitter = __webpack_require__(/*! events */ "events")

class Dispatcher extends EventEmitter {
  dispatch () {
    throw new Error('not implemented')
  }

  close () {
    throw new Error('not implemented')
  }

  destroy () {
    throw new Error('not implemented')
  }
}

module.exports = Dispatcher


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/body.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/body.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { ReadableStreamFrom, toUSVString, isBlobLike } = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const { FormData } = __webpack_require__(/*! ./formdata */ "../../node_modules/undici/lib/fetch/formdata.js")
const { kState } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")
const { Blob } = __webpack_require__(/*! buffer */ "buffer")
const { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! assert */ "assert")
const { NotSupportedError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { isErrored } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { isUint8Array, isArrayBuffer } = __webpack_require__(/*! util/types */ "util/types")

let ReadableStream

async function * blobGen (blob) {
  yield * blob.stream()
}

// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
function extractBody (object, keepalive = false) {
  if (!ReadableStream) {
    ReadableStream = (__webpack_require__(/*! stream/web */ "stream/web").ReadableStream)
  }

  // 1. Let stream be object if object is a ReadableStream object.
  // Otherwise, let stream be a new ReadableStream, and set up stream.
  let stream = null

  // 2. Let action be null.
  let action = null

  // 3. Let source be null.
  let source = null

  // 4. Let length be null.
  let length = null

  // 5. Let Content-Type be null.
  let contentType = null

  // 6. Switch on object:
  if (object == null) {
    // Note: The IDL processor cannot handle this situation. See
    // https://crbug.com/335871.
  } else if (object instanceof URLSearchParams) {
    // URLSearchParams

    // spec says to run application/x-www-form-urlencoded on body.list
    // this is implemented in Node.js as apart of an URLSearchParams instance toString method
    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490
    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100

    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.
    source = object.toString()

    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.
    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'
  } else if (isArrayBuffer(object) || ArrayBuffer.isView(object)) {
    // BufferSource

    if (object instanceof DataView) {
      // TODO: Blob doesn't seem to work with DataView?
      object = object.buffer
    }

    // Set source to a copy of the bytes held by object.
    source = new Uint8Array(object)
  } else if (util.isFormDataLike(object)) {
    const boundary = '----formdata-undici-' + Math.random()
    const prefix = `--${boundary}\r\nContent-Disposition: form-data`

    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */
    const escape = (str) =>
      str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22')
    const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n')

    // Set action to this step: run the multipart/form-data
    // encoding algorithm, with object’s entry list and UTF-8.
    action = async function * (object) {
      const enc = new TextEncoder()

      for (const [name, value] of object) {
        if (typeof value === 'string') {
          yield enc.encode(
            prefix +
              `; name="${escape(normalizeLinefeeds(name))}"` +
              `\r\n\r\n${normalizeLinefeeds(value)}\r\n`
          )
        } else {
          yield enc.encode(
            prefix +
              `; name="${escape(normalizeLinefeeds(name))}"` +
              (value.name ? `; filename="${escape(value.name)}"` : '') +
              '\r\n' +
              `Content-Type: ${
                value.type || 'application/octet-stream'
              }\r\n\r\n`
          )

          yield * blobGen(value)

          yield enc.encode('\r\n')
        }
      }

      yield enc.encode(`--${boundary}--`)
    }

    // Set source to object.
    source = object

    // Set length to unclear, see html/6424 for improving this.
    // TODO

    // Set Content-Type to `multipart/form-data; boundary=`,
    // followed by the multipart/form-data boundary string generated
    // by the multipart/form-data encoding algorithm.
    contentType = 'multipart/form-data; boundary=' + boundary
  } else if (isBlobLike(object)) {
    // Blob

    // Set action to this step: read object.
    action = blobGen

    // Set source to object.
    source = object

    // Set length to object’s size.
    length = object.size

    // If object’s type attribute is not the empty byte sequence, set
    // Content-Type to its value.
    if (object.type) {
      contentType = object.type
    }
  } else if (typeof object[Symbol.asyncIterator] === 'function') {
    // If keepalive is true, then throw a TypeError.
    if (keepalive) {
      throw new TypeError('keepalive')
    }

    // If object is disturbed or locked, then throw a TypeError.
    if (util.isDisturbed(object) || object.locked) {
      throw new TypeError(
        'Response body object should not be disturbed or locked'
      )
    }

    stream =
      object instanceof ReadableStream ? object : ReadableStreamFrom(object)
  } else {
    // TODO: byte sequence?
    // TODO: scalar value string?
    // TODO: else?
    source = toUSVString(object)
    contentType = 'text/plain;charset=UTF-8'
  }

  // 7. If source is a byte sequence, then set action to a
  // step that returns source and length to source’s length.
  // TODO: What is a "byte sequence?"
  if (typeof source === 'string' || util.isBuffer(source)) {
    length = Buffer.byteLength(source)
  }

  // 8. If action is non-null, then run these steps in in parallel:
  if (action != null) {
    // Run action.
    let iterator
    stream = new ReadableStream({
      async start () {
        iterator = action(object)[Symbol.asyncIterator]()
      },
      async pull (controller) {
        const { value, done } = await iterator.next()
        if (done) {
          // When running action is done, close stream.
          queueMicrotask(() => {
            controller.close()
          })
        } else {
          // Whenever one or more bytes are available and stream is not errored,
          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available
          // bytes into stream.
          if (!isErrored(stream)) {
            controller.enqueue(new Uint8Array(value))
          }
        }
        return controller.desiredSize > 0
      },
      async cancel (reason) {
        await iterator.return()
      }
    })
  } else if (!stream) {
    // TODO: Spec doesn't say anything about this?
    stream = new ReadableStream({
      async pull (controller) {
        controller.enqueue(
          typeof source === 'string' ? new TextEncoder().encode(source) : source
        )
        queueMicrotask(() => {
          controller.close()
        })
      }
    })
  }

  // 9. Let body be a body whose stream is stream, source is source,
  // and length is length.
  const body = { stream, source, length }

  // 10. Return body and Content-Type.
  return [body, contentType]
}

// https://fetch.spec.whatwg.org/#bodyinit-safely-extract
function safelyExtractBody (object, keepalive = false) {
  if (!ReadableStream) {
    // istanbul ignore next
    ReadableStream = (__webpack_require__(/*! stream/web */ "stream/web").ReadableStream)
  }

  // To safely extract a body and a `Content-Type` value from
  // a byte sequence or BodyInit object object, run these steps:

  // 1. If object is a ReadableStream object, then:
  if (object instanceof ReadableStream) {
    // Assert: object is neither disturbed nor locked.
    // istanbul ignore next
    assert(!util.isDisturbed(object), 'disturbed')
    // istanbul ignore next
    assert(!object.locked, 'locked')
  }

  // 2. Return the results of extracting object.
  return extractBody(object, keepalive)
}

function cloneBody (body) {
  // To clone a body body, run these steps:

  // https://fetch.spec.whatwg.org/#concept-body-clone

  // 1. Let « out1, out2 » be the result of teeing body’s stream.
  const [out1, out2] = body.stream.tee()

  // 2. Set body’s stream to out1.
  body.stream = out1

  // 3. Return a body whose stream is out2 and other members are copied from body.
  return {
    stream: out2,
    length: body.length,
    source: body.source
  }
}

async function * consumeBody (body) {
  if (body) {
    if (isUint8Array(body)) {
      yield body
    } else {
      const stream = body.stream

      if (util.isDisturbed(stream)) {
        throw new TypeError('disturbed')
      }

      if (stream.locked) {
        throw new TypeError('locked')
      }

      // Compat.
      stream[kBodyUsed] = true

      yield * stream
    }
  }
}

function bodyMixinMethods (instance) {
  const methods = {
    async blob () {
      if (!(this instanceof instance)) {
        throw new TypeError('Illegal invocation')
      }

      const chunks = []

      for await (const chunk of consumeBody(this[kState].body)) {
        if (!isUint8Array(chunk)) {
          throw new TypeError('Expected Uint8Array chunk')
        }

        // Assemble one final large blob with Uint8Array's can exhaust memory.
        // That's why we create create multiple blob's and using references
        chunks.push(new Blob([chunk]))
      }

      return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })
    },

    async arrayBuffer () {
      if (!(this instanceof instance)) {
        throw new TypeError('Illegal invocation')
      }

      const contentLength = this.headers.get('content-length')
      const encoded = this.headers.has('content-encoding')

      // if we have content length and no encoding, then we can
      // pre allocate the buffer and just read the data into it
      if (!encoded && contentLength) {
        const buffer = new Uint8Array(contentLength)
        let offset = 0

        for await (const chunk of consumeBody(this[kState].body)) {
          if (!isUint8Array(chunk)) {
            throw new TypeError('Expected Uint8Array chunk')
          }

          buffer.set(chunk, offset)
          offset += chunk.length
        }

        return buffer.buffer
      }

      // if we don't have content length, then we have to allocate 2x the
      // size of the body, once for consumed data, and once for the final buffer

      // This could be optimized by using growable ArrayBuffer, but it's not
      // implemented yet. https://github.com/tc39/proposal-resizablearraybuffer

      const chunks = []
      let size = 0

      for await (const chunk of consumeBody(this[kState].body)) {
        if (!isUint8Array(chunk)) {
          throw new TypeError('Expected Uint8Array chunk')
        }

        chunks.push(chunk)
        size += chunk.byteLength
      }

      const buffer = new Uint8Array(size)
      let offset = 0

      for (const chunk of chunks) {
        buffer.set(chunk, offset)
        offset += chunk.byteLength
      }

      return buffer.buffer
    },

    async text () {
      if (!(this instanceof instance)) {
        throw new TypeError('Illegal invocation')
      }

      let result = ''
      const textDecoder = new TextDecoder()

      for await (const chunk of consumeBody(this[kState].body)) {
        if (!isUint8Array(chunk)) {
          throw new TypeError('Expected Uint8Array chunk')
        }

        result += textDecoder.decode(chunk, { stream: true })
      }

      // flush
      result += textDecoder.decode()

      return result
    },

    async json () {
      if (!(this instanceof instance)) {
        throw new TypeError('Illegal invocation')
      }

      return JSON.parse(await this.text())
    },

    async formData () {
      if (!(this instanceof instance)) {
        throw new TypeError('Illegal invocation')
      }

      const contentType = this.headers.get('Content-Type')

      // If mimeType’s essence is "multipart/form-data", then:
      if (/multipart\/form-data/.test(contentType)) {
        throw new NotSupportedError('multipart/form-data not supported')
      } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
        // Otherwise, if mimeType’s essence is "application/x-www-form-urlencoded", then:

        // 1. Let entries be the result of parsing bytes.
        let entries
        try {
          entries = new URLSearchParams(await this.text())
        } catch (err) {
          // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.
          // 2. If entries is failure, then throw a TypeError.
          throw Object.assign(new TypeError(), { cause: err })
        }

        // 3. Return a new FormData object whose entries are entries.
        const formData = new FormData()
        for (const [name, value] of entries) {
          formData.append(name, value)
        }
        return formData
      } else {
        // Otherwise, throw a TypeError.
        webidl.errors.exception({
          header: `${instance.name}.formData`,
          value: 'Could not parse content as FormData.'
        })
      }
    }
  }

  return methods
}

const properties = {
  body: {
    enumerable: true,
    get () {
      if (!this || !this[kState]) {
        throw new TypeError('Illegal invocation')
      }

      return this[kState].body ? this[kState].body.stream : null
    }
  },
  bodyUsed: {
    enumerable: true,
    get () {
      if (!this || !this[kState]) {
        throw new TypeError('Illegal invocation')
      }

      return !!this[kState].body && util.isDisturbed(this[kState].body.stream)
    }
  }
}

function mixinBody (prototype) {
  Object.assign(prototype.prototype, bodyMixinMethods(prototype))
  Object.defineProperties(prototype.prototype, properties)
}

module.exports = {
  extractBody,
  safelyExtractBody,
  cloneBody,
  mixinBody
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/constants.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/constants.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


const corsSafeListedMethods = ['GET', 'HEAD', 'POST']

const nullBodyStatus = [101, 204, 205, 304]

const redirectStatus = [301, 302, 303, 307, 308]

const referrerPolicy = [
  '',
  'no-referrer',
  'no-referrer-when-downgrade',
  'same-origin',
  'origin',
  'strict-origin',
  'origin-when-cross-origin',
  'strict-origin-when-cross-origin',
  'unsafe-url'
]

const requestRedirect = ['follow', 'manual', 'error']

const safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']

const requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']

const requestCredentials = ['omit', 'same-origin', 'include']

const requestCache = [
  'default',
  'no-store',
  'reload',
  'no-cache',
  'force-cache',
  'only-if-cached'
]

const requestBodyHeader = [
  'content-encoding',
  'content-language',
  'content-location',
  'content-type'
]

// http://fetch.spec.whatwg.org/#forbidden-method
const forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']

const subresource = [
  'audio',
  'audioworklet',
  'font',
  'image',
  'manifest',
  'paintworklet',
  'script',
  'style',
  'track',
  'video',
  'xslt',
  ''
]

/** @type {globalThis['DOMException']} */
const DOMException = globalThis.DOMException ?? (() => {
  // DOMException was only made a global in Node v17.0.0,
  // but fetch supports >= v16.8.
  try {
    atob('~')
  } catch (err) {
    return Object.getPrototypeOf(err).constructor
  }
})()

module.exports = {
  DOMException,
  subresource,
  forbiddenMethods,
  requestBodyHeader,
  referrerPolicy,
  requestRedirect,
  requestMode,
  requestCredentials,
  requestCache,
  redirectStatus,
  corsSafeListedMethods,
  nullBodyStatus,
  safeMethods
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/dataURL.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/dataURL.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const assert = __webpack_require__(/*! assert */ "assert")
const { atob } = __webpack_require__(/*! buffer */ "buffer")

const encoder = new TextEncoder()

// https://fetch.spec.whatwg.org/#data-url-processor
/** @param {URL} dataURL */
function dataURLProcessor (dataURL) {
  // 1. Assert: dataURL’s scheme is "data".
  assert(dataURL.protocol === 'data:')

  // 2. Let input be the result of running the URL
  // serializer on dataURL with exclude fragment
  // set to true.
  let input = URLSerializer(dataURL, true)

  // 3. Remove the leading "data:" string from input.
  input = input.slice(5)

  // 4. Let position point at the start of input.
  const position = { position: 0 }

  // 5. Let mimeType be the result of collecting a
  // sequence of code points that are not equal
  // to U+002C (,), given position.
  let mimeType = collectASequenceOfCodePoints(
    (char) => char !== ',',
    input,
    position
  )

  // 6. Strip leading and trailing ASCII whitespace
  // from mimeType.
  // Note: This will only remove U+0020 SPACE code
  // points, if any.
  // Undici implementation note: we need to store the
  // length because if the mimetype has spaces removed,
  // the wrong amount will be sliced from the input in
  // step #9
  const mimeTypeLength = mimeType.length
  mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, '')

  // 7. If position is past the end of input, then
  // return failure
  if (position.position >= input.length) {
    return 'failure'
  }

  // 8. Advance position by 1.
  position.position++

  // 9. Let encodedBody be the remainder of input.
  const encodedBody = input.slice(mimeTypeLength + 1)

  // 10. Let body be the percent-decoding of encodedBody.
  /** @type {Uint8Array|string} */
  let body = stringPercentDecode(encodedBody)

  // 11. If mimeType ends with U+003B (;), followed by
  // zero or more U+0020 SPACE, followed by an ASCII
  // case-insensitive match for "base64", then:
  if (/;(\u0020){0,}base64$/i.test(mimeType)) {
    // 1. Let stringBody be the isomorphic decode of body.
    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body))
    // 2. Set body to the forgiving-base64 decode of
    // stringBody.
    body = forgivingBase64(stringBody)

    // 3. If body is failure, then return failure.
    if (body === 'failure') {
      return 'failure'
    }

    // 4. Remove the last 6 code points from mimeType.
    mimeType = mimeType.slice(0, -6)

    // 5. Remove trailing U+0020 SPACE code points from mimeType,
    // if any.
    mimeType = mimeType.replace(/(\u0020)+$/, '')

    // 6. Remove the last U+003B (;) code point from mimeType.
    mimeType = mimeType.slice(0, -1)
  }

  // 12. If mimeType starts with U+003B (;), then prepend
  // "text/plain" to mimeType.
  if (mimeType.startsWith(';')) {
    mimeType = 'text/plain' + mimeType
  }

  // 13. Let mimeTypeRecord be the result of parsing
  // mimeType.
  let mimeTypeRecord = parseMIMEType(mimeType)

  // 14. If mimeTypeRecord is failure, then set
  // mimeTypeRecord to text/plain;charset=US-ASCII.
  if (mimeTypeRecord === 'failure') {
    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')
  }

  // 15. Return a new data: URL struct whose MIME
  // type is mimeTypeRecord and body is body.
  // https://fetch.spec.whatwg.org/#data-url-struct
  return { mimeType: mimeTypeRecord, body }
}

// https://url.spec.whatwg.org/#concept-url-serializer
/**
 * @param {URL} url
 * @param {boolean} excludeFragment
 */
function URLSerializer (url, excludeFragment = false) {
  // 1. Let output be url’s scheme and U+003A (:) concatenated.
  let output = url.protocol

  // 2. If url’s host is non-null:
  if (url.host.length > 0) {
    // 1. Append "//" to output.
    output += '//'

    // 2. If url includes credentials, then:
    if (url.username.length > 0 || url.password.length > 0) {
      // 1. Append url’s username to output.
      output += url.username

      // 2. If url’s password is not the empty string, then append U+003A (:),
      // followed by url’s password, to output.
      if (url.password.length > 0) {
        output += ':' + url.password
      }

      // 3. Append U+0040 (@) to output.
      output += '@'
    }

    // 3. Append url’s host, serialized, to output.
    output += decodeURIComponent(url.host)

    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,
    // serialized, to output.
    if (url.port.length > 0) {
      output += ':' + url.port
    }
  }

  // 3. If url’s host is null, url does not have an opaque path,
  // url’s path’s size is greater than 1, and url’s path[0]
  // is the empty string, then append U+002F (/) followed by
  // U+002E (.) to output.
  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,
  // when parsed and then serialized, from ending up as web+demo://not-a-host/
  // (they end up as web+demo:/.//not-a-host/).
  // Undici implementation note: url's path[0] can never be an
  // empty string, so we have to slightly alter what the spec says.
  if (
    url.host.length === 0 &&
    url.pathname.length > 1 &&
    url.href.slice(url.protocol.length + 1)[0] === '.'
  ) {
    output += '/.'
  }

  // 4. Append the result of URL path serializing url to output.
  output += url.pathname

  // 5. If url’s query is non-null, append U+003F (?),
  // followed by url’s query, to output.
  if (url.search.length > 0) {
    output += url.search
  }

  // 6. If exclude fragment is false and url’s fragment is non-null,
  // then append U+0023 (#), followed by url’s fragment, to output.
  if (excludeFragment === false && url.hash.length > 0) {
    output += url.hash
  }

  // 7. Return output.
  return output
}

// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points
/**
 * @param {(char: string) => boolean} condition
 * @param {string} input
 * @param {{ position: number }} position
 */
function collectASequenceOfCodePoints (condition, input, position) {
  // 1. Let result be the empty string.
  let result = ''

  // 2. While position doesn’t point past the end of input and the
  // code point at position within input meets the condition condition:
  while (position.position < input.length && condition(input[position.position])) {
    // 1. Append that code point to the end of result.
    result += input[position.position]

    // 2. Advance position by 1.
    position.position++
  }

  // 3. Return result.
  return result
}

// https://url.spec.whatwg.org/#string-percent-decode
/** @param {string} input */
function stringPercentDecode (input) {
  // 1. Let bytes be the UTF-8 encoding of input.
  const bytes = encoder.encode(input)

  // 2. Return the percent-decoding of bytes.
  return percentDecode(bytes)
}

// https://url.spec.whatwg.org/#percent-decode
/** @param {Uint8Array} input */
function percentDecode (input) {
  // 1. Let output be an empty byte sequence.
  /** @type {number[]} */
  const output = []

  // 2. For each byte byte in input:
  for (let i = 0; i < input.length; i++) {
    const byte = input[i]

    // 1. If byte is not 0x25 (%), then append byte to output.
    if (byte !== 0x25) {
      output.push(byte)

    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes
    // after byte in input are not in the ranges
    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),
    // and 0x61 (a) to 0x66 (f), all inclusive, append byte
    // to output.
    } else if (
      byte === 0x25 &&
      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))
    ) {
      output.push(0x25)

    // 3. Otherwise:
    } else {
      // 1. Let bytePoint be the two bytes after byte in input,
      // decoded, and then interpreted as hexadecimal number.
      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])
      const bytePoint = Number.parseInt(nextTwoBytes, 16)

      // 2. Append a byte whose value is bytePoint to output.
      output.push(bytePoint)

      // 3. Skip the next two bytes in input.
      i += 2
    }
  }

  // 3. Return output.
  return Uint8Array.of(...output)
}

// https://mimesniff.spec.whatwg.org/#parse-a-mime-type
/** @param {string} input */
function parseMIMEType (input) {
  // 1. Remove any leading and trailing HTTP whitespace
  // from input.
  input = input.trim()

  // 2. Let position be a position variable for input,
  // initially pointing at the start of input.
  const position = { position: 0 }

  // 3. Let type be the result of collecting a sequence
  // of code points that are not U+002F (/) from
  // input, given position.
  const type = collectASequenceOfCodePoints(
    (char) => char !== '/',
    input,
    position
  )

  // 4. If type is the empty string or does not solely
  // contain HTTP token code points, then return failure.
  // https://mimesniff.spec.whatwg.org/#http-token-code-point
  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
    return 'failure'
  }

  // 5. If position is past the end of input, then return
  // failure
  if (position.position > input.length) {
    return 'failure'
  }

  // 6. Advance position by 1. (This skips past U+002F (/).)
  position.position++

  // 7. Let subtype be the result of collecting a sequence of
  // code points that are not U+003B (;) from input, given
  // position.
  let subtype = collectASequenceOfCodePoints(
    (char) => char !== ';',
    input,
    position
  )

  // 8. Remove any trailing HTTP whitespace from subtype.
  subtype = subtype.trim()

  // 9. If subtype is the empty string or does not solely
  // contain HTTP token code points, then return failure.
  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
    return 'failure'
  }

  // 10. Let mimeType be a new MIME type record whose type
  // is type, in ASCII lowercase, and subtype is subtype,
  // in ASCII lowercase.
  // https://mimesniff.spec.whatwg.org/#mime-type
  const mimeType = {
    type: type.toLowerCase(),
    subtype: subtype.toLowerCase(),
    /** @type {Map<string, string>} */
    parameters: new Map()
  }

  // 11. While position is not past the end of input:
  while (position.position < input.length) {
    // 1. Advance position by 1. (This skips past U+003B (;).)
    position.position++

    // 2. Collect a sequence of code points that are HTTP
    // whitespace from input given position.
    collectASequenceOfCodePoints(
      // https://fetch.spec.whatwg.org/#http-whitespace
      (char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char), // eslint-disable-line
      input,
      position
    )

    // 3. Let parameterName be the result of collecting a
    // sequence of code points that are not U+003B (;)
    // or U+003D (=) from input, given position.
    let parameterName = collectASequenceOfCodePoints(
      (char) => char !== ';' && char !== '=',
      input,
      position
    )

    // 4. Set parameterName to parameterName, in ASCII
    // lowercase.
    parameterName = parameterName.toLowerCase()

    // 5. If position is not past the end of input, then:
    if (position.position < input.length) {
      // 1. If the code point at position within input is
      // U+003B (;), then continue.
      if (input[position.position] === ';') {
        continue
      }

      // 2. Advance position by 1. (This skips past U+003D (=).)
      position.position++
    }

    // 6. If position is past the end of input, then break.
    if (position.position > input.length) {
      break
    }

    // 7. Let parameterValue be null.
    let parameterValue = null

    // 8. If the code point at position within input is
    // U+0022 ("), then:
    if (input[position.position] === '"') {
      // 1. Set parameterValue to the result of collecting
      // an HTTP quoted string from input, given position
      // and the extract-value flag.
      // Undici implementation note: extract-value is never
      // defined or mentioned anywhere.
      parameterValue = collectAnHTTPQuotedString(input, position/*, extractValue */)

      // 2. Collect a sequence of code points that are not
      // U+003B (;) from input, given position.
      collectASequenceOfCodePoints(
        (char) => char !== ';',
        input,
        position
      )

    // 9. Otherwise:
    } else {
      // 1. Set parameterValue to the result of collecting
      // a sequence of code points that are not U+003B (;)
      // from input, given position.
      parameterValue = collectASequenceOfCodePoints(
        (char) => char !== ';',
        input,
        position
      )

      // 2. Remove any trailing HTTP whitespace from parameterValue.
      parameterValue = parameterValue.trim()

      // 3. If parameterValue is the empty string, then continue.
      if (parameterValue.length === 0) {
        continue
      }
    }

    // 10. If all of the following are true
    // - parameterName is not the empty string
    // - parameterName solely contains HTTP token code points
    // - parameterValue solely contains HTTP quoted-string token code points
    // - mimeType’s parameters[parameterName] does not exist
    // then set mimeType’s parameters[parameterName] to parameterValue.
    if (
      parameterName.length !== 0 &&
      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&
      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point
      !/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) &&  // eslint-disable-line
      !mimeType.parameters.has(parameterName)
    ) {
      mimeType.parameters.set(parameterName, parameterValue)
    }
  }

  // 12. Return mimeType.
  return mimeType
}

// https://infra.spec.whatwg.org/#forgiving-base64-decode
/** @param {string} data */
function forgivingBase64 (data) {
  // 1. Remove all ASCII whitespace from data.
  data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '')  // eslint-disable-line

  // 2. If data’s code point length divides by 4 leaving
  // no remainder, then:
  if (data.length % 4 === 0) {
    // 1. If data ends with one or two U+003D (=) code points,
    // then remove them from data.
    data = data.replace(/=?=$/, '')
  }

  // 3. If data’s code point length divides by 4 leaving
  // a remainder of 1, then return failure.
  if (data.length % 4 === 1) {
    return 'failure'
  }

  // 4. If data contains a code point that is not one of
  //  U+002B (+)
  //  U+002F (/)
  //  ASCII alphanumeric
  // then return failure.
  if (/[^+/0-9A-Za-z]/.test(data)) {
    return 'failure'
  }

  const binary = atob(data)
  const bytes = new Uint8Array(binary.length)

  for (let byte = 0; byte < binary.length; byte++) {
    bytes[byte] = binary.charCodeAt(byte)
  }

  return bytes
}

// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string
// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string
/**
 * @param {string} input
 * @param {{ position: number }} position
 * @param {boolean?} extractValue
 */
function collectAnHTTPQuotedString (input, position, extractValue) {
  // 1. Let positionStart be position.
  const positionStart = position.position

  // 2. Let value be the empty string.
  let value = ''

  // 3. Assert: the code point at position within input
  // is U+0022 (").
  assert(input[position.position] === '"')

  // 4. Advance position by 1.
  position.position++

  // 5. While true:
  while (true) {
    // 1. Append the result of collecting a sequence of code points
    // that are not U+0022 (") or U+005C (\) from input, given
    // position, to value.
    value += collectASequenceOfCodePoints(
      (char) => char !== '"' && char !== '\\',
      input,
      position
    )

    // 2. If position is past the end of input, then break.
    if (position.position >= input.length) {
      break
    }

    // 3. Let quoteOrBackslash be the code point at position within
    // input.
    const quoteOrBackslash = input[position.position]

    // 4. Advance position by 1.
    position.position++

    // 5. If quoteOrBackslash is U+005C (\), then:
    if (quoteOrBackslash === '\\') {
      // 1. If position is past the end of input, then append
      // U+005C (\) to value and break.
      if (position.position >= input.length) {
        value += '\\'
        break
      }

      // 2. Append the code point at position within input to value.
      value += input[position.position]

      // 3. Advance position by 1.
      position.position++

    // 6. Otherwise:
    } else {
      // 1. Assert: quoteOrBackslash is U+0022 (").
      assert(quoteOrBackslash === '"')

      // 2. Break.
      break
    }
  }

  // 6. If the extract-value flag is set, then return value.
  if (extractValue) {
    return value
  }

  // 7. Return the code points from positionStart to position,
  // inclusive, within input.
  return input.slice(positionStart, position.position)
}

module.exports = {
  dataURLProcessor,
  URLSerializer,
  collectASequenceOfCodePoints,
  stringPercentDecode,
  parseMIMEType,
  collectAnHTTPQuotedString
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/file.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/file.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Blob } = __webpack_require__(/*! buffer */ "buffer")
const { types } = __webpack_require__(/*! util */ "util")
const { kState } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { isBlobLike } = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")

class File extends Blob {
  constructor (fileBits, fileName, options = {}) {
    // The File constructor is invoked with two or three parameters, depending
    // on whether the optional dictionary parameter is used. When the File()
    // constructor is invoked, user agents must run the following steps:
    if (arguments.length < 2) {
      throw new TypeError('2 arguments required')
    }

    fileBits = webidl.converters['sequence<BlobPart>'](fileBits)
    fileName = webidl.converters.USVString(fileName)
    options = webidl.converters.FilePropertyBag(options)

    // 1. Let bytes be the result of processing blob parts given fileBits and
    // options.
    // Note: Blob handles this for us

    // 2. Let n be the fileName argument to the constructor.
    const n = fileName

    // 3. Process FilePropertyBag dictionary argument by running the following
    // substeps:

    //    1. If the type member is provided and is not the empty string, let t
    //    be set to the type dictionary member. If t contains any characters
    //    outside the range U+0020 to U+007E, then set t to the empty string
    //    and return from these substeps.
    //    2. Convert every character in t to ASCII lowercase.
    // Note: Blob handles both of these steps for us

    //    3. If the lastModified member is provided, let d be set to the
    //    lastModified dictionary member. If it is not provided, set d to the
    //    current date and time represented as the number of milliseconds since
    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
    const d = options.lastModified

    // 4. Return a new File object F such that:
    // F refers to the bytes byte sequence.
    // F.size is set to the number of total bytes in bytes.
    // F.name is set to n.
    // F.type is set to t.
    // F.lastModified is set to d.

    super(processBlobParts(fileBits, options), { type: options.type })
    this[kState] = {
      name: n,
      lastModified: d
    }
  }

  get name () {
    if (!(this instanceof File)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].name
  }

  get lastModified () {
    if (!(this instanceof File)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].lastModified
  }

  get [Symbol.toStringTag] () {
    return this.constructor.name
  }
}

class FileLike {
  constructor (blobLike, fileName, options = {}) {
    // TODO: argument idl type check

    // The File constructor is invoked with two or three parameters, depending
    // on whether the optional dictionary parameter is used. When the File()
    // constructor is invoked, user agents must run the following steps:

    // 1. Let bytes be the result of processing blob parts given fileBits and
    // options.

    // 2. Let n be the fileName argument to the constructor.
    const n = fileName

    // 3. Process FilePropertyBag dictionary argument by running the following
    // substeps:

    //    1. If the type member is provided and is not the empty string, let t
    //    be set to the type dictionary member. If t contains any characters
    //    outside the range U+0020 to U+007E, then set t to the empty string
    //    and return from these substeps.
    //    TODO
    const t = options.type

    //    2. Convert every character in t to ASCII lowercase.
    //    TODO

    //    3. If the lastModified member is provided, let d be set to the
    //    lastModified dictionary member. If it is not provided, set d to the
    //    current date and time represented as the number of milliseconds since
    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).
    const d = options.lastModified ?? Date.now()

    // 4. Return a new File object F such that:
    // F refers to the bytes byte sequence.
    // F.size is set to the number of total bytes in bytes.
    // F.name is set to n.
    // F.type is set to t.
    // F.lastModified is set to d.

    this[kState] = {
      blobLike,
      name: n,
      type: t,
      lastModified: d
    }
  }

  stream (...args) {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.stream(...args)
  }

  arrayBuffer (...args) {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.arrayBuffer(...args)
  }

  slice (...args) {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.slice(...args)
  }

  text (...args) {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.text(...args)
  }

  get size () {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.size
  }

  get type () {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].blobLike.type
  }

  get name () {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].name
  }

  get lastModified () {
    if (!(this instanceof FileLike)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kState].lastModified
  }

  get [Symbol.toStringTag] () {
    return 'File'
  }
}

webidl.converters.Blob = webidl.interfaceConverter(Blob)

webidl.converters.BlobPart = function (V, opts) {
  if (webidl.util.Type(V) === 'Object') {
    if (isBlobLike(V)) {
      return webidl.converters.Blob(V, { strict: false })
    }

    return webidl.converters.BufferSource(V, opts)
  } else {
    return webidl.converters.USVString(V, opts)
  }
}

webidl.converters['sequence<BlobPart>'] = webidl.sequenceConverter(
  webidl.converters.BlobPart
)

// https://www.w3.org/TR/FileAPI/#dfn-FilePropertyBag
webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
  {
    key: 'lastModified',
    converter: webidl.converters['long long'],
    get defaultValue () {
      return Date.now()
    }
  },
  {
    key: 'type',
    converter: webidl.converters.DOMString,
    defaultValue: ''
  },
  {
    key: 'endings',
    converter: (value) => {
      value = webidl.converters.DOMString(value)
      value = value.toLowerCase()

      if (value !== 'native') {
        value = 'transparent'
      }

      return value
    },
    defaultValue: 'transparent'
  }
])

/**
 * @see https://www.w3.org/TR/FileAPI/#process-blob-parts
 * @param {(NodeJS.TypedArray|Blob|string)[]} parts
 * @param {{ type: string, endings: string }} options
 */
function processBlobParts (parts, options) {
  // 1. Let bytes be an empty sequence of bytes.
  /** @type {NodeJS.TypedArray[]} */
  const bytes = []

  // 2. For each element in parts:
  for (const element of parts) {
    // 1. If element is a USVString, run the following substeps:
    if (typeof element === 'string') {
      // 1. Let s be element.
      let s = element

      // 2. If the endings member of options is "native", set s
      //    to the result of converting line endings to native
      //    of element.
      if (options.endings === 'native') {
        s = convertLineEndingsNative(s)
      }

      // 3. Append the result of UTF-8 encoding s to bytes.
      bytes.push(new TextEncoder().encode(s))
    } else if (
      types.isAnyArrayBuffer(element) ||
      types.isTypedArray(element)
    ) {
      // 2. If element is a BufferSource, get a copy of the
      //    bytes held by the buffer source, and append those
      //    bytes to bytes.
      if (!element.buffer) { // ArrayBuffer
        bytes.push(new Uint8Array(element))
      } else {
        bytes.push(element.buffer)
      }
    } else if (isBlobLike(element)) {
      // 3. If element is a Blob, append the bytes it represents
      //    to bytes.
      bytes.push(element)
    }
  }

  // 3. Return bytes.
  return bytes
}

/**
 * @see https://www.w3.org/TR/FileAPI/#convert-line-endings-to-native
 * @param {string} s
 */
function convertLineEndingsNative (s) {
  // 1. Let native line ending be be the code point U+000A LF.
  let nativeLineEnding = '\n'

  // 2. If the underlying platform’s conventions are to
  //    represent newlines as a carriage return and line feed
  //    sequence, set native line ending to the code point
  //    U+000D CR followed by the code point U+000A LF.
  if (process.platform === 'win32') {
    nativeLineEnding = '\r\n'
  }

  return s.replace(/\r?\n/g, nativeLineEnding)
}

module.exports = { File, FileLike }


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/formdata.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/formdata.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isBlobLike, isFileLike, toUSVString, makeIterator } = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const { kState } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { File, FileLike } = __webpack_require__(/*! ./file */ "../../node_modules/undici/lib/fetch/file.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")
const { Blob } = __webpack_require__(/*! buffer */ "buffer")

// https://xhr.spec.whatwg.org/#formdata
class FormData {
  static name = 'FormData'

  constructor (form) {
    if (arguments.length > 0 && form != null) {
      webidl.errors.conversionFailed({
        prefix: 'FormData constructor',
        argument: 'Argument 1',
        types: ['null']
      })
    }

    this[kState] = []
  }

  append (name, value, filename = undefined) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 2) {
      throw new TypeError(
        `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
      )
    }

    if (arguments.length === 3 && !isBlobLike(value)) {
      throw new TypeError(
        "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
      )
    }

    // 1. Let value be value if given; otherwise blobValue.

    name = webidl.converters.USVString(name)
    value = isBlobLike(value)
      ? webidl.converters.Blob(value, { strict: false })
      : webidl.converters.USVString(value)
    filename = arguments.length === 3
      ? webidl.converters.USVString(filename)
      : undefined

    // 2. Let entry be the result of creating an entry with
    // name, value, and filename if given.
    const entry = makeEntry(name, value, filename)

    // 3. Append entry to this’s entry list.
    this[kState].push(entry)
  }

  delete (name) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.USVString(name)

    // The delete(name) method steps are to remove all entries whose name
    // is name from this’s entry list.
    const next = []
    for (const entry of this[kState]) {
      if (entry.name !== name) {
        next.push(entry)
      }
    }

    this[kState] = next
  }

  get (name) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.USVString(name)

    // 1. If there is no entry whose name is name in this’s entry list,
    // then return null.
    const idx = this[kState].findIndex((entry) => entry.name === name)
    if (idx === -1) {
      return null
    }

    // 2. Return the value of the first entry whose name is name from
    // this’s entry list.
    return this[kState][idx].value
  }

  getAll (name) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.USVString(name)

    // 1. If there is no entry whose name is name in this’s entry list,
    // then return the empty list.
    // 2. Return the values of all entries whose name is name, in order,
    // from this’s entry list.
    return this[kState]
      .filter((entry) => entry.name === name)
      .map((entry) => entry.value)
  }

  has (name) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.USVString(name)

    // The has(name) method steps are to return true if there is an entry
    // whose name is name in this’s entry list; otherwise false.
    return this[kState].findIndex((entry) => entry.name === name) !== -1
  }

  set (name, value, filename = undefined) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 2) {
      throw new TypeError(
        `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${arguments.length} present.`
      )
    }

    if (arguments.length === 3 && !isBlobLike(value)) {
      throw new TypeError(
        "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
      )
    }

    // The set(name, value) and set(name, blobValue, filename) method steps
    // are:

    // 1. Let value be value if given; otherwise blobValue.

    name = webidl.converters.USVString(name)
    value = isBlobLike(value)
      ? webidl.converters.Blob(value, { strict: false })
      : webidl.converters.USVString(value)
    filename = arguments.length === 3
      ? toUSVString(filename)
      : undefined

    // 2. Let entry be the result of creating an entry with name, value, and
    // filename if given.
    const entry = makeEntry(name, value, filename)

    // 3. If there are entries in this’s entry list whose name is name, then
    // replace the first such entry with entry and remove the others.
    const idx = this[kState].findIndex((entry) => entry.name === name)
    if (idx !== -1) {
      this[kState] = [
        ...this[kState].slice(0, idx),
        entry,
        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)
      ]
    } else {
      // 4. Otherwise, append entry to this’s entry list.
      this[kState].push(entry)
    }
  }

  get [Symbol.toStringTag] () {
    return this.constructor.name
  }

  entries () {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(
      makeIterable(this[kState], 'entries'),
      'FormData'
    )
  }

  keys () {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(
      makeIterable(this[kState], 'keys'),
      'FormData'
    )
  }

  values () {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(
      makeIterable(this[kState], 'values'),
      'FormData'
    )
  }

  /**
   * @param {(value: string, key: string, self: FormData) => void} callbackFn
   * @param {unknown} thisArg
   */
  forEach (callbackFn, thisArg = globalThis) {
    if (!(this instanceof FormData)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'forEach' on 'FormData': 1 argument required, but only ${arguments.length} present.`
      )
    }

    if (typeof callbackFn !== 'function') {
      throw new TypeError(
        "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
      )
    }

    for (const [key, value] of this) {
      callbackFn.apply(thisArg, [value, key, this])
    }
  }
}

FormData.prototype[Symbol.iterator] = FormData.prototype.entries

/**
 * @see https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#create-an-entry
 * @param {string} name
 * @param {string|Blob} value
 * @param {?string} filename
 * @returns
 */
function makeEntry (name, value, filename) {
  // 1. Set name to the result of converting name into a scalar value string.
  // "To convert a string into a scalar value string, replace any surrogates
  //  with U+FFFD."
  // see: https://nodejs.org/dist/latest-v18.x/docs/api/buffer.html#buftostringencoding-start-end
  name = Buffer.from(name).toString('utf8')

  // 2. If value is a string, then set value to the result of converting
  //    value into a scalar value string.
  if (typeof value === 'string') {
    value = Buffer.from(value).toString('utf8')
  } else {
    // 3. Otherwise:

    // 1. If value is not a File object, then set value to a new File object,
    //    representing the same bytes, whose name attribute value is "blob"
    if (!isFileLike(value)) {
      value = value instanceof Blob
        ? new File([value], 'blob', { type: value.type })
        : new FileLike(value, 'blob', { type: value.type })
    }

    // 2. If filename is given, then set value to a new File object,
    //    representing the same bytes, whose name attribute is filename.
    if (filename !== undefined) {
      value = value instanceof File
        ? new File([value], filename, { type: value.type })
        : new FileLike(value, filename, { type: value.type })
    }
  }

  // 4. Return an entry whose name is name and whose value is value.
  return { name, value }
}

function * makeIterable (entries, type) {
  // The value pairs to iterate over are this’s entry list’s entries
  // with the key being the name and the value being the value.
  for (const { name, value } of entries) {
    if (type === 'entries') {
      yield [name, value]
    } else if (type === 'values') {
      yield value
    } else {
      yield name
    }
  }
}

module.exports = { FormData }


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/headers.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/headers.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// https://github.com/Ethan-Arrowood/undici-fetch



const { kHeadersList } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const { kGuard } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { kEnumerableProperty } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const {
  makeIterator,
  isValidHeaderName,
  isValidHeaderValue
} = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")

const kHeadersMap = Symbol('headers map')
const kHeadersSortedMap = Symbol('headers map sorted')

/**
 * @see https://fetch.spec.whatwg.org/#concept-header-value-normalize
 * @param {string} potentialValue
 */
function headerValueNormalize (potentialValue) {
  //  To normalize a byte sequence potentialValue, remove
  //  any leading and trailing HTTP whitespace bytes from
  //  potentialValue.
  return potentialValue.replace(
    /^[\r\n\t ]+|[\r\n\t ]+$/g,
    ''
  )
}

function fill (headers, object) {
  // To fill a Headers object headers with a given object object, run these steps:

  // 1. If object is a sequence, then for each header in object:
  // Note: webidl conversion to array has already been done.
  if (Array.isArray(object)) {
    for (const header of object) {
      // 1. If header does not contain exactly two items, then throw a TypeError.
      if (header.length !== 2) {
        webidl.errors.exception({
          header: 'Headers constructor',
          message: `expected name/value pair to be length 2, found ${header.length}.`
        })
      }

      // 2. Append (header’s first item, header’s second item) to headers.
      headers.append(header[0], header[1])
    }
  } else if (typeof object === 'object' && object !== null) {
    // Note: null should throw

    // 2. Otherwise, object is a record, then for each key → value in object,
    //    append (key, value) to headers
    for (const [key, value] of Object.entries(object)) {
      headers.append(key, value)
    }
  } else {
    webidl.errors.conversionFailed({
      prefix: 'Headers constructor',
      argument: 'Argument 1',
      types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
    })
  }
}

class HeadersList {
  constructor (init) {
    if (init instanceof HeadersList) {
      this[kHeadersMap] = new Map(init[kHeadersMap])
      this[kHeadersSortedMap] = init[kHeadersSortedMap]
    } else {
      this[kHeadersMap] = new Map(init)
      this[kHeadersSortedMap] = null
    }
  }

  // https://fetch.spec.whatwg.org/#header-list-contains
  contains (name) {
    // A header list list contains a header name name if list
    // contains a header whose name is a byte-case-insensitive
    // match for name.
    name = name.toLowerCase()

    return this[kHeadersMap].has(name)
  }

  clear () {
    this[kHeadersMap].clear()
    this[kHeadersSortedMap] = null
  }

  // https://fetch.spec.whatwg.org/#concept-header-list-append
  append (name, value) {
    this[kHeadersSortedMap] = null

    // 1. If list contains name, then set name to the first such
    //    header’s name.
    name = name.toLowerCase()
    const exists = this[kHeadersMap].get(name)

    // 2. Append (name, value) to list.
    if (exists) {
      this[kHeadersMap].set(name, `${exists}, ${value}`)
    } else {
      this[kHeadersMap].set(name, `${value}`)
    }
  }

  // https://fetch.spec.whatwg.org/#concept-header-list-set
  set (name, value) {
    this[kHeadersSortedMap] = null
    name = name.toLowerCase()

    // 1. If list contains name, then set the value of
    //    the first such header to value and remove the
    //    others.
    // 2. Otherwise, append header (name, value) to list.
    return this[kHeadersMap].set(name, value)
  }

  // https://fetch.spec.whatwg.org/#concept-header-list-delete
  delete (name) {
    this[kHeadersSortedMap] = null

    name = name.toLowerCase()
    return this[kHeadersMap].delete(name)
  }

  // https://fetch.spec.whatwg.org/#concept-header-list-get
  get (name) {
    name = name.toLowerCase()

    // 1. If list does not contain name, then return null.
    if (!this.contains(name)) {
      return null
    }

    // 2. Return the values of all headers in list whose name
    //    is a byte-case-insensitive match for name,
    //    separated from each other by 0x2C 0x20, in order.
    return this[kHeadersMap].get(name) ?? null
  }

  has (name) {
    name = name.toLowerCase()
    return this[kHeadersMap].has(name)
  }

  keys () {
    return this[kHeadersMap].keys()
  }

  values () {
    return this[kHeadersMap].values()
  }

  entries () {
    return this[kHeadersMap].entries()
  }

  [Symbol.iterator] () {
    return this[kHeadersMap][Symbol.iterator]()
  }
}

// https://fetch.spec.whatwg.org/#headers-class
class Headers {
  constructor (init = undefined) {
    this[kHeadersList] = new HeadersList()

    // The new Headers(init) constructor steps are:

    // 1. Set this’s guard to "none".
    this[kGuard] = 'none'

    // 2. If init is given, then fill this with init.
    if (init !== undefined) {
      init = webidl.converters.HeadersInit(init)
      fill(this, init)
    }
  }

  get [Symbol.toStringTag] () {
    return this.constructor.name
  }

  // https://fetch.spec.whatwg.org/#dom-headers-append
  append (name, value) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 2) {
      throw new TypeError(
        `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.ByteString(name)
    value = webidl.converters.ByteString(value)

    // 1. Normalize value.
    value = headerValueNormalize(value)

    // 2. If name is not a header name or value is not a
    //    header value, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.append',
        value: name,
        type: 'header name'
      })
    } else if (!isValidHeaderValue(value)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.append',
        value,
        type: 'header value'
      })
    }

    // 3. If headers’s guard is "immutable", then throw a TypeError.
    // 4. Otherwise, if headers’s guard is "request" and name is a
    //    forbidden header name, return.
    // Note: undici does not implement forbidden header names
    if (this[kGuard] === 'immutable') {
      throw new TypeError('immutable')
    } else if (this[kGuard] === 'request-no-cors') {
      // 5. Otherwise, if headers’s guard is "request-no-cors":
      // TODO
    }

    // 6. Otherwise, if headers’s guard is "response" and name is a
    //    forbidden response-header name, return.

    // 7. Append (name, value) to headers’s header list.
    // 8. If headers’s guard is "request-no-cors", then remove
    //    privileged no-CORS request headers from headers
    return this[kHeadersList].append(name, value)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-delete
  delete (name) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.delete',
        value: name,
        type: 'header name'
      })
    }

    // 2. If this’s guard is "immutable", then throw a TypeError.
    // 3. Otherwise, if this’s guard is "request" and name is a
    //    forbidden header name, return.
    // 4. Otherwise, if this’s guard is "request-no-cors", name
    //    is not a no-CORS-safelisted request-header name, and
    //    name is not a privileged no-CORS request-header name,
    //    return.
    // 5. Otherwise, if this’s guard is "response" and name is
    //    a forbidden response-header name, return.
    // Note: undici does not implement forbidden header names
    if (this[kGuard] === 'immutable') {
      throw new TypeError('immutable')
    } else if (this[kGuard] === 'request-no-cors') {
      // TODO
    }

    // 6. If this’s header list does not contain name, then
    //    return.
    if (!this[kHeadersList].contains(name)) {
      return
    }

    // 7. Delete name from this’s header list.
    // 8. If this’s guard is "request-no-cors", then remove
    //    privileged no-CORS request headers from this.
    return this[kHeadersList].delete(name)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-get
  get (name) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.get',
        value: name,
        type: 'header name'
      })
    }

    // 2. Return the result of getting name from this’s header
    //    list.
    return this[kHeadersList].get(name)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-has
  has (name) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.ByteString(name)

    // 1. If name is not a header name, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.has',
        value: name,
        type: 'header name'
      })
    }

    // 2. Return true if this’s header list contains name;
    //    otherwise false.
    return this[kHeadersList].contains(name)
  }

  // https://fetch.spec.whatwg.org/#dom-headers-set
  set (name, value) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 2) {
      throw new TypeError(
        `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
      )
    }

    name = webidl.converters.ByteString(name)
    value = webidl.converters.ByteString(value)

    // 1. Normalize value.
    value = headerValueNormalize(value)

    // 2. If name is not a header name or value is not a
    //    header value, then throw a TypeError.
    if (!isValidHeaderName(name)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.set',
        value: name,
        type: 'header name'
      })
    } else if (!isValidHeaderValue(value)) {
      webidl.errors.invalidArgument({
        prefix: 'Headers.set',
        value,
        type: 'header value'
      })
    }

    // 3. If this’s guard is "immutable", then throw a TypeError.
    // 4. Otherwise, if this’s guard is "request" and name is a
    //    forbidden header name, return.
    // 5. Otherwise, if this’s guard is "request-no-cors" and
    //    name/value is not a no-CORS-safelisted request-header,
    //    return.
    // 6. Otherwise, if this’s guard is "response" and name is a
    //    forbidden response-header name, return.
    // Note: undici does not implement forbidden header names
    if (this[kGuard] === 'immutable') {
      throw new TypeError('immutable')
    } else if (this[kGuard] === 'request-no-cors') {
      // TODO
    }

    // 7. Set (name, value) in this’s header list.
    // 8. If this’s guard is "request-no-cors", then remove
    //    privileged no-CORS request headers from this
    return this[kHeadersList].set(name, value)
  }

  get [kHeadersSortedMap] () {
    this[kHeadersList][kHeadersSortedMap] ??= new Map([...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1))
    return this[kHeadersList][kHeadersSortedMap]
  }

  keys () {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(this[kHeadersSortedMap].keys(), 'Headers')
  }

  values () {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(this[kHeadersSortedMap].values(), 'Headers')
  }

  entries () {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    return makeIterator(this[kHeadersSortedMap].entries(), 'Headers')
  }

  /**
   * @param {(value: string, key: string, self: Headers) => void} callbackFn
   * @param {unknown} thisArg
   */
  forEach (callbackFn, thisArg = globalThis) {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`
      )
    }

    if (typeof callbackFn !== 'function') {
      throw new TypeError(
        "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
      )
    }

    for (const [key, value] of this) {
      callbackFn.apply(thisArg, [value, key, this])
    }
  }

  [Symbol.for('nodejs.util.inspect.custom')] () {
    if (!(this instanceof Headers)) {
      throw new TypeError('Illegal invocation')
    }

    return this[kHeadersList]
  }
}

Headers.prototype[Symbol.iterator] = Headers.prototype.entries

Object.defineProperties(Headers.prototype, {
  append: kEnumerableProperty,
  delete: kEnumerableProperty,
  get: kEnumerableProperty,
  has: kEnumerableProperty,
  set: kEnumerableProperty,
  keys: kEnumerableProperty,
  values: kEnumerableProperty,
  entries: kEnumerableProperty,
  forEach: kEnumerableProperty
})

webidl.converters.HeadersInit = function (V) {
  if (webidl.util.Type(V) === 'Object') {
    if (V[Symbol.iterator]) {
      return webidl.converters['sequence<sequence<ByteString>>'](V)
    }

    return webidl.converters['record<ByteString, ByteString>'](V)
  }

  webidl.errors.conversionFailed({
    prefix: 'Headers constructor',
    argument: 'Argument 1',
    types: ['sequence<sequence<ByteString>>', 'record<ByteString, ByteString>']
  })
}

module.exports = {
  fill,
  Headers,
  HeadersList
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/index.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// https://github.com/Ethan-Arrowood/undici-fetch



const {
  Response,
  makeNetworkError,
  makeAppropriateNetworkError,
  filterResponse,
  makeResponse
} = __webpack_require__(/*! ./response */ "../../node_modules/undici/lib/fetch/response.js")
const { Headers } = __webpack_require__(/*! ./headers */ "../../node_modules/undici/lib/fetch/headers.js")
const { Request, makeRequest } = __webpack_require__(/*! ./request */ "../../node_modules/undici/lib/fetch/request.js")
const zlib = __webpack_require__(/*! zlib */ "zlib")
const {
  matchRequestIntegrity,
  makePolicyContainer,
  clonePolicyContainer,
  requestBadPort,
  TAOCheck,
  appendRequestOriginHeader,
  responseLocationURL,
  requestCurrentURL,
  setRequestReferrerPolicyOnRedirect,
  tryUpgradeRequestToAPotentiallyTrustworthyURL,
  createOpaqueTimingInfo,
  appendFetchMetadata,
  corsCheck,
  crossOriginResourcePolicyCheck,
  determineRequestsReferrer,
  coarsenedSharedCurrentTime,
  createDeferredPromise,
  isBlobLike,
  sameOrigin,
  isCancelled,
  isAborted
} = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const assert = __webpack_require__(/*! assert */ "assert")
const { safelyExtractBody, extractBody } = __webpack_require__(/*! ./body */ "../../node_modules/undici/lib/fetch/body.js")
const {
  redirectStatus,
  nullBodyStatus,
  safeMethods,
  requestBodyHeader,
  subresource,
  DOMException
} = __webpack_require__(/*! ./constants */ "../../node_modules/undici/lib/fetch/constants.js")
const { kHeadersList } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const EE = __webpack_require__(/*! events */ "events")
const { Readable, pipeline } = __webpack_require__(/*! stream */ "stream")
const { isErrored, isReadable } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { dataURLProcessor } = __webpack_require__(/*! ./dataURL */ "../../node_modules/undici/lib/fetch/dataURL.js")
const { TransformStream } = __webpack_require__(/*! stream/web */ "stream/web")

/** @type {import('buffer').resolveObjectURL} */
let resolveObjectURL
let ReadableStream

const nodeVersion = process.versions.node.split('.')
const nodeMajor = Number(nodeVersion[0])
const nodeMinor = Number(nodeVersion[1])

class Fetch extends EE {
  constructor (dispatcher) {
    super()

    this.dispatcher = dispatcher
    this.connection = null
    this.dump = false
    this.state = 'ongoing'
  }

  terminate (reason) {
    if (this.state !== 'ongoing') {
      return
    }

    this.state = 'terminated'
    this.connection?.destroy(reason)
    this.emit('terminated', reason)
  }

  abort () {
    if (this.state !== 'ongoing') {
      return
    }

    const reason = new DOMException('The operation was aborted.', 'AbortError')

    this.state = 'aborted'
    this.connection?.destroy(reason)
    this.emit('terminated', reason)
  }
}

// https://fetch.spec.whatwg.org/#fetch-method
async function fetch (input, init = {}) {
  if (arguments.length < 1) {
    throw new TypeError(
      `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${arguments.length} present.`
    )
  }

  // 1. Let p be a new promise.
  const p = createDeferredPromise()

  // 2. Let requestObject be the result of invoking the initial value of
  // Request as constructor with input and init as arguments. If this throws
  // an exception, reject p with it and return p.
  let requestObject

  try {
    requestObject = new Request(input, init)
  } catch (e) {
    p.reject(e)
    return p.promise
  }

  // 3. Let request be requestObject’s request.
  const request = requestObject[kState]

  // 4. If requestObject’s signal’s aborted flag is set, then:
  if (requestObject.signal.aborted) {
    // 1. Abort fetch with p, request, and null.
    abortFetch(p, request, null)

    // 2. Return p.
    return p.promise
  }

  // 5. Let globalObject be request’s client’s global object.
  const globalObject = request.client.globalObject

  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set
  // request’s service-workers mode to "none".
  if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
    request.serviceWorkers = 'none'
  }

  // 7. Let responseObject be null.
  let responseObject = null

  // 8. Let relevantRealm be this’s relevant Realm.
  const relevantRealm = null

  // 9. Let locallyAborted be false.
  let locallyAborted = false

  // 10. Let controller be null.
  let controller = null

  // 11. Add the following abort steps to requestObject’s signal:
  requestObject.signal.addEventListener(
    'abort',
    () => {
      // 1. Set locallyAborted to true.
      locallyAborted = true

      // 2. Abort fetch with p, request, and responseObject.
      abortFetch(p, request, responseObject)

      // 3. If controller is not null, then abort controller.
      if (controller != null) {
        controller.abort()
      }
    },
    { once: true }
  )

  // 12. Let handleFetchDone given response response be to finalize and
  // report timing with response, globalObject, and "fetch".
  const handleFetchDone = (response) =>
    finalizeAndReportTiming(response, 'fetch')

  // 13. Set controller to the result of calling fetch given request,
  // with processResponseEndOfBody set to handleFetchDone, and processResponse
  // given response being these substeps:

  const processResponse = (response) => {
    // 1. If locallyAborted is true, terminate these substeps.
    if (locallyAborted) {
      return
    }

    // 2. If response’s aborted flag is set, then abort fetch with p,
    // request, and responseObject, and terminate these substeps.
    if (response.aborted) {
      abortFetch(p, request, responseObject)
      return
    }

    // 3. If response is a network error, then reject p with a TypeError
    // and terminate these substeps.
    if (response.type === 'error') {
      p.reject(
        Object.assign(new TypeError('fetch failed'), { cause: response.error })
      )
      return
    }

    // 4. Set responseObject to the result of creating a Response object,
    // given response, "immutable", and relevantRealm.
    responseObject = new Response()
    responseObject[kState] = response
    responseObject[kRealm] = relevantRealm
    responseObject[kHeaders][kHeadersList] = response.headersList
    responseObject[kHeaders][kGuard] = 'immutable'
    responseObject[kHeaders][kRealm] = relevantRealm

    // 5. Resolve p with responseObject.
    p.resolve(responseObject)
  }

  controller = fetching({
    request,
    processResponseEndOfBody: handleFetchDone,
    processResponse,
    dispatcher: this // undici
  })

  // 14. Return p.
  return p.promise
}

// https://fetch.spec.whatwg.org/#finalize-and-report-timing
function finalizeAndReportTiming (response, initiatorType = 'other') {
  // 1. If response is an aborted network error, then return.
  if (response.type === 'error' && response.aborted) {
    return
  }

  // 2. If response’s URL list is null or empty, then return.
  if (!response.urlList?.length) {
    return
  }

  // 3. Let originalURL be response’s URL list[0].
  const originalURL = response.urlList[0]

  // 4. Let timingInfo be response’s timing info.
  let timingInfo = response.timingInfo

  // 5. Let cacheState be response’s cache state.
  let cacheState = response.cacheState

  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.
  if (!/^https?:/.test(originalURL.protocol)) {
    return
  }

  // 7. If timingInfo is null, then return.
  if (timingInfo === null) {
    return
  }

  // 8. If response’s timing allow passed flag is not set, then:
  if (!timingInfo.timingAllowPassed) {
    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.
    timingInfo = createOpaqueTimingInfo({
      startTime: timingInfo.startTime
    })

    //  2. Set cacheState to the empty string.
    cacheState = ''
  }

  // 9. Set timingInfo’s end time to the coarsened shared current time
  // given global’s relevant settings object’s cross-origin isolated
  // capability.
  // TODO: given global’s relevant settings object’s cross-origin isolated
  // capability?
  response.timingInfo.endTime = coarsenedSharedCurrentTime()

  // 10. Set response’s timing info to timingInfo.
  response.timingInfo = timingInfo

  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,
  // global, and cacheState.
  markResourceTiming(
    timingInfo,
    originalURL,
    initiatorType,
    globalThis,
    cacheState
  )
}

// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing
function markResourceTiming (timingInfo, originalURL, initiatorType, globalThis, cacheState) {
  if (nodeMajor >= 18 && nodeMinor >= 2) {
    performance.markResourceTiming(timingInfo, originalURL, initiatorType, globalThis, cacheState)
  }
}

// https://fetch.spec.whatwg.org/#abort-fetch
function abortFetch (p, request, responseObject) {
  // 1. Let error be an "AbortError" DOMException.
  const error = new DOMException('The operation was aborted.', 'AbortError')

  // 2. Reject promise with error.
  p.reject(error)

  // 3. If request’s body is not null and is readable, then cancel request’s
  // body with error.
  if (request.body != null && isReadable(request.body?.stream)) {
    request.body.stream.cancel(error).catch((err) => {
      if (err.code === 'ERR_INVALID_STATE') {
        // Node bug?
        return
      }
      throw err
    })
  }

  // 4. If responseObject is null, then return.
  if (responseObject == null) {
    return
  }

  // 5. Let response be responseObject’s response.
  const response = responseObject[kState]

  // 6. If response’s body is not null and is readable, then error response’s
  // body with error.
  if (response.body != null && isReadable(response.body?.stream)) {
    response.body.stream.cancel(error).catch((err) => {
      if (err.code === 'ERR_INVALID_STATE') {
        // Node bug?
        return
      }
      throw err
    })
  }
}

// https://fetch.spec.whatwg.org/#fetching
function fetching ({
  request,
  processRequestBodyChunkLength,
  processRequestEndOfBody,
  processResponse,
  processResponseEndOfBody,
  processResponseConsumeBody,
  useParallelQueue = false,
  dispatcher // undici
}) {
  // 1. Let taskDestination be null.
  let taskDestination = null

  // 2. Let crossOriginIsolatedCapability be false.
  let crossOriginIsolatedCapability = false

  // 3. If request’s client is non-null, then:
  if (request.client != null) {
    // 1. Set taskDestination to request’s client’s global object.
    taskDestination = request.client.globalObject

    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin
    // isolated capability.
    crossOriginIsolatedCapability =
      request.client.crossOriginIsolatedCapability
  }

  // 4. If useParallelQueue is true, then set taskDestination to the result of
  // starting a new parallel queue.
  // TODO

  // 5. Let timingInfo be a new fetch timing info whose start time and
  // post-redirect start time are the coarsened shared current time given
  // crossOriginIsolatedCapability.
  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)
  const timingInfo = createOpaqueTimingInfo({
    startTime: currenTime
  })

  // 6. Let fetchParams be a new fetch params whose
  // request is request,
  // timing info is timingInfo,
  // process request body chunk length is processRequestBodyChunkLength,
  // process request end-of-body is processRequestEndOfBody,
  // process response is processResponse,
  // process response consume body is processResponseConsumeBody,
  // process response end-of-body is processResponseEndOfBody,
  // task destination is taskDestination,
  // and cross-origin isolated capability is crossOriginIsolatedCapability.
  const fetchParams = {
    controller: new Fetch(dispatcher),
    request,
    timingInfo,
    processRequestBodyChunkLength,
    processRequestEndOfBody,
    processResponse,
    processResponseConsumeBody,
    processResponseEndOfBody,
    taskDestination,
    crossOriginIsolatedCapability
  }

  // 7. If request’s body is a byte sequence, then set request’s body to the
  // first return value of safely extracting request’s body.
  // NOTE: Since fetching is only called from fetch, body should already be
  // extracted.
  assert(!request.body || request.body.stream)

  // 8. If request’s window is "client", then set request’s window to request’s
  // client, if request’s client’s global object is a Window object; otherwise
  // "no-window".
  if (request.window === 'client') {
    // TODO: What if request.client is null?
    request.window =
      request.client?.globalObject?.constructor?.name === 'Window'
        ? request.client
        : 'no-window'
  }

  // 9. If request’s origin is "client", then set request’s origin to request’s
  // client’s origin.
  if (request.origin === 'client') {
    // TODO: What if request.client is null?
    request.origin = request.client?.origin
  }

  // 10. If all of the following conditions are true:
  // TODO

  // 11. If request’s policy container is "client", then:
  if (request.policyContainer === 'client') {
    // 1. If request’s client is non-null, then set request’s policy
    // container to a clone of request’s client’s policy container. [HTML]
    if (request.client != null) {
      request.policyContainer = clonePolicyContainer(
        request.client.policyContainer
      )
    } else {
      // 2. Otherwise, set request’s policy container to a new policy
      // container.
      request.policyContainer = makePolicyContainer()
    }
  }

  // 12. If request’s header list does not contain `Accept`, then:
  if (!request.headersList.has('accept')) {
    // 1. Let value be `*/*`.
    const value = '*/*'

    // 2. A user agent should set value to the first matching statement, if
    // any, switching on request’s destination:
    // "document"
    // "frame"
    // "iframe"
    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`
    // "image"
    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`
    // "style"
    // `text/css,*/*;q=0.1`
    // TODO

    // 3. Append `Accept`/value to request’s header list.
    request.headersList.append('accept', value)
  }

  // 13. If request’s header list does not contain `Accept-Language`, then
  // user agents should append `Accept-Language`/an appropriate value to
  // request’s header list.
  if (!request.headersList.has('accept-language')) {
    request.headersList.append('accept-language', '*')
  }

  // 14. If request’s priority is null, then use request’s initiator and
  // destination appropriately in setting request’s priority to a
  // user-agent-defined object.
  if (request.priority === null) {
    // TODO
  }

  // 15. If request is a subresource request, then:
  if (subresource.includes(request.destination)) {
    // TODO
  }

  // 16. Run main fetch given fetchParams.
  mainFetch(fetchParams)
    .catch(err => {
      fetchParams.controller.terminate(err)
    })

  // 17. Return fetchParam's controller
  return fetchParams.controller
}

// https://fetch.spec.whatwg.org/#concept-main-fetch
async function mainFetch (fetchParams, recursive = false) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. If request’s local-URLs-only flag is set and request’s current URL is
  // not local, then set response to a network error.
  if (
    request.localURLsOnly &&
    !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)
  ) {
    response = makeNetworkError('local URLs only')
  }

  // 4. Run report Content Security Policy violations for request.
  // TODO

  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.
  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)

  // 6. If should request be blocked due to a bad port, should fetching request
  // be blocked as mixed content, or should request be blocked by Content
  // Security Policy returns blocked, then set response to a network error.
  if (requestBadPort(request) === 'blocked') {
    response = makeNetworkError('bad port')
  }
  // TODO: should fetching request be blocked as mixed content?
  // TODO: should request be blocked by Content Security Policy?

  // 7. If request’s referrer policy is the empty string, then set request’s
  // referrer policy to request’s policy container’s referrer policy.
  if (request.referrerPolicy === '') {
    request.referrerPolicy = request.policyContainer.referrerPolicy
  }

  // 8. If request’s referrer is not "no-referrer", then set request’s
  // referrer to the result of invoking determine request’s referrer.
  if (request.referrer !== 'no-referrer') {
    request.referrer = determineRequestsReferrer(request)
  }

  // 9. Set request’s current URL’s scheme to "https" if all of the following
  // conditions are true:
  // - request’s current URL’s scheme is "http"
  // - request’s current URL’s host is a domain
  // - Matching request’s current URL’s host per Known HSTS Host Domain Name
  //   Matching results in either a superdomain match with an asserted
  //   includeSubDomains directive or a congruent match (with or without an
  //   asserted includeSubDomains directive). [HSTS]
  // TODO

  // 10. If recursive is false, then run the remaining steps in parallel.
  // TODO

  // 11. If response is null, then set response to the result of running
  // the steps corresponding to the first matching statement:
  if (response === null) {
    response = await (async () => {
      const currentURL = requestCurrentURL(request)

      if (
        // - request’s current URL’s origin is same origin with request’s origin,
        //   and request’s response tainting is "basic"
        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||
        // request’s current URL’s scheme is "data"
        (currentURL.protocol === 'data:') ||
        // - request’s mode is "navigate" or "websocket"
        (request.mode === 'navigate' || request.mode === 'websocket')
      ) {
        // 1. Set request’s response tainting to "basic".
        request.responseTainting = 'basic'

        // 2. Return the result of running scheme fetch given fetchParams.
        return await schemeFetch(fetchParams)
      }

      // request’s mode is "same-origin"
      if (request.mode === 'same-origin') {
        // 1. Return a network error.
        return makeNetworkError('request mode cannot be "same-origin"')
      }

      // request’s mode is "no-cors"
      if (request.mode === 'no-cors') {
        // 1. If request’s redirect mode is not "follow", then return a network
        // error.
        if (request.redirect !== 'follow') {
          return makeNetworkError(
            'redirect mode cannot be "follow" for "no-cors" request'
          )
        }

        // 2. Set request’s response tainting to "opaque".
        request.responseTainting = 'opaque'

        // 3. Return the result of running scheme fetch given fetchParams.
        return await schemeFetch(fetchParams)
      }

      // request’s current URL’s scheme is not an HTTP(S) scheme
      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {
        // Return a network error.
        return makeNetworkError('URL scheme must be a HTTP(S) scheme')
      }

      // - request’s use-CORS-preflight flag is set
      // - request’s unsafe-request flag is set and either request’s method is
      //   not a CORS-safelisted method or CORS-unsafe request-header names with
      //   request’s header list is not empty
      //    1. Set request’s response tainting to "cors".
      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch
      //    given fetchParams and true.
      //    3. If corsWithPreflightResponse is a network error, then clear cache
      //    entries using request.
      //    4. Return corsWithPreflightResponse.
      // TODO

      // Otherwise
      //    1. Set request’s response tainting to "cors".
      request.responseTainting = 'cors'

      //    2. Return the result of running HTTP fetch given fetchParams.
      return await httpFetch(fetchParams)
    })()
  }

  // 12. If recursive is true, then return response.
  if (recursive) {
    return response
  }

  // 13. If response is not a network error and response is not a filtered
  // response, then:
  if (response.status !== 0 && !response.internalResponse) {
    // If request’s response tainting is "cors", then:
    if (request.responseTainting === 'cors') {
      // 1. Let headerNames be the result of extracting header list values
      // given `Access-Control-Expose-Headers` and response’s header list.
      // TODO
      // 2. If request’s credentials mode is not "include" and headerNames
      // contains `*`, then set response’s CORS-exposed header-name list to
      // all unique header names in response’s header list.
      // TODO
      // 3. Otherwise, if headerNames is not null or failure, then set
      // response’s CORS-exposed header-name list to headerNames.
      // TODO
    }

    // Set response to the following filtered response with response as its
    // internal response, depending on request’s response tainting:
    if (request.responseTainting === 'basic') {
      response = filterResponse(response, 'basic')
    } else if (request.responseTainting === 'cors') {
      response = filterResponse(response, 'cors')
    } else if (request.responseTainting === 'opaque') {
      response = filterResponse(response, 'opaque')
    } else {
      assert(false)
    }
  }

  // 14. Let internalResponse be response, if response is a network error,
  // and response’s internal response otherwise.
  let internalResponse =
    response.status === 0 ? response : response.internalResponse

  // 15. If internalResponse’s URL list is empty, then set it to a clone of
  // request’s URL list.
  if (internalResponse.urlList.length === 0) {
    internalResponse.urlList.push(...request.urlList)
  }

  // 16. If request’s timing allow failed flag is unset, then set
  // internalResponse’s timing allow passed flag.
  if (!request.timingAllowFailed) {
    response.timingAllowPassed = true
  }

  // 17. If response is not a network error and any of the following returns
  // blocked
  // - should internalResponse to request be blocked as mixed content
  // - should internalResponse to request be blocked by Content Security Policy
  // - should internalResponse to request be blocked due to its MIME type
  // - should internalResponse to request be blocked due to nosniff
  // TODO

  // 18. If response’s type is "opaque", internalResponse’s status is 206,
  // internalResponse’s range-requested flag is set, and request’s header
  // list does not contain `Range`, then set response and internalResponse
  // to a network error.
  if (
    response.type === 'opaque' &&
    internalResponse.status === 206 &&
    internalResponse.rangeRequested &&
    !request.headers.has('range')
  ) {
    response = internalResponse = makeNetworkError()
  }

  // 19. If response is not a network error and either request’s method is
  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,
  // set internalResponse’s body to null and disregard any enqueuing toward
  // it (if any).
  if (
    response.status !== 0 &&
    (request.method === 'HEAD' ||
      request.method === 'CONNECT' ||
      nullBodyStatus.includes(internalResponse.status))
  ) {
    internalResponse.body = null
    fetchParams.controller.dump = true
  }

  // 20. If request’s integrity metadata is not the empty string, then:
  if (request.integrity) {
    // 1. Let processBodyError be this step: run fetch finale given fetchParams
    // and a network error.
    const processBodyError = (reason) =>
      fetchFinale(fetchParams, makeNetworkError(reason))

    // 2. If request’s response tainting is "opaque", or response’s body is null,
    // then run processBodyError and abort these steps.
    if (request.responseTainting === 'opaque' || response.body == null) {
      processBodyError(response.error)
      return
    }

    // 3. Let processBody given bytes be these steps:
    const processBody = (bytes) => {
      // 1. If bytes do not match request’s integrity metadata,
      // then run processBodyError and abort these steps. [SRI]
      if (!matchRequestIntegrity(request, bytes)) {
        processBodyError('integrity mismatch')
        return
      }

      // 2. Set response’s body to the first return value of safely
      // extracting bytes.
      response.body = safelyExtractBody(bytes)[0]

      // 3. Run fetch finale given fetchParams and response.
      fetchFinale(fetchParams, response)
    }

    // 4. Fully read response’s body given processBody and processBodyError.
    try {
      processBody(await response.arrayBuffer())
    } catch (err) {
      processBodyError(err)
    }
  } else {
    // 21. Otherwise, run fetch finale given fetchParams and response.
    fetchFinale(fetchParams, response)
  }
}

// https://fetch.spec.whatwg.org/#concept-scheme-fetch
// given a fetch params fetchParams
async function schemeFetch (fetchParams) {
  // let request be fetchParams’s request
  const { request } = fetchParams

  const {
    protocol: scheme,
    pathname: path
  } = requestCurrentURL(request)

  // switch on request’s current URL’s scheme, and run the associated steps:
  switch (scheme) {
    case 'about:': {
      // If request’s current URL’s path is the string "blank", then return a new response
      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) »,
      // and body is the empty byte sequence.
      if (path === 'blank') {
        const resp = makeResponse({
          statusText: 'OK',
          headersList: [
            ['content-type', 'text/html;charset=utf-8']
          ]
        })

        resp.urlList = [new URL('about:blank')]
        return resp
      }

      // Otherwise, return a network error.
      return makeNetworkError('invalid path called')
    }
    case 'blob:': {
      resolveObjectURL = resolveObjectURL || (__webpack_require__(/*! buffer */ "buffer").resolveObjectURL)

      // 1. Run these steps, but abort when the ongoing fetch is terminated:
      //    1. Let blob be request’s current URL’s blob URL entry’s object.
      //       https://w3c.github.io/FileAPI/#blob-url-entry
      //       P.S. Thank God this method is available in node.
      const currentURL = requestCurrentURL(request)

      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56
      // Buffer.resolveObjectURL does not ignore URL queries.
      if (currentURL.search.length !== 0) {
        return makeNetworkError('NetworkError when attempting to fetch resource.')
      }

      const blob = resolveObjectURL(currentURL.toString())

      //    2. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]
      if (request.method !== 'GET' || !isBlobLike(blob)) {
        return makeNetworkError('invalid method')
      }

      //    3. Let response be a new response whose status message is `OK`.
      const response = makeResponse({ statusText: 'OK', urlList: [currentURL] })

      //    4. Append (`Content-Length`, blob’s size attribute value) to response’s header list.
      response.headersList.set('content-length', `${blob.size}`)

      //    5. Append (`Content-Type`, blob’s type attribute value) to response’s header list.
      response.headersList.set('content-type', blob.type)

      //    6. Set response’s body to the result of performing the read operation on blob.
      // TODO (fix): This needs to read?
      response.body = extractBody(blob)[0]

      //    7. Return response.
      return response

      // 2. If aborted, then return the appropriate network error for fetchParams.
      // TODO
    }
    case 'data:': {
      // 1. Let dataURLStruct be the result of running the
      //    data: URL processor on request’s current URL.
      const currentURL = requestCurrentURL(request)
      const dataURLStruct = dataURLProcessor(currentURL)

      // 2. If dataURLStruct is failure, then return a
      //    network error.
      if (dataURLStruct === 'failure') {
        return makeNetworkError('failed to fetch the data URL')
      }

      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.
      const { mimeType } = dataURLStruct

      /** @type {string} */
      let contentType = `${mimeType.type}/${mimeType.subtype}`
      const contentTypeParams = []

      if (mimeType.parameters.size > 0) {
        contentType += ';'
      }

      for (const [key, value] of mimeType.parameters) {
        if (value.length > 0) {
          contentTypeParams.push(`${key}=${value}`)
        } else {
          contentTypeParams.push(key)
        }
      }

      contentType += contentTypeParams.join(',')

      // 4. Return a response whose status message is `OK`,
      //    header list is « (`Content-Type`, mimeType) »,
      //    and body is dataURLStruct’s body.
      return makeResponse({
        statusText: 'OK',
        headersList: [
          ['content-type', contentType]
        ],
        body: extractBody(dataURLStruct.body)[0]
      })
    }
    case 'file:': {
      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.
      // When in doubt, return a network error.
      return makeNetworkError('not implemented... yet...')
    }
    case 'http:':
    case 'https:': {
      // Return the result of running HTTP fetch given fetchParams.

      return await httpFetch(fetchParams)
        .catch((err) => makeNetworkError(err))
    }
    default: {
      return makeNetworkError('unknown scheme')
    }
  }
}

// https://fetch.spec.whatwg.org/#finalize-response
function finalizeResponse (fetchParams, response) {
  // 1. Set fetchParams’s request’s done flag.
  fetchParams.request.done = true

  // 2, If fetchParams’s process response done is not null, then queue a fetch
  // task to run fetchParams’s process response done given response, with
  // fetchParams’s task destination.
  if (fetchParams.processResponseDone != null) {
    queueMicrotask(() => fetchParams.processResponseDone(response))
  }
}

// https://fetch.spec.whatwg.org/#fetch-finale
async function fetchFinale (fetchParams, response) {
  // 1. If response is a network error, then:
  if (response.type === 'error') {
    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».
    response.urlList = [fetchParams.request.urlList[0]]

    // 2. Set response’s timing info to the result of creating an opaque timing
    // info for fetchParams’s timing info.
    response.timingInfo = createOpaqueTimingInfo({
      startTime: fetchParams.timingInfo.startTime
    })
  }

  // 2. Let processResponseEndOfBody be the following steps:
  const processResponseEndOfBody = () => {
    // 1. Set fetchParams’s request’s done flag.
    fetchParams.request.done = true

    // If fetchParams’s process response end-of-body is not null,
    // then queue a fetch task to run fetchParams’s process response
    // end-of-body given response with fetchParams’s task destination.
    if (fetchParams.processResponseEndOfBody != null) {
      queueMicrotask(() => fetchParams.processResponseEndOfBody(response))
    }
  }

  // 3. If fetchParams’s process response is non-null, then queue a fetch task
  // to run fetchParams’s process response given response, with fetchParams’s
  // task destination.
  if (fetchParams.processResponse != null) {
    queueMicrotask(() => fetchParams.processResponse(response))
  }

  // 4. If response’s body is null, then run processResponseEndOfBody.
  if (response.body == null) {
    processResponseEndOfBody()
  } else {
  // 5. Otherwise:

    // 1. Let transformStream be a new a TransformStream.

    // 2. Let identityTransformAlgorithm be an algorithm which, given chunk,
    // enqueues chunk in transformStream.
    const identityTransformAlgorithm = (chunk, controller) => {
      controller.enqueue(chunk)
    }

    // 3. Set up transformStream with transformAlgorithm set to identityTransformAlgorithm
    // and flushAlgorithm set to processResponseEndOfBody.
    const transformStream = new TransformStream({
      start () {},
      transform: identityTransformAlgorithm,
      flush: processResponseEndOfBody
    })

    // 4. Set response’s body to the result of piping response’s body through transformStream.
    response.body = { stream: response.body.stream.pipeThrough(transformStream) }
  }

  // 6. If fetchParams’s process response consume body is non-null, then:
  if (fetchParams.processResponseConsumeBody != null) {
    // 1. Let processBody given nullOrBytes be this step: run fetchParams’s
    // process response consume body given response and nullOrBytes.
    const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes)

    // 2. Let processBodyError be this step: run fetchParams’s process
    // response consume body given response and failure.
    const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure)

    // 3. If response’s body is null, then queue a fetch task to run processBody
    // given null, with fetchParams’s task destination.
    if (response.body == null) {
      queueMicrotask(() => processBody(null))
    } else {
      // 4. Otherwise, fully read response’s body given processBody, processBodyError,
      // and fetchParams’s task destination.
      try {
        processBody(await response.body.stream.arrayBuffer())
      } catch (err) {
        processBodyError(err)
      }
    }
  }
}

// https://fetch.spec.whatwg.org/#http-fetch
async function httpFetch (fetchParams) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. Let actualResponse be null.
  let actualResponse = null

  // 4. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 5. If request’s service-workers mode is "all", then:
  if (request.serviceWorkers === 'all') {
    // TODO
  }

  // 6. If response is null, then:
  if (response === null) {
    // 1. If makeCORSPreflight is true and one of these conditions is true:
    // TODO

    // 2. If request’s redirect mode is "follow", then set request’s
    // service-workers mode to "none".
    if (request.redirect === 'follow') {
      request.serviceWorkers = 'none'
    }

    // 3. Set response and actualResponse to the result of running
    // HTTP-network-or-cache fetch given fetchParams.
    actualResponse = response = await httpNetworkOrCacheFetch(fetchParams)

    // 4. If request’s response tainting is "cors" and a CORS check
    // for request and response returns failure, then return a network error.
    if (
      request.responseTainting === 'cors' &&
      corsCheck(request, response) === 'failure'
    ) {
      return makeNetworkError('cors failure')
    }

    // 5. If the TAO check for request and response returns failure, then set
    // request’s timing allow failed flag.
    if (TAOCheck(request, response) === 'failure') {
      request.timingAllowFailed = true
    }
  }

  // 7. If either request’s response tainting or response’s type
  // is "opaque", and the cross-origin resource policy check with
  // request’s origin, request’s client, request’s destination,
  // and actualResponse returns blocked, then return a network error.
  if (
    (request.responseTainting === 'opaque' || response.type === 'opaque') &&
    crossOriginResourcePolicyCheck(
      request.origin,
      request.client,
      request.destination,
      actualResponse
    ) === 'blocked'
  ) {
    return makeNetworkError('blocked')
  }

  // 8. If actualResponse’s status is a redirect status, then:
  if (redirectStatus.includes(actualResponse.status)) {
    // 1. If actualResponse’s status is not 303, request’s body is not null,
    // and the connection uses HTTP/2, then user agents may, and are even
    // encouraged to, transmit an RST_STREAM frame.
    // See, https://github.com/whatwg/fetch/issues/1288
    fetchParams.controller.connection.destroy()

    // 2. Switch on request’s redirect mode:
    if (request.redirect === 'error') {
      // Set response to a network error.
      response = makeNetworkError('unexpected redirect')
    } else if (request.redirect === 'manual') {
      // Set response to an opaque-redirect filtered response whose internal
      // response is actualResponse.
      // NOTE(spec): On the web this would return an `opaqueredirect` response,
      // but that doesn't make sense server side.
      // See https://github.com/nodejs/undici/issues/1193.
      response = actualResponse
    } else if (request.redirect === 'follow') {
      // Set response to the result of running HTTP-redirect fetch given
      // fetchParams and response.
      response = await httpRedirectFetch(fetchParams, response)
    } else {
      assert(false)
    }
  }

  // 9. Set response’s timing info to timingInfo.
  response.timingInfo = timingInfo

  // 10. Return response.
  return response
}

// https://fetch.spec.whatwg.org/#http-redirect-fetch
async function httpRedirectFetch (fetchParams, response) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let actualResponse be response, if response is not a filtered response,
  // and response’s internal response otherwise.
  const actualResponse = response.internalResponse
    ? response.internalResponse
    : response

  // 3. Let locationURL be actualResponse’s location URL given request’s current
  // URL’s fragment.
  let locationURL

  try {
    locationURL = responseLocationURL(
      actualResponse,
      requestCurrentURL(request).hash
    )

    // 4. If locationURL is null, then return response.
    if (locationURL == null) {
      return response
    }
  } catch (err) {
    // 5. If locationURL is failure, then return a network error.
    return makeNetworkError(err)
  }

  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network
  // error.
  if (!/^https?:/.test(locationURL.protocol)) {
    return makeNetworkError('URL scheme must be a HTTP(S) scheme')
  }

  // 7. If request’s redirect count is twenty, return a network error.
  if (request.redirectCount === 20) {
    return makeNetworkError('redirect count exceeded')
  }

  // 8. Increase request’s redirect count by one.
  request.redirectCount += 1

  // 9. If request’s mode is "cors", locationURL includes credentials, and
  // request’s origin is not same origin with locationURL’s origin, then return
  //  a network error.
  if (
    request.mode === 'cors' &&
    (locationURL.username || locationURL.password) &&
    !sameOrigin(request, locationURL)
  ) {
    return makeNetworkError('cross origin not allowed for request mode "cors"')
  }

  // 10. If request’s response tainting is "cors" and locationURL includes
  // credentials, then return a network error.
  if (
    request.responseTainting === 'cors' &&
    (locationURL.username || locationURL.password)
  ) {
    return makeNetworkError(
      'URL cannot contain credentials for request mode "cors"'
    )
  }

  // 11. If actualResponse’s status is not 303, request’s body is non-null,
  // and request’s body’s source is null, then return a network error.
  if (
    actualResponse.status !== 303 &&
    request.body != null &&
    request.body.source == null
  ) {
    return makeNetworkError()
  }

  // 12. If one of the following is true
  // - actualResponse’s status is 301 or 302 and request’s method is `POST`
  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`
  if (
    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||
    (actualResponse.status === 303 &&
      !['GET', 'HEAD'].includes(request.method))
  ) {
    // then:
    // 1. Set request’s method to `GET` and request’s body to null.
    request.method = 'GET'
    request.body = null

    // 2. For each headerName of request-body-header name, delete headerName from
    // request’s header list.
    for (const headerName of requestBodyHeader) {
      request.headersList.delete(headerName)
    }
  }

  // 13. If request’s body is non-null, then set request’s body to the first return
  // value of safely extracting request’s body’s source.
  if (request.body != null) {
    assert(request.body.source)
    request.body = safelyExtractBody(request.body.source)[0]
  }

  // 14. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 15. Set timingInfo’s redirect end time and post-redirect start time to the
  // coarsened shared current time given fetchParams’s cross-origin isolated
  // capability.
  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =
    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)

  // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s
  //  redirect start time to timingInfo’s start time.
  if (timingInfo.redirectStartTime === 0) {
    timingInfo.redirectStartTime = timingInfo.startTime
  }

  // 17. Append locationURL to request’s URL list.
  request.urlList.push(locationURL)

  // 18. Invoke set request’s referrer policy on redirect on request and
  // actualResponse.
  setRequestReferrerPolicyOnRedirect(request, actualResponse)

  // 19. Return the result of running main fetch given fetchParams and true.
  return mainFetch(fetchParams, true)
}

// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
async function httpNetworkOrCacheFetch (
  fetchParams,
  isAuthenticationFetch = false,
  isNewConnectionFetch = false
) {
  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let httpFetchParams be null.
  let httpFetchParams = null

  // 3. Let httpRequest be null.
  let httpRequest = null

  // 4. Let response be null.
  let response = null

  // 5. Let storedResponse be null.
  // TODO: cache

  // 6. Let httpCache be null.
  const httpCache = null

  // 7. Let the revalidatingFlag be unset.
  const revalidatingFlag = false

  // 8. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. If request’s window is "no-window" and request’s redirect mode is
  //    "error", then set httpFetchParams to fetchParams and httpRequest to
  //    request.
  if (request.window === 'no-window' && request.redirect === 'error') {
    httpFetchParams = fetchParams
    httpRequest = request
  } else {
    // Otherwise:

    // 1. Set httpRequest to a clone of request.
    httpRequest = makeRequest(request)

    // 2. Set httpFetchParams to a copy of fetchParams.
    httpFetchParams = { ...fetchParams }

    // 3. Set httpFetchParams’s request to httpRequest.
    httpFetchParams.request = httpRequest
  }

  //    3. Let includeCredentials be true if one of
  const includeCredentials =
    request.credentials === 'include' ||
    (request.credentials === 'same-origin' &&
      request.responseTainting === 'basic')

  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s
  //    body is non-null; otherwise null.
  const contentLength = httpRequest.body ? httpRequest.body.length : null

  //    5. Let contentLengthHeaderValue be null.
  let contentLengthHeaderValue = null

  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or
  //    `PUT`, then set contentLengthHeaderValue to `0`.
  if (
    httpRequest.body == null &&
    ['POST', 'PUT'].includes(httpRequest.method)
  ) {
    contentLengthHeaderValue = '0'
  }

  //    7. If contentLength is non-null, then set contentLengthHeaderValue to
  //    contentLength, serialized and isomorphic encoded.
  if (contentLength != null) {
    // TODO: isomorphic encoded
    contentLengthHeaderValue = String(contentLength)
  }

  //    8. If contentLengthHeaderValue is non-null, then append
  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header
  //    list.
  if (contentLengthHeaderValue != null) {
    httpRequest.headersList.append('content-length', contentLengthHeaderValue)
  }

  //    9. If contentLengthHeaderValue is non-null, then append (`Content-Length`,
  //    contentLengthHeaderValue) to httpRequest’s header list.

  //    10. If contentLength is non-null and httpRequest’s keepalive is true,
  //    then:
  if (contentLength != null && httpRequest.keepalive) {
    // NOTE: keepalive is a noop outside of browser context.
  }

  //    11. If httpRequest’s referrer is a URL, then append
  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,
  //     to httpRequest’s header list.
  if (httpRequest.referrer instanceof URL) {
    // TODO: isomorphic encoded
    httpRequest.headersList.append('referer', httpRequest.referrer.href)
  }

  //    12. Append a request `Origin` header for httpRequest.
  appendRequestOriginHeader(httpRequest)

  //    13. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]
  appendFetchMetadata(httpRequest)

  //    14. If httpRequest’s header list does not contain `User-Agent`, then
  //    user agents should append `User-Agent`/default `User-Agent` value to
  //    httpRequest’s header list.
  if (!httpRequest.headersList.has('user-agent')) {
    httpRequest.headersList.append('user-agent', 'undici')
  }

  //    15. If httpRequest’s cache mode is "default" and httpRequest’s header
  //    list contains `If-Modified-Since`, `If-None-Match`,
  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set
  //    httpRequest’s cache mode to "no-store".
  if (
    httpRequest.cache === 'default' &&
    (httpRequest.headersList.has('if-modified-since') ||
      httpRequest.headersList.has('if-none-match') ||
      httpRequest.headersList.has('if-unmodified-since') ||
      httpRequest.headersList.has('if-match') ||
      httpRequest.headersList.has('if-range'))
  ) {
    httpRequest.cache = 'no-store'
  }

  //    16. If httpRequest’s cache mode is "no-cache", httpRequest’s prevent
  //    no-cache cache-control header modification flag is unset, and
  //    httpRequest’s header list does not contain `Cache-Control`, then append
  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.
  if (
    httpRequest.cache === 'no-cache' &&
    !httpRequest.preventNoCacheCacheControlHeaderModification &&
    !httpRequest.headersList.has('cache-control')
  ) {
    httpRequest.headersList.append('cache-control', 'max-age=0')
  }

  //    17. If httpRequest’s cache mode is "no-store" or "reload", then:
  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
    // 1. If httpRequest’s header list does not contain `Pragma`, then append
    // `Pragma`/`no-cache` to httpRequest’s header list.
    if (!httpRequest.headersList.has('pragma')) {
      httpRequest.headersList.append('pragma', 'no-cache')
    }

    // 2. If httpRequest’s header list does not contain `Cache-Control`,
    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.
    if (!httpRequest.headersList.has('cache-control')) {
      httpRequest.headersList.append('cache-control', 'no-cache')
    }
  }

  //    18. If httpRequest’s header list contains `Range`, then append
  //    `Accept-Encoding`/`identity` to httpRequest’s header list.
  if (httpRequest.headersList.has('range')) {
    httpRequest.headersList.append('accept-encoding', 'identity')
  }

  //    19. Modify httpRequest’s header list per HTTP. Do not append a given
  //    header if httpRequest’s header list contains that header’s name.
  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129
  if (!httpRequest.headersList.has('accept-encoding')) {
    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')
    } else {
      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')
    }
  }

  //    20. If includeCredentials is true, then:
  if (includeCredentials) {
    // 1. If the user agent is not configured to block cookies for httpRequest
    // (see section 7 of [COOKIES]), then:
    // TODO: credentials
    // 2. If httpRequest’s header list does not contain `Authorization`, then:
    // TODO: credentials
  }

  //    21. If there’s a proxy-authentication entry, use it as appropriate.
  //    TODO: proxy-authentication

  //    22. Set httpCache to the result of determining the HTTP cache
  //    partition, given httpRequest.
  //    TODO: cache

  //    23. If httpCache is null, then set httpRequest’s cache mode to
  //    "no-store".
  if (httpCache == null) {
    httpRequest.cache = 'no-store'
  }

  //    24. If httpRequest’s cache mode is neither "no-store" nor "reload",
  //    then:
  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {
    // TODO: cache
  }

  // 9. If aborted, then return the appropriate network error for fetchParams.
  // TODO

  // 10. If response is null, then:
  if (response == null) {
    // 1. If httpRequest’s cache mode is "only-if-cached", then return a
    // network error.
    if (httpRequest.mode === 'only-if-cached') {
      return makeNetworkError('only if cached')
    }

    // 2. Let forwardResponse be the result of running HTTP-network fetch
    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.
    const forwardResponse = await httpNetworkFetch(
      httpFetchParams,
      includeCredentials,
      isNewConnectionFetch
    )

    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is
    // in the range 200 to 399, inclusive, invalidate appropriate stored
    // responses in httpCache, as per the "Invalidation" chapter of HTTP
    // Caching, and set storedResponse to null. [HTTP-CACHING]
    if (
      !safeMethods.includes(httpRequest.method) &&
      forwardResponse.status >= 200 &&
      forwardResponse.status <= 399
    ) {
      // TODO: cache
    }

    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,
    // then:
    if (revalidatingFlag && forwardResponse.status === 304) {
      // TODO: cache
    }

    // 5. If response is null, then:
    if (response == null) {
      // 1. Set response to forwardResponse.
      response = forwardResponse

      // 2. Store httpRequest and forwardResponse in httpCache, as per the
      // "Storing Responses in Caches" chapter of HTTP Caching. [HTTP-CACHING]
      // TODO: cache
    }
  }

  // 11. Set response’s URL list to a clone of httpRequest’s URL list.
  response.urlList = [...httpRequest.urlList]

  // 12. If httpRequest’s header list contains `Range`, then set response’s
  // range-requested flag.
  if (httpRequest.headersList.has('range')) {
    response.rangeRequested = true
  }

  // 13. Set response’s request-includes-credentials to includeCredentials.
  response.requestIncludesCredentials = includeCredentials

  // 14. If response’s status is 401, httpRequest’s response tainting is not
  // "cors", includeCredentials is true, and request’s window is an environment
  // settings object, then:
  // TODO

  // 15. If response’s status is 407, then:
  if (response.status === 407) {
    // 1. If request’s window is "no-window", then return a network error.
    if (request.window === 'no-window') {
      return makeNetworkError()
    }

    // 2. ???

    // 3. If fetchParams is canceled, then return the appropriate network error for fetchParams.
    if (isCancelled(fetchParams)) {
      return makeAppropriateNetworkError(fetchParams)
    }

    // 4. Prompt the end user as appropriate in request’s window and store
    // the result as a proxy-authentication entry. [HTTP-AUTH]
    // TODO: Invoke some kind of callback?

    // 5. Set response to the result of running HTTP-network-or-cache fetch given
    // fetchParams.
    // TODO
    return makeNetworkError('proxy authentication required')
  }

  // 16. If all of the following are true
  if (
    // response’s status is 421
    response.status === 421 &&
    // isNewConnectionFetch is false
    !isNewConnectionFetch &&
    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
    (request.body == null || request.body.source != null)
  ) {
    // then:

    // 1. If fetchParams is canceled, then return the appropriate network error for fetchParams.
    if (isCancelled(fetchParams)) {
      return makeAppropriateNetworkError(fetchParams)
    }

    // 2. Set response to the result of running HTTP-network-or-cache
    // fetch given fetchParams, isAuthenticationFetch, and true.

    // TODO (spec): The spec doesn't specify this but we need to cancel
    // the active response before we can start a new one.
    // https://github.com/whatwg/fetch/issues/1293
    fetchParams.controller.connection.destroy()

    response = await httpNetworkOrCacheFetch(
      fetchParams,
      isAuthenticationFetch,
      true
    )
  }

  // 17. If isAuthenticationFetch is true, then create an authentication entry
  if (isAuthenticationFetch) {
    // TODO
  }

  // 18. Return response.
  return response
}

// https://fetch.spec.whatwg.org/#http-network-fetch
async function httpNetworkFetch (
  fetchParams,
  includeCredentials = false,
  forceNewConnection = false
) {
  assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed)

  fetchParams.controller.connection = {
    abort: null,
    destroyed: false,
    destroy (err) {
      if (!this.destroyed) {
        this.destroyed = true
        this.abort?.(err ?? new DOMException('The operation was aborted.', 'AbortError'))
      }
    }
  }

  // 1. Let request be fetchParams’s request.
  const request = fetchParams.request

  // 2. Let response be null.
  let response = null

  // 3. Let timingInfo be fetchParams’s timing info.
  const timingInfo = fetchParams.timingInfo

  // 4. Let httpCache be the result of determining the HTTP cache partition,
  // given request.
  // TODO: cache
  const httpCache = null

  // 5. If httpCache is null, then set request’s cache mode to "no-store".
  if (httpCache == null) {
    request.cache = 'no-store'
  }

  // 6. Let networkPartitionKey be the result of determining the network
  // partition key given request.
  // TODO

  // 7. Let newConnection be "yes" if forceNewConnection is true; otherwise
  // "no".
  const newConnection = forceNewConnection ? 'yes' : 'no' // eslint-disable-line no-unused-vars

  // 8. Switch on request’s mode:
  if (request.mode === 'websocket') {
    // Let connection be the result of obtaining a WebSocket connection,
    // given request’s current URL.
    // TODO
  } else {
    // Let connection be the result of obtaining a connection, given
    // networkPartitionKey, request’s current URL’s origin,
    // includeCredentials, and forceNewConnection.
    // TODO
  }

  // 9. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. If connection is failure, then return a network error.

  //    2. Set timingInfo’s final connection timing info to the result of
  //    calling clamp and coarsen connection timing info with connection’s
  //    timing info, timingInfo’s post-redirect start time, and fetchParams’s
  //    cross-origin isolated capability.

  //    3. If connection is not an HTTP/2 connection, request’s body is non-null,
  //    and request’s body’s source is null, then append (`Transfer-Encoding`,
  //    `chunked`) to request’s header list.

  //    4. Set timingInfo’s final network-request start time to the coarsened
  //    shared current time given fetchParams’s cross-origin isolated
  //    capability.

  //    5. Set response to the result of making an HTTP request over connection
  //    using request with the following caveats:

  //        - Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]
  //        [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]

  //        - If request’s body is non-null, and request’s body’s source is null,
  //        then the user agent may have a buffer of up to 64 kibibytes and store
  //        a part of request’s body in that buffer. If the user agent reads from
  //        request’s body beyond that buffer’s size and the user agent needs to
  //        resend request, then instead return a network error.

  //        - Set timingInfo’s final network-response start time to the coarsened
  //        shared current time given fetchParams’s cross-origin isolated capability,
  //        immediately after the user agent’s HTTP parser receives the first byte
  //        of the response (e.g., frame header bytes for HTTP/2 or response status
  //        line for HTTP/1.x).

  //        - Wait until all the headers are transmitted.

  //        - Any responses whose status is in the range 100 to 199, inclusive,
  //        and is not 101, are to be ignored, except for the purposes of setting
  //        timingInfo’s final network-response start time above.

  //    - If request’s header list contains `Transfer-Encoding`/`chunked` and
  //    response is transferred via HTTP/1.0 or older, then return a network
  //    error.

  //    - If the HTTP request results in a TLS client certificate dialog, then:

  //        1. If request’s window is an environment settings object, make the
  //        dialog available in request’s window.

  //        2. Otherwise, return a network error.

  // To transmit request’s body body, run these steps:
  let requestBody = null
  // 1. If body is null and fetchParams’s process request end-of-body is
  // non-null, then queue a fetch task given fetchParams’s process request
  // end-of-body and fetchParams’s task destination.
  if (request.body == null && fetchParams.processRequestEndOfBody) {
    queueMicrotask(() => fetchParams.processRequestEndOfBody())
  } else if (request.body != null) {
    // 2. Otherwise, if body is non-null:

    //    1. Let processBodyChunk given bytes be these steps:
    const processBodyChunk = async function * (bytes) {
      // 1. If the ongoing fetch is terminated, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. Run this step in parallel: transmit bytes.
      yield bytes

      // 3. If fetchParams’s process request body is non-null, then run
      // fetchParams’s process request body given bytes’s length.
      fetchParams.processRequestBodyChunkLength?.(bytes.byteLength)
    }

    // 2. Let processEndOfBody be these steps:
    const processEndOfBody = () => {
      // 1. If fetchParams is canceled, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. If fetchParams’s process request end-of-body is non-null,
      // then run fetchParams’s process request end-of-body.
      if (fetchParams.processRequestEndOfBody) {
        fetchParams.processRequestEndOfBody()
      }
    }

    // 3. Let processBodyError given e be these steps:
    const processBodyError = (e) => {
      // 1. If fetchParams is canceled, then abort these steps.
      if (isCancelled(fetchParams)) {
        return
      }

      // 2. If e is an "AbortError" DOMException, then abort fetchParams’s controller.
      if (e.name === 'AbortError') {
        fetchParams.controller.abort()
      } else {
        fetchParams.controller.terminate(e)
      }
    }

    // 4. Incrementally read request’s body given processBodyChunk, processEndOfBody,
    // processBodyError, and fetchParams’s task destination.
    requestBody = (async function * () {
      try {
        for await (const bytes of request.body.stream) {
          yield * processBodyChunk(bytes)
        }
        processEndOfBody()
      } catch (err) {
        processBodyError(err)
      }
    })()
  }

  try {
    const { body, status, statusText, headersList } = await dispatch({ body: requestBody })

    const iterator = body[Symbol.asyncIterator]()
    fetchParams.controller.next = () => iterator.next()

    response = makeResponse({ status, statusText, headersList })
  } catch (err) {
    // 10. If aborted, then:
    if (err.name === 'AbortError') {
      // 1. If connection uses HTTP/2, then transmit an RST_STREAM frame.
      fetchParams.controller.connection.destroy()

      // 2. Return the appropriate network error for fetchParams.
      return makeAppropriateNetworkError(fetchParams)
    }

    return makeNetworkError(err)
  }

  // 11. Let pullAlgorithm be an action that resumes the ongoing fetch
  // if it is suspended.
  const pullAlgorithm = () => {
    fetchParams.controller.resume()
  }

  // 12. Let cancelAlgorithm be an algorithm that aborts fetchParams’s
  // controller.
  const cancelAlgorithm = () => {
    fetchParams.controller.abort()
  }

  // 13. Let highWaterMark be a non-negative, non-NaN number, chosen by
  // the user agent.
  // TODO

  // 14. Let sizeAlgorithm be an algorithm that accepts a chunk object
  // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.
  // TODO

  // 15. Let stream be a new ReadableStream.
  // 16. Set up stream with pullAlgorithm set to pullAlgorithm,
  // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to
  // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.
  if (!ReadableStream) {
    ReadableStream = (__webpack_require__(/*! stream/web */ "stream/web").ReadableStream)
  }

  const stream = new ReadableStream(
    {
      async start (controller) {
        fetchParams.controller.controller = controller
      },
      async pull (controller) {
        await pullAlgorithm(controller)
      },
      async cancel (reason) {
        await cancelAlgorithm(reason)
      }
    },
    { highWaterMark: 0 }
  )

  // 17. Run these steps, but abort when the ongoing fetch is terminated:

  //    1. Set response’s body to a new body whose stream is stream.
  response.body = { stream }

  //    2. If response is not a network error and request’s cache mode is
  //    not "no-store", then update response in httpCache for request.
  //    TODO

  //    3. If includeCredentials is true and the user agent is not configured
  //    to block cookies for request (see section 7 of [COOKIES]), then run the
  //    "set-cookie-string" parsing algorithm (see section 5.2 of [COOKIES]) on
  //    the value of each header whose name is a byte-case-insensitive match for
  //    `Set-Cookie` in response’s header list, if any, and request’s current URL.
  //    TODO

  // 18. If aborted, then:
  // TODO

  // 19. Run these steps in parallel:

  //    1. Run these steps, but abort when fetchParams is canceled:
  fetchParams.controller.on('terminated', onAborted)
  fetchParams.controller.resume = async () => {
    // 1. While true
    while (true) {
      // 1-3. See onData...

      // 4. Set bytes to the result of handling content codings given
      // codings and bytes.
      let bytes
      try {
        const { done, value } = await fetchParams.controller.next()

        if (isAborted(fetchParams)) {
          break
        }

        bytes = done ? undefined : value
      } catch (err) {
        if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
          // zlib doesn't like empty streams.
          bytes = undefined
        } else {
          bytes = err
        }
      }

      if (bytes === undefined) {
        // 2. Otherwise, if the bytes transmission for response’s message
        // body is done normally and stream is readable, then close
        // stream, finalize response for fetchParams and response, and
        // abort these in-parallel steps.
        try {
          fetchParams.controller.controller.close()
        } catch (err) {
          // TODO (fix): How/Why can this happen? Do we have a bug?
          if (!/Controller is already closed/.test(err)) {
            throw err
          }
        }

        finalizeResponse(fetchParams, response)

        return
      }

      // 5. Increase timingInfo’s decoded body size by bytes’s length.
      timingInfo.decodedBodySize += bytes?.byteLength ?? 0

      // 6. If bytes is failure, then terminate fetchParams’s controller.
      if (bytes instanceof Error) {
        fetchParams.controller.terminate(bytes)
        return
      }

      // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes
      // into stream.
      fetchParams.controller.controller.enqueue(new Uint8Array(bytes))

      // 8. If stream is errored, then terminate the ongoing fetch.
      if (isErrored(stream)) {
        fetchParams.controller.terminate()
        return
      }

      // 9. If stream doesn’t need more data ask the user agent to suspend
      // the ongoing fetch.
      if (!fetchParams.controller.controller.desiredSize) {
        return
      }
    }
  }

  //    2. If aborted, then:
  function onAborted (reason) {
    // 2. If fetchParams is aborted, then:
    if (isAborted(fetchParams)) {
      // 1. Set response’s aborted flag.
      response.aborted = true

      // 2. If stream is readable, error stream with an "AbortError" DOMException.
      if (isReadable(stream)) {
        fetchParams.controller.controller.error(
          new DOMException('The operation was aborted.', 'AbortError')
        )
      }
    } else {
      // 3. Otherwise, if stream is readable, error stream with a TypeError.
      if (isReadable(stream)) {
        fetchParams.controller.controller.error(new TypeError('terminated', {
          cause: reason instanceof Error ? reason : undefined
        }))
      }
    }

    // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.
    // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.
    fetchParams.controller.connection.destroy()
  }

  // 20. Return response.
  return response

  async function dispatch ({ body }) {
    const url = requestCurrentURL(request)
    return new Promise((resolve, reject) => fetchParams.controller.dispatcher.dispatch(
      {
        path: url.pathname + url.search,
        origin: url.origin,
        method: request.method,
        body: fetchParams.controller.dispatcher.isMockActive ? request.body && request.body.source : body,
        headers: [...request.headersList].flat(),
        maxRedirections: 0,
        bodyTimeout: 300_000,
        headersTimeout: 300_000
      },
      {
        body: null,
        abort: null,

        onConnect (abort) {
          // TODO (fix): Do we need connection here?
          const { connection } = fetchParams.controller

          if (connection.destroyed) {
            abort(new DOMException('The operation was aborted.', 'AbortError'))
          } else {
            fetchParams.controller.on('terminated', abort)
            this.abort = connection.abort = abort
          }
        },

        onHeaders (status, headersList, resume, statusText) {
          if (status < 200) {
            return
          }

          let codings = []

          const headers = new Headers()
          for (let n = 0; n < headersList.length; n += 2) {
            const key = headersList[n + 0].toString()
            const val = headersList[n + 1].toString()

            if (key.toLowerCase() === 'content-encoding') {
              codings = val.split(',').map((x) => x.trim())
            }

            headers.append(key, val)
          }

          this.body = new Readable({ read: resume })

          const decoders = []

          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
          if (request.method !== 'HEAD' && request.method !== 'CONNECT' && !nullBodyStatus.includes(status)) {
            for (const coding of codings) {
              if (/(x-)?gzip/.test(coding)) {
                decoders.push(zlib.createGunzip())
              } else if (/(x-)?deflate/.test(coding)) {
                decoders.push(zlib.createInflate())
              } else if (coding === 'br') {
                decoders.push(zlib.createBrotliDecompress())
              } else {
                decoders.length = 0
                break
              }
            }
          }

          resolve({
            status,
            statusText,
            headersList: headers[kHeadersList],
            body: decoders.length
              ? pipeline(this.body, ...decoders, () => {})
              : this.body.on('error', () => {})
          })

          return true
        },

        onData (chunk) {
          if (fetchParams.controller.dump) {
            return
          }

          // 1. If one or more bytes have been transmitted from response’s
          // message body, then:

          //  1. Let bytes be the transmitted bytes.
          const bytes = chunk

          //  2. Let codings be the result of extracting header list values
          //  given `Content-Encoding` and response’s header list.
          //  See pullAlgorithm.

          //  3. Increase timingInfo’s encoded body size by bytes’s length.
          timingInfo.encodedBodySize += bytes.byteLength

          //  4. See pullAlgorithm...

          return this.body.push(bytes)
        },

        onComplete () {
          if (this.abort) {
            fetchParams.controller.off('terminated', this.abort)
          }

          fetchParams.controller.ended = true

          this.body.push(null)
        },

        onError (error) {
          if (this.abort) {
            fetchParams.controller.off('terminated', this.abort)
          }

          this.body?.destroy(error)

          fetchParams.controller.terminate(error)

          reject(error)
        }
      }
    ))
  }
}

module.exports = fetch


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/request.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/request.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* globals AbortController */



const { extractBody, mixinBody, cloneBody } = __webpack_require__(/*! ./body */ "../../node_modules/undici/lib/fetch/body.js")
const { Headers, fill: fillHeaders, HeadersList } = __webpack_require__(/*! ./headers */ "../../node_modules/undici/lib/fetch/headers.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const {
  isValidHTTPToken,
  sameOrigin,
  normalizeMethod
} = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const {
  forbiddenMethods,
  corsSafeListedMethods,
  referrerPolicy,
  requestRedirect,
  requestMode,
  requestCredentials,
  requestCache
} = __webpack_require__(/*! ./constants */ "../../node_modules/undici/lib/fetch/constants.js")
const { kEnumerableProperty } = util
const { kHeaders, kSignal, kState, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")
const { kHeadersList } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! assert */ "assert")

let TransformStream

const kInit = Symbol('init')

const requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
  signal.removeEventListener('abort', abort)
})

// https://fetch.spec.whatwg.org/#request-class
class Request {
  // https://fetch.spec.whatwg.org/#dom-request
  constructor (input, init = {}) {
    if (input === kInit) {
      return
    }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to construct 'Request': 1 argument required, but only ${arguments.length} present.`
      )
    }

    input = webidl.converters.RequestInfo(input)
    init = webidl.converters.RequestInit(init)

    // TODO
    this[kRealm] = { settingsObject: {} }

    // 1. Let request be null.
    let request = null

    // 2. Let fallbackMode be null.
    let fallbackMode = null

    // 3. Let baseURL be this’s relevant settings object’s API base URL.
    const baseUrl = this[kRealm].settingsObject.baseUrl

    // 4. Let signal be null.
    let signal = null

    // 5. If input is a string, then:
    if (typeof input === 'string') {
      // 1. Let parsedURL be the result of parsing input with baseURL.
      // 2. If parsedURL is failure, then throw a TypeError.
      let parsedURL
      try {
        parsedURL = new URL(input, baseUrl)
      } catch (err) {
        throw new TypeError('Failed to parse URL from ' + input, { cause: err })
      }

      // 3. If parsedURL includes credentials, then throw a TypeError.
      if (parsedURL.username || parsedURL.password) {
        throw new TypeError(
          'Request cannot be constructed from a URL that includes credentials: ' +
            input
        )
      }

      // 4. Set request to a new request whose URL is parsedURL.
      request = makeRequest({ urlList: [parsedURL] })

      // 5. Set fallbackMode to "cors".
      fallbackMode = 'cors'
    } else {
      // 6. Otherwise:

      // 7. Assert: input is a Request object.
      assert(input instanceof Request)

      // 8. Set request to input’s request.
      request = input[kState]

      // 9. Set signal to input’s signal.
      signal = input[kSignal]
    }

    // 7. Let origin be this’s relevant settings object’s origin.
    const origin = this[kRealm].settingsObject.origin

    // 8. Let window be "client".
    let window = 'client'

    // 9. If request’s window is an environment settings object and its origin
    // is same origin with origin, then set window to request’s window.
    if (
      request.window?.constructor?.name === 'EnvironmentSettingsObject' &&
      sameOrigin(request.window, origin)
    ) {
      window = request.window
    }

    // 10. If init["window"] exists and is non-null, then throw a TypeError.
    if (init.window !== undefined && init.window != null) {
      throw new TypeError(`'window' option '${window}' must be null`)
    }

    // 11. If init["window"] exists, then set window to "no-window".
    if (init.window !== undefined) {
      window = 'no-window'
    }

    // 12. Set request to a new request with the following properties:
    request = makeRequest({
      // URL request’s URL.
      // undici implementation note: this is set as the first item in request's urlList in makeRequest
      // method request’s method.
      method: request.method,
      // header list A copy of request’s header list.
      // undici implementation note: headersList is cloned in makeRequest
      headersList: request.headersList,
      // unsafe-request flag Set.
      unsafeRequest: request.unsafeRequest,
      // client This’s relevant settings object.
      client: this[kRealm].settingsObject,
      // window window.
      window,
      // priority request’s priority.
      priority: request.priority,
      // origin request’s origin. The propagation of the origin is only significant for navigation requests
      // being handled by a service worker. In this scenario a request can have an origin that is different
      // from the current client.
      origin: request.origin,
      // referrer request’s referrer.
      referrer: request.referrer,
      // referrer policy request’s referrer policy.
      referrerPolicy: request.referrerPolicy,
      // mode request’s mode.
      mode: request.mode,
      // credentials mode request’s credentials mode.
      credentials: request.credentials,
      // cache mode request’s cache mode.
      cache: request.cache,
      // redirect mode request’s redirect mode.
      redirect: request.redirect,
      // integrity metadata request’s integrity metadata.
      integrity: request.integrity,
      // keepalive request’s keepalive.
      keepalive: request.keepalive,
      // reload-navigation flag request’s reload-navigation flag.
      reloadNavigation: request.reloadNavigation,
      // history-navigation flag request’s history-navigation flag.
      historyNavigation: request.historyNavigation,
      // URL list A clone of request’s URL list.
      urlList: [...request.urlList]
    })

    // 13. If init is not empty, then:
    if (Object.keys(init).length > 0) {
      // 1. If request’s mode is "navigate", then set it to "same-origin".
      if (request.mode === 'navigate') {
        request.mode = 'same-origin'
      }

      // 2. Unset request’s reload-navigation flag.
      request.reloadNavigation = false

      // 3. Unset request’s history-navigation flag.
      request.historyNavigation = false

      // 4. Set request’s origin to "client".
      request.origin = 'client'

      // 5. Set request’s referrer to "client"
      request.referrer = 'client'

      // 6. Set request’s referrer policy to the empty string.
      request.referrerPolicy = ''

      // 7. Set request’s URL to request’s current URL.
      request.url = request.urlList[request.urlList.length - 1]

      // 8. Set request’s URL list to « request’s URL ».
      request.urlList = [request.url]
    }

    // 14. If init["referrer"] exists, then:
    if (init.referrer !== undefined) {
      // 1. Let referrer be init["referrer"].
      const referrer = init.referrer

      // 2. If referrer is the empty string, then set request’s referrer to "no-referrer".
      if (referrer === '') {
        request.referrer = 'no-referrer'
      } else {
        // 1. Let parsedReferrer be the result of parsing referrer with
        // baseURL.
        // 2. If parsedReferrer is failure, then throw a TypeError.
        let parsedReferrer
        try {
          parsedReferrer = new URL(referrer, baseUrl)
        } catch (err) {
          throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err })
        }

        // 3. If one of the following is true
        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is "about",
        // and path contains a single string "client"
        // parsedReferrer’s origin is not same origin with origin
        // then set request’s referrer to "client".
        // TODO

        // 4. Otherwise, set request’s referrer to parsedReferrer.
        request.referrer = parsedReferrer
      }
    }

    // 15. If init["referrerPolicy"] exists, then set request’s referrer policy
    // to it.
    if (init.referrerPolicy !== undefined) {
      request.referrerPolicy = init.referrerPolicy
      if (!referrerPolicy.includes(request.referrerPolicy)) {
        throw new TypeError(
          `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`
        )
      }
    }

    // 16. Let mode be init["mode"] if it exists, and fallbackMode otherwise.
    let mode
    if (init.mode !== undefined) {
      mode = init.mode
      if (!requestMode.includes(mode)) {
        throw new TypeError(
          `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`
        )
      }
    } else {
      mode = fallbackMode
    }

    // 17. If mode is "navigate", then throw a TypeError.
    if (mode === 'navigate') {
      webidl.errors.exception({
        header: 'Request constructor',
        message: 'invalid request mode navigate.'
      })
    }

    // 18. If mode is non-null, set request’s mode to mode.
    if (mode != null) {
      request.mode = mode
    }

    // 19. If init["credentials"] exists, then set request’s credentials mode
    // to it.
    if (init.credentials !== undefined) {
      request.credentials = init.credentials
      if (!requestCredentials.includes(request.credentials)) {
        throw new TypeError(
          `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`
        )
      }
    }

    // 18. If init["cache"] exists, then set request’s cache mode to it.
    if (init.cache !== undefined) {
      request.cache = init.cache
      if (!requestCache.includes(request.cache)) {
        throw new TypeError(
          `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`
        )
      }
    }

    // 21. If request’s cache mode is "only-if-cached" and request’s mode is
    // not "same-origin", then throw a TypeError.
    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {
      throw new TypeError(
        "'only-if-cached' can be set only with 'same-origin' mode"
      )
    }

    // 22. If init["redirect"] exists, then set request’s redirect mode to it.
    if (init.redirect !== undefined) {
      request.redirect = init.redirect
      if (!requestRedirect.includes(request.redirect)) {
        throw new TypeError(
          `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`
        )
      }
    }

    // 23. If init["integrity"] exists, then set request’s integrity metadata to it.
    if (init.integrity !== undefined && init.integrity != null) {
      request.integrity = String(init.integrity)
    }

    // 24. If init["keepalive"] exists, then set request’s keepalive to it.
    if (init.keepalive !== undefined) {
      request.keepalive = Boolean(init.keepalive)
    }

    // 25. If init["method"] exists, then:
    if (init.method !== undefined) {
      // 1. Let method be init["method"].
      let method = init.method

      // 2. If method is not a method or method is a forbidden method, then
      // throw a TypeError.
      if (!isValidHTTPToken(init.method)) {
        throw TypeError(`'${init.method}' is not a valid HTTP method.`)
      }

      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
        throw TypeError(`'${init.method}' HTTP method is unsupported.`)
      }

      // 3. Normalize method.
      method = normalizeMethod(init.method)

      // 4. Set request’s method to method.
      request.method = method
    }

    // 26. If init["signal"] exists, then set signal to it.
    if (init.signal !== undefined) {
      signal = init.signal
    }

    // 27. Set this’s request to request.
    this[kState] = request

    // 28. Set this’s signal to a new AbortSignal object with this’s relevant
    // Realm.
    const ac = new AbortController()
    this[kSignal] = ac.signal
    this[kSignal][kRealm] = this[kRealm]

    // 29. If signal is not null, then make this’s signal follow signal.
    if (signal != null) {
      if (
        !signal ||
        typeof signal.aborted !== 'boolean' ||
        typeof signal.addEventListener !== 'function'
      ) {
        throw new TypeError(
          "Failed to construct 'Request': member signal is not of type AbortSignal."
        )
      }

      if (signal.aborted) {
        ac.abort()
      } else {
        const abort = () => ac.abort()
        signal.addEventListener('abort', abort, { once: true })
        requestFinalizer.register(this, { signal, abort })
      }
    }

    // 30. Set this’s headers to a new Headers object with this’s relevant
    // Realm, whose header list is request’s header list and guard is
    // "request".
    this[kHeaders] = new Headers()
    this[kHeaders][kHeadersList] = request.headersList
    this[kHeaders][kGuard] = 'request'
    this[kHeaders][kRealm] = this[kRealm]

    // 31. If this’s request’s mode is "no-cors", then:
    if (mode === 'no-cors') {
      // 1. If this’s request’s method is not a CORS-safelisted method,
      // then throw a TypeError.
      if (!corsSafeListedMethods.includes(request.method)) {
        throw new TypeError(
          `'${request.method} is unsupported in no-cors mode.`
        )
      }

      // 2. Set this’s headers’s guard to "request-no-cors".
      this[kHeaders][kGuard] = 'request-no-cors'
    }

    // 32. If init is not empty, then:
    if (Object.keys(init).length !== 0) {
      // 1. Let headers be a copy of this’s headers and its associated header
      // list.
      let headers = new Headers(this[kHeaders])

      // 2. If init["headers"] exists, then set headers to init["headers"].
      if (init.headers !== undefined) {
        headers = init.headers
      }

      // 3. Empty this’s headers’s header list.
      this[kHeaders][kHeadersList].clear()

      // 4. If headers is a Headers object, then for each header in its header
      // list, append header’s name/header’s value to this’s headers.
      if (headers.constructor.name === 'Headers') {
        for (const [key, val] of headers) {
          this[kHeaders].append(key, val)
        }
      } else {
        // 5. Otherwise, fill this’s headers with headers.
        fillHeaders(this[kHeaders], headers)
      }
    }

    // 33. Let inputBody be input’s request’s body if input is a Request
    // object; otherwise null.
    const inputBody = input instanceof Request ? input[kState].body : null

    // 34. If either init["body"] exists and is non-null or inputBody is
    // non-null, and request’s method is `GET` or `HEAD`, then throw a
    // TypeError.
    if (
      ((init.body !== undefined && init.body != null) || inputBody != null) &&
      (request.method === 'GET' || request.method === 'HEAD')
    ) {
      throw new TypeError('Request with GET/HEAD method cannot have body.')
    }

    // 35. Let initBody be null.
    let initBody = null

    // 36. If init["body"] exists and is non-null, then:
    if (init.body !== undefined && init.body != null) {
      // 1. Let Content-Type be null.
      // 2. Set initBody and Content-Type to the result of extracting
      // init["body"], with keepalive set to request’s keepalive.
      const [extractedBody, contentType] = extractBody(
        init.body,
        request.keepalive
      )
      initBody = extractedBody

      // 3, If Content-Type is non-null and this’s headers’s header list does
      // not contain `Content-Type`, then append `Content-Type`/Content-Type to
      // this’s headers.
      if (contentType && !this[kHeaders].has('content-type')) {
        this[kHeaders].append('content-type', contentType)
      }
    }

    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise
    // inputBody.
    const inputOrInitBody = initBody ?? inputBody

    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is
    // null, then:
    if (inputOrInitBody != null && inputOrInitBody.source == null) {
      // 1. If this’s request’s mode is neither "same-origin" nor "cors",
      // then throw a TypeError.
      if (request.mode !== 'same-origin' && request.mode !== 'cors') {
        throw new TypeError(
          'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
        )
      }

      // 2. Set this’s request’s use-CORS-preflight flag.
      request.useCORSPreflightFlag = true
    }

    // 39. Let finalBody be inputOrInitBody.
    let finalBody = inputOrInitBody

    // 40. If initBody is null and inputBody is non-null, then:
    if (initBody == null && inputBody != null) {
      // 1. If input is unusable, then throw a TypeError.
      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
        throw new TypeError(
          'Cannot construct a Request with a Request object that has already been used.'
        )
      }

      // 2. Set finalBody to the result of creating a proxy for inputBody.
      if (!TransformStream) {
        TransformStream = (__webpack_require__(/*! stream/web */ "stream/web").TransformStream)
      }

      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy
      const identityTransform = new TransformStream()
      inputBody.stream.pipeThrough(identityTransform)
      finalBody = {
        source: inputBody.source,
        length: inputBody.length,
        stream: identityTransform.readable
      }
    }

    // 41. Set this’s request’s body to finalBody.
    this[kState].body = finalBody
  }

  get [Symbol.toStringTag] () {
    return this.constructor.name
  }

  // Returns request’s HTTP method, which is "GET" by default.
  get method () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The method getter steps are to return this’s request’s method.
    return this[kState].method
  }

  // Returns the URL of request as a string.
  get url () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The url getter steps are to return this’s request’s URL, serialized.
    return this[kState].url.toString()
  }

  // Returns a Headers object consisting of the headers associated with request.
  // Note that headers added in the network layer by the user agent will not
  // be accounted for in this object, e.g., the "Host" header.
  get headers () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The headers getter steps are to return this’s headers.
    return this[kHeaders]
  }

  // Returns the kind of resource requested by request, e.g., "document"
  // or "script".
  get destination () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The destination getter are to return this’s request’s destination.
    return this[kState].destination
  }

  // Returns the referrer of request. Its value can be a same-origin URL if
  // explicitly set in init, the empty string to indicate no referrer, and
  // "about:client" when defaulting to the global’s default. This is used
  // during fetching to determine the value of the `Referer` header of the
  // request being made.
  get referrer () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // 1. If this’s request’s referrer is "no-referrer", then return the
    // empty string.
    if (this[kState].referrer === 'no-referrer') {
      return ''
    }

    // 2. If this’s request’s referrer is "client", then return
    // "about:client".
    if (this[kState].referrer === 'client') {
      return 'about:client'
    }

    // Return this’s request’s referrer, serialized.
    return this[kState].referrer.toString()
  }

  // Returns the referrer policy associated with request.
  // This is used during fetching to compute the value of the request’s
  // referrer.
  get referrerPolicy () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The referrerPolicy getter steps are to return this’s request’s referrer policy.
    return this[kState].referrerPolicy
  }

  // Returns the mode associated with request, which is a string indicating
  // whether the request will use CORS, or will be restricted to same-origin
  // URLs.
  get mode () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The mode getter steps are to return this’s request’s mode.
    return this[kState].mode
  }

  // Returns the credentials mode associated with request,
  // which is a string indicating whether credentials will be sent with the
  // request always, never, or only when sent to a same-origin URL.
  get credentials () {
    // The credentials getter steps are to return this’s request’s credentials mode.
    return this[kState].credentials
  }

  // Returns the cache mode associated with request,
  // which is a string indicating how the request will
  // interact with the browser’s cache when fetching.
  get cache () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The cache getter steps are to return this’s request’s cache mode.
    return this[kState].cache
  }

  // Returns the redirect mode associated with request,
  // which is a string indicating how redirects for the
  // request will be handled during fetching. A request
  // will follow redirects by default.
  get redirect () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The redirect getter steps are to return this’s request’s redirect mode.
    return this[kState].redirect
  }

  // Returns request’s subresource integrity metadata, which is a
  // cryptographic hash of the resource being fetched. Its value
  // consists of multiple hashes separated by whitespace. [SRI]
  get integrity () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The integrity getter steps are to return this’s request’s integrity
    // metadata.
    return this[kState].integrity
  }

  // Returns a boolean indicating whether or not request can outlive the
  // global in which it was created.
  get keepalive () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The keepalive getter steps are to return this’s request’s keepalive.
    return this[kState].keepalive
  }

  // Returns a boolean indicating whether or not request is for a reload
  // navigation.
  get isReloadNavigation () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The isReloadNavigation getter steps are to return true if this’s
    // request’s reload-navigation flag is set; otherwise false.
    return this[kState].reloadNavigation
  }

  // Returns a boolean indicating whether or not request is for a history
  // navigation (a.k.a. back-foward navigation).
  get isHistoryNavigation () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The isHistoryNavigation getter steps are to return true if this’s request’s
    // history-navigation flag is set; otherwise false.
    return this[kState].historyNavigation
  }

  // Returns the signal associated with request, which is an AbortSignal
  // object indicating whether or not request has been aborted, and its
  // abort event handler.
  get signal () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // The signal getter steps are to return this’s signal.
    return this[kSignal]
  }

  // Returns a clone of request.
  clone () {
    if (!(this instanceof Request)) {
      throw new TypeError('Illegal invocation')
    }

    // 1. If this is unusable, then throw a TypeError.
    if (this.bodyUsed || this.body?.locked) {
      throw new TypeError('unusable')
    }

    // 2. Let clonedRequest be the result of cloning this’s request.
    const clonedRequest = cloneRequest(this[kState])

    // 3. Let clonedRequestObject be the result of creating a Request object,
    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.
    const clonedRequestObject = new Request(kInit)
    clonedRequestObject[kState] = clonedRequest
    clonedRequestObject[kRealm] = this[kRealm]
    clonedRequestObject[kHeaders] = new Headers()
    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList
    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]
    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]

    // 4. Make clonedRequestObject’s signal follow this’s signal.
    const ac = new AbortController()
    if (this.signal.aborted) {
      ac.abort()
    } else {
      this.signal.addEventListener(
        'abort',
        function () {
          ac.abort()
        },
        { once: true }
      )
    }
    clonedRequestObject[kSignal] = ac.signal

    // 4. Return clonedRequestObject.
    return clonedRequestObject
  }
}

mixinBody(Request)

function makeRequest (init) {
  // https://fetch.spec.whatwg.org/#requests
  const request = {
    method: 'GET',
    localURLsOnly: false,
    unsafeRequest: false,
    body: null,
    client: null,
    reservedClient: null,
    replacesClientId: '',
    window: 'client',
    keepalive: false,
    serviceWorkers: 'all',
    initiator: '',
    destination: '',
    priority: null,
    origin: 'client',
    policyContainer: 'client',
    referrer: 'client',
    referrerPolicy: '',
    mode: 'no-cors',
    useCORSPreflightFlag: false,
    credentials: 'same-origin',
    useCredentials: false,
    cache: 'default',
    redirect: 'follow',
    integrity: '',
    cryptoGraphicsNonceMetadata: '',
    parserMetadata: '',
    reloadNavigation: false,
    historyNavigation: false,
    userActivation: false,
    taintedOrigin: false,
    redirectCount: 0,
    responseTainting: 'basic',
    preventNoCacheCacheControlHeaderModification: false,
    done: false,
    timingAllowFailed: false,
    ...init,
    headersList: init.headersList
      ? new HeadersList(init.headersList)
      : new HeadersList()
  }
  request.url = request.urlList[0]
  return request
}

// https://fetch.spec.whatwg.org/#concept-request-clone
function cloneRequest (request) {
  // To clone a request request, run these steps:

  // 1. Let newRequest be a copy of request, except for its body.
  const newRequest = makeRequest({ ...request, body: null })

  // 2. If request’s body is non-null, set newRequest’s body to the
  // result of cloning request’s body.
  if (request.body != null) {
    newRequest.body = cloneBody(request.body)
  }

  // 3. Return newRequest.
  return newRequest
}

Object.defineProperties(Request.prototype, {
  method: kEnumerableProperty,
  url: kEnumerableProperty,
  headers: kEnumerableProperty,
  redirect: kEnumerableProperty,
  clone: kEnumerableProperty,
  signal: kEnumerableProperty
})

webidl.converters.Request = webidl.interfaceConverter(
  Request
)

// https://fetch.spec.whatwg.org/#requestinfo
webidl.converters.RequestInfo = function (V) {
  if (typeof V === 'string') {
    return webidl.converters.USVString(V)
  }

  if (V instanceof Request) {
    return webidl.converters.Request(V)
  }

  return webidl.converters.USVString(V)
}

webidl.converters.AbortSignal = webidl.interfaceConverter(
  AbortSignal
)

// https://fetch.spec.whatwg.org/#requestinit
webidl.converters.RequestInit = webidl.dictionaryConverter([
  {
    key: 'method',
    converter: webidl.converters.ByteString
  },
  {
    key: 'headers',
    converter: webidl.converters.HeadersInit
  },
  {
    key: 'body',
    converter: webidl.nullableConverter(
      webidl.converters.BodyInit
    )
  },
  {
    key: 'referrer',
    converter: webidl.converters.USVString
  },
  {
    key: 'referrerPolicy',
    converter: webidl.converters.DOMString,
    // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
    allowedValues: [
      '', 'no-referrer', 'no-referrer-when-downgrade',
      'same-origin', 'origin', 'strict-origin',
      'origin-when-cross-origin', 'strict-origin-when-cross-origin',
      'unsafe-url'
    ]
  },
  {
    key: 'mode',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#concept-request-mode
    allowedValues: [
      'same-origin', 'cors', 'no-cors', 'navigate', 'websocket'
    ]
  },
  {
    key: 'credentials',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestcredentials
    allowedValues: [
      'omit', 'same-origin', 'include'
    ]
  },
  {
    key: 'cache',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestcache
    allowedValues: [
      'default', 'no-store', 'reload', 'no-cache', 'force-cache',
      'only-if-cached'
    ]
  },
  {
    key: 'redirect',
    converter: webidl.converters.DOMString,
    // https://fetch.spec.whatwg.org/#requestredirect
    allowedValues: [
      'follow', 'error', 'manual'
    ]
  },
  {
    key: 'integrity',
    converter: webidl.converters.DOMString
  },
  {
    key: 'keepalive',
    converter: webidl.converters.boolean
  },
  {
    key: 'signal',
    converter: webidl.nullableConverter(
      webidl.converters.AbortSignal
    )
  },
  {
    key: 'window',
    converter: webidl.converters.any
  }
])

module.exports = { Request, makeRequest }


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/response.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/response.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Headers, HeadersList, fill } = __webpack_require__(/*! ./headers */ "../../node_modules/undici/lib/fetch/headers.js")
const { extractBody, cloneBody, mixinBody } = __webpack_require__(/*! ./body */ "../../node_modules/undici/lib/fetch/body.js")
const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { kEnumerableProperty } = util
const {
  responseURL,
  isValidReasonPhrase,
  isCancelled,
  isAborted,
  isBlobLike,
  serializeJavascriptValueToJSONString
} = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")
const {
  redirectStatus,
  nullBodyStatus,
  DOMException
} = __webpack_require__(/*! ./constants */ "../../node_modules/undici/lib/fetch/constants.js")
const { kState, kHeaders, kGuard, kRealm } = __webpack_require__(/*! ./symbols */ "../../node_modules/undici/lib/fetch/symbols.js")
const { webidl } = __webpack_require__(/*! ./webidl */ "../../node_modules/undici/lib/fetch/webidl.js")
const { FormData } = __webpack_require__(/*! ./formdata */ "../../node_modules/undici/lib/fetch/formdata.js")
const { kHeadersList } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! assert */ "assert")
const { types } = __webpack_require__(/*! util */ "util")

const ReadableStream = globalThis.ReadableStream || (__webpack_require__(/*! stream/web */ "stream/web").ReadableStream)

// https://fetch.spec.whatwg.org/#response-class
class Response {
  // Creates network error Response.
  static error () {
    // TODO
    const relevantRealm = { settingsObject: {} }

    // The static error() method steps are to return the result of creating a
    // Response object, given a new network error, "immutable", and this’s
    // relevant Realm.
    const responseObject = new Response()
    responseObject[kState] = makeNetworkError()
    responseObject[kRealm] = relevantRealm
    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList
    responseObject[kHeaders][kGuard] = 'immutable'
    responseObject[kHeaders][kRealm] = relevantRealm
    return responseObject
  }

  // https://fetch.spec.whatwg.org/#dom-response-json
  static json (data, init = {}) {
    if (arguments.length === 0) {
      throw new TypeError(
        'Failed to execute \'json\' on \'Response\': 1 argument required, but 0 present.'
      )
    }

    if (init !== null) {
      init = webidl.converters.ResponseInit(init)
    }

    // 1. Let bytes the result of running serialize a JavaScript value to JSON bytes on data.
    const bytes = new TextEncoder('utf-8').encode(
      serializeJavascriptValueToJSONString(data)
    )

    // 2. Let body be the result of extracting bytes.
    const body = extractBody(bytes)

    // 3. Let responseObject be the result of creating a Response object, given a new response,
    //    "response", and this’s relevant Realm.
    const relevantRealm = { settingsObject: {} }
    const responseObject = new Response()
    responseObject[kRealm] = relevantRealm
    responseObject[kHeaders][kGuard] = 'response'
    responseObject[kHeaders][kRealm] = relevantRealm

    // 4. Perform initialize a response given responseObject, init, and (body, "application/json").
    initializeResponse(responseObject, init, { body: body[0], type: 'application/json' })

    // 5. Return responseObject.
    return responseObject
  }

  // Creates a redirect Response that redirects to url with status status.
  static redirect (url, status = 302) {
    const relevantRealm = { settingsObject: {} }

    if (arguments.length < 1) {
      throw new TypeError(
        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`
      )
    }

    url = webidl.converters.USVString(url)
    status = webidl.converters['unsigned short'](status)

    // 1. Let parsedURL be the result of parsing url with current settings
    // object’s API base URL.
    // 2. If parsedURL is failure, then throw a TypeError.
    // TODO: base-URL?
    let parsedURL
    try {
      parsedURL = new URL(url)
    } catch (err) {
      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
        cause: err
      })
    }

    // 3. If status is not a redirect status, then throw a RangeError.
    if (!redirectStatus.includes(status)) {
      throw new RangeError('Invalid status code')
    }

    // 4. Let responseObject be the result of creating a Response object,
    // given a new response, "immutable", and this’s relevant Realm.
    const responseObject = new Response()
    responseObject[kRealm] = relevantRealm
    responseObject[kHeaders][kGuard] = 'immutable'
    responseObject[kHeaders][kRealm] = relevantRealm

    // 5. Set responseObject’s response’s status to status.
    responseObject[kState].status = status

    // 6. Let value be parsedURL, serialized and isomorphic encoded.
    // TODO: isomorphic encoded?
    const value = parsedURL.toString()

    // 7. Append `Location`/value to responseObject’s response’s header list.
    responseObject[kState].headersList.append('location', value)

    // 8. Return responseObject.
    return responseObject
  }

  // https://fetch.spec.whatwg.org/#dom-response
  constructor (body = null, init = {}) {
    if (body !== null) {
      body = webidl.converters.BodyInit(body)
    }

    init = webidl.converters.ResponseInit(init)

    // TODO
    this[kRealm] = { settingsObject: {} }

    // 1. Set this’s response to a new response.
    this[kState] = makeResponse({})

    // 2. Set this’s headers to a new Headers object with this’s relevant
    // Realm, whose header list is this’s response’s header list and guard
    // is "response".
    this[kHeaders] = new Headers()
    this[kHeaders][kGuard] = 'response'
    this[kHeaders][kHeadersList] = this[kState].headersList
    this[kHeaders][kRealm] = this[kRealm]

    // 3. Let bodyWithType be null.
    let bodyWithType = null

    // 4. If body is non-null, then set bodyWithType to the result of extracting body.
    if (body != null) {
      const [extractedBody, type] = extractBody(body)
      bodyWithType = { body: extractedBody, type }
    }

    // 5. Perform initialize a response given this, init, and bodyWithType.
    initializeResponse(this, init, bodyWithType)
  }

  get [Symbol.toStringTag] () {
    return this.constructor.name
  }

  // Returns response’s type, e.g., "cors".
  get type () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The type getter steps are to return this’s response’s type.
    return this[kState].type
  }

  // Returns response’s URL, if it has one; otherwise the empty string.
  get url () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The url getter steps are to return the empty string if this’s
    // response’s URL is null; otherwise this’s response’s URL,
    // serialized with exclude fragment set to true.
    let url = responseURL(this[kState])

    if (url == null) {
      return ''
    }

    if (url.hash) {
      url = new URL(url)
      url.hash = ''
    }

    return url.toString()
  }

  // Returns whether response was obtained through a redirect.
  get redirected () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The redirected getter steps are to return true if this’s response’s URL
    // list has more than one item; otherwise false.
    return this[kState].urlList.length > 1
  }

  // Returns response’s status.
  get status () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The status getter steps are to return this’s response’s status.
    return this[kState].status
  }

  // Returns whether response’s status is an ok status.
  get ok () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The ok getter steps are to return true if this’s response’s status is an
    // ok status; otherwise false.
    return this[kState].status >= 200 && this[kState].status <= 299
  }

  // Returns response’s status message.
  get statusText () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The statusText getter steps are to return this’s response’s status
    // message.
    return this[kState].statusText
  }

  // Returns response’s headers as Headers.
  get headers () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // The headers getter steps are to return this’s headers.
    return this[kHeaders]
  }

  // Returns a clone of response.
  clone () {
    if (!(this instanceof Response)) {
      throw new TypeError('Illegal invocation')
    }

    // 1. If this is unusable, then throw a TypeError.
    if (this.bodyUsed || (this.body && this.body.locked)) {
      webidl.errors.exception({
        header: 'Response.clone',
        message: 'Body has already been consumed.'
      })
    }

    // 2. Let clonedResponse be the result of cloning this’s response.
    const clonedResponse = cloneResponse(this[kState])

    // 3. Return the result of creating a Response object, given
    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.
    const clonedResponseObject = new Response()
    clonedResponseObject[kState] = clonedResponse
    clonedResponseObject[kRealm] = this[kRealm]
    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList
    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]
    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]

    return clonedResponseObject
  }
}

mixinBody(Response)

Object.defineProperties(Response.prototype, {
  type: kEnumerableProperty,
  url: kEnumerableProperty,
  status: kEnumerableProperty,
  ok: kEnumerableProperty,
  redirected: kEnumerableProperty,
  statusText: kEnumerableProperty,
  headers: kEnumerableProperty,
  clone: kEnumerableProperty
})

// https://fetch.spec.whatwg.org/#concept-response-clone
function cloneResponse (response) {
  // To clone a response response, run these steps:

  // 1. If response is a filtered response, then return a new identical
  // filtered response whose internal response is a clone of response’s
  // internal response.
  if (response.internalResponse) {
    return filterResponse(
      cloneResponse(response.internalResponse),
      response.type
    )
  }

  // 2. Let newResponse be a copy of response, except for its body.
  const newResponse = makeResponse({ ...response, body: null })

  // 3. If response’s body is non-null, then set newResponse’s body to the
  // result of cloning response’s body.
  if (response.body != null) {
    newResponse.body = cloneBody(response.body)
  }

  // 4. Return newResponse.
  return newResponse
}

function makeResponse (init) {
  return {
    aborted: false,
    rangeRequested: false,
    timingAllowPassed: false,
    requestIncludesCredentials: false,
    type: 'default',
    status: 200,
    timingInfo: null,
    cacheState: '',
    statusText: '',
    ...init,
    headersList: init.headersList
      ? new HeadersList(init.headersList)
      : new HeadersList(),
    urlList: init.urlList ? [...init.urlList] : []
  }
}

function makeNetworkError (reason) {
  return makeResponse({
    type: 'error',
    status: 0,
    error:
      reason instanceof Error
        ? reason
        : new Error(reason ? String(reason) : reason, {
          cause: reason instanceof Error ? reason : undefined
        }),
    aborted: reason && reason.name === 'AbortError'
  })
}

function makeFilteredResponse (response, state) {
  state = {
    internalResponse: response,
    ...state
  }

  return new Proxy(response, {
    get (target, p) {
      return p in state ? state[p] : target[p]
    },
    set (target, p, value) {
      assert(!(p in state))
      target[p] = value
      return true
    }
  })
}

// https://fetch.spec.whatwg.org/#concept-filtered-response
function filterResponse (response, type) {
  // Set response to the following filtered response with response as its
  // internal response, depending on request’s response tainting:
  if (type === 'basic') {
    // A basic filtered response is a filtered response whose type is "basic"
    // and header list excludes any headers in internal response’s header list
    // whose name is a forbidden response-header name.

    // Note: undici does not implement forbidden response-header names
    return makeFilteredResponse(response, {
      type: 'basic',
      headersList: response.headersList
    })
  } else if (type === 'cors') {
    // A CORS filtered response is a filtered response whose type is "cors"
    // and header list excludes any headers in internal response’s header
    // list whose name is not a CORS-safelisted response-header name, given
    // internal response’s CORS-exposed header-name list.

    // Note: undici does not implement CORS-safelisted response-header names
    return makeFilteredResponse(response, {
      type: 'cors',
      headersList: response.headersList
    })
  } else if (type === 'opaque') {
    // An opaque filtered response is a filtered response whose type is
    // "opaque", URL list is the empty list, status is 0, status message
    // is the empty byte sequence, header list is empty, and body is null.

    return makeFilteredResponse(response, {
      type: 'opaque',
      urlList: Object.freeze([]),
      status: 0,
      statusText: '',
      body: null
    })
  } else if (type === 'opaqueredirect') {
    // An opaque-redirect filtered response is a filtered response whose type
    // is "opaqueredirect", status is 0, status message is the empty byte
    // sequence, header list is empty, and body is null.

    return makeFilteredResponse(response, {
      type: 'opaqueredirect',
      status: 0,
      statusText: '',
      headersList: [],
      body: null
    })
  } else {
    assert(false)
  }
}

// https://fetch.spec.whatwg.org/#appropriate-network-error
function makeAppropriateNetworkError (fetchParams) {
  // 1. Assert: fetchParams is canceled.
  assert(isCancelled(fetchParams))

  // 2. Return an aborted network error if fetchParams is aborted;
  // otherwise return a network error.
  return isAborted(fetchParams)
    ? makeNetworkError(new DOMException('The operation was aborted.', 'AbortError'))
    : makeNetworkError(fetchParams.controller.terminated.reason)
}

// https://whatpr.org/fetch/1392.html#initialize-a-response
function initializeResponse (response, init, body) {
  // 1. If init["status"] is not in the range 200 to 599, inclusive, then
  //    throw a RangeError.
  if (init.status !== null && (init.status < 200 || init.status > 599)) {
    throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.')
  }

  // 2. If init["statusText"] does not match the reason-phrase token production,
  //    then throw a TypeError.
  if ('statusText' in init && init.statusText != null) {
    // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:
    //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )
    if (!isValidReasonPhrase(String(init.statusText))) {
      throw new TypeError('Invalid statusText')
    }
  }

  // 3. Set response’s response’s status to init["status"].
  if ('status' in init && init.status != null) {
    response[kState].status = init.status
  }

  // 4. Set response’s response’s status message to init["statusText"].
  if ('statusText' in init && init.statusText != null) {
    response[kState].statusText = init.statusText
  }

  // 5. If init["headers"] exists, then fill response’s headers with init["headers"].
  if ('headers' in init && init.headers != null) {
    fill(response[kState].headersList, init.headers)
  }

  // 6. If body was given, then:
  if (body) {
    // 1. If response's status is a null body status, then throw a TypeError.
    if (nullBodyStatus.includes(response.status)) {
      webidl.errors.exception({
        header: 'Response constructor',
        message: 'Invalid response status code.'
      })
    }

    // 2. Set response's body to body's body.
    response[kState].body = body.body

    // 3. If body's type is non-null and response's header list does not contain
    //    `Content-Type`, then append (`Content-Type`, body's type) to response's header list.
    if (body.type != null && !response[kState].headersList.has('Content-Type')) {
      response[kState].headersList.append('content-type', body.type)
    }
  }
}

webidl.converters.ReadableStream = webidl.interfaceConverter(
  ReadableStream
)

webidl.converters.FormData = webidl.interfaceConverter(
  FormData
)

webidl.converters.URLSearchParams = webidl.interfaceConverter(
  URLSearchParams
)

// https://fetch.spec.whatwg.org/#typedefdef-xmlhttprequestbodyinit
webidl.converters.XMLHttpRequestBodyInit = function (V) {
  if (typeof V === 'string') {
    return webidl.converters.USVString(V)
  }

  if (isBlobLike(V)) {
    return webidl.converters.Blob(V)
  }

  if (
    types.isAnyArrayBuffer(V) ||
    types.isTypedArray(V) ||
    types.isDataView(V)
  ) {
    return webidl.converters.BufferSource(V)
  }

  if (V instanceof FormData) {
    return webidl.converters.FormData(V)
  }

  if (V instanceof URLSearchParams) {
    return webidl.converters.URLSearchParams(V)
  }

  return webidl.converters.DOMString(V)
}

// https://fetch.spec.whatwg.org/#bodyinit
webidl.converters.BodyInit = function (V) {
  if (V instanceof ReadableStream) {
    return webidl.converters.ReadableStream(V)
  }

  // Note: the spec doesn't include async iterables,
  // this is an undici extension.
  if (V?.[Symbol.asyncIterator]) {
    return V
  }

  return webidl.converters.XMLHttpRequestBodyInit(V)
}

webidl.converters.ResponseInit = webidl.dictionaryConverter([
  {
    key: 'status',
    converter: webidl.converters['unsigned short'],
    defaultValue: 200
  },
  {
    key: 'statusText',
    converter: webidl.converters.ByteString,
    defaultValue: ''
  },
  {
    key: 'headers',
    converter: webidl.converters.HeadersInit
  }
])

module.exports = {
  makeNetworkError,
  makeResponse,
  makeAppropriateNetworkError,
  filterResponse,
  Response
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/symbols.js":
/*!******************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/symbols.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kUrl: Symbol('url'),
  kHeaders: Symbol('headers'),
  kSignal: Symbol('signal'),
  kState: Symbol('state'),
  kGuard: Symbol('guard'),
  kRealm: Symbol('realm')
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/util.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/util.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { redirectStatus } = __webpack_require__(/*! ./constants */ "../../node_modules/undici/lib/fetch/constants.js")
const { performance } = __webpack_require__(/*! perf_hooks */ "perf_hooks")
const { isBlobLike, toUSVString, ReadableStreamFrom } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const assert = __webpack_require__(/*! assert */ "assert")

let File

// https://fetch.spec.whatwg.org/#block-bad-port
const badPorts = [
  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',
  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',
  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',
  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',
  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',
  '10080'
]

function responseURL (response) {
  // https://fetch.spec.whatwg.org/#responses
  // A response has an associated URL. It is a pointer to the last URL
  // in response’s URL list and null if response’s URL list is empty.
  const urlList = response.urlList
  const length = urlList.length
  return length === 0 ? null : urlList[length - 1].toString()
}

// https://fetch.spec.whatwg.org/#concept-response-location-url
function responseLocationURL (response, requestFragment) {
  // 1. If response’s status is not a redirect status, then return null.
  if (!redirectStatus.includes(response.status)) {
    return null
  }

  // 2. Let location be the result of extracting header list values given
  // `Location` and response’s header list.
  let location = response.headersList.get('location')

  // 3. If location is a value, then set location to the result of parsing
  // location with response’s URL.
  location = location ? new URL(location, responseURL(response)) : null

  // 4. If location is a URL whose fragment is null, then set location’s
  // fragment to requestFragment.
  if (location && !location.hash) {
    location.hash = requestFragment
  }

  // 5. Return location.
  return location
}

/** @returns {URL} */
function requestCurrentURL (request) {
  return request.urlList[request.urlList.length - 1]
}

function requestBadPort (request) {
  // 1. Let url be request’s current URL.
  const url = requestCurrentURL(request)

  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,
  // then return blocked.
  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {
    return 'blocked'
  }

  // 3. Return allowed.
  return 'allowed'
}

function isFileLike (object) {
  if (!File) {
    File = (__webpack_require__(/*! ./file */ "../../node_modules/undici/lib/fetch/file.js").File)
  }
  return object instanceof File || (
    object &&
    (typeof object.stream === 'function' ||
     typeof object.arrayBuffer === 'function') &&
    /^(File)$/.test(object[Symbol.toStringTag])
  )
}

// Check whether |statusText| is a ByteString and
// matches the Reason-Phrase token production.
// RFC 2616: https://tools.ietf.org/html/rfc2616
// RFC 7230: https://tools.ietf.org/html/rfc7230
// "reason-phrase = *( HTAB / SP / VCHAR / obs-text )"
// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116
function isValidReasonPhrase (statusText) {
  for (let i = 0; i < statusText.length; ++i) {
    const c = statusText.charCodeAt(i)
    if (
      !(
        (
          c === 0x09 || // HTAB
          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR
          (c >= 0x80 && c <= 0xff)
        ) // obs-text
      )
    ) {
      return false
    }
  }
  return true
}

function isTokenChar (c) {
  return !(
    c >= 0x7f ||
    c <= 0x20 ||
    c === '(' ||
    c === ')' ||
    c === '<' ||
    c === '>' ||
    c === '@' ||
    c === ',' ||
    c === ';' ||
    c === ':' ||
    c === '\\' ||
    c === '"' ||
    c === '/' ||
    c === '[' ||
    c === ']' ||
    c === '?' ||
    c === '=' ||
    c === '{' ||
    c === '}'
  )
}

// See RFC 7230, Section 3.2.6.
// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321
function isValidHTTPToken (characters) {
  if (!characters || typeof characters !== 'string') {
    return false
  }
  for (let i = 0; i < characters.length; ++i) {
    const c = characters.charCodeAt(i)
    if (c > 0x7f || !isTokenChar(c)) {
      return false
    }
  }
  return true
}

// https://fetch.spec.whatwg.org/#header-name
// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342
function isValidHeaderName (potentialValue) {
  if (potentialValue.length === 0) {
    return false
  }

  for (const char of potentialValue) {
    if (!isValidHTTPToken(char)) {
      return false
    }
  }

  return true
}

/**
 * @see https://fetch.spec.whatwg.org/#header-value
 * @param {string} potentialValue
 */
function isValidHeaderValue (potentialValue) {
  // - Has no leading or trailing HTTP tab or space bytes.
  // - Contains no 0x00 (NUL) or HTTP newline bytes.
  if (
    potentialValue.startsWith('\t') ||
    potentialValue.startsWith(' ') ||
    potentialValue.endsWith('\t') ||
    potentialValue.endsWith(' ')
  ) {
    return false
  }

  if (
    potentialValue.includes('\0') ||
    potentialValue.includes('\r') ||
    potentialValue.includes('\n')
  ) {
    return false
  }

  return true
}

// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect
function setRequestReferrerPolicyOnRedirect (request, actualResponse) {
  //  Given a request request and a response actualResponse, this algorithm
  //  updates request’s referrer policy according to the Referrer-Policy
  //  header (if any) in actualResponse.

  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy
  // from a Referrer-Policy header on actualResponse.
  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header
  const policy = ''

  // 2. If policy is not the empty string, then set request’s referrer policy to policy.
  if (policy !== '') {
    request.referrerPolicy = policy
  }
}

// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check
function crossOriginResourcePolicyCheck () {
  // TODO
  return 'allowed'
}

// https://fetch.spec.whatwg.org/#concept-cors-check
function corsCheck () {
  // TODO
  return 'success'
}

// https://fetch.spec.whatwg.org/#concept-tao-check
function TAOCheck () {
  // TODO
  return 'success'
}

function appendFetchMetadata (httpRequest) {
  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header
  //  TODO

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header

  //  1. Assert: r’s url is a potentially trustworthy URL.
  //  TODO

  //  2. Let header be a Structured Header whose value is a token.
  let header = null

  //  3. Set header’s value to r’s mode.
  header = httpRequest.mode

  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.
  httpRequest.headersList.set('sec-fetch-mode', header)

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header
  //  TODO

  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header
  //  TODO
}

// https://fetch.spec.whatwg.org/#append-a-request-origin-header
function appendRequestOriginHeader (request) {
  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.
  let serializedOrigin = request.origin

  // 2. If request’s response tainting is "cors" or request’s mode is "websocket", then append (`Origin`, serializedOrigin) to request’s header list.
  if (request.responseTainting === 'cors' || request.mode === 'websocket') {
    if (serializedOrigin) {
      request.headersList.append('Origin', serializedOrigin)
    }

  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:
  } else if (request.method !== 'GET' && request.method !== 'HEAD') {
    // 1. Switch on request’s referrer policy:
    switch (request.referrerPolicy) {
      case 'no-referrer':
        // Set serializedOrigin to `null`.
        serializedOrigin = null
        break
      case 'no-referrer-when-downgrade':
      case 'strict-origin':
      case 'strict-origin-when-cross-origin':
        // If request’s origin is a tuple origin, its scheme is "https", and request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {
          serializedOrigin = null
        }
        break
      case 'same-origin':
        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.
        if (!sameOrigin(request, requestCurrentURL(request))) {
          serializedOrigin = null
        }
        break
      default:
        // Do nothing.
    }

    if (serializedOrigin) {
      // 2. Append (`Origin`, serializedOrigin) to request’s header list.
      request.headersList.append('Origin', serializedOrigin)
    }
  }
}

function coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {
  // TODO
  return performance.now()
}

// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info
function createOpaqueTimingInfo (timingInfo) {
  return {
    startTime: timingInfo.startTime ?? 0,
    redirectStartTime: 0,
    redirectEndTime: 0,
    postRedirectStartTime: timingInfo.startTime ?? 0,
    finalServiceWorkerStartTime: 0,
    finalNetworkResponseStartTime: 0,
    finalNetworkRequestStartTime: 0,
    endTime: 0,
    encodedBodySize: 0,
    decodedBodySize: 0,
    finalConnectionTimingInfo: null
  }
}

// https://html.spec.whatwg.org/multipage/origin.html#policy-container
function makePolicyContainer () {
  // TODO
  return {}
}

// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container
function clonePolicyContainer () {
  // TODO
  return {}
}

// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer
function determineRequestsReferrer (request) {
  // TODO
  return 'no-referrer'
}

function matchRequestIntegrity (request, bytes) {
  return false
}

// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request
function tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {
  // TODO
}

/**
 * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}
 * @param {URL} A
 * @param {URL} B
 */
function sameOrigin (A, B) {
  // 1. If A and B are the same opaque origin, then return true.
  // "opaque origin" is an internal value we cannot access, ignore.

  // 2. If A and B are both tuple origins and their schemes,
  //    hosts, and port are identical, then return true.
  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {
    return true
  }

  // 3. Return false.
  return false
}

function createDeferredPromise () {
  let res
  let rej
  const promise = new Promise((resolve, reject) => {
    res = resolve
    rej = reject
  })

  return { promise, resolve: res, reject: rej }
}

function isAborted (fetchParams) {
  return fetchParams.controller.state === 'aborted'
}

function isCancelled (fetchParams) {
  return fetchParams.controller.state === 'aborted' ||
    fetchParams.controller.state === 'terminated'
}

// https://fetch.spec.whatwg.org/#concept-method-normalize
function normalizeMethod (method) {
  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)
    ? method.toUpperCase()
    : method
}

// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string
function serializeJavascriptValueToJSONString (value) {
  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).
  const result = JSON.stringify(value)

  // 2. If result is undefined, then throw a TypeError.
  if (result === undefined) {
    throw new TypeError('Value is not JSON serializable')
  }

  // 3. Assert: result is a string.
  assert(typeof result === 'string')

  // 4. Return result.
  return result
}

// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object
const esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))

// https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object
function makeIterator (iterator, name) {
  const i = {
    next () {
      if (Object.getPrototypeOf(this) !== i) {
        throw new TypeError(
          `'next' called on an object that does not implement interface ${name} Iterator.`
        )
      }

      return iterator.next()
    },
    // The class string of an iterator prototype object for a given interface is the
    // result of concatenating the identifier of the interface and the string " Iterator".
    [Symbol.toStringTag]: `${name} Iterator`
  }

  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.
  Object.setPrototypeOf(i, esIteratorPrototype)
  // esIteratorPrototype needs to be the prototype of i
  // which is the prototype of an empty object. Yes, it's confusing.
  return Object.setPrototypeOf({}, i)
}

/**
 * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.
 */
const hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))

module.exports = {
  isAborted,
  isCancelled,
  createDeferredPromise,
  ReadableStreamFrom,
  toUSVString,
  tryUpgradeRequestToAPotentiallyTrustworthyURL,
  coarsenedSharedCurrentTime,
  matchRequestIntegrity,
  determineRequestsReferrer,
  makePolicyContainer,
  clonePolicyContainer,
  appendFetchMetadata,
  appendRequestOriginHeader,
  TAOCheck,
  corsCheck,
  crossOriginResourcePolicyCheck,
  createOpaqueTimingInfo,
  setRequestReferrerPolicyOnRedirect,
  isValidHTTPToken,
  requestBadPort,
  requestCurrentURL,
  responseURL,
  responseLocationURL,
  isBlobLike,
  isFileLike,
  isValidReasonPhrase,
  sameOrigin,
  normalizeMethod,
  serializeJavascriptValueToJSONString,
  makeIterator,
  isValidHeaderName,
  isValidHeaderValue,
  hasOwn
}


/***/ }),

/***/ "../../node_modules/undici/lib/fetch/webidl.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/fetch/webidl.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { types } = __webpack_require__(/*! util */ "util")
const { hasOwn, toUSVString } = __webpack_require__(/*! ./util */ "../../node_modules/undici/lib/fetch/util.js")

const webidl = {}
webidl.converters = {}
webidl.util = {}
webidl.errors = {}

/**
 *
 * @param {{
 *   header: string
 *   message: string
 * }} message
 */
webidl.errors.exception = function (message) {
  throw new TypeError(`${message.header}: ${message.message}`)
}

/**
 * Throw an error when conversion from one type to another has failed
 * @param {{
 *   prefix: string
 *   argument: string
 *   types: string[]
 * }} context
 */
webidl.errors.conversionFailed = function (context) {
  const plural = context.types.length === 1 ? '' : ' one of'
  const message =
    `${context.argument} could not be converted to` +
    `${plural}: ${context.types.join(', ')}.`

  return webidl.errors.exception({
    header: context.prefix,
    message
  })
}

/**
 * Throw an error when an invalid argument is provided
 * @param {{
 *   prefix: string
 *   value: string
 *   type: string
 * }} context
 */
webidl.errors.invalidArgument = function (context) {
  return webidl.errors.exception({
    header: context.prefix,
    message: `"${context.value}" is an invalid ${context.type}.`
  })
}

// https://tc39.es/ecma262/#sec-ecmascript-data-types-and-values
webidl.util.Type = function (V) {
  switch (typeof V) {
    case 'undefined': return 'Undefined'
    case 'boolean': return 'Boolean'
    case 'string': return 'String'
    case 'symbol': return 'Symbol'
    case 'number': return 'Number'
    case 'bigint': return 'BigInt'
    case 'function':
    case 'object': {
      if (V === null) {
        return 'Null'
      }

      return 'Object'
    }
  }
}

// https://webidl.spec.whatwg.org/#abstract-opdef-converttoint
webidl.util.ConvertToInt = function (V, bitLength, signedness, opts = {}) {
  let upperBound
  let lowerBound

  // 1. If bitLength is 64, then:
  if (bitLength === 64) {
    // 1. Let upperBound be 2^53 − 1.
    upperBound = Math.pow(2, 53) - 1

    // 2. If signedness is "unsigned", then let lowerBound be 0.
    if (signedness === 'unsigned') {
      lowerBound = 0
    } else {
      // 3. Otherwise let lowerBound be −2^53 + 1.
      lowerBound = Math.pow(-2, 53) + 1
    }
  } else if (signedness === 'unsigned') {
    // 2. Otherwise, if signedness is "unsigned", then:

    // 1. Let lowerBound be 0.
    lowerBound = 0

    // 2. Let upperBound be 2^bitLength − 1.
    upperBound = Math.pow(2, bitLength) - 1
  } else {
    // 3. Otherwise:

    // 1. Let lowerBound be -2^bitLength − 1.
    lowerBound = Math.pow(-2, bitLength) - 1

    // 2. Let upperBound be 2^bitLength − 1 − 1.
    upperBound = Math.pow(2, bitLength - 1) - 1
  }

  // 4. Let x be ? ToNumber(V).
  let x = Number(V)

  // 5. If x is −0, then set x to +0.
  if (Object.is(-0, x)) {
    x = 0
  }

  // 6. If the conversion is to an IDL type associated
  //    with the [EnforceRange] extended attribute, then:
  if (opts.enforceRange === true) {
    // 1. If x is NaN, +∞, or −∞, then throw a TypeError.
    if (
      Number.isNaN(x) ||
      x === Number.POSITIVE_INFINITY ||
      x === Number.NEGATIVE_INFINITY
    ) {
      webidl.errors.exception({
        header: 'Integer conversion',
        message: `Could not convert ${V} to an integer.`
      })
    }

    // 2. Set x to IntegerPart(x).
    x = webidl.util.IntegerPart(x)

    // 3. If x < lowerBound or x > upperBound, then
    //    throw a TypeError.
    if (x < lowerBound || x > upperBound) {
      webidl.errors.exception({
        header: 'Integer conversion',
        message: `Value must be between ${lowerBound}-${upperBound}, got ${x}.`
      })
    }

    // 4. Return x.
    return x
  }

  // 7. If x is not NaN and the conversion is to an IDL
  //    type associated with the [Clamp] extended
  //    attribute, then:
  if (!Number.isNaN(x) && opts.clamp === true) {
    // 1. Set x to min(max(x, lowerBound), upperBound).
    x = Math.min(Math.max(x, lowerBound), upperBound)

    // 2. Round x to the nearest integer, choosing the
    //    even integer if it lies halfway between two,
    //    and choosing +0 rather than −0.
    if (Math.floor(x) % 2 === 0) {
      x = Math.floor(x)
    } else {
      x = Math.ceil(x)
    }

    // 3. Return x.
    return x
  }

  // 8. If x is NaN, +0, +∞, or −∞, then return +0.
  if (
    Number.isNaN(x) ||
    Object.is(0, x) ||
    x === Number.POSITIVE_INFINITY ||
    x === Number.NEGATIVE_INFINITY
  ) {
    return 0
  }

  // 9. Set x to IntegerPart(x).
  x = webidl.util.IntegerPart(x)

  // 10. Set x to x modulo 2^bitLength.
  x = x % Math.pow(2, bitLength)

  // 11. If signedness is "signed" and x ≥ 2^bitLength − 1,
  //    then return x − 2^bitLength.
  if (signedness === 'signed' && x >= Math.pow(2, bitLength) - 1) {
    return x - Math.pow(2, bitLength)
  }

  // 12. Otherwise, return x.
  return x
}

// https://webidl.spec.whatwg.org/#abstract-opdef-integerpart
webidl.util.IntegerPart = function (n) {
  // 1. Let r be floor(abs(n)).
  const r = Math.floor(Math.abs(n))

  // 2. If n < 0, then return -1 × r.
  if (n < 0) {
    return -1 * r
  }

  // 3. Otherwise, return r.
  return r
}

// https://webidl.spec.whatwg.org/#es-sequence
webidl.sequenceConverter = function (converter) {
  return (V) => {
    // 1. If Type(V) is not Object, throw a TypeError.
    if (webidl.util.Type(V) !== 'Object') {
      webidl.errors.exception({
        header: 'Sequence',
        message: `Value of type ${webidl.util.Type(V)} is not an Object.`
      })
    }

    // 2. Let method be ? GetMethod(V, @@iterator).
    /** @type {Generator} */
    const method = V?.[Symbol.iterator]?.()
    const seq = []

    // 3. If method is undefined, throw a TypeError.
    if (
      method === undefined ||
      typeof method.next !== 'function'
    ) {
      webidl.errors.exception({
        header: 'Sequence',
        message: 'Object is not an iterator.'
      })
    }

    // https://webidl.spec.whatwg.org/#create-sequence-from-iterable
    while (true) {
      const { done, value } = method.next()

      if (done) {
        break
      }

      seq.push(converter(value))
    }

    return seq
  }
}

webidl.recordConverter = function (keyConverter, valueConverter) {
  return (V) => {
    const record = {}
    const type = webidl.util.Type(V)

    if (type === 'Undefined' || type === 'Null') {
      return record
    }

    if (type !== 'Object') {
      webidl.errors.exception({
        header: 'Record',
        message: `Expected ${V} to be an Object type.`
      })
    }

    for (let [key, value] of Object.entries(V)) {
      key = keyConverter(key)
      value = valueConverter(value)

      record[key] = value
    }

    return record
  }
}

webidl.interfaceConverter = function (i) {
  return (V, opts = {}) => {
    if (opts.strict !== false && !(V instanceof i)) {
      webidl.errors.exception({
        header: i.name,
        message: `Expected ${V} to be an instance of ${i.name}.`
      })
    }

    return V
  }
}

/**
 * @param {{
 *   key: string,
 *   defaultValue?: any,
 *   required?: boolean,
 *   converter: (...args: unknown[]) => unknown,
 *   allowedValues?: any[]
 * }[]} converters
 * @returns
 */
webidl.dictionaryConverter = function (converters) {
  return (dictionary) => {
    const type = webidl.util.Type(dictionary)
    const dict = {}

    if (type !== 'Null' && type !== 'Undefined' && type !== 'Object') {
      webidl.errors.exception({
        header: 'Dictionary',
        message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
      })
    }

    for (const options of converters) {
      const { key, defaultValue, required, converter } = options

      if (required === true) {
        if (!hasOwn(dictionary, key)) {
          webidl.errors.exception({
            header: 'Dictionary',
            message: `Missing required key "${key}".`
          })
        }
      }

      let value = dictionary[key]
      const hasDefault = hasOwn(options, 'defaultValue')

      // Only use defaultValue if value is undefined and
      // a defaultValue options was provided.
      if (hasDefault && value !== null) {
        value = value ?? defaultValue
      }

      // A key can be optional and have no default value.
      // When this happens, do not perform a conversion,
      // and do not assign the key a value.
      if (required || hasDefault || value !== undefined) {
        value = converter(value)

        if (
          options.allowedValues &&
          !options.allowedValues.includes(value)
        ) {
          webidl.errors.exception({
            header: 'Dictionary',
            message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(', ')}.`
          })
        }

        dict[key] = value
      }
    }

    return dict
  }
}

webidl.nullableConverter = function (converter) {
  return (V) => {
    if (V === null) {
      return V
    }

    return converter(V)
  }
}

// https://webidl.spec.whatwg.org/#es-DOMString
webidl.converters.DOMString = function (V, opts = {}) {
  // 1. If V is null and the conversion is to an IDL type
  //    associated with the [LegacyNullToEmptyString]
  //    extended attribute, then return the DOMString value
  //    that represents the empty string.
  if (V === null && opts.legacyNullToEmptyString) {
    return ''
  }

  // 2. Let x be ? ToString(V).
  if (typeof V === 'symbol') {
    throw new TypeError('Could not convert argument of type symbol to string.')
  }

  // 3. Return the IDL DOMString value that represents the
  //    same sequence of code units as the one the
  //    ECMAScript String value x represents.
  return String(V)
}

// eslint-disable-next-line no-control-regex
const isNotLatin1 = /[^\u0000-\u00ff]/

// https://webidl.spec.whatwg.org/#es-ByteString
webidl.converters.ByteString = function (V) {
  // 1. Let x be ? ToString(V).
  // Note: DOMString converter perform ? ToString(V)
  const x = webidl.converters.DOMString(V)

  // 2. If the value of any element of x is greater than
  //    255, then throw a TypeError.
  if (isNotLatin1.test(x)) {
    throw new TypeError('Argument is not a ByteString')
  }

  // 3. Return an IDL ByteString value whose length is the
  //    length of x, and where the value of each element is
  //    the value of the corresponding element of x.
  return x
}

// https://webidl.spec.whatwg.org/#es-USVString
// TODO: ensure that util.toUSVString follows webidl spec
webidl.converters.USVString = toUSVString

// https://webidl.spec.whatwg.org/#es-boolean
webidl.converters.boolean = function (V) {
  // 1. Let x be the result of computing ToBoolean(V).
  const x = Boolean(V)

  // 2. Return the IDL boolean value that is the one that represents
  //    the same truth value as the ECMAScript Boolean value x.
  return x
}

// https://webidl.spec.whatwg.org/#es-any
webidl.converters.any = function (V) {
  return V
}

// https://webidl.spec.whatwg.org/#es-long-long
webidl.converters['long long'] = function (V, opts) {
  // 1. Let x be ? ConvertToInt(V, 64, "signed").
  const x = webidl.util.ConvertToInt(V, 64, 'signed', opts)

  // 2. Return the IDL long long value that represents
  //    the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#es-unsigned-short
webidl.converters['unsigned short'] = function (V) {
  // 1. Let x be ? ConvertToInt(V, 16, "unsigned").
  const x = webidl.util.ConvertToInt(V, 16, 'unsigned')

  // 2. Return the IDL unsigned short value that represents
  //    the same numeric value as x.
  return x
}

// https://webidl.spec.whatwg.org/#idl-ArrayBuffer
webidl.converters.ArrayBuffer = function (V, opts = {}) {
  // 1. If Type(V) is not Object, or V does not have an
  //    [[ArrayBufferData]] internal slot, then throw a
  //    TypeError.
  // see: https://tc39.es/ecma262/#sec-properties-of-the-arraybuffer-instances
  // see: https://tc39.es/ecma262/#sec-properties-of-the-sharedarraybuffer-instances
  if (
    webidl.util.Type(V) !== 'Object' ||
    !types.isAnyArrayBuffer(V)
  ) {
    webidl.errors.conversionFailed({
      prefix: `${V}`,
      argument: `${V}`,
      types: ['ArrayBuffer']
    })
  }

  // 2. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V) is true, then throw a
  //    TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V)) {
    webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V) is true, then throw a
  //    TypeError.
  // Note: resizable ArrayBuffers are currently a proposal.

  // 4. Return the IDL ArrayBuffer value that is a
  //    reference to the same object as V.
  return V
}

webidl.converters.TypedArray = function (V, T, opts = {}) {
  // 1. Let T be the IDL type V is being converted to.

  // 2. If Type(V) is not Object, or V does not have a
  //    [[TypedArrayName]] internal slot with a value
  //    equal to T’s name, then throw a TypeError.
  if (
    webidl.util.Type(V) !== 'Object' ||
    !types.isTypedArray(V) ||
    V.constructor.name !== T.name
  ) {
    webidl.errors.conversionFailed({
      prefix: `${T.name}`,
      argument: `${V}`,
      types: [T.name]
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
    webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 4. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  // Note: resizable array buffers are currently a proposal

  // 5. Return the IDL value of type T that is a reference
  //    to the same object as V.
  return V
}

webidl.converters.DataView = function (V, opts = {}) {
  // 1. If Type(V) is not Object, or V does not have a
  //    [[DataView]] internal slot, then throw a TypeError.
  if (webidl.util.Type(V) !== 'Object' || !types.isDataView(V)) {
    webidl.errors.exception({
      header: 'DataView',
      message: 'Object is not a DataView.'
    })
  }

  // 2. If the conversion is not to an IDL type associated
  //    with the [AllowShared] extended attribute, and
  //    IsSharedArrayBuffer(V.[[ViewedArrayBuffer]]) is true,
  //    then throw a TypeError.
  if (opts.allowShared === false && types.isSharedArrayBuffer(V.buffer)) {
    webidl.errors.exception({
      header: 'ArrayBuffer',
      message: 'SharedArrayBuffer is not allowed.'
    })
  }

  // 3. If the conversion is not to an IDL type associated
  //    with the [AllowResizable] extended attribute, and
  //    IsResizableArrayBuffer(V.[[ViewedArrayBuffer]]) is
  //    true, then throw a TypeError.
  // Note: resizable ArrayBuffers are currently a proposal

  // 4. Return the IDL DataView value that is a reference
  //    to the same object as V.
  return V
}

// https://webidl.spec.whatwg.org/#BufferSource
webidl.converters.BufferSource = function (V, opts = {}) {
  if (types.isAnyArrayBuffer(V)) {
    return webidl.converters.ArrayBuffer(V, opts)
  }

  if (types.isTypedArray(V)) {
    return webidl.converters.TypedArray(V, V.constructor)
  }

  if (types.isDataView(V)) {
    return webidl.converters.DataView(V, opts)
  }

  throw new TypeError(`Could not convert ${V} to a BufferSource.`)
}

webidl.converters['sequence<ByteString>'] = webidl.sequenceConverter(
  webidl.converters.ByteString
)

webidl.converters['sequence<sequence<ByteString>>'] = webidl.sequenceConverter(
  webidl.converters['sequence<ByteString>']
)

webidl.converters['record<ByteString, ByteString>'] = webidl.recordConverter(
  webidl.converters.ByteString,
  webidl.converters.ByteString
)

module.exports = {
  webidl
}


/***/ }),

/***/ "../../node_modules/undici/lib/global.js":
/*!***********************************************!*\
  !*** ../../node_modules/undici/lib/global.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// We include a version number for the Dispatcher API. In case of breaking changes,
// this version number must be increased to avoid conflicts.
const globalDispatcher = Symbol.for('undici.globalDispatcher.1')
const { InvalidArgumentError } = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const Agent = __webpack_require__(/*! ./agent */ "../../node_modules/undici/lib/agent.js")

if (getGlobalDispatcher() === undefined) {
  setGlobalDispatcher(new Agent())
}

function setGlobalDispatcher (agent) {
  if (!agent || typeof agent.dispatch !== 'function') {
    throw new InvalidArgumentError('Argument agent must implement Agent')
  }
  Object.defineProperty(globalThis, globalDispatcher, {
    value: agent,
    writable: true,
    enumerable: false,
    configurable: false
  })
}

function getGlobalDispatcher () {
  return globalThis[globalDispatcher]
}

module.exports = {
  setGlobalDispatcher,
  getGlobalDispatcher
}


/***/ }),

/***/ "../../node_modules/undici/lib/handler/redirect.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/handler/redirect.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")
const { kBodyUsed } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const assert = __webpack_require__(/*! assert */ "assert")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const EE = __webpack_require__(/*! events */ "events")

const redirectableStatusCodes = [300, 301, 302, 303, 307, 308]

const kBody = Symbol('body')

class BodyAsyncIterable {
  constructor (body) {
    this[kBody] = body
    this[kBodyUsed] = false
  }

  async * [Symbol.asyncIterator] () {
    assert(!this[kBodyUsed], 'disturbed')
    this[kBodyUsed] = true
    yield * this[kBody]
  }
}

class RedirectHandler {
  constructor (dispatcher, maxRedirections, opts, handler) {
    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
      throw new InvalidArgumentError('maxRedirections must be a positive number')
    }

    util.validateHandler(handler, opts.method, opts.upgrade)

    this.dispatcher = dispatcher
    this.location = null
    this.abort = null
    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy
    this.maxRedirections = maxRedirections
    this.handler = handler
    this.history = []

    if (util.isStream(this.opts.body)) {
      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp
      // so that it can be dispatched again?
      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?
      if (util.bodyLength(this.opts.body) === 0) {
        this.opts.body
          .on('data', function () {
            assert(false)
          })
      }

      if (typeof this.opts.body.readableDidRead !== 'boolean') {
        this.opts.body[kBodyUsed] = false
        EE.prototype.on.call(this.opts.body, 'data', function () {
          this[kBodyUsed] = true
        })
      }
    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
      // TODO (fix): We can't access ReadableStream internal state
      // to determine whether or not it has been disturbed. This is just
      // a workaround.
      this.opts.body = new BodyAsyncIterable(this.opts.body)
    } else if (
      this.opts.body &&
      typeof this.opts.body !== 'string' &&
      !ArrayBuffer.isView(this.opts.body) &&
      util.isIterable(this.opts.body)
    ) {
      // TODO: Should we allow re-using iterable if !this.opts.idempotent
      // or through some other flag?
      this.opts.body = new BodyAsyncIterable(this.opts.body)
    }
  }

  onConnect (abort) {
    this.abort = abort
    this.handler.onConnect(abort, { history: this.history })
  }

  onUpgrade (statusCode, headers, socket) {
    this.handler.onUpgrade(statusCode, headers, socket)
  }

  onError (error) {
    this.handler.onError(error)
  }

  onHeaders (statusCode, headers, resume, statusText) {
    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)
      ? null
      : parseLocation(statusCode, headers)

    if (this.opts.origin) {
      this.history.push(new URL(this.opts.path, this.opts.origin))
    }

    if (!this.location) {
      return this.handler.onHeaders(statusCode, headers, resume, statusText)
    }

    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)))
    const path = search ? `${pathname}${search}` : pathname

    // Remove headers referring to the original URL.
    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.
    // https://tools.ietf.org/html/rfc7231#section-6.4
    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)
    this.opts.path = path
    this.opts.origin = origin
    this.opts.maxRedirections = 0

    // https://tools.ietf.org/html/rfc7231#section-6.4.4
    // In case of HTTP 303, always replace method to be either HEAD or GET
    if (statusCode === 303 && this.opts.method !== 'HEAD') {
      this.opts.method = 'GET'
      this.opts.body = null
    }
  }

  onData (chunk) {
    if (this.location) {
      /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response bodies.

        Redirection is used to serve the requested resource from another URL, so it is assumes that
        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.

        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually
        (which means it's optional and not mandated) contain just an hyperlink to the value of
        the Location response header, so the body can be ignored safely.

        For status 300, which is "Multiple Choices", the spec mentions both generating a Location
        response header AND a response body with the other possible location to follow.
        Since the spec explicitily chooses not to specify a format for such body and leave it to
        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.
      */
    } else {
      return this.handler.onData(chunk)
    }
  }

  onComplete (trailers) {
    if (this.location) {
      /*
        https://tools.ietf.org/html/rfc7231#section-6.4

        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections
        and neither are useful if present.

        See comment on onData method above for more detailed informations.
      */

      this.location = null
      this.abort = null

      this.dispatcher.dispatch(this.opts, this)
    } else {
      this.handler.onComplete(trailers)
    }
  }

  onBodySent (chunk) {
    if (this.handler.onBodySent) {
      this.handler.onBodySent(chunk)
    }
  }
}

function parseLocation (statusCode, headers) {
  if (redirectableStatusCodes.indexOf(statusCode) === -1) {
    return null
  }

  for (let i = 0; i < headers.length; i += 2) {
    if (headers[i].toString().toLowerCase() === 'location') {
      return headers[i + 1]
    }
  }
}

// https://tools.ietf.org/html/rfc7231#section-6.4.4
function shouldRemoveHeader (header, removeContent, unknownOrigin) {
  return (
    (header.length === 4 && header.toString().toLowerCase() === 'host') ||
    (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||
    (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization') ||
    (unknownOrigin && header.length === 6 && header.toString().toLowerCase() === 'cookie')
  )
}

// https://tools.ietf.org/html/rfc7231#section-6.4
function cleanRequestHeaders (headers, removeContent, unknownOrigin) {
  const ret = []
  if (Array.isArray(headers)) {
    for (let i = 0; i < headers.length; i += 2) {
      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
        ret.push(headers[i], headers[i + 1])
      }
    }
  } else if (headers && typeof headers === 'object') {
    for (const key of Object.keys(headers)) {
      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
        ret.push(key, headers[key])
      }
    }
  } else {
    assert(headers == null, 'headers must be an object or an array')
  }
  return ret
}

module.exports = RedirectHandler


/***/ }),

/***/ "../../node_modules/undici/lib/llhttp/constants.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/constants.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/undici/lib/llhttp/utils.js");
// C headers
var ERROR;
(function (ERROR) {
    ERROR[ERROR["OK"] = 0] = "OK";
    ERROR[ERROR["INTERNAL"] = 1] = "INTERNAL";
    ERROR[ERROR["STRICT"] = 2] = "STRICT";
    ERROR[ERROR["LF_EXPECTED"] = 3] = "LF_EXPECTED";
    ERROR[ERROR["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
    ERROR[ERROR["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
    ERROR[ERROR["INVALID_METHOD"] = 6] = "INVALID_METHOD";
    ERROR[ERROR["INVALID_URL"] = 7] = "INVALID_URL";
    ERROR[ERROR["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
    ERROR[ERROR["INVALID_VERSION"] = 9] = "INVALID_VERSION";
    ERROR[ERROR["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
    ERROR[ERROR["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
    ERROR[ERROR["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
    ERROR[ERROR["INVALID_STATUS"] = 13] = "INVALID_STATUS";
    ERROR[ERROR["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
    ERROR[ERROR["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
    ERROR[ERROR["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
    ERROR[ERROR["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
    ERROR[ERROR["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
    ERROR[ERROR["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
    ERROR[ERROR["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
    ERROR[ERROR["PAUSED"] = 21] = "PAUSED";
    ERROR[ERROR["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
    ERROR[ERROR["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
    ERROR[ERROR["USER"] = 24] = "USER";
})(ERROR = exports.ERROR || (exports.ERROR = {}));
var TYPE;
(function (TYPE) {
    TYPE[TYPE["BOTH"] = 0] = "BOTH";
    TYPE[TYPE["REQUEST"] = 1] = "REQUEST";
    TYPE[TYPE["RESPONSE"] = 2] = "RESPONSE";
})(TYPE = exports.TYPE || (exports.TYPE = {}));
var FLAGS;
(function (FLAGS) {
    FLAGS[FLAGS["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
    FLAGS[FLAGS["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
    FLAGS[FLAGS["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
    FLAGS[FLAGS["CHUNKED"] = 8] = "CHUNKED";
    FLAGS[FLAGS["UPGRADE"] = 16] = "UPGRADE";
    FLAGS[FLAGS["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
    FLAGS[FLAGS["SKIPBODY"] = 64] = "SKIPBODY";
    FLAGS[FLAGS["TRAILING"] = 128] = "TRAILING";
    // 1 << 8 is unused
    FLAGS[FLAGS["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));
var LENIENT_FLAGS;
(function (LENIENT_FLAGS) {
    LENIENT_FLAGS[LENIENT_FLAGS["HEADERS"] = 1] = "HEADERS";
    LENIENT_FLAGS[LENIENT_FLAGS["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
    LENIENT_FLAGS[LENIENT_FLAGS["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
var METHODS;
(function (METHODS) {
    METHODS[METHODS["DELETE"] = 0] = "DELETE";
    METHODS[METHODS["GET"] = 1] = "GET";
    METHODS[METHODS["HEAD"] = 2] = "HEAD";
    METHODS[METHODS["POST"] = 3] = "POST";
    METHODS[METHODS["PUT"] = 4] = "PUT";
    /* pathological */
    METHODS[METHODS["CONNECT"] = 5] = "CONNECT";
    METHODS[METHODS["OPTIONS"] = 6] = "OPTIONS";
    METHODS[METHODS["TRACE"] = 7] = "TRACE";
    /* WebDAV */
    METHODS[METHODS["COPY"] = 8] = "COPY";
    METHODS[METHODS["LOCK"] = 9] = "LOCK";
    METHODS[METHODS["MKCOL"] = 10] = "MKCOL";
    METHODS[METHODS["MOVE"] = 11] = "MOVE";
    METHODS[METHODS["PROPFIND"] = 12] = "PROPFIND";
    METHODS[METHODS["PROPPATCH"] = 13] = "PROPPATCH";
    METHODS[METHODS["SEARCH"] = 14] = "SEARCH";
    METHODS[METHODS["UNLOCK"] = 15] = "UNLOCK";
    METHODS[METHODS["BIND"] = 16] = "BIND";
    METHODS[METHODS["REBIND"] = 17] = "REBIND";
    METHODS[METHODS["UNBIND"] = 18] = "UNBIND";
    METHODS[METHODS["ACL"] = 19] = "ACL";
    /* subversion */
    METHODS[METHODS["REPORT"] = 20] = "REPORT";
    METHODS[METHODS["MKACTIVITY"] = 21] = "MKACTIVITY";
    METHODS[METHODS["CHECKOUT"] = 22] = "CHECKOUT";
    METHODS[METHODS["MERGE"] = 23] = "MERGE";
    /* upnp */
    METHODS[METHODS["M-SEARCH"] = 24] = "M-SEARCH";
    METHODS[METHODS["NOTIFY"] = 25] = "NOTIFY";
    METHODS[METHODS["SUBSCRIBE"] = 26] = "SUBSCRIBE";
    METHODS[METHODS["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
    /* RFC-5789 */
    METHODS[METHODS["PATCH"] = 28] = "PATCH";
    METHODS[METHODS["PURGE"] = 29] = "PURGE";
    /* CalDAV */
    METHODS[METHODS["MKCALENDAR"] = 30] = "MKCALENDAR";
    /* RFC-2068, section 19.6.1.2 */
    METHODS[METHODS["LINK"] = 31] = "LINK";
    METHODS[METHODS["UNLINK"] = 32] = "UNLINK";
    /* icecast */
    METHODS[METHODS["SOURCE"] = 33] = "SOURCE";
    /* RFC-7540, section 11.6 */
    METHODS[METHODS["PRI"] = 34] = "PRI";
    /* RFC-2326 RTSP */
    METHODS[METHODS["DESCRIBE"] = 35] = "DESCRIBE";
    METHODS[METHODS["ANNOUNCE"] = 36] = "ANNOUNCE";
    METHODS[METHODS["SETUP"] = 37] = "SETUP";
    METHODS[METHODS["PLAY"] = 38] = "PLAY";
    METHODS[METHODS["PAUSE"] = 39] = "PAUSE";
    METHODS[METHODS["TEARDOWN"] = 40] = "TEARDOWN";
    METHODS[METHODS["GET_PARAMETER"] = 41] = "GET_PARAMETER";
    METHODS[METHODS["SET_PARAMETER"] = 42] = "SET_PARAMETER";
    METHODS[METHODS["REDIRECT"] = 43] = "REDIRECT";
    METHODS[METHODS["RECORD"] = 44] = "RECORD";
    /* RAOP */
    METHODS[METHODS["FLUSH"] = 45] = "FLUSH";
})(METHODS = exports.METHODS || (exports.METHODS = {}));
exports.METHODS_HTTP = [
    METHODS.DELETE,
    METHODS.GET,
    METHODS.HEAD,
    METHODS.POST,
    METHODS.PUT,
    METHODS.CONNECT,
    METHODS.OPTIONS,
    METHODS.TRACE,
    METHODS.COPY,
    METHODS.LOCK,
    METHODS.MKCOL,
    METHODS.MOVE,
    METHODS.PROPFIND,
    METHODS.PROPPATCH,
    METHODS.SEARCH,
    METHODS.UNLOCK,
    METHODS.BIND,
    METHODS.REBIND,
    METHODS.UNBIND,
    METHODS.ACL,
    METHODS.REPORT,
    METHODS.MKACTIVITY,
    METHODS.CHECKOUT,
    METHODS.MERGE,
    METHODS['M-SEARCH'],
    METHODS.NOTIFY,
    METHODS.SUBSCRIBE,
    METHODS.UNSUBSCRIBE,
    METHODS.PATCH,
    METHODS.PURGE,
    METHODS.MKCALENDAR,
    METHODS.LINK,
    METHODS.UNLINK,
    METHODS.PRI,
    // TODO(indutny): should we allow it with HTTP?
    METHODS.SOURCE,
];
exports.METHODS_ICE = [
    METHODS.SOURCE,
];
exports.METHODS_RTSP = [
    METHODS.OPTIONS,
    METHODS.DESCRIBE,
    METHODS.ANNOUNCE,
    METHODS.SETUP,
    METHODS.PLAY,
    METHODS.PAUSE,
    METHODS.TEARDOWN,
    METHODS.GET_PARAMETER,
    METHODS.SET_PARAMETER,
    METHODS.REDIRECT,
    METHODS.RECORD,
    METHODS.FLUSH,
    // For AirPlay
    METHODS.GET,
    METHODS.POST,
];
exports.METHOD_MAP = utils_1.enumToMap(METHODS);
exports.H_METHOD_MAP = {};
Object.keys(exports.METHOD_MAP).forEach((key) => {
    if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
    }
});
var FINISH;
(function (FINISH) {
    FINISH[FINISH["SAFE"] = 0] = "SAFE";
    FINISH[FINISH["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
    FINISH[FINISH["UNSAFE"] = 2] = "UNSAFE";
})(FINISH = exports.FINISH || (exports.FINISH = {}));
exports.ALPHA = [];
for (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {
    // Upper case
    exports.ALPHA.push(String.fromCharCode(i));
    // Lower case
    exports.ALPHA.push(String.fromCharCode(i + 0x20));
}
exports.NUM_MAP = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
};
exports.HEX_MAP = {
    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,
    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,
    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,
    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,
};
exports.NUM = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
];
exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
exports.MARK = ['-', '_', '.', '!', '~', '*', '\'', '(', ')'];
exports.USERINFO_CHARS = exports.ALPHANUM
    .concat(exports.MARK)
    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);
// TODO(indutny): use RFC
exports.STRICT_URL_CHAR = [
    '!', '"', '$', '%', '&', '\'',
    '(', ')', '*', '+', ',', '-', '.', '/',
    ':', ';', '<', '=', '>',
    '@', '[', '\\', ']', '^', '_',
    '`',
    '{', '|', '}', '~',
].concat(exports.ALPHANUM);
exports.URL_CHAR = exports.STRICT_URL_CHAR
    .concat(['\t', '\f']);
// All characters with 0x80 bit set to 1
for (let i = 0x80; i <= 0xff; i++) {
    exports.URL_CHAR.push(i);
}
exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
/* Tokens as defined by rfc 2616. Also lowercases them.
 *        token       = 1*<any CHAR except CTLs or separators>
 *     separators     = "(" | ")" | "<" | ">" | "@"
 *                    | "," | ";" | ":" | "\" | <">
 *                    | "/" | "[" | "]" | "?" | "="
 *                    | "{" | "}" | SP | HT
 */
exports.STRICT_TOKEN = [
    '!', '#', '$', '%', '&', '\'',
    '*', '+', '-', '.',
    '^', '_', '`',
    '|', '~',
].concat(exports.ALPHANUM);
exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
/*
 * Verify that a char is a valid visible (printable) US-ASCII
 * character or %x80-FF
 */
exports.HEADER_CHARS = ['\t'];
for (let i = 32; i <= 255; i++) {
    if (i !== 127) {
        exports.HEADER_CHARS.push(i);
    }
}
// ',' = \x44
exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
exports.MAJOR = exports.NUM_MAP;
exports.MINOR = exports.MAJOR;
var HEADER_STATE;
(function (HEADER_STATE) {
    HEADER_STATE[HEADER_STATE["GENERAL"] = 0] = "GENERAL";
    HEADER_STATE[HEADER_STATE["CONNECTION"] = 1] = "CONNECTION";
    HEADER_STATE[HEADER_STATE["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
    HEADER_STATE[HEADER_STATE["UPGRADE"] = 4] = "UPGRADE";
    HEADER_STATE[HEADER_STATE["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
    HEADER_STATE[HEADER_STATE["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
    HEADER_STATE[HEADER_STATE["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
    HEADER_STATE[HEADER_STATE["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
exports.SPECIAL_HEADERS = {
    'connection': HEADER_STATE.CONNECTION,
    'content-length': HEADER_STATE.CONTENT_LENGTH,
    'proxy-connection': HEADER_STATE.CONNECTION,
    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
    'upgrade': HEADER_STATE.UPGRADE,
};
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "../../node_modules/undici/lib/llhttp/llhttp.wasm.js":
/*!***********************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/llhttp.wasm.js ***!
  \***********************************************************/
/***/ ((module) => {

module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYKxqgCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAtFACAAQgA3AgAgAEEwakIANwIAIABBKGpCADcCACAAQSBqQgA3AgAgAEEYakIANwIAIABBEGpCADcCACAAQQhqQgA3AgALZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI0IgFFDQAgASgCHCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQv4CAgAAACyAAQf+RgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQYSUgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBGkkNABC/gICAAAALIABBAnRByJuAgABqKAIACyIAAkAgAEEuSQ0AEL+AgIAAAAsgAEECdEGwnICAAGooAgALFgAgACAALQAtQf4BcSABQQBHcjoALQsZACAAIAAtAC1B/QFxIAFBAEdBAXRyOgAtCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZyOgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIoIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCLCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB3ZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcOQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAI0IgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAhQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCHCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB0oiAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAiAiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL8gEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AIAAtAC1BCnENAEEFDwtBBA8LAkAgBEEgcQ0AAkAgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AQQQhBSAEQYgEcUGABEYNAiAEQShxRQ0CC0EADwtBAEEDIAApAyBQGyEFCyAFC10BAn9BACEBAkAgAC0AKEEBRg0AIAAvATIiAkGcf2pB5ABJDQAgAkHMAUYNACACQbACRg0AIAAvATAiAEHAAHENAEEBIQEgAEGIBHFBgARGDQAgAEEocUUhAQsgAQuiAQEDfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEDIAAvATAiBEECcUUNAQwCC0EAIQMgAC8BMCIEQQFxRQ0BC0EBIQMgAC0AKEEBRg0AIAAvATIiBUGcf2pB5ABJDQAgBUHMAUYNACAFQbACRg0AIARBwABxDQBBACEDIARBiARxQYAERg0AIARBKHFBAEchAwsgAEEAOwEwIABBADoALyADC5QBAQJ/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQEgAC8BMCICQQJxRQ0BDAILQQAhASAALwEwIgJBAXFFDQELQQEhASAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQAgAkHAAHENAEEAIQEgAkGIBHFBgARGDQAgAkEocUEARyEBCyABC08AIABBGGpCADcDACAAQgA3AwAgAEEwakIANwMAIABBKGpCADcDACAAQSBqQgA3AwAgAEEQakIANwMAIABBCGpCADcDACAAQbwBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC9POAQMcfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaIAEhGyABIRwgASEdAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIeQX9qDrwBtwEBtgECAwQFBgcICQoLDA0ODxDAAb8BERITtQEUFRYXGBkavQG8ARscHR4fICG0AbMBIiOyAbEBJCUmJygpKissLS4vMDEyMzQ1Njc4OTq4ATs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAQC5AQtBACEeDK8BC0EPIR4MrgELQQ4hHgytAQtBECEeDKwBC0ERIR4MqwELQRQhHgyqAQtBFSEeDKkBC0EWIR4MqAELQRchHgynAQtBGCEeDKYBC0EIIR4MpQELQRkhHgykAQtBGiEeDKMBC0ETIR4MogELQRIhHgyhAQtBGyEeDKABC0EcIR4MnwELQR0hHgyeAQtBHiEeDJ0BC0GqASEeDJwBC0GrASEeDJsBC0EgIR4MmgELQSEhHgyZAQtBIiEeDJgBC0EjIR4MlwELQSQhHgyWAQtBrQEhHgyVAQtBJSEeDJQBC0EpIR4MkwELQQ0hHgySAQtBJiEeDJEBC0EnIR4MkAELQSghHgyPAQtBLiEeDI4BC0EqIR4MjQELQa4BIR4MjAELQQwhHgyLAQtBLyEeDIoBC0ErIR4MiQELQQshHgyIAQtBLCEeDIcBC0EtIR4MhgELQQohHgyFAQtBMSEeDIQBC0EwIR4MgwELQQkhHgyCAQtBHyEeDIEBC0EyIR4MgAELQTMhHgx/C0E0IR4MfgtBNSEeDH0LQTYhHgx8C0E3IR4MewtBOCEeDHoLQTkhHgx5C0E6IR4MeAtBrAEhHgx3C0E7IR4MdgtBPCEeDHULQT0hHgx0C0E+IR4McwtBPyEeDHILQcAAIR4McQtBwQAhHgxwC0HCACEeDG8LQcMAIR4MbgtBxAAhHgxtC0EHIR4MbAtBxQAhHgxrC0EGIR4MagtBxgAhHgxpC0EFIR4MaAtBxwAhHgxnC0EEIR4MZgtByAAhHgxlC0HJACEeDGQLQcoAIR4MYwtBywAhHgxiC0EDIR4MYQtBzAAhHgxgC0HNACEeDF8LQc4AIR4MXgtB0AAhHgxdC0HPACEeDFwLQdEAIR4MWwtB0gAhHgxaC0ECIR4MWQtB0wAhHgxYC0HUACEeDFcLQdUAIR4MVgtB1gAhHgxVC0HXACEeDFQLQdgAIR4MUwtB2QAhHgxSC0HaACEeDFELQdsAIR4MUAtB3AAhHgxPC0HdACEeDE4LQd4AIR4MTQtB3wAhHgxMC0HgACEeDEsLQeEAIR4MSgtB4gAhHgxJC0HjACEeDEgLQeQAIR4MRwtB5QAhHgxGC0HmACEeDEULQecAIR4MRAtB6AAhHgxDC0HpACEeDEILQeoAIR4MQQtB6wAhHgxAC0HsACEeDD8LQe0AIR4MPgtB7gAhHgw9C0HvACEeDDwLQfAAIR4MOwtB8QAhHgw6C0HyACEeDDkLQfMAIR4MOAtB9AAhHgw3C0H1ACEeDDYLQfYAIR4MNQtB9wAhHgw0C0H4ACEeDDMLQfkAIR4MMgtB+gAhHgwxC0H7ACEeDDALQfwAIR4MLwtB/QAhHgwuC0H+ACEeDC0LQf8AIR4MLAtBgAEhHgwrC0GBASEeDCoLQYIBIR4MKQtBgwEhHgwoC0GEASEeDCcLQYUBIR4MJgtBhgEhHgwlC0GHASEeDCQLQYgBIR4MIwtBiQEhHgwiC0GKASEeDCELQYsBIR4MIAtBjAEhHgwfC0GNASEeDB4LQY4BIR4MHQtBjwEhHgwcC0GQASEeDBsLQZEBIR4MGgtBkgEhHgwZC0GTASEeDBgLQZQBIR4MFwtBlQEhHgwWC0GWASEeDBULQZcBIR4MFAtBmAEhHgwTC0GZASEeDBILQZ0BIR4MEQtBmgEhHgwQC0EBIR4MDwtBmwEhHgwOC0GcASEeDA0LQZ4BIR4MDAtBoAEhHgwLC0GfASEeDAoLQaEBIR4MCQtBogEhHgwIC0GjASEeDAcLQaQBIR4MBgtBpQEhHgwFC0GmASEeDAQLQacBIR4MAwtBqAEhHgwCC0GpASEeDAELQa8BIR4LA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHg6wAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgaHB4fICMkJSYnKCkqLC0uLzD7AjQ2ODk8P0FCQ0RFRkdISUpLTE1OT1BRUlNVV1lcXV5gYmNkZWZnaGtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAdoB4AHhAeQB8QG9Ar0CCyABIgggAkcNwgFBvAEhHgyVAwsgASIeIAJHDbEBQawBIR4MlAMLIAEiASACRw1nQeIAIR4MkwMLIAEiASACRw1dQdoAIR4MkgMLIAEiASACRw1WQdUAIR4MkQMLIAEiASACRw1SQdMAIR4MkAMLIAEiASACRw1PQdEAIR4MjwMLIAEiASACRw1MQc8AIR4MjgMLIAEiASACRw0QQQwhHgyNAwsgASIBIAJHDTNBOCEeDIwDCyABIgEgAkcNL0E1IR4MiwMLIAEiASACRw0mQTIhHgyKAwsgASIBIAJHDSRBLyEeDIkDCyABIgEgAkcNHUEkIR4MiAMLIAAtAC5BAUYN/QIMxwELIAAgASIBIAIQtICAgABBAUcNtAEMtQELIAAgASIBIAIQrYCAgAAiHg21ASABIQEMsAILAkAgASIBIAJHDQBBBiEeDIUDCyAAIAFBAWoiASACELCAgIAAIh4NtgEgASEBDA8LIABCADcDIEETIR4M8wILIAEiHiACRw0JQQ8hHgyCAwsCQCABIgEgAkYNACABQQFqIQFBESEeDPICC0EHIR4MgQMLIABCACAAKQMgIh8gAiABIh5rrSIgfSIhICEgH1YbNwMgIB8gIFYiIkUNswFBCCEeDIADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEVIR4M8AILQQkhHgz/AgsgASEBIAApAyBQDbIBIAEhAQytAgsCQCABIgEgAkcNAEELIR4M/gILIAAgAUEBaiIBIAIQr4CAgAAiHg2yASABIQEMrQILA0ACQCABLQAAQfCdgIAAai0AACIeQQFGDQAgHkECRw20ASABQQFqIQEMAwsgAUEBaiIBIAJHDQALQQwhHgz8AgsCQCABIgEgAkcNAEENIR4M/AILAkACQCABLQAAIh5Bc2oOFAG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgEAtAELIAFBAWohAQy0AQsgAUEBaiEBC0EYIR4M6gILAkAgASIeIAJHDQBBDiEeDPoCC0IAIR8gHiEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAeLQAAQVBqDjfIAccBAAECAwQFBge+Ar4CvgK+Ar4CvgK+AggJCgsMDb4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgIODxAREhO+AgtCAiEfDMcBC0IDIR8MxgELQgQhHwzFAQtCBSEfDMQBC0IGIR8MwwELQgchHwzCAQtCCCEfDMEBC0IJIR8MwAELQgohHwy/AQtCCyEfDL4BC0IMIR8MvQELQg0hHwy8AQtCDiEfDLsBC0IPIR8MugELQgohHwy5AQtCCyEfDLgBC0IMIR8MtwELQg0hHwy2AQtCDiEfDLUBC0IPIR8MtAELQgAhHwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHi0AAEFQag43xwHGAQABAgMEBQYHyAHIAcgByAHIAcgByAEICQoLDA3IAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgBDg8QERITyAELQgIhHwzGAQtCAyEfDMUBC0IEIR8MxAELQgUhHwzDAQtCBiEfDMIBC0IHIR8MwQELQgghHwzAAQtCCSEfDL8BC0IKIR8MvgELQgshHwy9AQtCDCEfDLwBC0INIR8MuwELQg4hHwy6AQtCDyEfDLkBC0IKIR8MuAELQgshHwy3AQtCDCEfDLYBC0INIR8MtQELQg4hHwy0AQtCDyEfDLMBCyAAQgAgACkDICIfIAIgASIea60iIH0iISAhIB9WGzcDICAfICBWIiJFDbQBQREhHgz3AgsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBGyEeDOcCC0ESIR4M9gILIAAgASIeIAIQsoCAgABBf2oOBaYBAKICAbMBtAELQRIhHgzkAgsgAEEBOgAvIB4hAQzyAgsgASIBIAJHDbQBQRYhHgzyAgsgASIcIAJHDRlBOSEeDPECCwJAIAEiASACRw0AQRohHgzxAgsgAEEANgIEIABBioCAgAA2AgggACABIAEQqoCAgAAiHg22ASABIQEMuQELAkAgASIeIAJHDQBBGyEeDPACCwJAIB4tAAAiAUEgRw0AIB5BAWohAQwaCyABQQlHDbYBIB5BAWohAQwZCwJAIAEiASACRg0AIAFBAWohAQwUC0EcIR4M7gILAkAgASIeIAJHDQBBHSEeDO4CCwJAIB4tAAAiAUEJRw0AIB4hAQzSAgsgAUEgRw21ASAeIQEM0QILAkAgASIBIAJHDQBBHiEeDO0CCyABLQAAQQpHDbgBIAFBAWohAQygAgsgASIBIAJHDbgBQSIhHgzrAgsDQAJAIAEtAAAiHkEgRg0AAkAgHkF2ag4EAL4BvgEAvAELIAEhAQzEAQsgAUEBaiIBIAJHDQALQSQhHgzqAgtBJSEeIAEiIyACRg3pAiACICNrIAAoAgAiJGohJSAjISYgJCEBAkADQCAmLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQfCfgIAAai0AAEcNASABQQNGDdYCIAFBAWohASAmQQFqIiYgAkcNAAsgACAlNgIADOoCCyAAQQA2AgAgJiEBDLsBC0EmIR4gASIjIAJGDegCIAIgI2sgACgCACIkaiElICMhJiAkIQECQANAICYtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFB9J+AgABqLQAARw0BIAFBCEYNvQEgAUEBaiEBICZBAWoiJiACRw0ACyAAICU2AgAM6QILIABBADYCACAmIQEMugELQSchHiABIiMgAkYN5wIgAiAjayAAKAIAIiRqISUgIyEmICQhAQJAA0AgJi0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHQpoCAAGotAABHDQEgAUEFRg29ASABQQFqIQEgJkEBaiImIAJHDQALIAAgJTYCAAzoAgsgAEEANgIAICYhAQy5AQsCQCABIgEgAkYNAANAAkAgAS0AAEGAooCAAGotAAAiHkEBRg0AIB5BAkYNCiABIQEMwQELIAFBAWoiASACRw0AC0EjIR4M5wILQSMhHgzmAgsCQCABIgEgAkYNAANAAkAgAS0AACIeQSBGDQAgHkF2ag4EvQG+Ab4BvQG+AQsgAUEBaiIBIAJHDQALQSshHgzmAgtBKyEeDOUCCwNAAkAgAS0AACIeQSBGDQAgHkEJRw0DCyABQQFqIgEgAkcNAAtBLyEeDOQCCwNAAkAgAS0AACIeQSBGDQACQAJAIB5BdmoOBL4BAQG+AQALIB5BLEYNvwELIAEhAQwECyABQQFqIgEgAkcNAAtBMiEeDOMCCyABIQEMvwELQTMhHiABIiYgAkYN4QIgAiAmayAAKAIAIiNqISQgJiEiICMhAQJAA0AgIi0AAEEgciABQYCkgIAAai0AAEcNASABQQZGDdACIAFBAWohASAiQQFqIiIgAkcNAAsgACAkNgIADOICCyAAQQA2AgAgIiEBC0ErIR4M0AILAkAgASIdIAJHDQBBNCEeDOACCyAAQYqAgIAANgIIIAAgHTYCBCAdIQEgAC0ALEF/ag4ErwG5AbsBvQHHAgsgAUEBaiEBDK4BCwJAIAEiASACRg0AA0ACQCABLQAAIh5BIHIgHiAeQb9/akH/AXFBGkkbQf8BcSIeQQlGDQAgHkEgRg0AAkACQAJAAkAgHkGdf2oOEwADAwMDAwMDAQMDAwMDAwMDAwIDCyABQQFqIQFBJiEeDNMCCyABQQFqIQFBJyEeDNICCyABQQFqIQFBKCEeDNECCyABIQEMsgELIAFBAWoiASACRw0AC0EoIR4M3gILQSghHgzdAgsCQCABIgEgAkYNAANAAkAgAS0AAEGAoICAAGotAABBAUYNACABIQEMtwELIAFBAWoiASACRw0AC0EwIR4M3QILQTAhHgzcAgsCQANAAkAgAS0AAEF3ag4YAALBAsECxwLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQIAwQILIAFBAWoiASACRw0AC0E1IR4M3AILIAFBAWohAQtBISEeDMoCCyABIgEgAkcNuQFBNyEeDNkCCwNAAkAgAS0AAEGQpICAAGotAABBAUYNACABIQEMkAILIAFBAWoiASACRw0AC0E4IR4M2AILIBwtAAAiHkEgRg2aASAeQTpHDcYCIAAoAgQhASAAQQA2AgQgACABIBwQqICAgAAiAQ22ASAcQQFqIQEMuAELIAAgASACEKmAgIAAGgtBCiEeDMUCC0E6IR4gASImIAJGDdQCIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBkKaAgABqLQAARw3EAiABQQVGDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM1QILIABBADYCACAAQQE6ACwgJiAja0EGaiEBDL4CC0E7IR4gASImIAJGDdMCIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBlqaAgABqLQAARw3DAiABQQlGDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM1AILIABBADYCACAAQQI6ACwgJiAja0EKaiEBDL0CCwJAIAEiHCACRw0AQTwhHgzTAgsCQAJAIBwtAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZJ/ag4HAMMCwwLDAsMCwwIBwwILIBxBAWohAUEyIR4MwwILIBxBAWohAUEzIR4MwgILQT0hHiABIiYgAkYN0QIgAiAmayAAKAIAIiNqISQgJiEcICMhAQNAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBoKaAgABqLQAARw3AAiABQQFGDbQCIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNECC0E+IR4gASImIAJGDdACIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBoqaAgABqLQAARw3AAiABQQ5GDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM0QILIABBADYCACAAQQE6ACwgJiAja0EPaiEBDLoCC0E/IR4gASImIAJGDc8CIAIgJmsgACgCACIjaiEkICYhHCAjIQECQANAIBwtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFBwKaAgABqLQAARw2/AiABQQ9GDQEgAUEBaiEBIBxBAWoiHCACRw0ACyAAICQ2AgAM0AILIABBADYCACAAQQM6ACwgJiAja0EQaiEBDLkCC0HAACEeIAEiJiACRg3OAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQdCmgIAAai0AAEcNvgIgAUEFRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADM8CCyAAQQA2AgAgAEEEOgAsICYgI2tBBmohAQy4AgsCQCABIhwgAkcNAEHBACEeDM4CCwJAAkACQAJAIBwtAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAMACwALAAsACwALAAsACwALAAsACwALAAgHAAsACwAICA8ACCyAcQQFqIQFBNSEeDMACCyAcQQFqIQFBNiEeDL8CCyAcQQFqIQFBNyEeDL4CCyAcQQFqIQFBOCEeDL0CCwJAIAEiASACRg0AIABBi4CAgAA2AgggACABNgIEIAEhAUE5IR4MvQILQcIAIR4MzAILIAEiASACRw2vAUHEACEeDMsCC0HFACEeIAEiJiACRg3KAiACICZrIAAoAgAiI2ohJCAmISIgIyEBAkADQCAiLQAAIAFB1qaAgABqLQAARw20ASABQQFGDQEgAUEBaiEBICJBAWoiIiACRw0ACyAAICQ2AgAMywILIABBADYCACAmICNrQQJqIQEMrwELAkAgASIBIAJHDQBBxwAhHgzKAgsgAS0AAEEKRw2zASABQQFqIQEMrwELAkAgASIBIAJHDQBByAAhHgzJAgsCQAJAIAEtAABBdmoOBAG0AbQBALQBCyABQQFqIQFBPSEeDLkCCyABQQFqIQEMrgELAkAgASIBIAJHDQBByQAhHgzIAgtBACEeAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgq7AboBAAECAwQFBge8AQtBAiEeDLoBC0EDIR4MuQELQQQhHgy4AQtBBSEeDLcBC0EGIR4MtgELQQchHgy1AQtBCCEeDLQBC0EJIR4MswELAkAgASIBIAJHDQBBygAhHgzHAgsgAS0AAEEuRw20ASABQQFqIQEMgAILAkAgASIBIAJHDQBBywAhHgzGAgtBACEeAkACQAJAAkACQAJAAkACQCABLQAAQVBqDgq9AbwBAAECAwQFBge+AQtBAiEeDLwBC0EDIR4MuwELQQQhHgy6AQtBBSEeDLkBC0EGIR4MuAELQQchHgy3AQtBCCEeDLYBC0EJIR4MtQELQcwAIR4gASImIAJGDcQCIAIgJmsgACgCACIjaiEkICYhASAjISIDQCABLQAAICJB4qaAgABqLQAARw24ASAiQQNGDbcBICJBAWohIiABQQFqIgEgAkcNAAsgACAkNgIADMQCC0HNACEeIAEiJiACRg3DAiACICZrIAAoAgAiI2ohJCAmIQEgIyEiA0AgAS0AACAiQeamgIAAai0AAEcNtwEgIkECRg25ASAiQQFqISIgAUEBaiIBIAJHDQALIAAgJDYCAAzDAgtBzgAhHiABIiYgAkYNwgIgAiAmayAAKAIAIiNqISQgJiEBICMhIgNAIAEtAAAgIkHppoCAAGotAABHDbYBICJBA0YNuQEgIkEBaiEiIAFBAWoiASACRw0ACyAAICQ2AgAMwgILA0ACQCABLQAAIh5BIEYNAAJAAkACQCAeQbh/ag4LAAG6AboBugG6AboBugG6AboBAroBCyABQQFqIQFBwgAhHgy1AgsgAUEBaiEBQcMAIR4MtAILIAFBAWohAUHEACEeDLMCCyABQQFqIgEgAkcNAAtBzwAhHgzBAgsCQCABIgEgAkYNACAAIAFBAWoiASACEKWAgIAAGiABIQFBByEeDLECC0HQACEeDMACCwNAAkAgAS0AAEHwpoCAAGotAAAiHkEBRg0AIB5BfmoOA7kBugG7AbwBCyABQQFqIgEgAkcNAAtB0QAhHgy/AgsCQCABIgEgAkYNACABQQFqIQEMAwtB0gAhHgy+AgsDQAJAIAEtAABB8KiAgABqLQAAIh5BAUYNAAJAIB5BfmoOBLwBvQG+AQC/AQsgASEBQcYAIR4MrwILIAFBAWoiASACRw0AC0HTACEeDL0CCwJAIAEiASACRw0AQdQAIR4MvQILAkAgAS0AACIeQXZqDhqkAb8BvwGmAb8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/AbQBvwG/AQC9AQsgAUEBaiEBC0EGIR4MqwILA0ACQCABLQAAQfCqgIAAai0AAEEBRg0AIAEhAQz6AQsgAUEBaiIBIAJHDQALQdUAIR4MugILAkAgASIBIAJGDQAgAUEBaiEBDAMLQdYAIR4MuQILAkAgASIBIAJHDQBB1wAhHgy5AgsgAUEBaiEBDAELAkAgASIBIAJHDQBB2AAhHgy4AgsgAUEBaiEBC0EEIR4MpgILAkAgASIiIAJHDQBB2QAhHgy2AgsgIiEBAkACQAJAICItAABB8KyAgABqLQAAQX9qDge+Ab8BwAEA+AEBAsEBCyAiQQFqIQEMCgsgIkEBaiEBDLcBC0EAIR4gAEEANgIcIABB8Y6AgAA2AhAgAEEHNgIMIAAgIkEBajYCFAy1AgsCQANAAkAgAS0AAEHwrICAAGotAAAiHkEERg0AAkACQCAeQX9qDge8Ab0BvgHDAQAEAcMBCyABIQFByQAhHgyoAgsgAUEBaiEBQcsAIR4MpwILIAFBAWoiASACRw0AC0HaACEeDLUCCyABQQFqIQEMtQELAkAgASIiIAJHDQBB2wAhHgy0AgsgIi0AAEEvRw2+ASAiQQFqIQEMBgsCQCABIiIgAkcNAEHcACEeDLMCCwJAICItAAAiAUEvRw0AICJBAWohAUHMACEeDKMCCyABQXZqIgFBFksNvQFBASABdEGJgIACcUUNvQEMkwILAkAgASIBIAJGDQAgAUEBaiEBQc0AIR4MogILQd0AIR4MsQILAkAgASIiIAJHDQBB3wAhHgyxAgsgIiEBAkAgIi0AAEHwsICAAGotAABBf2oOA5IC8AEAvgELQdAAIR4MoAILAkAgASIiIAJGDQADQAJAICItAABB8K6AgABqLQAAIgFBA0YNAAJAIAFBf2oOApQCAL8BCyAiIQFBzgAhHgyiAgsgIkEBaiIiIAJHDQALQd4AIR4MsAILQd4AIR4MrwILAkAgASIBIAJGDQAgAEGMgICAADYCCCAAIAE2AgQgASEBQc8AIR4MnwILQeAAIR4MrgILAkAgASIBIAJHDQBB4QAhHgyuAgsgAEGMgICAADYCCCAAIAE2AgQgASEBC0EDIR4MnAILA0AgAS0AAEEgRw2MAiABQQFqIgEgAkcNAAtB4gAhHgyrAgsCQCABIgEgAkcNAEHjACEeDKsCCyABLQAAQSBHDbgBIAFBAWohAQzUAQsCQCABIgggAkcNAEHkACEeDKoCCyAILQAAQcwARw27ASAIQQFqIQFBEyEeDLkBC0HlACEeIAEiIiACRg2oAiACICJrIAAoAgAiJmohIyAiIQggJiEBA0AgCC0AACABQfCygIAAai0AAEcNugEgAUEFRg24ASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAyoAgsCQCABIgggAkcNAEHmACEeDKgCCwJAAkAgCC0AAEG9f2oODAC7AbsBuwG7AbsBuwG7AbsBuwG7AQG7AQsgCEEBaiEBQdQAIR4MmAILIAhBAWohAUHVACEeDJcCC0HnACEeIAEiIiACRg2mAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB7bOAgABqLQAARw25ASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpwILIABBADYCACAiICZrQQNqIQFBECEeDLYBC0HoACEeIAEiIiACRg2lAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB9rKAgABqLQAARw24ASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpgILIABBADYCACAiICZrQQZqIQFBFiEeDLUBC0HpACEeIAEiIiACRg2kAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB/LKAgABqLQAARw23ASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMpQILIABBADYCACAiICZrQQRqIQFBBSEeDLQBCwJAIAEiCCACRw0AQeoAIR4MpAILIAgtAABB2QBHDbUBIAhBAWohAUEIIR4MswELAkAgASIIIAJHDQBB6wAhHgyjAgsCQAJAIAgtAABBsn9qDgMAtgEBtgELIAhBAWohAUHZACEeDJMCCyAIQQFqIQFB2gAhHgySAgsCQCABIgggAkcNAEHsACEeDKICCwJAAkAgCC0AAEG4f2oOCAC1AbUBtQG1AbUBtQEBtQELIAhBAWohAUHYACEeDJICCyAIQQFqIQFB2wAhHgyRAgtB7QAhHiABIiIgAkYNoAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYCzgIAAai0AAEcNswEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKECC0EAIR4gAEEANgIAICIgJmtBA2ohAQywAQtB7gAhHiABIiIgAkYNnwIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQYOzgIAAai0AAEcNsgEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKACCyAAQQA2AgAgIiAma0EFaiEBQSMhHgyvAQsCQCABIgggAkcNAEHvACEeDJ8CCwJAAkAgCC0AAEG0f2oOCACyAbIBsgGyAbIBsgEBsgELIAhBAWohAUHdACEeDI8CCyAIQQFqIQFB3gAhHgyOAgsCQCABIgggAkcNAEHwACEeDJ4CCyAILQAAQcUARw2vASAIQQFqIQEM3gELQfEAIR4gASIiIAJGDZwCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGIs4CAAGotAABHDa8BIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAydAgsgAEEANgIAICIgJmtBBGohAUEtIR4MrAELQfIAIR4gASIiIAJGDZsCIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUHQs4CAAGotAABHDa4BIAFBCEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAycAgsgAEEANgIAICIgJmtBCWohAUEpIR4MqwELAkAgASIBIAJHDQBB8wAhHgybAgtBASEeIAEtAABB3wBHDaoBIAFBAWohAQzcAQtB9AAhHiABIiIgAkYNmQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUGMs4CAAGotAABHDasBIAFBAUYN9wEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMmQILAkAgASIeIAJHDQBB9QAhHgyZAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQY6zgIAAai0AAEcNqwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfUAIR4MmQILIABBADYCACAeICJrQQNqIQFBAiEeDKgBCwJAIAEiHiACRw0AQfYAIR4MmAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHws4CAAGotAABHDaoBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH2ACEeDJgCCyAAQQA2AgAgHiAia0ECaiEBQR8hHgynAQsCQCABIh4gAkcNAEH3ACEeDJcCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8rOAgABqLQAARw2pASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9wAhHgyXAgsgAEEANgIAIB4gImtBAmohAUEJIR4MpgELAkAgASIIIAJHDQBB+AAhHgyWAgsCQAJAIAgtAABBt39qDgcAqQGpAakBqQGpAQGpAQsgCEEBaiEBQeYAIR4MhgILIAhBAWohAUHnACEeDIUCCwJAIAEiHiACRw0AQfkAIR4MlQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGRs4CAAGotAABHDacBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH5ACEeDJUCCyAAQQA2AgAgHiAia0EGaiEBQRghHgykAQsCQCABIh4gAkcNAEH6ACEeDJQCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBl7OAgABqLQAARw2mASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB+gAhHgyUAgsgAEEANgIAIB4gImtBA2ohAUEXIR4MowELAkAgASIeIAJHDQBB+wAhHgyTAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQZqzgIAAai0AAEcNpQEgAUEGRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfsAIR4MkwILIABBADYCACAeICJrQQdqIQFBFSEeDKIBCwJAIAEiHiACRw0AQfwAIR4MkgILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGhs4CAAGotAABHDaQBIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH8ACEeDJICCyAAQQA2AgAgHiAia0EGaiEBQR4hHgyhAQsCQCABIgggAkcNAEH9ACEeDJECCyAILQAAQcwARw2iASAIQQFqIQFBCiEeDKABCwJAIAEiCCACRw0AQf4AIR4MkAILAkACQCAILQAAQb9/ag4PAKMBowGjAaMBowGjAaMBowGjAaMBowGjAaMBAaMBCyAIQQFqIQFB7AAhHgyAAgsgCEEBaiEBQe0AIR4M/wELAkAgASIIIAJHDQBB/wAhHgyPAgsCQAJAIAgtAABBv39qDgMAogEBogELIAhBAWohAUHrACEeDP8BCyAIQQFqIQFB7gAhHgz+AQsCQCABIh4gAkcNAEGAASEeDI4CCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBp7OAgABqLQAARw2gASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBgAEhHgyOAgsgAEEANgIAIB4gImtBAmohAUELIR4MnQELAkAgASIIIAJHDQBBgQEhHgyNAgsCQAJAAkACQCAILQAAQVNqDiMAogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAQGiAaIBogGiAaIBAqIBogGiAQOiAQsgCEEBaiEBQekAIR4M/wELIAhBAWohAUHqACEeDP4BCyAIQQFqIQFB7wAhHgz9AQsgCEEBaiEBQfAAIR4M/AELAkAgASIeIAJHDQBBggEhHgyMAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQamzgIAAai0AAEcNngEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYIBIR4MjAILIABBADYCACAeICJrQQVqIQFBGSEeDJsBCwJAIAEiIiACRw0AQYMBIR4MiwILIAIgImsgACgCACImaiEeICIhCCAmIQECQANAIAgtAAAgAUGus4CAAGotAABHDZ0BIAFBBUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgHjYCAEGDASEeDIsCCyAAQQA2AgBBBiEeICIgJmtBBmohAQyaAQsCQCABIh4gAkcNAEGEASEeDIoCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBtLOAgABqLQAARw2cASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhAEhHgyKAgsgAEEANgIAIB4gImtBAmohAUEcIR4MmQELAkAgASIeIAJHDQBBhQEhHgyJAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbazgIAAai0AAEcNmwEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYUBIR4MiQILIABBADYCACAeICJrQQJqIQFBJyEeDJgBCwJAIAEiCCACRw0AQYYBIR4MiAILAkACQCAILQAAQax/ag4CAAGbAQsgCEEBaiEBQfQAIR4M+AELIAhBAWohAUH1ACEeDPcBCwJAIAEiHiACRw0AQYcBIR4MhwILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG4s4CAAGotAABHDZkBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGHASEeDIcCCyAAQQA2AgAgHiAia0ECaiEBQSYhHgyWAQsCQCABIh4gAkcNAEGIASEeDIYCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBurOAgABqLQAARw2YASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBiAEhHgyGAgsgAEEANgIAIB4gImtBAmohAUEDIR4MlQELAkAgASIeIAJHDQBBiQEhHgyFAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQe2zgIAAai0AAEcNlwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYkBIR4MhQILIABBADYCACAeICJrQQNqIQFBDCEeDJQBCwJAIAEiHiACRw0AQYoBIR4MhAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG8s4CAAGotAABHDZYBIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGKASEeDIQCCyAAQQA2AgAgHiAia0EEaiEBQQ0hHgyTAQsCQCABIgggAkcNAEGLASEeDIMCCwJAAkAgCC0AAEG6f2oOCwCWAZYBlgGWAZYBlgGWAZYBlgEBlgELIAhBAWohAUH5ACEeDPMBCyAIQQFqIQFB+gAhHgzyAQsCQCABIgggAkcNAEGMASEeDIICCyAILQAAQdAARw2TASAIQQFqIQEMxAELAkAgASIIIAJHDQBBjQEhHgyBAgsCQAJAIAgtAABBt39qDgcBlAGUAZQBlAGUAQCUAQsgCEEBaiEBQfwAIR4M8QELIAhBAWohAUEiIR4MkAELAkAgASIeIAJHDQBBjgEhHgyAAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQcCzgIAAai0AAEcNkgEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQY4BIR4MgAILIABBADYCACAeICJrQQJqIQFBHSEeDI8BCwJAIAEiCCACRw0AQY8BIR4M/wELAkACQCAILQAAQa5/ag4DAJIBAZIBCyAIQQFqIQFB/gAhHgzvAQsgCEEBaiEBQQQhHgyOAQsCQCABIgggAkcNAEGQASEeDP4BCwJAAkACQAJAAkAgCC0AAEG/f2oOFQCUAZQBlAGUAZQBlAGUAZQBlAGUAQGUAZQBApQBlAEDlAGUAQSUAQsgCEEBaiEBQfYAIR4M8QELIAhBAWohAUH3ACEeDPABCyAIQQFqIQFB+AAhHgzvAQsgCEEBaiEBQf0AIR4M7gELIAhBAWohAUH/ACEeDO0BCwJAIAQgAkcNAEGRASEeDP0BCyACIARrIAAoAgAiHmohIiAEIQggHiEBAkADQCAILQAAIAFB7bOAgABqLQAARw2PASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBkQEhHgz9AQsgAEEANgIAIAQgHmtBA2ohAUERIR4MjAELAkAgBSACRw0AQZIBIR4M/AELIAIgBWsgACgCACIeaiEiIAUhCCAeIQECQANAIAgtAAAgAUHCs4CAAGotAABHDY4BIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGSASEeDPwBCyAAQQA2AgAgBSAea0EDaiEBQSwhHgyLAQsCQCAGIAJHDQBBkwEhHgz7AQsgAiAGayAAKAIAIh5qISIgBiEIIB4hAQJAA0AgCC0AACABQcWzgIAAai0AAEcNjQEgAUEERg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZMBIR4M+wELIABBADYCACAGIB5rQQVqIQFBKyEeDIoBCwJAIAcgAkcNAEGUASEeDPoBCyACIAdrIAAoAgAiHmohIiAHIQggHiEBAkADQCAILQAAIAFByrOAgABqLQAARw2MASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBlAEhHgz6AQsgAEEANgIAIAcgHmtBA2ohAUEUIR4MiQELAkAgCCACRw0AQZUBIR4M+QELAkACQAJAAkAgCC0AAEG+f2oODwABAo4BjgGOAY4BjgGOAY4BjgGOAY4BjgEDjgELIAhBAWohBEGBASEeDOsBCyAIQQFqIQVBggEhHgzqAQsgCEEBaiEGQYMBIR4M6QELIAhBAWohB0GEASEeDOgBCwJAIAggAkcNAEGWASEeDPgBCyAILQAAQcUARw2JASAIQQFqIQgMuwELAkAgCSACRw0AQZcBIR4M9wELIAIgCWsgACgCACIeaiEiIAkhCCAeIQECQANAIAgtAAAgAUHNs4CAAGotAABHDYkBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGXASEeDPcBCyAAQQA2AgAgCSAea0EDaiEBQQ4hHgyGAQsCQCAIIAJHDQBBmAEhHgz2AQsgCC0AAEHQAEcNhwEgCEEBaiEBQSUhHgyFAQsCQCAKIAJHDQBBmQEhHgz1AQsgAiAKayAAKAIAIh5qISIgCiEIIB4hAQJAA0AgCC0AACABQdCzgIAAai0AAEcNhwEgAUEIRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZkBIR4M9QELIABBADYCACAKIB5rQQlqIQFBKiEeDIQBCwJAIAggAkcNAEGaASEeDPQBCwJAAkAgCC0AAEGrf2oOCwCHAYcBhwGHAYcBhwGHAYcBhwEBhwELIAhBAWohCEGIASEeDOQBCyAIQQFqIQpBiQEhHgzjAQsCQCAIIAJHDQBBmwEhHgzzAQsCQAJAIAgtAABBv39qDhQAhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBAYYBCyAIQQFqIQlBhwEhHgzjAQsgCEEBaiEIQYoBIR4M4gELAkAgCyACRw0AQZwBIR4M8gELIAIgC2sgACgCACIeaiEiIAshCCAeIQECQANAIAgtAAAgAUHZs4CAAGotAABHDYQBIAFBA0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGcASEeDPIBCyAAQQA2AgAgCyAea0EEaiEBQSEhHgyBAQsCQCAMIAJHDQBBnQEhHgzxAQsgAiAMayAAKAIAIh5qISIgDCEIIB4hAQJAA0AgCC0AACABQd2zgIAAai0AAEcNgwEgAUEGRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZ0BIR4M8QELIABBADYCACAMIB5rQQdqIQFBGiEeDIABCwJAIAggAkcNAEGeASEeDPABCwJAAkACQCAILQAAQbt/ag4RAIQBhAGEAYQBhAGEAYQBhAGEAQGEAYQBhAGEAYQBAoQBCyAIQQFqIQhBiwEhHgzhAQsgCEEBaiELQYwBIR4M4AELIAhBAWohDEGNASEeDN8BCwJAIA0gAkcNAEGfASEeDO8BCyACIA1rIAAoAgAiHmohIiANIQggHiEBAkADQCAILQAAIAFB5LOAgABqLQAARw2BASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBnwEhHgzvAQsgAEEANgIAIA0gHmtBBmohAUEoIR4MfgsCQCAOIAJHDQBBoAEhHgzuAQsgAiAOayAAKAIAIh5qISIgDiEIIB4hAQJAA0AgCC0AACABQeqzgIAAai0AAEcNgAEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQaABIR4M7gELIABBADYCACAOIB5rQQNqIQFBByEeDH0LAkAgCCACRw0AQaEBIR4M7QELAkACQCAILQAAQbt/ag4OAIABgAGAAYABgAGAAYABgAGAAYABgAGAAQGAAQsgCEEBaiENQY8BIR4M3QELIAhBAWohDkGQASEeDNwBCwJAIA8gAkcNAEGiASEeDOwBCyACIA9rIAAoAgAiHmohIiAPIQggHiEBAkADQCAILQAAIAFB7bOAgABqLQAARw1+IAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGiASEeDOwBCyAAQQA2AgAgDyAea0EDaiEBQRIhHgx7CwJAIBAgAkcNAEGjASEeDOsBCyACIBBrIAAoAgAiHmohIiAQIQggHiEBAkADQCAILQAAIAFB8LOAgABqLQAARw19IAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGjASEeDOsBCyAAQQA2AgAgECAea0ECaiEBQSAhHgx6CwJAIBEgAkcNAEGkASEeDOoBCyACIBFrIAAoAgAiHmohIiARIQggHiEBAkADQCAILQAAIAFB8rOAgABqLQAARw18IAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGkASEeDOoBCyAAQQA2AgAgESAea0ECaiEBQQ8hHgx5CwJAIAggAkcNAEGlASEeDOkBCwJAAkAgCC0AAEG3f2oOBwB8fHx8fAF8CyAIQQFqIRBBkwEhHgzZAQsgCEEBaiERQZQBIR4M2AELAkAgEiACRw0AQaYBIR4M6AELIAIgEmsgACgCACIeaiEiIBIhCCAeIQECQANAIAgtAAAgAUH0s4CAAGotAABHDXogAUEHRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQaYBIR4M6AELIABBADYCACASIB5rQQhqIQFBGyEeDHcLAkAgCCACRw0AQacBIR4M5wELAkACQAJAIAgtAABBvn9qDhIAe3t7e3t7e3t7AXt7e3t7ewJ7CyAIQQFqIQ9BkgEhHgzYAQsgCEEBaiEIQZUBIR4M1wELIAhBAWohEkGWASEeDNYBCwJAIAggAkcNAEGoASEeDOYBCyAILQAAQc4ARw13IAhBAWohCAyqAQsCQCAIIAJHDQBBqQEhHgzlAQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAILQAAQb9/ag4VAAECA4YBBAUGhgGGAYYBBwgJCguGAQwNDg+GAQsgCEEBaiEBQdYAIR4M4wELIAhBAWohAUHXACEeDOIBCyAIQQFqIQFB3AAhHgzhAQsgCEEBaiEBQeAAIR4M4AELIAhBAWohAUHhACEeDN8BCyAIQQFqIQFB5AAhHgzeAQsgCEEBaiEBQeUAIR4M3QELIAhBAWohAUHoACEeDNwBCyAIQQFqIQFB8QAhHgzbAQsgCEEBaiEBQfIAIR4M2gELIAhBAWohAUHzACEeDNkBCyAIQQFqIQFBgAEhHgzYAQsgCEEBaiEIQYYBIR4M1wELIAhBAWohCEGOASEeDNYBCyAIQQFqIQhBkQEhHgzVAQsgCEEBaiEIQZgBIR4M1AELAkAgFCACRw0AQasBIR4M5AELIBRBAWohEwx3CwNAAkAgHi0AAEF2ag4EdwAAegALIB5BAWoiHiACRw0AC0GsASEeDOIBCwJAIBUgAkYNACAAQY2AgIAANgIIIAAgFTYCBCAVIQFBASEeDNIBC0GtASEeDOEBCwJAIBUgAkcNAEGuASEeDOEBCwJAAkAgFS0AAEF2ag4EAasBqwEAqwELIBVBAWohFAx4CyAVQQFqIRMMdAsgACATIAIQp4CAgAAaIBMhAQxFCwJAIBUgAkcNAEGvASEeDN8BCwJAAkAgFS0AAEF2ag4XAXl5AXl5eXl5eXl5eXl5eXl5eXl5eQB5CyAVQQFqIRULQZwBIR4MzgELAkAgFiACRw0AQbEBIR4M3gELIBYtAABBIEcNdyAAQQA7ATIgFkEBaiEBQaABIR4MzQELIAEhJgJAA0AgJiIVIAJGDQEgFS0AAEFQakH/AXEiHkEKTw2oAQJAIAAvATIiIkGZM0sNACAAICJBCmwiIjsBMiAeQf//A3MgIkH+/wNxSQ0AIBVBAWohJiAAICIgHmoiHjsBMiAeQf//A3FB6AdJDQELC0EAIR4gAEEANgIcIABBnYmAgAA2AhAgAEENNgIMIAAgFUEBajYCFAzdAQtBsAEhHgzcAQsCQCAXIAJHDQBBsgEhHgzcAQtBACEeAkACQAJAAkACQAJAAkACQCAXLQAAQVBqDgp/fgABAgMEBQYHgAELQQIhHgx+C0EDIR4MfQtBBCEeDHwLQQUhHgx7C0EGIR4MegtBByEeDHkLQQghHgx4C0EJIR4MdwsCQCAYIAJHDQBBswEhHgzbAQsgGC0AAEEuRw14IBhBAWohFwymAQsCQCAZIAJHDQBBtAEhHgzaAQtBACEeAkACQAJAAkACQAJAAkACQCAZLQAAQVBqDgqBAYABAAECAwQFBgeCAQtBAiEeDIABC0EDIR4MfwtBBCEeDH4LQQUhHgx9C0EGIR4MfAtBByEeDHsLQQghHgx6C0EJIR4MeQsCQCAIIAJHDQBBtQEhHgzZAQsgAiAIayAAKAIAIiJqISYgCCEZICIhHgNAIBktAAAgHkH8s4CAAGotAABHDXsgHkEERg20ASAeQQFqIR4gGUEBaiIZIAJHDQALIAAgJjYCAEG1ASEeDNgBCwJAIBogAkcNAEG2ASEeDNgBCyACIBprIAAoAgAiHmohIiAaIQggHiEBA0AgCC0AACABQYG0gIAAai0AAEcNeyABQQFGDbYBIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQbYBIR4M1wELAkAgGyACRw0AQbcBIR4M1wELIAIgG2sgACgCACIZaiEiIBshCCAZIR4DQCAILQAAIB5Bg7SAgABqLQAARw16IB5BAkYNfCAeQQFqIR4gCEEBaiIIIAJHDQALIAAgIjYCAEG3ASEeDNYBCwJAIAggAkcNAEG4ASEeDNYBCwJAAkAgCC0AAEG7f2oOEAB7e3t7e3t7e3t7e3t7ewF7CyAIQQFqIRpBpQEhHgzGAQsgCEEBaiEbQaYBIR4MxQELAkAgCCACRw0AQbkBIR4M1QELIAgtAABByABHDXggCEEBaiEIDKIBCwJAIAggAkcNAEG6ASEeDNQBCyAILQAAQcgARg2iASAAQQE6ACgMmQELA0ACQCAILQAAQXZqDgQAenoAegsgCEEBaiIIIAJHDQALQbwBIR4M0gELIABBADoALyAALQAtQQRxRQ3IAQsgAEEAOgAvIAEhAQx5CyAeQRVGDakBIABBADYCHCAAIAE2AhQgAEGrjICAADYCECAAQRI2AgxBACEeDM8BCwJAIAAgHiACEK2AgIAAIgENACAeIQEMxQELAkAgAUEVRw0AIABBAzYCHCAAIB42AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDM8BCyAAQQA2AhwgACAeNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgzOAQsgHkEVRg2lASAAQQA2AhwgACABNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhHgzNAQsgACgCBCEmIABBADYCBCAeIB+naiIjIQEgACAmIB4gIyAiGyIeEK6AgIAAIiJFDXogAEEHNgIcIAAgHjYCFCAAICI2AgxBACEeDMwBCyAAIAAvATBBgAFyOwEwIAEhAQwxCyAeQRVGDaEBIABBADYCHCAAIAE2AhQgAEHFi4CAADYCECAAQRM2AgxBACEeDMoBCyAAQQA2AhwgACABNgIUIABBi4uAgAA2AhAgAEECNgIMQQAhHgzJAQsgHkE7Rw0BIAFBAWohAQtBCCEeDLcBC0EAIR4gAEEANgIcIAAgATYCFCAAQaOQgIAANgIQIABBDDYCDAzGAQtCASEfCyAeQQFqIQECQCAAKQMgIiBC//////////8PVg0AIAAgIEIEhiAfhDcDICABIQEMdwsgAEEANgIcIAAgATYCFCAAQYmJgIAANgIQIABBDDYCDEEAIR4MxAELIABBADYCHCAAIB42AhQgAEGjkICAADYCECAAQQw2AgxBACEeDMMBCyAAKAIEISYgAEEANgIEIB4gH6dqIiMhASAAICYgHiAjICIbIh4QroCAgAAiIkUNbiAAQQU2AhwgACAeNgIUIAAgIjYCDEEAIR4MwgELIABBADYCHCAAIB42AhQgAEHdlICAADYCECAAQQ82AgxBACEeDMEBCyAAIB4gAhCtgICAACIBDQEgHiEBC0EPIR4MrwELAkAgAUEVRw0AIABBAjYCHCAAIB42AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDL8BCyAAQQA2AhwgACAeNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgy+AQsgAUEBaiEeAkAgAC8BMCIBQYABcUUNAAJAIAAgHiACELCAgIAAIgENACAeIQEMawsgAUEVRw2XASAAQQU2AhwgACAeNgIUIABBvpKAgAA2AhAgAEEVNgIMQQAhHgy+AQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgHjYCFCAAQeyPgIAANgIQIABBBDYCDEEAIR4MvgELIAAgHiACELGAgIAAGiAeIQECQAJAAkACQAJAIAAgHiACEKyAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIB4hAQtBHSEeDK8BCyAAQRU2AhwgACAeNgIUIABB4ZGAgAA2AhAgAEEVNgIMQQAhHgy+AQsgAEEANgIcIAAgHjYCFCAAQbGLgIAANgIQIABBETYCDEEAIR4MvQELIAAtAC1BAXFFDQFBqgEhHgysAQsCQCAcIAJGDQADQAJAIBwtAABBIEYNACAcIQEMqAELIBxBAWoiHCACRw0AC0EXIR4MvAELQRchHgy7AQsgACgCBCEBIABBADYCBCAAIAEgHBCogICAACIBRQ2QASAAQRg2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MugELIABBGTYCHCAAIAE2AhQgACAeNgIMQQAhHgy5AQsgHiEBQQEhIgJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEiDAELQQQhIgsgAEEBOgAsIAAgAC8BMCAicjsBMAsgHiEBC0EgIR4MqQELIABBADYCHCAAIB42AhQgAEGBj4CAADYCECAAQQs2AgxBACEeDLgBCyAeIQFBASEiAkACQAJAAkACQCAALQAsQXtqDgQCAAEDBQtBAiEiDAELQQQhIgsgAEEBOgAsIAAgAC8BMCAicjsBMAwBCyAAIAAvATBBCHI7ATALIB4hAQtBqwEhHgymAQsgACABIAIQq4CAgAAaDBsLAkAgASIeIAJGDQAgHiEBAkACQCAeLQAAQXZqDgQBamoAagsgHkEBaiEBC0EeIR4MpQELQcMAIR4MtAELIABBADYCHCAAIAE2AhQgAEGRkYCAADYCECAAQQM2AgxBACEeDLMBCwJAIAEtAABBDUcNACAAKAIEIR4gAEEANgIEAkAgACAeIAEQqoCAgAAiHg0AIAFBAWohAQxpCyAAQR42AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MswELIAEhASAALQAtQQFxRQ2uAUGtASEeDKIBCwJAIAEiASACRw0AQR8hHgyyAQsCQAJAA0ACQCABLQAAQXZqDgQCAAADAAsgAUEBaiIBIAJHDQALQR8hHgyzAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABIQEMaAsgAEEeNgIcIAAgATYCFCAAIB42AgxBACEeDLIBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQqoCAgAAiHg0AIAFBAWohAQxnCyAAQR42AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MsQELIB5BLEcNASABQQFqIR5BASEBAkACQAJAAkACQCAALQAsQXtqDgQDAQIEAAsgHiEBDAQLQQIhAQwBC0EEIQELIABBAToALCAAIAAvATAgAXI7ATAgHiEBDAELIAAgAC8BMEEIcjsBMCAeIQELQS4hHgyfAQsgAEEAOgAsIAEhAQtBKSEeDJ0BCyAAQQA2AgAgIyAka0EJaiEBQQUhHgyYAQsgAEEANgIAICMgJGtBBmohAUEHIR4MlwELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEIIABBADYCBAJAIAAgCCABEKqAgIAAIggNACABIQEMnQELIABBKjYCHCAAIAE2AhQgACAINgIMQQAhHgypAQsgAEEIOgAsIAEhAQtBJSEeDJcBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNeCABIQEMAwsgAC0AMEEgcQ15Qa4BIR4MlQELAkAgHSACRg0AAkADQAJAIB0tAABBUGoiAUH/AXFBCkkNACAdIQFBKiEeDJgBCyAAKQMgIh9CmbPmzJmz5swZVg0BIAAgH0IKfiIfNwMgIB8gAa0iIEJ/hUKAfoRWDQEgACAfICBC/wGDfDcDICAdQQFqIh0gAkcNAAtBLCEeDKYBCyAAKAIEIQggAEEANgIEIAAgCCAdQQFqIgEQqoCAgAAiCA16IAEhAQyZAQtBLCEeDKQBCwJAIAAvATAiAUEIcUUNACAALQAoQQFHDQAgAC0ALUEIcUUNdQsgACABQff7A3FBgARyOwEwIB0hAQtBLCEeDJIBCyAAIAAvATBBEHI7ATAMhwELIABBNjYCHCAAIAE2AgwgACAcQQFqNgIUQQAhHgygAQsgAS0AAEE6Rw0CIAAoAgQhHiAAQQA2AgQgACAeIAEQqICAgAAiHg0BIAFBAWohAQtBMSEeDI4BCyAAQTY2AhwgACAeNgIMIAAgAUEBajYCFEEAIR4MnQELIABBADYCHCAAIAE2AhQgAEGHjoCAADYCECAAQQo2AgxBACEeDJwBCyABQQFqIQELIABBgBI7ASogACABIAIQpYCAgAAaIAEhAQtBrAEhHgyJAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMUAsgAEHEADYCHCAAIAE2AhQgACAeNgIMQQAhHgyYAQsgAEEANgIcIAAgIjYCFCAAQeWYgIAANgIQIABBBzYCDCAAQQA2AgBBACEeDJcBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxPCyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDJYBC0EAIR4gAEEANgIcIAAgATYCFCAAQeuNgIAANgIQIABBCTYCDAyVAQtBASEeCyAAIB46ACsgAUEBaiEBIAAtAClBIkYNiwEMTAsgAEEANgIcIAAgATYCFCAAQaKNgIAANgIQIABBCTYCDEEAIR4MkgELIABBADYCHCAAIAE2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDJEBC0EBIR4LIAAgHjoAKiABQQFqIQEMSgsgAEEANgIcIAAgATYCFCAAQbiNgIAANgIQIABBCTYCDEEAIR4MjgELIABBADYCACAmICNrQQRqIQECQCAALQApQSNPDQAgASEBDEoLIABBADYCHCAAIAE2AhQgAEGviYCAADYCECAAQQg2AgxBACEeDI0BCyAAQQA2AgALQQAhHiAAQQA2AhwgACABNgIUIABBuZuAgAA2AhAgAEEINgIMDIsBCyAAQQA2AgAgJiAja0EDaiEBAkAgAC0AKUEhRw0AIAEhAQxHCyAAQQA2AhwgACABNgIUIABB94mAgAA2AhAgAEEINgIMQQAhHgyKAQsgAEEANgIAICYgI2tBBGohAQJAIAAtACkiHkFdakELTw0AIAEhAQxGCwJAIB5BBksNAEEBIB50QcoAcUUNACABIQEMRgtBACEeIABBADYCHCAAIAE2AhQgAEHTiYCAADYCECAAQQg2AgwMiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDEYLIABB0AA2AhwgACABNgIUIAAgHjYCDEEAIR4MiAELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDD8LIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MhwELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDD8LIABBxQA2AhwgACABNgIUIAAgHjYCDEEAIR4MhgELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDEMLIABB0AA2AhwgACABNgIUIAAgHjYCDEEAIR4MhQELIABBADYCHCAAIAE2AhQgAEGiioCAADYCECAAQQc2AgxBACEeDIQBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw7CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDIMBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw7CyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDIIBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIEBCyAAQQA2AhwgACABNgIUIABBuIiAgAA2AhAgAEEHNgIMQQAhHgyAAQsgHkE/Rw0BIAFBAWohAQtBBSEeDG4LQQAhHiAAQQA2AhwgACABNgIUIABB04+AgAA2AhAgAEEHNgIMDH0LIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDDQLIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MfAsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMNAsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgx7CyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw4CyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDHoLIAAoAgQhASAAQQA2AgQCQCAAIAEgIhCkgICAACIBDQAgIiEBDDELIABBxAA2AhwgACAiNgIUIAAgATYCDEEAIR4MeQsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMMQsgAEHFADYCHCAAICI2AhQgACABNgIMQQAhHgx4CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQw1CyAAQdAANgIcIAAgIjYCFCAAIAE2AgxBACEeDHcLIABBADYCHCAAICI2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHYLIABBADYCHCAAIAE2AhQgAEHQjICAADYCECAAQQc2AgxBACEeDHULQQAhHiAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMDHQLIABBADYCHCAAICI2AhQgAEG/lICAADYCECAAQQc2AgxBACEeDHMLIABBADYCHCAAICI2AhQgAEHUjoCAADYCECAAQQc2AgxBACEeDHILIABBADYCHCAAIAE2AhQgAEHBk4CAADYCECAAQQY2AgxBACEeDHELIABBADYCACAiICZrQQZqIQFBJCEeCyAAIB46ACkgASEBDE4LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGklICAADYCECAAQQY2AgwMbQsgACgCBCETIABBADYCBCAAIBMgHhCmgICAACITDQEgHkEBaiETC0GdASEeDFsLIABBqgE2AhwgACATNgIMIAAgHkEBajYCFEEAIR4MagsgACgCBCEUIABBADYCBCAAIBQgHhCmgICAACIUDQEgHkEBaiEUC0GaASEeDFgLIABBqwE2AhwgACAUNgIMIAAgHkEBajYCFEEAIR4MZwsgAEEANgIcIAAgFTYCFCAAQfOKgIAANgIQIABBDTYCDEEAIR4MZgsgAEEANgIcIAAgFjYCFCAAQc6NgIAANgIQIABBCTYCDEEAIR4MZQtBASEeCyAAIB46ACsgF0EBaiEWDC4LIABBADYCHCAAIBc2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDGILIABBADYCHCAAIBg2AhQgAEHFioCAADYCECAAQQk2AgxBACEeDGELQQEhHgsgACAeOgAqIBlBAWohGAwsCyAAQQA2AhwgACAZNgIUIABBuI2AgAA2AhAgAEEJNgIMQQAhHgxeCyAAQQA2AhwgACAZNgIUIABBuZuAgAA2AhAgAEEINgIMIABBADYCAEEAIR4MXQsgAEEANgIAC0EAIR4gAEEANgIcIAAgCDYCFCAAQYuUgIAANgIQIABBCDYCDAxbCyAAQQI6ACggAEEANgIAIBsgGWtBA2ohGQw2CyAAQQI6AC8gACAIIAIQo4CAgAAiHg0BQa8BIR4MSQsgAC0AKEF/ag4CHiAfCyAeQRVHDScgAEG7ATYCHCAAIAg2AhQgAEGnkoCAADYCECAAQRU2AgxBACEeDFcLQQAhHgxGC0ECIR4MRQtBDiEeDEQLQRAhHgxDC0EcIR4MQgtBFCEeDEELQRYhHgxAC0EXIR4MPwtBGSEeDD4LQRohHgw9C0E6IR4MPAtBIyEeDDsLQSQhHgw6C0EwIR4MOQtBOyEeDDgLQTwhHgw3C0E+IR4MNgtBPyEeDDULQcAAIR4MNAtBwQAhHgwzC0HFACEeDDILQccAIR4MMQtByAAhHgwwC0HKACEeDC8LQd8AIR4MLgtB4gAhHgwtC0H7ACEeDCwLQYUBIR4MKwtBlwEhHgwqC0GZASEeDCkLQakBIR4MKAtBpAEhHgwnC0GbASEeDCYLQZ4BIR4MJQtBnwEhHgwkC0GhASEeDCMLQaIBIR4MIgtBpwEhHgwhC0GoASEeDCALIABBADYCHCAAIAg2AhQgAEHmi4CAADYCECAAQRA2AgxBACEeDC8LIABBADYCBCAAIB0gHRCqgICAACIBRQ0BIABBLTYCHCAAIAE2AgwgACAdQQFqNgIUQQAhHgwuCyAAKAIEIQggAEEANgIEAkAgACAIIAEQqoCAgAAiCEUNACAAQS42AhwgACAINgIMIAAgAUEBajYCFEEAIR4MLgsgAUEBaiEBDB4LIB1BAWohAQweCyAAQQA2AhwgACAdNgIUIABBuo+AgAA2AhAgAEEENgIMQQAhHgwrCyAAQSk2AhwgACABNgIUIAAgCDYCDEEAIR4MKgsgHEEBaiEBDB4LIABBCjYCHCAAIAE2AhQgAEGRkoCAADYCECAAQRU2AgxBACEeDCgLIABBEDYCHCAAIAE2AhQgAEG+koCAADYCECAAQRU2AgxBACEeDCcLIABBADYCHCAAIB42AhQgAEGIjICAADYCECAAQRQ2AgxBACEeDCYLIABBBDYCHCAAIAE2AhQgAEHWkoCAADYCECAAQRU2AgxBACEeDCULIABBADYCACAIICJrQQVqIRkLQaMBIR4MEwsgAEEANgIAICIgJmtBAmohAUHjACEeDBILIABBADYCACAAQYEEOwEoIBogHmtBAmohAQtB0wAhHgwQCyABIQECQCAALQApQQVHDQBB0gAhHgwQC0HRACEeDA8LQQAhHiAAQQA2AhwgAEG6joCAADYCECAAQQc2AgwgACAiQQFqNgIUDB4LIABBADYCACAmICNrQQJqIQFBNCEeDA0LIAEhAQtBLSEeDAsLAkAgASIdIAJGDQADQAJAIB0tAABBgKKAgABqLQAAIgFBAUYNACABQQJHDQMgHUEBaiEBDAQLIB1BAWoiHSACRw0AC0ExIR4MGwtBMSEeDBoLIABBADoALCAdIQEMAQtBDCEeDAgLQS8hHgwHCyABQQFqIQFBIiEeDAYLQR8hHgwFCyAAQQA2AgAgIyAka0EEaiEBQQYhHgsgACAeOgAsIAEhAUENIR4MAwsgAEEANgIAICYgI2tBB2ohAUELIR4MAgsgAEEANgIACyAAQQA6ACwgHCEBQQkhHgwACwtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDgtBACEeIABBADYCHCAAIAE2AhQgAEG4kYCAADYCECAAQQ82AgwMDQtBACEeIABBADYCHCAAIAE2AhQgAEGWj4CAADYCECAAQQs2AgwMDAtBACEeIABBADYCHCAAIAE2AhQgAEHxiICAADYCECAAQQs2AgwMCwtBACEeIABBADYCHCAAIAE2AhQgAEGIjYCAADYCECAAQQo2AgwMCgsgAEECNgIcIAAgATYCFCAAQfCSgIAANgIQIABBFjYCDEEAIR4MCQtBASEeDAgLQcYAIR4gASIBIAJGDQcgA0EIaiAAIAEgAkHYpoCAAEEKELmAgIAAIAMoAgwhASADKAIIDgMBBwIACxC/gICAAAALIABBADYCHCAAQYmTgIAANgIQIABBFzYCDCAAIAFBAWo2AhRBACEeDAULIABBADYCHCAAIAE2AhQgAEGek4CAADYCECAAQQk2AgxBACEeDAQLAkAgASIBIAJHDQBBISEeDAQLAkAgAS0AAEEKRg0AIABBADYCHCAAIAE2AhQgAEHujICAADYCECAAQQo2AgxBACEeDAQLIAAoAgQhCCAAQQA2AgQgACAIIAEQqoCAgAAiCA0BIAFBAWohAQtBACEeIABBADYCHCAAIAE2AhQgAEHqkICAADYCECAAQRk2AgwMAgsgAEEgNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDAELAkAgASIBIAJHDQBBFCEeDAELIABBiYCAgAA2AgggACABNgIEQRMhHgsgA0EQaiSAgICAACAeC68BAQJ/IAEoAgAhBgJAAkAgAiADRg0AIAQgBmohBCAGIANqIAJrIQcgAiAGQX9zIAVqIgZqIQUDQAJAIAItAAAgBC0AAEYNAEECIQQMAwsCQCAGDQBBACEEIAUhAgwDCyAGQX9qIQYgBEEBaiEEIAJBAWoiAiADRw0ACyAHIQYgAyECCyAAQQE2AgAgASAGNgIAIAAgAjYCBA8LIAFBADYCACAAIAQ2AgAgACACNgIECwoAIAAQu4CAgAALlTcBC38jgICAgABBEGsiASSAgICAAAJAQQAoAqC0gIAADQBBABC+gICAAEGAuISAAGsiAkHZAEkNAEEAIQMCQEEAKALgt4CAACIEDQBBAEJ/NwLst4CAAEEAQoCAhICAgMAANwLkt4CAAEEAIAFBCGpBcHFB2KrVqgVzIgQ2AuC3gIAAQQBBADYC9LeAgABBAEEANgLEt4CAAAtBACACNgLMt4CAAEEAQYC4hIAANgLIt4CAAEEAQYC4hIAANgKYtICAAEEAIAQ2Aqy0gIAAQQBBfzYCqLSAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0AC0GAuISAAEF4QYC4hIAAa0EPcUEAQYC4hIAAQQhqQQ9xGyIDaiIEQQRqIAIgA2tBSGoiA0EBcjYCAEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgAkGAuISAAGpBTGpBODYCAAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEHsAUsNAAJAQQAoAoi0gIAAIgZBECAAQRNqQXBxIABBC0kbIgJBA3YiBHYiA0EDcUUNACADQQFxIARyQQFzIgVBA3QiAEG4tICAAGooAgAiBEEIaiEDAkACQCAEKAIIIgIgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3E2Aoi0gIAADAELIAAgAjYCCCACIAA2AgwLIAQgBUEDdCIFQQNyNgIEIAQgBWpBBGoiBCAEKAIAQQFyNgIADAwLIAJBACgCkLSAgAAiB00NAQJAIANFDQACQAJAIAMgBHRBAiAEdCIDQQAgA2tycSIDQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmoiBUEDdCIAQbi0gIAAaigCACIEKAIIIgMgAEGwtICAAGoiAEcNAEEAIAZBfiAFd3EiBjYCiLSAgAAMAQsgACADNgIIIAMgADYCDAsgBEEIaiEDIAQgAkEDcjYCBCAEIAVBA3QiBWogBSACayIFNgIAIAQgAmoiACAFQQFyNgIEAkAgB0UNACAHQQN2IghBA3RBsLSAgABqIQJBACgCnLSAgAAhBAJAAkAgBkEBIAh0IghxDQBBACAGIAhyNgKItICAACACIQgMAQsgAigCCCEICyAIIAQ2AgwgAiAENgIIIAQgAjYCDCAEIAg2AggLQQAgADYCnLSAgABBACAFNgKQtICAAAwMC0EAKAKMtICAACIJRQ0BIAlBACAJa3FBf2oiAyADQQx2QRBxIgN2IgRBBXZBCHEiBSADciAEIAV2IgNBAnZBBHEiBHIgAyAEdiIDQQF2QQJxIgRyIAMgBHYiA0EBdkEBcSIEciADIAR2akECdEG4toCAAGooAgAiACgCBEF4cSACayEEIAAhBQJAA0ACQCAFKAIQIgMNACAFQRRqKAIAIgNFDQILIAMoAgRBeHEgAmsiBSAEIAUgBEkiBRshBCADIAAgBRshACADIQUMAAsLIAAoAhghCgJAIAAoAgwiCCAARg0AQQAoApi0gIAAIAAoAggiA0saIAggAzYCCCADIAg2AgwMCwsCQCAAQRRqIgUoAgAiAw0AIAAoAhAiA0UNAyAAQRBqIQULA0AgBSELIAMiCEEUaiIFKAIAIgMNACAIQRBqIQUgCCgCECIDDQALIAtBADYCAAwKC0F/IQIgAEG/f0sNACAAQRNqIgNBcHEhAkEAKAKMtICAACIHRQ0AQQAhCwJAIAJBgAJJDQBBHyELIAJB////B0sNACADQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgUgBUGAgA9qQRB2QQJxIgV0QQ92IAMgBHIgBXJrIgNBAXQgAiADQRVqdkEBcXJBHGohCwtBACACayEEAkACQAJAAkAgC0ECdEG4toCAAGooAgAiBQ0AQQAhA0EAIQgMAQtBACEDIAJBAEEZIAtBAXZrIAtBH0YbdCEAQQAhCANAAkAgBSgCBEF4cSACayIGIARPDQAgBiEEIAUhCCAGDQBBACEEIAUhCCAFIQMMAwsgAyAFQRRqKAIAIgYgBiAFIABBHXZBBHFqQRBqKAIAIgVGGyADIAYbIQMgAEEBdCEAIAUNAAsLAkAgAyAIcg0AQQAhCEECIAt0IgNBACADa3IgB3EiA0UNAyADQQAgA2txQX9qIgMgA0EMdkEQcSIDdiIFQQV2QQhxIgAgA3IgBSAAdiIDQQJ2QQRxIgVyIAMgBXYiA0EBdkECcSIFciADIAV2IgNBAXZBAXEiBXIgAyAFdmpBAnRBuLaAgABqKAIAIQMLIANFDQELA0AgAygCBEF4cSACayIGIARJIQACQCADKAIQIgUNACADQRRqKAIAIQULIAYgBCAAGyEEIAMgCCAAGyEIIAUhAyAFDQALCyAIRQ0AIARBACgCkLSAgAAgAmtPDQAgCCgCGCELAkAgCCgCDCIAIAhGDQBBACgCmLSAgAAgCCgCCCIDSxogACADNgIIIAMgADYCDAwJCwJAIAhBFGoiBSgCACIDDQAgCCgCECIDRQ0DIAhBEGohBQsDQCAFIQYgAyIAQRRqIgUoAgAiAw0AIABBEGohBSAAKAIQIgMNAAsgBkEANgIADAgLAkBBACgCkLSAgAAiAyACSQ0AQQAoApy0gIAAIQQCQAJAIAMgAmsiBUEQSQ0AIAQgAmoiACAFQQFyNgIEQQAgBTYCkLSAgABBACAANgKctICAACAEIANqIAU2AgAgBCACQQNyNgIEDAELIAQgA0EDcjYCBCADIARqQQRqIgMgAygCAEEBcjYCAEEAQQA2Apy0gIAAQQBBADYCkLSAgAALIARBCGohAwwKCwJAQQAoApS0gIAAIgAgAk0NAEEAKAKgtICAACIDIAJqIgQgACACayIFQQFyNgIEQQAgBTYClLSAgABBACAENgKgtICAACADIAJBA3I2AgQgA0EIaiEDDAoLAkACQEEAKALgt4CAAEUNAEEAKALot4CAACEEDAELQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQxqQXBxQdiq1aoFczYC4LeAgABBAEEANgL0t4CAAEEAQQA2AsS3gIAAQYCABCEEC0EAIQMCQCAEIAJBxwBqIgdqIgZBACAEayILcSIIIAJLDQBBAEEwNgL4t4CAAAwKCwJAQQAoAsC3gIAAIgNFDQACQEEAKAK4t4CAACIEIAhqIgUgBE0NACAFIANNDQELQQAhA0EAQTA2Avi3gIAADAoLQQAtAMS3gIAAQQRxDQQCQAJAAkBBACgCoLSAgAAiBEUNAEHIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIARLDQMLIAMoAggiAw0ACwtBABC+gICAACIAQX9GDQUgCCEGAkBBACgC5LeAgAAiA0F/aiIEIABxRQ0AIAggAGsgBCAAakEAIANrcWohBgsgBiACTQ0FIAZB/v///wdLDQUCQEEAKALAt4CAACIDRQ0AQQAoAri3gIAAIgQgBmoiBSAETQ0GIAUgA0sNBgsgBhC+gICAACIDIABHDQEMBwsgBiAAayALcSIGQf7///8HSw0EIAYQvoCAgAAiACADKAIAIAMoAgRqRg0DIAAhAwsCQCADQX9GDQAgAkHIAGogBk0NAAJAIAcgBmtBACgC6LeAgAAiBGpBACAEa3EiBEH+////B00NACADIQAMBwsCQCAEEL6AgIAAQX9GDQAgBCAGaiEGIAMhAAwHC0EAIAZrEL6AgIAAGgwECyADIQAgA0F/Rw0FDAMLQQAhCAwHC0EAIQAMBQsgAEF/Rw0CC0EAQQAoAsS3gIAAQQRyNgLEt4CAAAsgCEH+////B0sNASAIEL6AgIAAIQBBABC+gICAACEDIABBf0YNASADQX9GDQEgACADTw0BIAMgAGsiBiACQThqTQ0BC0EAQQAoAri3gIAAIAZqIgM2Ari3gIAAAkAgA0EAKAK8t4CAAE0NAEEAIAM2Ary3gIAACwJAAkACQAJAQQAoAqC0gIAAIgRFDQBByLeAgAAhAwNAIAAgAygCACIFIAMoAgQiCGpGDQIgAygCCCIDDQAMAwsLAkACQEEAKAKYtICAACIDRQ0AIAAgA08NAQtBACAANgKYtICAAAtBACEDQQAgBjYCzLeAgABBACAANgLIt4CAAEEAQX82Aqi0gIAAQQBBACgC4LeAgAA2Aqy0gIAAQQBBADYC1LeAgAADQCADQcS0gIAAaiADQbi0gIAAaiIENgIAIAQgA0GwtICAAGoiBTYCACADQby0gIAAaiAFNgIAIANBzLSAgABqIANBwLSAgABqIgU2AgAgBSAENgIAIANB1LSAgABqIANByLSAgABqIgQ2AgAgBCAFNgIAIANB0LSAgABqIAQ2AgAgA0EgaiIDQYACRw0ACyAAQXggAGtBD3FBACAAQQhqQQ9xGyIDaiIEIAYgA2tBSGoiA0EBcjYCBEEAQQAoAvC3gIAANgKktICAAEEAIAQ2AqC0gIAAQQAgAzYClLSAgAAgBiAAakFMakE4NgIADAILIAMtAAxBCHENACAFIARLDQAgACAETQ0AIARBeCAEa0EPcUEAIARBCGpBD3EbIgVqIgBBACgClLSAgAAgBmoiCyAFayIFQQFyNgIEIAMgCCAGajYCBEEAQQAoAvC3gIAANgKktICAAEEAIAU2ApS0gIAAQQAgADYCoLSAgAAgCyAEakEEakE4NgIADAELAkAgAEEAKAKYtICAACILTw0AQQAgADYCmLSAgAAgACELCyAAIAZqIQhByLeAgAAhAwJAAkACQAJAAkACQAJAA0AgAygCACAIRg0BIAMoAggiAw0ADAILCyADLQAMQQhxRQ0BC0HIt4CAACEDA0ACQCADKAIAIgUgBEsNACAFIAMoAgRqIgUgBEsNAwsgAygCCCEDDAALCyADIAA2AgAgAyADKAIEIAZqNgIEIABBeCAAa0EPcUEAIABBCGpBD3EbaiIGIAJBA3I2AgQgCEF4IAhrQQ9xQQAgCEEIakEPcRtqIgggBiACaiICayEFAkAgBCAIRw0AQQAgAjYCoLSAgABBAEEAKAKUtICAACAFaiIDNgKUtICAACACIANBAXI2AgQMAwsCQEEAKAKctICAACAIRw0AQQAgAjYCnLSAgABBAEEAKAKQtICAACAFaiIDNgKQtICAACACIANBAXI2AgQgAiADaiADNgIADAMLAkAgCCgCBCIDQQNxQQFHDQAgA0F4cSEHAkACQCADQf8BSw0AIAgoAggiBCADQQN2IgtBA3RBsLSAgABqIgBGGgJAIAgoAgwiAyAERw0AQQBBACgCiLSAgABBfiALd3E2Aoi0gIAADAILIAMgAEYaIAMgBDYCCCAEIAM2AgwMAQsgCCgCGCEJAkACQCAIKAIMIgAgCEYNACALIAgoAggiA0saIAAgAzYCCCADIAA2AgwMAQsCQCAIQRRqIgMoAgAiBA0AIAhBEGoiAygCACIEDQBBACEADAELA0AgAyELIAQiAEEUaiIDKAIAIgQNACAAQRBqIQMgACgCECIEDQALIAtBADYCAAsgCUUNAAJAAkAgCCgCHCIEQQJ0Qbi2gIAAaiIDKAIAIAhHDQAgAyAANgIAIAANAUEAQQAoAoy0gIAAQX4gBHdxNgKMtICAAAwCCyAJQRBBFCAJKAIQIAhGG2ogADYCACAARQ0BCyAAIAk2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCCgCFCIDRQ0AIABBFGogAzYCACADIAA2AhgLIAcgBWohBSAIIAdqIQgLIAggCCgCBEF+cTYCBCACIAVqIAU2AgAgAiAFQQFyNgIEAkAgBUH/AUsNACAFQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCACNgIMIAMgAjYCCCACIAM2AgwgAiAENgIIDAMLQR8hAwJAIAVB////B0sNACAFQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgQgBEGA4B9qQRB2QQRxIgR0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBHIgAHJrIgNBAXQgBSADQRVqdkEBcXJBHGohAwsgAiADNgIcIAJCADcCECADQQJ0Qbi2gIAAaiEEAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBCACNgIAQQAgACAIcjYCjLSAgAAgAiAENgIYIAIgAjYCCCACIAI2AgwMAwsgBUEAQRkgA0EBdmsgA0EfRht0IQMgBCgCACEAA0AgACIEKAIEQXhxIAVGDQIgA0EddiEAIANBAXQhAyAEIABBBHFqQRBqIggoAgAiAA0ACyAIIAI2AgAgAiAENgIYIAIgAjYCDCACIAI2AggMAgsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiCyAGIANrQUhqIgNBAXI2AgQgCEFMakE4NgIAIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8LeAgAA2AqS0gIAAQQAgCzYCoLSAgABBACADNgKUtICAACAIQRBqQQApAtC3gIAANwIAIAhBACkCyLeAgAA3AghBACAIQQhqNgLQt4CAAEEAIAY2Asy3gIAAQQAgADYCyLeAgABBAEEANgLUt4CAACAIQSRqIQMDQCADQQc2AgAgBSADQQRqIgNLDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgY2AgAgBCAGQQFyNgIEAkAgBkH/AUsNACAGQQN2IgVBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgBBASAFdCIFcQ0AQQAgACAFcjYCiLSAgAAgAyEFDAELIAMoAgghBQsgBSAENgIMIAMgBDYCCCAEIAM2AgwgBCAFNgIIDAQLQR8hAwJAIAZB////B0sNACAGQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAMgBXIgAHJrIgNBAXQgBiADQRVqdkEBcXJBHGohAwsgBEIANwIQIARBHGogAzYCACADQQJ0Qbi2gIAAaiEFAkBBACgCjLSAgAAiAEEBIAN0IghxDQAgBSAENgIAQQAgACAIcjYCjLSAgAAgBEEYaiAFNgIAIAQgBDYCCCAEIAQ2AgwMBAsgBkEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACEAA0AgACIFKAIEQXhxIAZGDQMgA0EddiEAIANBAXQhAyAFIABBBHFqQRBqIggoAgAiAA0ACyAIIAQ2AgAgBEEYaiAFNgIAIAQgBDYCDCAEIAQ2AggMAwsgBCgCCCIDIAI2AgwgBCACNgIIIAJBADYCGCACIAQ2AgwgAiADNgIICyAGQQhqIQMMBQsgBSgCCCIDIAQ2AgwgBSAENgIIIARBGGpBADYCACAEIAU2AgwgBCADNgIIC0EAKAKUtICAACIDIAJNDQBBACgCoLSAgAAiBCACaiIFIAMgAmsiA0EBcjYCBEEAIAM2ApS0gIAAQQAgBTYCoLSAgAAgBCACQQNyNgIEIARBCGohAwwDC0EAIQNBAEEwNgL4t4CAAAwCCwJAIAtFDQACQAJAIAggCCgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgADYCACAADQFBACAHQX4gBXdxIgc2Aoy0gIAADAILIAtBEEEUIAsoAhAgCEYbaiAANgIAIABFDQELIAAgCzYCGAJAIAgoAhAiA0UNACAAIAM2AhAgAyAANgIYCyAIQRRqKAIAIgNFDQAgAEEUaiADNgIAIAMgADYCGAsCQAJAIARBD0sNACAIIAQgAmoiA0EDcjYCBCADIAhqQQRqIgMgAygCAEEBcjYCAAwBCyAIIAJqIgAgBEEBcjYCBCAIIAJBA3I2AgQgACAEaiAENgIAAkAgBEH/AUsNACAEQQN2IgRBA3RBsLSAgABqIQMCQAJAQQAoAoi0gIAAIgVBASAEdCIEcQ0AQQAgBSAEcjYCiLSAgAAgAyEEDAELIAMoAgghBAsgBCAANgIMIAMgADYCCCAAIAM2AgwgACAENgIIDAELQR8hAwJAIARB////B0sNACAEQQh2IgMgA0GA/j9qQRB2QQhxIgN0IgUgBUGA4B9qQRB2QQRxIgV0IgIgAkGAgA9qQRB2QQJxIgJ0QQ92IAMgBXIgAnJrIgNBAXQgBCADQRVqdkEBcXJBHGohAwsgACADNgIcIABCADcCECADQQJ0Qbi2gIAAaiEFAkAgB0EBIAN0IgJxDQAgBSAANgIAQQAgByACcjYCjLSAgAAgACAFNgIYIAAgADYCCCAAIAA2AgwMAQsgBEEAQRkgA0EBdmsgA0EfRht0IQMgBSgCACECAkADQCACIgUoAgRBeHEgBEYNASADQR12IQIgA0EBdCEDIAUgAkEEcWpBEGoiBigCACICDQALIAYgADYCACAAIAU2AhggACAANgIMIAAgADYCCAwBCyAFKAIIIgMgADYCDCAFIAA2AgggAEEANgIYIAAgBTYCDCAAIAM2AggLIAhBCGohAwwBCwJAIApFDQACQAJAIAAgACgCHCIFQQJ0Qbi2gIAAaiIDKAIARw0AIAMgCDYCACAIDQFBACAJQX4gBXdxNgKMtICAAAwCCyAKQRBBFCAKKAIQIABGG2ogCDYCACAIRQ0BCyAIIAo2AhgCQCAAKAIQIgNFDQAgCCADNgIQIAMgCDYCGAsgAEEUaigCACIDRQ0AIAhBFGogAzYCACADIAg2AhgLAkACQCAEQQ9LDQAgACAEIAJqIgNBA3I2AgQgAyAAakEEaiIDIAMoAgBBAXI2AgAMAQsgACACaiIFIARBAXI2AgQgACACQQNyNgIEIAUgBGogBDYCAAJAIAdFDQAgB0EDdiIIQQN0QbC0gIAAaiECQQAoApy0gIAAIQMCQAJAQQEgCHQiCCAGcQ0AQQAgCCAGcjYCiLSAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2Apy0gIAAQQAgBDYCkLSAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQvYCAgAAL8A0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApi0gIAAIgRJDQEgAiAAaiEAAkBBACgCnLSAgAAgAUYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGwtICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKItICAAEF+IAV3cTYCiLSAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAQgASgCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABKAIcIgRBAnRBuLaAgABqIgIoAgAgAUcNACACIAY2AgAgBg0BQQBBACgCjLSAgABBfiAEd3E2Aoy0gIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQtICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgAyABTQ0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkBBACgCoLSAgAAgA0cNAEEAIAE2AqC0gIAAQQBBACgClLSAgAAgAGoiADYClLSAgAAgASAAQQFyNgIEIAFBACgCnLSAgABHDQNBAEEANgKQtICAAEEAQQA2Apy0gIAADwsCQEEAKAKctICAACADRw0AQQAgATYCnLSAgABBAEEAKAKQtICAACAAaiIANgKQtICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsLSAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiLSAgABBfiAFd3E2Aoi0gIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNAEEAKAKYtICAACADKAIIIgJLGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMoAhwiBEECdEG4toCAAGoiAigCACADRw0AIAIgBjYCACAGDQFBAEEAKAKMtICAAEF+IAR3cTYCjLSAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnLSAgABHDQFBACAANgKQtICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEEDdiICQQN0QbC0gIAAaiEAAkACQEEAKAKItICAACIEQQEgAnQiAnENAEEAIAQgAnI2Aoi0gIAAIAAhAgwBCyAAKAIIIQILIAIgATYCDCAAIAE2AgggASAANgIMIAEgAjYCCA8LQR8hAgJAIABB////B0sNACAAQQh2IgIgAkGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgYgBkGAgA9qQRB2QQJxIgZ0QQ92IAIgBHIgBnJrIgJBAXQgACACQRVqdkEBcXJBHGohAgsgAUIANwIQIAFBHGogAjYCACACQQJ0Qbi2gIAAaiEEAkACQEEAKAKMtICAACIGQQEgAnQiA3ENACAEIAE2AgBBACAGIANyNgKMtICAACABQRhqIAQ2AgAgASABNgIIIAEgATYCDAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQYCQANAIAYiBCgCBEF4cSAARg0BIAJBHXYhBiACQQF0IQIgBCAGQQRxakEQaiIDKAIAIgYNAAsgAyABNgIAIAFBGGogBDYCACABIAE2AgwgASABNgIIDAELIAQoAggiACABNgIMIAQgATYCCCABQRhqQQA2AgAgASAENgIMIAEgADYCCAtBAEEAKAKotICAAEF/aiIBQX8gARs2Aqi0gIAACwtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+LeAgABBfw8LIABBEHQPCxC/gICAAAALBAAAAAsLjiwBAEGACAuGLAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW52YWxpZCBjaGFyIGluIHVybCBxdWVyeQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2JvZHkAQ29udGVudC1MZW5ndGggb3ZlcmZsb3cAQ2h1bmsgc2l6ZSBvdmVyZmxvdwBSZXNwb25zZSBvdmVyZmxvdwBJbnZhbGlkIG1ldGhvZCBmb3IgSFRUUC94LnggcmVxdWVzdABJbnZhbGlkIG1ldGhvZCBmb3IgUlRTUC94LnggcmVxdWVzdABFeHBlY3RlZCBTT1VSQ0UgbWV0aG9kIGZvciBJQ0UveC54IHJlcXVlc3QASW52YWxpZCBjaGFyIGluIHVybCBmcmFnbWVudCBzdGFydABFeHBlY3RlZCBkb3QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9zdGF0dXMASW52YWxpZCByZXNwb25zZSBzdGF0dXMASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgcGFyYW1ldGVycwBVc2VyIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUATWlzc2luZyBleHBlY3RlZCBDUiBhZnRlciBoZWFkZXIgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBST1BQQVRDSABNLVNFQVJDSABIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBIUEVfQ0JfSEVBREVSU19DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBQQVVTRQBQVVJHRQBNRVJHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAFBST1BGSU5EAFVOQklORABSRUJJTkQASFBFX0NSX0VYUEVDVEVEAEhQRV9MRl9FWFBFQ1RFRABIUEVfUEFVU0VEAEhFQUQARXhwZWN0ZWQgSFRUUC8A3AsAAM8LAADTCgAAmQ0AABAMAABdCwAAXw0AALULAAC6CgAAcwsAAJwLAAD1CwAAcwwAAO8KAADcDAAARwwAAIcLAACPDAAAvQwAAC8LAACnDAAAqQ0AAAQNAAAXDQAAJgsAAIkNAADVDAAAzwoAALQNAACuCgAAoQoAAOcKAAACCwAAPQ0AAJAKAADsCwAAxQsAAIoMAAByDQAANAwAAEAMAADqCwAAhA0AAIINAAB7DQAAywsAALMKAACFCgAApQoAAP4MAAA+DAAAlQoAAE4NAABMDQAAOAwAAPgMAABDCwAA5QsAAOMLAAAtDQAA8QsAAEMNAAA0DQAATgsAAJwKAADyDAAAVAsAABgLAAAKCwAA3goAAFgNAAAuDAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8='


/***/ }),

/***/ "../../node_modules/undici/lib/llhttp/llhttp_simd.wasm.js":
/*!****************************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/llhttp_simd.wasm.js ***!
  \****************************************************************/
/***/ ((module) => {

module.exports = 'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGAuAQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYKuKgCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAs+AQF7IAD9DAAAAAAAAAAAAAAAAAAAAAAiAf0LAgAgAEEwakIANwIAIABBIGogAf0LAgAgAEEQaiAB/QsCAAtnAQF/QQAhAQJAIAAoAgwNAAJAAkACQAJAIAAtAC8OAwEAAwILIAAoAjQiAUUNACABKAIcIgFFDQAgACABEYCAgIAAACIBDQMLQQAPCxC/gICAAAALIABB/5GAgAA2AhBBDiEBCyABCx4AAkAgACgCDA0AIABBhJSAgAA2AhAgAEEVNgIMCwsWAAJAIAAoAgxBFUcNACAAQQA2AgwLCxYAAkAgACgCDEEWRw0AIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCyIAAkAgAEEaSQ0AEL+AgIAAAAsgAEECdEHIm4CAAGooAgALIgACQCAAQS5JDQAQv4CAgAAACyAAQQJ0QbCcgIAAaigCAAsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCACIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIEIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBnI6AgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAigiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCCCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQdKKgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAgwiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHdk4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCMCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIQIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBw5CAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCFCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIcIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAhgiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSiICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCICIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIkIgRFDQAgACAEEYCAgIAAACEDCyADC0UBAX8CQAJAIAAvATBBFHFBFEcNAEEBIQMgAC0AKEEBRg0BIAAvATJB5QBGIQMMAQsgAC0AKUEFRiEDCyAAIAM6AC5BAAvyAQEDf0EBIQMCQCAALwEwIgRBCHENACAAKQMgQgBSIQMLAkACQCAALQAuRQ0AQQEhBSAALQApQQVGDQFBASEFIARBwABxRSADcUEBRw0BC0EAIQUgBEHAAHENAEECIQUgBEEIcQ0AAkAgBEGABHFFDQACQCAALQAoQQFHDQAgAC0ALUEKcQ0AQQUPC0EEDwsCQCAEQSBxDQACQCAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELSAEBeyAAQRBq/QwAAAAAAAAAAAAAAAAAAAAAIgH9CwMAIAAgAf0LAwAgAEEwakIANwMAIABBIGogAf0LAwAgAEG8ATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACELiAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvTzgEDHH8DfgV/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8gASEQIAEhESABIRIgASETIAEhFCABIRUgASEWIAEhFyABIRggASEZIAEhGiABIRsgASEcIAEhHQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiHkF/ag68AbcBAbYBAgMEBQYHCAkKCwwNDg8QwAG/ARESE7UBFBUWFxgZGr0BvAEbHB0eHyAhtAGzASIjsgGxASQlJicoKSorLC0uLzAxMjM0NTY3ODk6uAE7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwEAuQELQQAhHgyvAQtBDyEeDK4BC0EOIR4MrQELQRAhHgysAQtBESEeDKsBC0EUIR4MqgELQRUhHgypAQtBFiEeDKgBC0EXIR4MpwELQRghHgymAQtBCCEeDKUBC0EZIR4MpAELQRohHgyjAQtBEyEeDKIBC0ESIR4MoQELQRshHgygAQtBHCEeDJ8BC0EdIR4MngELQR4hHgydAQtBqgEhHgycAQtBqwEhHgybAQtBICEeDJoBC0EhIR4MmQELQSIhHgyYAQtBIyEeDJcBC0EkIR4MlgELQa0BIR4MlQELQSUhHgyUAQtBKSEeDJMBC0ENIR4MkgELQSYhHgyRAQtBJyEeDJABC0EoIR4MjwELQS4hHgyOAQtBKiEeDI0BC0GuASEeDIwBC0EMIR4MiwELQS8hHgyKAQtBKyEeDIkBC0ELIR4MiAELQSwhHgyHAQtBLSEeDIYBC0EKIR4MhQELQTEhHgyEAQtBMCEeDIMBC0EJIR4MggELQR8hHgyBAQtBMiEeDIABC0EzIR4MfwtBNCEeDH4LQTUhHgx9C0E2IR4MfAtBNyEeDHsLQTghHgx6C0E5IR4MeQtBOiEeDHgLQawBIR4MdwtBOyEeDHYLQTwhHgx1C0E9IR4MdAtBPiEeDHMLQT8hHgxyC0HAACEeDHELQcEAIR4McAtBwgAhHgxvC0HDACEeDG4LQcQAIR4MbQtBByEeDGwLQcUAIR4MawtBBiEeDGoLQcYAIR4MaQtBBSEeDGgLQccAIR4MZwtBBCEeDGYLQcgAIR4MZQtByQAhHgxkC0HKACEeDGMLQcsAIR4MYgtBAyEeDGELQcwAIR4MYAtBzQAhHgxfC0HOACEeDF4LQdAAIR4MXQtBzwAhHgxcC0HRACEeDFsLQdIAIR4MWgtBAiEeDFkLQdMAIR4MWAtB1AAhHgxXC0HVACEeDFYLQdYAIR4MVQtB1wAhHgxUC0HYACEeDFMLQdkAIR4MUgtB2gAhHgxRC0HbACEeDFALQdwAIR4MTwtB3QAhHgxOC0HeACEeDE0LQd8AIR4MTAtB4AAhHgxLC0HhACEeDEoLQeIAIR4MSQtB4wAhHgxIC0HkACEeDEcLQeUAIR4MRgtB5gAhHgxFC0HnACEeDEQLQegAIR4MQwtB6QAhHgxCC0HqACEeDEELQesAIR4MQAtB7AAhHgw/C0HtACEeDD4LQe4AIR4MPQtB7wAhHgw8C0HwACEeDDsLQfEAIR4MOgtB8gAhHgw5C0HzACEeDDgLQfQAIR4MNwtB9QAhHgw2C0H2ACEeDDULQfcAIR4MNAtB+AAhHgwzC0H5ACEeDDILQfoAIR4MMQtB+wAhHgwwC0H8ACEeDC8LQf0AIR4MLgtB/gAhHgwtC0H/ACEeDCwLQYABIR4MKwtBgQEhHgwqC0GCASEeDCkLQYMBIR4MKAtBhAEhHgwnC0GFASEeDCYLQYYBIR4MJQtBhwEhHgwkC0GIASEeDCMLQYkBIR4MIgtBigEhHgwhC0GLASEeDCALQYwBIR4MHwtBjQEhHgweC0GOASEeDB0LQY8BIR4MHAtBkAEhHgwbC0GRASEeDBoLQZIBIR4MGQtBkwEhHgwYC0GUASEeDBcLQZUBIR4MFgtBlgEhHgwVC0GXASEeDBQLQZgBIR4MEwtBmQEhHgwSC0GdASEeDBELQZoBIR4MEAtBASEeDA8LQZsBIR4MDgtBnAEhHgwNC0GeASEeDAwLQaABIR4MCwtBnwEhHgwKC0GhASEeDAkLQaIBIR4MCAtBowEhHgwHC0GkASEeDAYLQaUBIR4MBQtBpgEhHgwEC0GnASEeDAMLQagBIR4MAgtBqQEhHgwBC0GvASEeCwNAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4OsAEAAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGhweHyAjJCUmJygpKiwtLi8w+wI0Njg5PD9BQkNERUZHSElKS0xNTk9QUVJTVVdZXF1eYGJjZGVmZ2hrbG1ub3BxcnN0dXZ3eHl6e3x9fn+AAYEBggGDAYQBhQGGAYcBiAGJAYoBiwGMAY0BjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHaAeAB4QHkAfEBvQK9AgsgASIIIAJHDcIBQbwBIR4MlQMLIAEiHiACRw2xAUGsASEeDJQDCyABIgEgAkcNZ0HiACEeDJMDCyABIgEgAkcNXUHaACEeDJIDCyABIgEgAkcNVkHVACEeDJEDCyABIgEgAkcNUkHTACEeDJADCyABIgEgAkcNT0HRACEeDI8DCyABIgEgAkcNTEHPACEeDI4DCyABIgEgAkcNEEEMIR4MjQMLIAEiASACRw0zQTghHgyMAwsgASIBIAJHDS9BNSEeDIsDCyABIgEgAkcNJkEyIR4MigMLIAEiASACRw0kQS8hHgyJAwsgASIBIAJHDR1BJCEeDIgDCyAALQAuQQFGDf0CDMcBCyAAIAEiASACELSAgIAAQQFHDbQBDLUBCyAAIAEiASACEK2AgIAAIh4NtQEgASEBDLACCwJAIAEiASACRw0AQQYhHgyFAwsgACABQQFqIgEgAhCwgICAACIeDbYBIAEhAQwPCyAAQgA3AyBBEyEeDPMCCyABIh4gAkcNCUEPIR4MggMLAkAgASIBIAJGDQAgAUEBaiEBQREhHgzyAgtBByEeDIEDCyAAQgAgACkDICIfIAIgASIea60iIH0iISAhIB9WGzcDICAfICBWIiJFDbMBQQghHgyAAwsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBFSEeDPACC0EJIR4M/wILIAEhASAAKQMgUA2yASABIQEMrQILAkAgASIBIAJHDQBBCyEeDP4CCyAAIAFBAWoiASACEK+AgIAAIh4NsgEgASEBDK0CCwNAAkAgAS0AAEHwnYCAAGotAAAiHkEBRg0AIB5BAkcNtAEgAUEBaiEBDAMLIAFBAWoiASACRw0AC0EMIR4M/AILAkAgASIBIAJHDQBBDSEeDPwCCwJAAkAgAS0AACIeQXNqDhQBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBtgG2AbYBALQBCyABQQFqIQEMtAELIAFBAWohAQtBGCEeDOoCCwJAIAEiHiACRw0AQQ4hHgz6AgtCACEfIB4hAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgHi0AAEFQag43yAHHAQABAgMEBQYHvgK+Ar4CvgK+Ar4CvgIICQoLDA2+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CvgK+Ar4CDg8QERITvgILQgIhHwzHAQtCAyEfDMYBC0IEIR8MxQELQgUhHwzEAQtCBiEfDMMBC0IHIR8MwgELQgghHwzBAQtCCSEfDMABC0IKIR8MvwELQgshHwy+AQtCDCEfDL0BC0INIR8MvAELQg4hHwy7AQtCDyEfDLoBC0IKIR8MuQELQgshHwy4AQtCDCEfDLcBC0INIR8MtgELQg4hHwy1AQtCDyEfDLQBC0IAIR8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIB4tAABBUGoON8cBxgEAAQIDBAUGB8gByAHIAcgByAHIAcgBCAkKCwwNyAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAcgByAHIAQ4PEBESE8gBC0ICIR8MxgELQgMhHwzFAQtCBCEfDMQBC0IFIR8MwwELQgYhHwzCAQtCByEfDMEBC0IIIR8MwAELQgkhHwy/AQtCCiEfDL4BC0ILIR8MvQELQgwhHwy8AQtCDSEfDLsBC0IOIR8MugELQg8hHwy5AQtCCiEfDLgBC0ILIR8MtwELQgwhHwy2AQtCDSEfDLUBC0IOIR8MtAELQg8hHwyzAQsgAEIAIAApAyAiHyACIAEiHmutIiB9IiEgISAfVhs3AyAgHyAgViIiRQ20AUERIR4M9wILAkAgASIBIAJGDQAgAEGJgICAADYCCCAAIAE2AgQgASEBQRshHgznAgtBEiEeDPYCCyAAIAEiHiACELKAgIAAQX9qDgWmAQCiAgGzAbQBC0ESIR4M5AILIABBAToALyAeIQEM8gILIAEiASACRw20AUEWIR4M8gILIAEiHCACRw0ZQTkhHgzxAgsCQCABIgEgAkcNAEEaIR4M8QILIABBADYCBCAAQYqAgIAANgIIIAAgASABEKqAgIAAIh4NtgEgASEBDLkBCwJAIAEiHiACRw0AQRshHgzwAgsCQCAeLQAAIgFBIEcNACAeQQFqIQEMGgsgAUEJRw22ASAeQQFqIQEMGQsCQCABIgEgAkYNACABQQFqIQEMFAtBHCEeDO4CCwJAIAEiHiACRw0AQR0hHgzuAgsCQCAeLQAAIgFBCUcNACAeIQEM0gILIAFBIEcNtQEgHiEBDNECCwJAIAEiASACRw0AQR4hHgztAgsgAS0AAEEKRw24ASABQQFqIQEMoAILIAEiASACRw24AUEiIR4M6wILA0ACQCABLQAAIh5BIEYNAAJAIB5BdmoOBAC+Ab4BALwBCyABIQEMxAELIAFBAWoiASACRw0AC0EkIR4M6gILQSUhHiABIiMgAkYN6QIgAiAjayAAKAIAIiRqISUgIyEmICQhAQJAA0AgJi0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHwn4CAAGotAABHDQEgAUEDRg3WAiABQQFqIQEgJkEBaiImIAJHDQALIAAgJTYCAAzqAgsgAEEANgIAICYhAQy7AQtBJiEeIAEiIyACRg3oAiACICNrIAAoAgAiJGohJSAjISYgJCEBAkADQCAmLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQfSfgIAAai0AAEcNASABQQhGDb0BIAFBAWohASAmQQFqIiYgAkcNAAsgACAlNgIADOkCCyAAQQA2AgAgJiEBDLoBC0EnIR4gASIjIAJGDecCIAIgI2sgACgCACIkaiElICMhJiAkIQECQANAICYtAAAiIkEgciAiICJBv39qQf8BcUEaSRtB/wFxIAFB0KaAgABqLQAARw0BIAFBBUYNvQEgAUEBaiEBICZBAWoiJiACRw0ACyAAICU2AgAM6AILIABBADYCACAmIQEMuQELAkAgASIBIAJGDQADQAJAIAEtAABBgKKAgABqLQAAIh5BAUYNACAeQQJGDQogASEBDMEBCyABQQFqIgEgAkcNAAtBIyEeDOcCC0EjIR4M5gILAkAgASIBIAJGDQADQAJAIAEtAAAiHkEgRg0AIB5BdmoOBL0BvgG+Ab0BvgELIAFBAWoiASACRw0AC0ErIR4M5gILQSshHgzlAgsDQAJAIAEtAAAiHkEgRg0AIB5BCUcNAwsgAUEBaiIBIAJHDQALQS8hHgzkAgsDQAJAIAEtAAAiHkEgRg0AAkACQCAeQXZqDgS+AQEBvgEACyAeQSxGDb8BCyABIQEMBAsgAUEBaiIBIAJHDQALQTIhHgzjAgsgASEBDL8BC0EzIR4gASImIAJGDeECIAIgJmsgACgCACIjaiEkICYhIiAjIQECQANAICItAABBIHIgAUGApICAAGotAABHDQEgAUEGRg3QAiABQQFqIQEgIkEBaiIiIAJHDQALIAAgJDYCAAziAgsgAEEANgIAICIhAQtBKyEeDNACCwJAIAEiHSACRw0AQTQhHgzgAgsgAEGKgICAADYCCCAAIB02AgQgHSEBIAAtACxBf2oOBK8BuQG7Ab0BxwILIAFBAWohAQyuAQsCQCABIgEgAkYNAANAAkAgAS0AACIeQSByIB4gHkG/f2pB/wFxQRpJG0H/AXEiHkEJRg0AIB5BIEYNAAJAAkACQAJAIB5BnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQSYhHgzTAgsgAUEBaiEBQSchHgzSAgsgAUEBaiEBQSghHgzRAgsgASEBDLIBCyABQQFqIgEgAkcNAAtBKCEeDN4CC0EoIR4M3QILAkAgASIBIAJGDQADQAJAIAEtAABBgKCAgABqLQAAQQFGDQAgASEBDLcBCyABQQFqIgEgAkcNAAtBMCEeDN0CC0EwIR4M3AILAkADQAJAIAEtAABBd2oOGAACwQLBAscCwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECwQLBAsECAMECCyABQQFqIgEgAkcNAAtBNSEeDNwCCyABQQFqIQELQSEhHgzKAgsgASIBIAJHDbkBQTchHgzZAgsDQAJAIAEtAABBkKSAgABqLQAAQQFGDQAgASEBDJACCyABQQFqIgEgAkcNAAtBOCEeDNgCCyAcLQAAIh5BIEYNmgEgHkE6Rw3GAiAAKAIEIQEgAEEANgIEIAAgASAcEKiAgIAAIgENtgEgHEEBaiEBDLgBCyAAIAEgAhCpgICAABoLQQohHgzFAgtBOiEeIAEiJiACRg3UAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZCmgIAAai0AAEcNxAIgAUEFRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNUCCyAAQQA2AgAgAEEBOgAsICYgI2tBBmohAQy+AgtBOyEeIAEiJiACRg3TAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQZamgIAAai0AAEcNwwIgAUEJRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNQCCyAAQQA2AgAgAEECOgAsICYgI2tBCmohAQy9AgsCQCABIhwgAkcNAEE8IR4M0wILAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwDDAsMCwwLDAsMCAcMCCyAcQQFqIQFBMiEeDMMCCyAcQQFqIQFBMyEeDMICC0E9IR4gASImIAJGDdECIAIgJmsgACgCACIjaiEkICYhHCAjIQEDQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaCmgIAAai0AAEcNwAIgAUEBRg20AiABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzRAgtBPiEeIAEiJiACRg3QAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQaKmgIAAai0AAEcNwAIgAUEORg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNECCyAAQQA2AgAgAEEBOgAsICYgI2tBD2ohAQy6AgtBPyEeIAEiJiACRg3PAiACICZrIAAoAgAiI2ohJCAmIRwgIyEBAkADQCAcLQAAIiJBIHIgIiAiQb9/akH/AXFBGkkbQf8BcSABQcCmgIAAai0AAEcNvwIgAUEPRg0BIAFBAWohASAcQQFqIhwgAkcNAAsgACAkNgIADNACCyAAQQA2AgAgAEEDOgAsICYgI2tBEGohAQy5AgtBwAAhHiABIiYgAkYNzgIgAiAmayAAKAIAIiNqISQgJiEcICMhAQJAA0AgHC0AACIiQSByICIgIkG/f2pB/wFxQRpJG0H/AXEgAUHQpoCAAGotAABHDb4CIAFBBUYNASABQQFqIQEgHEEBaiIcIAJHDQALIAAgJDYCAAzPAgsgAEEANgIAIABBBDoALCAmICNrQQZqIQEMuAILAkAgASIcIAJHDQBBwQAhHgzOAgsCQAJAAkACQCAcLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGdf2oOEwDAAsACwALAAsACwALAAsACwALAAsACwAIBwALAAsACAgPAAgsgHEEBaiEBQTUhHgzAAgsgHEEBaiEBQTYhHgy/AgsgHEEBaiEBQTchHgy+AgsgHEEBaiEBQTghHgy9AgsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBOSEeDL0CC0HCACEeDMwCCyABIgEgAkcNrwFBxAAhHgzLAgtBxQAhHiABIiYgAkYNygIgAiAmayAAKAIAIiNqISQgJiEiICMhAQJAA0AgIi0AACABQdamgIAAai0AAEcNtAEgAUEBRg0BIAFBAWohASAiQQFqIiIgAkcNAAsgACAkNgIADMsCCyAAQQA2AgAgJiAja0ECaiEBDK8BCwJAIAEiASACRw0AQccAIR4MygILIAEtAABBCkcNswEgAUEBaiEBDK8BCwJAIAEiASACRw0AQcgAIR4MyQILAkACQCABLQAAQXZqDgQBtAG0AQC0AQsgAUEBaiEBQT0hHgy5AgsgAUEBaiEBDK4BCwJAIAEiASACRw0AQckAIR4MyAILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KuwG6AQABAgMEBQYHvAELQQIhHgy6AQtBAyEeDLkBC0EEIR4MuAELQQUhHgy3AQtBBiEeDLYBC0EHIR4MtQELQQghHgy0AQtBCSEeDLMBCwJAIAEiASACRw0AQcoAIR4MxwILIAEtAABBLkcNtAEgAUEBaiEBDIACCwJAIAEiASACRw0AQcsAIR4MxgILQQAhHgJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KvQG8AQABAgMEBQYHvgELQQIhHgy8AQtBAyEeDLsBC0EEIR4MugELQQUhHgy5AQtBBiEeDLgBC0EHIR4MtwELQQghHgy2AQtBCSEeDLUBC0HMACEeIAEiJiACRg3EAiACICZrIAAoAgAiI2ohJCAmIQEgIyEiA0AgAS0AACAiQeKmgIAAai0AAEcNuAEgIkEDRg23ASAiQQFqISIgAUEBaiIBIAJHDQALIAAgJDYCAAzEAgtBzQAhHiABIiYgAkYNwwIgAiAmayAAKAIAIiNqISQgJiEBICMhIgNAIAEtAAAgIkHmpoCAAGotAABHDbcBICJBAkYNuQEgIkEBaiEiIAFBAWoiASACRw0ACyAAICQ2AgAMwwILQc4AIR4gASImIAJGDcICIAIgJmsgACgCACIjaiEkICYhASAjISIDQCABLQAAICJB6aaAgABqLQAARw22ASAiQQNGDbkBICJBAWohIiABQQFqIgEgAkcNAAsgACAkNgIADMICCwNAAkAgAS0AACIeQSBGDQACQAJAAkAgHkG4f2oOCwABugG6AboBugG6AboBugG6AQK6AQsgAUEBaiEBQcIAIR4MtQILIAFBAWohAUHDACEeDLQCCyABQQFqIQFBxAAhHgyzAgsgAUEBaiIBIAJHDQALQc8AIR4MwQILAkAgASIBIAJGDQAgACABQQFqIgEgAhClgICAABogASEBQQchHgyxAgtB0AAhHgzAAgsDQAJAIAEtAABB8KaAgABqLQAAIh5BAUYNACAeQX5qDgO5AboBuwG8AQsgAUEBaiIBIAJHDQALQdEAIR4MvwILAkAgASIBIAJGDQAgAUEBaiEBDAMLQdIAIR4MvgILA0ACQCABLQAAQfCogIAAai0AACIeQQFGDQACQCAeQX5qDgS8Ab0BvgEAvwELIAEhAUHGACEeDK8CCyABQQFqIgEgAkcNAAtB0wAhHgy9AgsCQCABIgEgAkcNAEHUACEeDL0CCwJAIAEtAAAiHkF2ag4apAG/Ab8BpgG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG/Ab8BvwG0Ab8BvwEAvQELIAFBAWohAQtBBiEeDKsCCwNAAkAgAS0AAEHwqoCAAGotAABBAUYNACABIQEM+gELIAFBAWoiASACRw0AC0HVACEeDLoCCwJAIAEiASACRg0AIAFBAWohAQwDC0HWACEeDLkCCwJAIAEiASACRw0AQdcAIR4MuQILIAFBAWohAQwBCwJAIAEiASACRw0AQdgAIR4MuAILIAFBAWohAQtBBCEeDKYCCwJAIAEiIiACRw0AQdkAIR4MtgILICIhAQJAAkACQCAiLQAAQfCsgIAAai0AAEF/ag4HvgG/AcABAPgBAQLBAQsgIkEBaiEBDAoLICJBAWohAQy3AQtBACEeIABBADYCHCAAQfGOgIAANgIQIABBBzYCDCAAICJBAWo2AhQMtQILAkADQAJAIAEtAABB8KyAgABqLQAAIh5BBEYNAAJAAkAgHkF/ag4HvAG9Ab4BwwEABAHDAQsgASEBQckAIR4MqAILIAFBAWohAUHLACEeDKcCCyABQQFqIgEgAkcNAAtB2gAhHgy1AgsgAUEBaiEBDLUBCwJAIAEiIiACRw0AQdsAIR4MtAILICItAABBL0cNvgEgIkEBaiEBDAYLAkAgASIiIAJHDQBB3AAhHgyzAgsCQCAiLQAAIgFBL0cNACAiQQFqIQFBzAAhHgyjAgsgAUF2aiIBQRZLDb0BQQEgAXRBiYCAAnFFDb0BDJMCCwJAIAEiASACRg0AIAFBAWohAUHNACEeDKICC0HdACEeDLECCwJAIAEiIiACRw0AQd8AIR4MsQILICIhAQJAICItAABB8LCAgABqLQAAQX9qDgOSAvABAL4BC0HQACEeDKACCwJAIAEiIiACRg0AA0ACQCAiLQAAQfCugIAAai0AACIBQQNGDQACQCABQX9qDgKUAgC/AQsgIiEBQc4AIR4MogILICJBAWoiIiACRw0AC0HeACEeDLACC0HeACEeDK8CCwJAIAEiASACRg0AIABBjICAgAA2AgggACABNgIEIAEhAUHPACEeDJ8CC0HgACEeDK4CCwJAIAEiASACRw0AQeEAIR4MrgILIABBjICAgAA2AgggACABNgIEIAEhAQtBAyEeDJwCCwNAIAEtAABBIEcNjAIgAUEBaiIBIAJHDQALQeIAIR4MqwILAkAgASIBIAJHDQBB4wAhHgyrAgsgAS0AAEEgRw24ASABQQFqIQEM1AELAkAgASIIIAJHDQBB5AAhHgyqAgsgCC0AAEHMAEcNuwEgCEEBaiEBQRMhHgy5AQtB5QAhHiABIiIgAkYNqAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQNAIAgtAAAgAUHwsoCAAGotAABHDboBIAFBBUYNuAEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMqAILAkAgASIIIAJHDQBB5gAhHgyoAgsCQAJAIAgtAABBvX9qDgwAuwG7AbsBuwG7AbsBuwG7AbsBuwEBuwELIAhBAWohAUHUACEeDJgCCyAIQQFqIQFB1QAhHgyXAgtB5wAhHiABIiIgAkYNpgIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQe2zgIAAai0AAEcNuQEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKcCCyAAQQA2AgAgIiAma0EDaiEBQRAhHgy2AQtB6AAhHiABIiIgAkYNpQIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfaygIAAai0AAEcNuAEgAUEFRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKYCCyAAQQA2AgAgIiAma0EGaiEBQRYhHgy1AQtB6QAhHiABIiIgAkYNpAIgAiAiayAAKAIAIiZqISMgIiEIICYhAQJAA0AgCC0AACABQfyygIAAai0AAEcNtwEgAUEDRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADKUCCyAAQQA2AgAgIiAma0EEaiEBQQUhHgy0AQsCQCABIgggAkcNAEHqACEeDKQCCyAILQAAQdkARw21ASAIQQFqIQFBCCEeDLMBCwJAIAEiCCACRw0AQesAIR4MowILAkACQCAILQAAQbJ/ag4DALYBAbYBCyAIQQFqIQFB2QAhHgyTAgsgCEEBaiEBQdoAIR4MkgILAkAgASIIIAJHDQBB7AAhHgyiAgsCQAJAIAgtAABBuH9qDggAtQG1AbUBtQG1AbUBAbUBCyAIQQFqIQFB2AAhHgySAgsgCEEBaiEBQdsAIR4MkQILQe0AIR4gASIiIAJGDaACIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGAs4CAAGotAABHDbMBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAyhAgtBACEeIABBADYCACAiICZrQQNqIQEMsAELQe4AIR4gASIiIAJGDZ8CIAIgImsgACgCACImaiEjICIhCCAmIQECQANAIAgtAAAgAUGDs4CAAGotAABHDbIBIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIzYCAAygAgsgAEEANgIAICIgJmtBBWohAUEjIR4MrwELAkAgASIIIAJHDQBB7wAhHgyfAgsCQAJAIAgtAABBtH9qDggAsgGyAbIBsgGyAbIBAbIBCyAIQQFqIQFB3QAhHgyPAgsgCEEBaiEBQd4AIR4MjgILAkAgASIIIAJHDQBB8AAhHgyeAgsgCC0AAEHFAEcNrwEgCEEBaiEBDN4BC0HxACEeIAEiIiACRg2cAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFBiLOAgABqLQAARw2vASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnQILIABBADYCACAiICZrQQRqIQFBLSEeDKwBC0HyACEeIAEiIiACRg2bAiACICJrIAAoAgAiJmohIyAiIQggJiEBAkADQCAILQAAIAFB0LOAgABqLQAARw2uASABQQhGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICM2AgAMnAILIABBADYCACAiICZrQQlqIQFBKSEeDKsBCwJAIAEiASACRw0AQfMAIR4MmwILQQEhHiABLQAAQd8ARw2qASABQQFqIQEM3AELQfQAIR4gASIiIAJGDZkCIAIgImsgACgCACImaiEjICIhCCAmIQEDQCAILQAAIAFBjLOAgABqLQAARw2rASABQQFGDfcBIAFBAWohASAIQQFqIgggAkcNAAsgACAjNgIADJkCCwJAIAEiHiACRw0AQfUAIR4MmQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGOs4CAAGotAABHDasBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH1ACEeDJkCCyAAQQA2AgAgHiAia0EDaiEBQQIhHgyoAQsCQCABIh4gAkcNAEH2ACEeDJgCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFB8LOAgABqLQAARw2qASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB9gAhHgyYAgsgAEEANgIAIB4gImtBAmohAUEfIR4MpwELAkAgASIeIAJHDQBB9wAhHgyXAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQfKzgIAAai0AAEcNqQEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfcAIR4MlwILIABBADYCACAeICJrQQJqIQFBCSEeDKYBCwJAIAEiCCACRw0AQfgAIR4MlgILAkACQCAILQAAQbd/ag4HAKkBqQGpAakBqQEBqQELIAhBAWohAUHmACEeDIYCCyAIQQFqIQFB5wAhHgyFAgsCQCABIh4gAkcNAEH5ACEeDJUCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBkbOAgABqLQAARw2nASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB+QAhHgyVAgsgAEEANgIAIB4gImtBBmohAUEYIR4MpAELAkAgASIeIAJHDQBB+gAhHgyUAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQZezgIAAai0AAEcNpgEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQfoAIR4MlAILIABBADYCACAeICJrQQNqIQFBFyEeDKMBCwJAIAEiHiACRw0AQfsAIR4MkwILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGas4CAAGotAABHDaUBIAFBBkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEH7ACEeDJMCCyAAQQA2AgAgHiAia0EHaiEBQRUhHgyiAQsCQCABIh4gAkcNAEH8ACEeDJICCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBobOAgABqLQAARw2kASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBB/AAhHgySAgsgAEEANgIAIB4gImtBBmohAUEeIR4MoQELAkAgASIIIAJHDQBB/QAhHgyRAgsgCC0AAEHMAEcNogEgCEEBaiEBQQohHgygAQsCQCABIgggAkcNAEH+ACEeDJACCwJAAkAgCC0AAEG/f2oODwCjAaMBowGjAaMBowGjAaMBowGjAaMBowGjAQGjAQsgCEEBaiEBQewAIR4MgAILIAhBAWohAUHtACEeDP8BCwJAIAEiCCACRw0AQf8AIR4MjwILAkACQCAILQAAQb9/ag4DAKIBAaIBCyAIQQFqIQFB6wAhHgz/AQsgCEEBaiEBQe4AIR4M/gELAkAgASIeIAJHDQBBgAEhHgyOAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQaezgIAAai0AAEcNoAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYABIR4MjgILIABBADYCACAeICJrQQJqIQFBCyEeDJ0BCwJAIAEiCCACRw0AQYEBIR4MjQILAkACQAJAAkAgCC0AAEFTag4jAKIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogGiAaIBogEBogGiAaIBogGiAQKiAaIBogEDogELIAhBAWohAUHpACEeDP8BCyAIQQFqIQFB6gAhHgz+AQsgCEEBaiEBQe8AIR4M/QELIAhBAWohAUHwACEeDPwBCwJAIAEiHiACRw0AQYIBIR4MjAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUGps4CAAGotAABHDZ4BIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGCASEeDIwCCyAAQQA2AgAgHiAia0EFaiEBQRkhHgybAQsCQCABIiIgAkcNAEGDASEeDIsCCyACICJrIAAoAgAiJmohHiAiIQggJiEBAkADQCAILQAAIAFBrrOAgABqLQAARw2dASABQQVGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAIB42AgBBgwEhHgyLAgsgAEEANgIAQQYhHiAiICZrQQZqIQEMmgELAkAgASIeIAJHDQBBhAEhHgyKAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbSzgIAAai0AAEcNnAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYQBIR4MigILIABBADYCACAeICJrQQJqIQFBHCEeDJkBCwJAIAEiHiACRw0AQYUBIR4MiQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUG2s4CAAGotAABHDZsBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGFASEeDIkCCyAAQQA2AgAgHiAia0ECaiEBQSchHgyYAQsCQCABIgggAkcNAEGGASEeDIgCCwJAAkAgCC0AAEGsf2oOAgABmwELIAhBAWohAUH0ACEeDPgBCyAIQQFqIQFB9QAhHgz3AQsCQCABIh4gAkcNAEGHASEeDIcCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBuLOAgABqLQAARw2ZASABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBhwEhHgyHAgsgAEEANgIAIB4gImtBAmohAUEmIR4MlgELAkAgASIeIAJHDQBBiAEhHgyGAgsgAiAeayAAKAIAIiJqISYgHiEIICIhAQJAA0AgCC0AACABQbqzgIAAai0AAEcNmAEgAUEBRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAmNgIAQYgBIR4MhgILIABBADYCACAeICJrQQJqIQFBAyEeDJUBCwJAIAEiHiACRw0AQYkBIR4MhQILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHts4CAAGotAABHDZcBIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGJASEeDIUCCyAAQQA2AgAgHiAia0EDaiEBQQwhHgyUAQsCQCABIh4gAkcNAEGKASEeDIQCCyACIB5rIAAoAgAiImohJiAeIQggIiEBAkADQCAILQAAIAFBvLOAgABqLQAARw2WASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICY2AgBBigEhHgyEAgsgAEEANgIAIB4gImtBBGohAUENIR4MkwELAkAgASIIIAJHDQBBiwEhHgyDAgsCQAJAIAgtAABBun9qDgsAlgGWAZYBlgGWAZYBlgGWAZYBAZYBCyAIQQFqIQFB+QAhHgzzAQsgCEEBaiEBQfoAIR4M8gELAkAgASIIIAJHDQBBjAEhHgyCAgsgCC0AAEHQAEcNkwEgCEEBaiEBDMQBCwJAIAEiCCACRw0AQY0BIR4MgQILAkACQCAILQAAQbd/ag4HAZQBlAGUAZQBlAEAlAELIAhBAWohAUH8ACEeDPEBCyAIQQFqIQFBIiEeDJABCwJAIAEiHiACRw0AQY4BIR4MgAILIAIgHmsgACgCACIiaiEmIB4hCCAiIQECQANAIAgtAAAgAUHAs4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgJjYCAEGOASEeDIACCyAAQQA2AgAgHiAia0ECaiEBQR0hHgyPAQsCQCABIgggAkcNAEGPASEeDP8BCwJAAkAgCC0AAEGuf2oOAwCSAQGSAQsgCEEBaiEBQf4AIR4M7wELIAhBAWohAUEEIR4MjgELAkAgASIIIAJHDQBBkAEhHgz+AQsCQAJAAkACQAJAIAgtAABBv39qDhUAlAGUAZQBlAGUAZQBlAGUAZQBlAEBlAGUAQKUAZQBA5QBlAEElAELIAhBAWohAUH2ACEeDPEBCyAIQQFqIQFB9wAhHgzwAQsgCEEBaiEBQfgAIR4M7wELIAhBAWohAUH9ACEeDO4BCyAIQQFqIQFB/wAhHgztAQsCQCAEIAJHDQBBkQEhHgz9AQsgAiAEayAAKAIAIh5qISIgBCEIIB4hAQJAA0AgCC0AACABQe2zgIAAai0AAEcNjwEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZEBIR4M/QELIABBADYCACAEIB5rQQNqIQFBESEeDIwBCwJAIAUgAkcNAEGSASEeDPwBCyACIAVrIAAoAgAiHmohIiAFIQggHiEBAkADQCAILQAAIAFBwrOAgABqLQAARw2OASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBkgEhHgz8AQsgAEEANgIAIAUgHmtBA2ohAUEsIR4MiwELAkAgBiACRw0AQZMBIR4M+wELIAIgBmsgACgCACIeaiEiIAYhCCAeIQECQANAIAgtAAAgAUHFs4CAAGotAABHDY0BIAFBBEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGTASEeDPsBCyAAQQA2AgAgBiAea0EFaiEBQSshHgyKAQsCQCAHIAJHDQBBlAEhHgz6AQsgAiAHayAAKAIAIh5qISIgByEIIB4hAQJAA0AgCC0AACABQcqzgIAAai0AAEcNjAEgAUECRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZQBIR4M+gELIABBADYCACAHIB5rQQNqIQFBFCEeDIkBCwJAIAggAkcNAEGVASEeDPkBCwJAAkACQAJAIAgtAABBvn9qDg8AAQKOAY4BjgGOAY4BjgGOAY4BjgGOAY4BA44BCyAIQQFqIQRBgQEhHgzrAQsgCEEBaiEFQYIBIR4M6gELIAhBAWohBkGDASEeDOkBCyAIQQFqIQdBhAEhHgzoAQsCQCAIIAJHDQBBlgEhHgz4AQsgCC0AAEHFAEcNiQEgCEEBaiEIDLsBCwJAIAkgAkcNAEGXASEeDPcBCyACIAlrIAAoAgAiHmohIiAJIQggHiEBAkADQCAILQAAIAFBzbOAgABqLQAARw2JASABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBlwEhHgz3AQsgAEEANgIAIAkgHmtBA2ohAUEOIR4MhgELAkAgCCACRw0AQZgBIR4M9gELIAgtAABB0ABHDYcBIAhBAWohAUElIR4MhQELAkAgCiACRw0AQZkBIR4M9QELIAIgCmsgACgCACIeaiEiIAohCCAeIQECQANAIAgtAAAgAUHQs4CAAGotAABHDYcBIAFBCEYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGZASEeDPUBCyAAQQA2AgAgCiAea0EJaiEBQSohHgyEAQsCQCAIIAJHDQBBmgEhHgz0AQsCQAJAIAgtAABBq39qDgsAhwGHAYcBhwGHAYcBhwGHAYcBAYcBCyAIQQFqIQhBiAEhHgzkAQsgCEEBaiEKQYkBIR4M4wELAkAgCCACRw0AQZsBIR4M8wELAkACQCAILQAAQb9/ag4UAIYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAYYBhgGGAQGGAQsgCEEBaiEJQYcBIR4M4wELIAhBAWohCEGKASEeDOIBCwJAIAsgAkcNAEGcASEeDPIBCyACIAtrIAAoAgAiHmohIiALIQggHiEBAkADQCAILQAAIAFB2bOAgABqLQAARw2EASABQQNGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBnAEhHgzyAQsgAEEANgIAIAsgHmtBBGohAUEhIR4MgQELAkAgDCACRw0AQZ0BIR4M8QELIAIgDGsgACgCACIeaiEiIAwhCCAeIQECQANAIAgtAAAgAUHds4CAAGotAABHDYMBIAFBBkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGdASEeDPEBCyAAQQA2AgAgDCAea0EHaiEBQRohHgyAAQsCQCAIIAJHDQBBngEhHgzwAQsCQAJAAkAgCC0AAEG7f2oOEQCEAYQBhAGEAYQBhAGEAYQBhAEBhAGEAYQBhAGEAQKEAQsgCEEBaiEIQYsBIR4M4QELIAhBAWohC0GMASEeDOABCyAIQQFqIQxBjQEhHgzfAQsCQCANIAJHDQBBnwEhHgzvAQsgAiANayAAKAIAIh5qISIgDSEIIB4hAQJAA0AgCC0AACABQeSzgIAAai0AAEcNgQEgAUEFRg0BIAFBAWohASAIQQFqIgggAkcNAAsgACAiNgIAQZ8BIR4M7wELIABBADYCACANIB5rQQZqIQFBKCEeDH4LAkAgDiACRw0AQaABIR4M7gELIAIgDmsgACgCACIeaiEiIA4hCCAeIQECQANAIAgtAAAgAUHqs4CAAGotAABHDYABIAFBAkYNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGgASEeDO4BCyAAQQA2AgAgDiAea0EDaiEBQQchHgx9CwJAIAggAkcNAEGhASEeDO0BCwJAAkAgCC0AAEG7f2oODgCAAYABgAGAAYABgAGAAYABgAGAAYABgAEBgAELIAhBAWohDUGPASEeDN0BCyAIQQFqIQ5BkAEhHgzcAQsCQCAPIAJHDQBBogEhHgzsAQsgAiAPayAAKAIAIh5qISIgDyEIIB4hAQJAA0AgCC0AACABQe2zgIAAai0AAEcNfiABQQJGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBogEhHgzsAQsgAEEANgIAIA8gHmtBA2ohAUESIR4MewsCQCAQIAJHDQBBowEhHgzrAQsgAiAQayAAKAIAIh5qISIgECEIIB4hAQJAA0AgCC0AACABQfCzgIAAai0AAEcNfSABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBowEhHgzrAQsgAEEANgIAIBAgHmtBAmohAUEgIR4MegsCQCARIAJHDQBBpAEhHgzqAQsgAiARayAAKAIAIh5qISIgESEIIB4hAQJAA0AgCC0AACABQfKzgIAAai0AAEcNfCABQQFGDQEgAUEBaiEBIAhBAWoiCCACRw0ACyAAICI2AgBBpAEhHgzqAQsgAEEANgIAIBEgHmtBAmohAUEPIR4MeQsCQCAIIAJHDQBBpQEhHgzpAQsCQAJAIAgtAABBt39qDgcAfHx8fHwBfAsgCEEBaiEQQZMBIR4M2QELIAhBAWohEUGUASEeDNgBCwJAIBIgAkcNAEGmASEeDOgBCyACIBJrIAAoAgAiHmohIiASIQggHiEBAkADQCAILQAAIAFB9LOAgABqLQAARw16IAFBB0YNASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEGmASEeDOgBCyAAQQA2AgAgEiAea0EIaiEBQRshHgx3CwJAIAggAkcNAEGnASEeDOcBCwJAAkACQCAILQAAQb5/ag4SAHt7e3t7e3t7ewF7e3t7e3sCewsgCEEBaiEPQZIBIR4M2AELIAhBAWohCEGVASEeDNcBCyAIQQFqIRJBlgEhHgzWAQsCQCAIIAJHDQBBqAEhHgzmAQsgCC0AAEHOAEcNdyAIQQFqIQgMqgELAkAgCCACRw0AQakBIR4M5QELAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCC0AAEG/f2oOFQABAgOGAQQFBoYBhgGGAQcICQoLhgEMDQ4PhgELIAhBAWohAUHWACEeDOMBCyAIQQFqIQFB1wAhHgziAQsgCEEBaiEBQdwAIR4M4QELIAhBAWohAUHgACEeDOABCyAIQQFqIQFB4QAhHgzfAQsgCEEBaiEBQeQAIR4M3gELIAhBAWohAUHlACEeDN0BCyAIQQFqIQFB6AAhHgzcAQsgCEEBaiEBQfEAIR4M2wELIAhBAWohAUHyACEeDNoBCyAIQQFqIQFB8wAhHgzZAQsgCEEBaiEBQYABIR4M2AELIAhBAWohCEGGASEeDNcBCyAIQQFqIQhBjgEhHgzWAQsgCEEBaiEIQZEBIR4M1QELIAhBAWohCEGYASEeDNQBCwJAIBQgAkcNAEGrASEeDOQBCyAUQQFqIRMMdwsDQAJAIB4tAABBdmoOBHcAAHoACyAeQQFqIh4gAkcNAAtBrAEhHgziAQsCQCAVIAJGDQAgAEGNgICAADYCCCAAIBU2AgQgFSEBQQEhHgzSAQtBrQEhHgzhAQsCQCAVIAJHDQBBrgEhHgzhAQsCQAJAIBUtAABBdmoOBAGrAasBAKsBCyAVQQFqIRQMeAsgFUEBaiETDHQLIAAgEyACEKeAgIAAGiATIQEMRQsCQCAVIAJHDQBBrwEhHgzfAQsCQAJAIBUtAABBdmoOFwF5eQF5eXl5eXl5eXl5eXl5eXl5eXkAeQsgFUEBaiEVC0GcASEeDM4BCwJAIBYgAkcNAEGxASEeDN4BCyAWLQAAQSBHDXcgAEEAOwEyIBZBAWohAUGgASEeDM0BCyABISYCQANAICYiFSACRg0BIBUtAABBUGpB/wFxIh5BCk8NqAECQCAALwEyIiJBmTNLDQAgACAiQQpsIiI7ATIgHkH//wNzICJB/v8DcUkNACAVQQFqISYgACAiIB5qIh47ATIgHkH//wNxQegHSQ0BCwtBACEeIABBADYCHCAAQZ2JgIAANgIQIABBDTYCDCAAIBVBAWo2AhQM3QELQbABIR4M3AELAkAgFyACRw0AQbIBIR4M3AELQQAhHgJAAkACQAJAAkACQAJAAkAgFy0AAEFQag4Kf34AAQIDBAUGB4ABC0ECIR4MfgtBAyEeDH0LQQQhHgx8C0EFIR4MewtBBiEeDHoLQQchHgx5C0EIIR4MeAtBCSEeDHcLAkAgGCACRw0AQbMBIR4M2wELIBgtAABBLkcNeCAYQQFqIRcMpgELAkAgGSACRw0AQbQBIR4M2gELQQAhHgJAAkACQAJAAkACQAJAAkAgGS0AAEFQag4KgQGAAQABAgMEBQYHggELQQIhHgyAAQtBAyEeDH8LQQQhHgx+C0EFIR4MfQtBBiEeDHwLQQchHgx7C0EIIR4MegtBCSEeDHkLAkAgCCACRw0AQbUBIR4M2QELIAIgCGsgACgCACIiaiEmIAghGSAiIR4DQCAZLQAAIB5B/LOAgABqLQAARw17IB5BBEYNtAEgHkEBaiEeIBlBAWoiGSACRw0ACyAAICY2AgBBtQEhHgzYAQsCQCAaIAJHDQBBtgEhHgzYAQsgAiAaayAAKAIAIh5qISIgGiEIIB4hAQNAIAgtAAAgAUGBtICAAGotAABHDXsgAUEBRg22ASABQQFqIQEgCEEBaiIIIAJHDQALIAAgIjYCAEG2ASEeDNcBCwJAIBsgAkcNAEG3ASEeDNcBCyACIBtrIAAoAgAiGWohIiAbIQggGSEeA0AgCC0AACAeQYO0gIAAai0AAEcNeiAeQQJGDXwgHkEBaiEeIAhBAWoiCCACRw0ACyAAICI2AgBBtwEhHgzWAQsCQCAIIAJHDQBBuAEhHgzWAQsCQAJAIAgtAABBu39qDhAAe3t7e3t7e3t7e3t7e3sBewsgCEEBaiEaQaUBIR4MxgELIAhBAWohG0GmASEeDMUBCwJAIAggAkcNAEG5ASEeDNUBCyAILQAAQcgARw14IAhBAWohCAyiAQsCQCAIIAJHDQBBugEhHgzUAQsgCC0AAEHIAEYNogEgAEEBOgAoDJkBCwNAAkAgCC0AAEF2ag4EAHp6AHoLIAhBAWoiCCACRw0AC0G8ASEeDNIBCyAAQQA6AC8gAC0ALUEEcUUNyAELIABBADoALyABIQEMeQsgHkEVRg2pASAAQQA2AhwgACABNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhHgzPAQsCQCAAIB4gAhCtgICAACIBDQAgHiEBDMUBCwJAIAFBFUcNACAAQQM2AhwgACAeNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgzPAQsgAEEANgIcIAAgHjYCFCAAQauMgIAANgIQIABBEjYCDEEAIR4MzgELIB5BFUYNpQEgAEEANgIcIAAgATYCFCAAQYiMgIAANgIQIABBFDYCDEEAIR4MzQELIAAoAgQhJiAAQQA2AgQgHiAfp2oiIyEBIAAgJiAeICMgIhsiHhCugICAACIiRQ16IABBBzYCHCAAIB42AhQgACAiNgIMQQAhHgzMAQsgACAALwEwQYABcjsBMCABIQEMMQsgHkEVRg2hASAAQQA2AhwgACABNgIUIABBxYuAgAA2AhAgAEETNgIMQQAhHgzKAQsgAEEANgIcIAAgATYCFCAAQYuLgIAANgIQIABBAjYCDEEAIR4MyQELIB5BO0cNASABQQFqIQELQQghHgy3AQtBACEeIABBADYCHCAAIAE2AhQgAEGjkICAADYCECAAQQw2AgwMxgELQgEhHwsgHkEBaiEBAkAgACkDICIgQv//////////D1YNACAAICBCBIYgH4Q3AyAgASEBDHcLIABBADYCHCAAIAE2AhQgAEGJiYCAADYCECAAQQw2AgxBACEeDMQBCyAAQQA2AhwgACAeNgIUIABBo5CAgAA2AhAgAEEMNgIMQQAhHgzDAQsgACgCBCEmIABBADYCBCAeIB+naiIjIQEgACAmIB4gIyAiGyIeEK6AgIAAIiJFDW4gAEEFNgIcIAAgHjYCFCAAICI2AgxBACEeDMIBCyAAQQA2AhwgACAeNgIUIABB3ZSAgAA2AhAgAEEPNgIMQQAhHgzBAQsgACAeIAIQrYCAgAAiAQ0BIB4hAQtBDyEeDK8BCwJAIAFBFUcNACAAQQI2AhwgACAeNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgy/AQsgAEEANgIcIAAgHjYCFCAAQauMgIAANgIQIABBEjYCDEEAIR4MvgELIAFBAWohHgJAIAAvATAiAUGAAXFFDQACQCAAIB4gAhCwgICAACIBDQAgHiEBDGsLIAFBFUcNlwEgAEEFNgIcIAAgHjYCFCAAQb6SgIAANgIQIABBFTYCDEEAIR4MvgELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIB42AhQgAEHsj4CAADYCECAAQQQ2AgxBACEeDL4BCyAAIB4gAhCxgICAABogHiEBAkACQAJAAkACQCAAIB4gAhCsgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAeIQELQR0hHgyvAQsgAEEVNgIcIAAgHjYCFCAAQeGRgIAANgIQIABBFTYCDEEAIR4MvgELIABBADYCHCAAIB42AhQgAEGxi4CAADYCECAAQRE2AgxBACEeDL0BCyAALQAtQQFxRQ0BQaoBIR4MrAELAkAgHCACRg0AA0ACQCAcLQAAQSBGDQAgHCEBDKgBCyAcQQFqIhwgAkcNAAtBFyEeDLwBC0EXIR4MuwELIAAoAgQhASAAQQA2AgQgACABIBwQqICAgAAiAUUNkAEgAEEYNgIcIAAgATYCDCAAIBxBAWo2AhRBACEeDLoBCyAAQRk2AhwgACABNgIUIAAgHjYCDEEAIR4MuQELIB4hAUEBISICQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhIgwBC0EEISILIABBAToALCAAIAAvATAgInI7ATALIB4hAQtBICEeDKkBCyAAQQA2AhwgACAeNgIUIABBgY+AgAA2AhAgAEELNgIMQQAhHgy4AQsgHiEBQQEhIgJAAkACQAJAAkAgAC0ALEF7ag4EAgABAwULQQIhIgwBC0EEISILIABBAToALCAAIAAvATAgInI7ATAMAQsgACAALwEwQQhyOwEwCyAeIQELQasBIR4MpgELIAAgASACEKuAgIAAGgwbCwJAIAEiHiACRg0AIB4hAQJAAkAgHi0AAEF2ag4EAWpqAGoLIB5BAWohAQtBHiEeDKUBC0HDACEeDLQBCyAAQQA2AhwgACABNgIUIABBkZGAgAA2AhAgAEEDNgIMQQAhHgyzAQsCQCABLQAAQQ1HDQAgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABQQFqIQEMaQsgAEEeNgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDLMBCyABIQEgAC0ALUEBcUUNrgFBrQEhHgyiAQsCQCABIgEgAkcNAEEfIR4MsgELAkACQANAAkAgAS0AAEF2ag4EAgAAAwALIAFBAWoiASACRw0AC0EfIR4MswELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCqgICAACIeDQAgASEBDGgLIABBHjYCHCAAIAE2AhQgACAeNgIMQQAhHgyyAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKqAgIAAIh4NACABQQFqIQEMZwsgAEEeNgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDLEBCyAeQSxHDQEgAUEBaiEeQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIB4hAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIB4hAQwBCyAAIAAvATBBCHI7ATAgHiEBC0EuIR4MnwELIABBADoALCABIQELQSkhHgydAQsgAEEANgIAICMgJGtBCWohAUEFIR4MmAELIABBADYCACAjICRrQQZqIQFBByEeDJcBCyAAIAAvATBBIHI7ATAgASEBDAILIAAoAgQhCCAAQQA2AgQCQCAAIAggARCqgICAACIIDQAgASEBDJ0BCyAAQSo2AhwgACABNgIUIAAgCDYCDEEAIR4MqQELIABBCDoALCABIQELQSUhHgyXAQsCQCAALQAoQQFGDQAgASEBDAQLIAAtAC1BCHFFDXggASEBDAMLIAAtADBBIHENeUGuASEeDJUBCwJAIB0gAkYNAAJAA0ACQCAdLQAAQVBqIgFB/wFxQQpJDQAgHSEBQSohHgyYAQsgACkDICIfQpmz5syZs+bMGVYNASAAIB9CCn4iHzcDICAfIAGtIiBCf4VCgH6EVg0BIAAgHyAgQv8Bg3w3AyAgHUEBaiIdIAJHDQALQSwhHgymAQsgACgCBCEIIABBADYCBCAAIAggHUEBaiIBEKqAgIAAIggNeiABIQEMmQELQSwhHgykAQsCQCAALwEwIgFBCHFFDQAgAC0AKEEBRw0AIAAtAC1BCHFFDXULIAAgAUH3+wNxQYAEcjsBMCAdIQELQSwhHgySAQsgACAALwEwQRByOwEwDIcBCyAAQTY2AhwgACABNgIMIAAgHEEBajYCFEEAIR4MoAELIAEtAABBOkcNAiAAKAIEIR4gAEEANgIEIAAgHiABEKiAgIAAIh4NASABQQFqIQELQTEhHgyOAQsgAEE2NgIcIAAgHjYCDCAAIAFBAWo2AhRBACEeDJ0BCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhHgycAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIR4MiQELIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDFALIABBxAA2AhwgACABNgIUIAAgHjYCDEEAIR4MmAELIABBADYCHCAAICI2AhQgAEHlmICAADYCECAAQQc2AgwgAEEANgIAQQAhHgyXAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMTwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyWAQtBACEeIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMlQELQQEhHgsgACAeOgArIAFBAWohASAALQApQSJGDYsBDEwLIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEeDJIBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgyRAQtBASEeCyAAIB46ACogAUEBaiEBDEoLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEeDI4BCyAAQQA2AgAgJiAja0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxKCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhHgyNAQsgAEEANgIAC0EAIR4gAEEANgIcIAAgATYCFCAAQbmbgIAANgIQIABBCDYCDAyLAQsgAEEANgIAICYgI2tBA2ohAQJAIAAtAClBIUcNACABIQEMRwsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIR4MigELIABBADYCACAmICNrQQRqIQECQCAALQApIh5BXWpBC08NACABIQEMRgsCQCAeQQZLDQBBASAedEHKAHFFDQAgASEBDEYLQQAhHiAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMDIkBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxGCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIgBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDIcBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw/CyAAQcUANgIcIAAgATYCFCAAIB42AgxBACEeDIYBCyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQxDCyAAQdAANgIcIAAgATYCFCAAIB42AgxBACEeDIUBCyAAQQA2AhwgACABNgIUIABBooqAgAA2AhAgAEEHNgIMQQAhHgyEAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHEADYCHCAAIAE2AhQgACAeNgIMQQAhHgyDAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOwsgAEHFADYCHCAAIAE2AhQgACAeNgIMQQAhHgyCAQsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMPwsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgyBAQsgAEEANgIcIAAgATYCFCAAQbiIgIAANgIQIABBBzYCDEEAIR4MgAELIB5BP0cNASABQQFqIQELQQUhHgxuC0EAIR4gAEEANgIcIAAgATYCFCAAQdOPgIAANgIQIABBBzYCDAx9CyAAKAIEIR4gAEEANgIEAkAgACAeIAEQpICAgAAiHg0AIAEhAQw0CyAAQcQANgIcIAAgATYCFCAAIB42AgxBACEeDHwLIAAoAgQhHiAAQQA2AgQCQCAAIB4gARCkgICAACIeDQAgASEBDDQLIABBxQA2AhwgACABNgIUIAAgHjYCDEEAIR4MewsgACgCBCEeIABBADYCBAJAIAAgHiABEKSAgIAAIh4NACABIQEMOAsgAEHQADYCHCAAIAE2AhQgACAeNgIMQQAhHgx6CyAAKAIEIQEgAEEANgIEAkAgACABICIQpICAgAAiAQ0AICIhAQwxCyAAQcQANgIcIAAgIjYCFCAAIAE2AgxBACEeDHkLIAAoAgQhASAAQQA2AgQCQCAAIAEgIhCkgICAACIBDQAgIiEBDDELIABBxQA2AhwgACAiNgIUIAAgATYCDEEAIR4MeAsgACgCBCEBIABBADYCBAJAIAAgASAiEKSAgIAAIgENACAiIQEMNQsgAEHQADYCHCAAICI2AhQgACABNgIMQQAhHgx3CyAAQQA2AhwgACAiNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx2CyAAQQA2AhwgACABNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhHgx1C0EAIR4gAEEANgIcIAAgIjYCFCAAQb+UgIAANgIQIABBBzYCDAx0CyAAQQA2AhwgACAiNgIUIABBv5SAgAA2AhAgAEEHNgIMQQAhHgxzCyAAQQA2AhwgACAiNgIUIABB1I6AgAA2AhAgAEEHNgIMQQAhHgxyCyAAQQA2AhwgACABNgIUIABBwZOAgAA2AhAgAEEGNgIMQQAhHgxxCyAAQQA2AgAgIiAma0EGaiEBQSQhHgsgACAeOgApIAEhAQxOCyAAQQA2AgALQQAhHiAAQQA2AhwgACAINgIUIABBpJSAgAA2AhAgAEEGNgIMDG0LIAAoAgQhEyAAQQA2AgQgACATIB4QpoCAgAAiEw0BIB5BAWohEwtBnQEhHgxbCyAAQaoBNgIcIAAgEzYCDCAAIB5BAWo2AhRBACEeDGoLIAAoAgQhFCAAQQA2AgQgACAUIB4QpoCAgAAiFA0BIB5BAWohFAtBmgEhHgxYCyAAQasBNgIcIAAgFDYCDCAAIB5BAWo2AhRBACEeDGcLIABBADYCHCAAIBU2AhQgAEHzioCAADYCECAAQQ02AgxBACEeDGYLIABBADYCHCAAIBY2AhQgAEHOjYCAADYCECAAQQk2AgxBACEeDGULQQEhHgsgACAeOgArIBdBAWohFgwuCyAAQQA2AhwgACAXNgIUIABBoo2AgAA2AhAgAEEJNgIMQQAhHgxiCyAAQQA2AhwgACAYNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhHgxhC0EBIR4LIAAgHjoAKiAZQQFqIRgMLAsgAEEANgIcIAAgGTYCFCAAQbiNgIAANgIQIABBCTYCDEEAIR4MXgsgAEEANgIcIAAgGTYCFCAAQbmbgIAANgIQIABBCDYCDCAAQQA2AgBBACEeDF0LIABBADYCAAtBACEeIABBADYCHCAAIAg2AhQgAEGLlICAADYCECAAQQg2AgwMWwsgAEECOgAoIABBADYCACAbIBlrQQNqIRkMNgsgAEECOgAvIAAgCCACEKOAgIAAIh4NAUGvASEeDEkLIAAtAChBf2oOAh4gHwsgHkEVRw0nIABBuwE2AhwgACAINgIUIABBp5KAgAA2AhAgAEEVNgIMQQAhHgxXC0EAIR4MRgtBAiEeDEULQQ4hHgxEC0EQIR4MQwtBHCEeDEILQRQhHgxBC0EWIR4MQAtBFyEeDD8LQRkhHgw+C0EaIR4MPQtBOiEeDDwLQSMhHgw7C0EkIR4MOgtBMCEeDDkLQTshHgw4C0E8IR4MNwtBPiEeDDYLQT8hHgw1C0HAACEeDDQLQcEAIR4MMwtBxQAhHgwyC0HHACEeDDELQcgAIR4MMAtBygAhHgwvC0HfACEeDC4LQeIAIR4MLQtB+wAhHgwsC0GFASEeDCsLQZcBIR4MKgtBmQEhHgwpC0GpASEeDCgLQaQBIR4MJwtBmwEhHgwmC0GeASEeDCULQZ8BIR4MJAtBoQEhHgwjC0GiASEeDCILQacBIR4MIQtBqAEhHgwgCyAAQQA2AhwgACAINgIUIABB5ouAgAA2AhAgAEEQNgIMQQAhHgwvCyAAQQA2AgQgACAdIB0QqoCAgAAiAUUNASAAQS02AhwgACABNgIMIAAgHUEBajYCFEEAIR4MLgsgACgCBCEIIABBADYCBAJAIAAgCCABEKqAgIAAIghFDQAgAEEuNgIcIAAgCDYCDCAAIAFBAWo2AhRBACEeDC4LIAFBAWohAQweCyAdQQFqIQEMHgsgAEEANgIcIAAgHTYCFCAAQbqPgIAANgIQIABBBDYCDEEAIR4MKwsgAEEpNgIcIAAgATYCFCAAIAg2AgxBACEeDCoLIBxBAWohAQweCyAAQQo2AhwgACABNgIUIABBkZKAgAA2AhAgAEEVNgIMQQAhHgwoCyAAQRA2AhwgACABNgIUIABBvpKAgAA2AhAgAEEVNgIMQQAhHgwnCyAAQQA2AhwgACAeNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhHgwmCyAAQQQ2AhwgACABNgIUIABB1pKAgAA2AhAgAEEVNgIMQQAhHgwlCyAAQQA2AgAgCCAia0EFaiEZC0GjASEeDBMLIABBADYCACAiICZrQQJqIQFB4wAhHgwSCyAAQQA2AgAgAEGBBDsBKCAaIB5rQQJqIQELQdMAIR4MEAsgASEBAkAgAC0AKUEFRw0AQdIAIR4MEAtB0QAhHgwPC0EAIR4gAEEANgIcIABBuo6AgAA2AhAgAEEHNgIMIAAgIkEBajYCFAweCyAAQQA2AgAgJiAja0ECaiEBQTQhHgwNCyABIQELQS0hHgwLCwJAIAEiHSACRg0AA0ACQCAdLQAAQYCigIAAai0AACIBQQFGDQAgAUECRw0DIB1BAWohAQwECyAdQQFqIh0gAkcNAAtBMSEeDBsLQTEhHgwaCyAAQQA6ACwgHSEBDAELQQwhHgwIC0EvIR4MBwsgAUEBaiEBQSIhHgwGC0EfIR4MBQsgAEEANgIAICMgJGtBBGohAUEGIR4LIAAgHjoALCABIQFBDSEeDAMLIABBADYCACAmICNrQQdqIQFBCyEeDAILIABBADYCAAsgAEEAOgAsIBwhAUEJIR4MAAsLQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA4LQQAhHiAAQQA2AhwgACABNgIUIABBuJGAgAA2AhAgAEEPNgIMDA0LQQAhHiAAQQA2AhwgACABNgIUIABBlo+AgAA2AhAgAEELNgIMDAwLQQAhHiAAQQA2AhwgACABNgIUIABB8YiAgAA2AhAgAEELNgIMDAsLQQAhHiAAQQA2AhwgACABNgIUIABBiI2AgAA2AhAgAEEKNgIMDAoLIABBAjYCHCAAIAE2AhQgAEHwkoCAADYCECAAQRY2AgxBACEeDAkLQQEhHgwIC0HGACEeIAEiASACRg0HIANBCGogACABIAJB2KaAgABBChC5gICAACADKAIMIQEgAygCCA4DAQcCAAsQv4CAgAAACyAAQQA2AhwgAEGJk4CAADYCECAAQRc2AgwgACABQQFqNgIUQQAhHgwFCyAAQQA2AhwgACABNgIUIABBnpOAgAA2AhAgAEEJNgIMQQAhHgwECwJAIAEiASACRw0AQSEhHgwECwJAIAEtAABBCkYNACAAQQA2AhwgACABNgIUIABB7oyAgAA2AhAgAEEKNgIMQQAhHgwECyAAKAIEIQggAEEANgIEIAAgCCABEKqAgIAAIggNASABQQFqIQELQQAhHiAAQQA2AhwgACABNgIUIABB6pCAgAA2AhAgAEEZNgIMDAILIABBIDYCHCAAIAg2AgwgACABQQFqNgIUQQAhHgwBCwJAIAEiASACRw0AQRQhHgwBCyAAQYmAgIAANgIIIAAgATYCBEETIR4LIANBEGokgICAgAAgHguvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKAKgtICAAA0AQQAQvoCAgABBgLiEgABrIgJB2QBJDQBBACEDAkBBACgC4LeAgAAiBA0AQQBCfzcC7LeAgABBAEKAgISAgIDAADcC5LeAgABBACABQQhqQXBxQdiq1aoFcyIENgLgt4CAAEEAQQA2AvS3gIAAQQBBADYCxLeAgAALQQAgAjYCzLeAgABBAEGAuISAADYCyLeAgABBAEGAuISAADYCmLSAgABBACAENgKstICAAEEAQX82Aqi0gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAtBgLiEgABBeEGAuISAAGtBD3FBAEGAuISAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAJBgLiEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKItICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBBuLSAgABqKAIAIgRBCGohAwJAAkAgBCgCCCICIABBsLSAgABqIgBHDQBBACAGQX4gBXdxNgKItICAAAwBCyAAIAI2AgggAiAANgIMCyAEIAVBA3QiBUEDcjYCBCAEIAVqQQRqIgQgBCgCAEEBcjYCAAwMCyACQQAoApC0gIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgVBA3QiAEG4tICAAGooAgAiBCgCCCIDIABBsLSAgABqIgBHDQBBACAGQX4gBXdxIgY2Aoi0gIAADAELIAAgAzYCCCADIAA2AgwLIARBCGohAyAEIAJBA3I2AgQgBCAFQQN0IgVqIAUgAmsiBTYCACAEIAJqIgAgBUEBcjYCBAJAIAdFDQAgB0EDdiIIQQN0QbC0gIAAaiECQQAoApy0gIAAIQQCQAJAIAZBASAIdCIIcQ0AQQAgBiAIcjYCiLSAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIIC0EAIAA2Apy0gIAAQQAgBTYCkLSAgAAMDAtBACgCjLSAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRBuLaAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNAEEAKAKYtICAACAAKAIIIgNLGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCjLSAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRBuLaAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0Qbi2gIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoApC0gIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AQQAoApi0gIAAIAgoAggiA0saIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoApC0gIAAIgMgAkkNAEEAKAKctICAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ApC0gIAAQQAgADYCnLSAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgAyAEakEEaiIDIAMoAgBBAXI2AgBBAEEANgKctICAAEEAQQA2ApC0gIAACyAEQQhqIQMMCgsCQEEAKAKUtICAACIAIAJNDQBBACgCoLSAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ApS0gIAAQQAgBDYCoLSAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgC4LeAgABFDQBBACgC6LeAgAAhBAwBC0EAQn83Auy3gIAAQQBCgICEgICAwAA3AuS3gIAAQQAgAUEMakFwcUHYqtWqBXM2AuC3gIAAQQBBADYC9LeAgABBAEEANgLEt4CAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYC+LeAgAAMCgsCQEEAKALAt4CAACIDRQ0AAkBBACgCuLeAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgL4t4CAAAwKC0EALQDEt4CAAEEEcQ0EAkACQAJAQQAoAqC0gIAAIgRFDQBByLeAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQvoCAgAAiAEF/Rg0FIAghBgJAQQAoAuS3gIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgCwLeAgAAiA0UNAEEAKAK4t4CAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQvoCAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEL6AgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAui3gIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBC+gICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxC+gICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALEt4CAAEEEcjYCxLeAgAALIAhB/v///wdLDQEgCBC+gICAACEAQQAQvoCAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKAK4t4CAACAGaiIDNgK4t4CAAAJAIANBACgCvLeAgABNDQBBACADNgK8t4CAAAsCQAJAAkACQEEAKAKgtICAACIERQ0AQci3gIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCmLSAgAAiA0UNACAAIANPDQELQQAgADYCmLSAgAALQQAhA0EAIAY2Asy3gIAAQQAgADYCyLeAgABBAEF/NgKotICAAEEAQQAoAuC3gIAANgKstICAAEEAQQA2AtS3gIAAA0AgA0HEtICAAGogA0G4tICAAGoiBDYCACAEIANBsLSAgABqIgU2AgAgA0G8tICAAGogBTYCACADQcy0gIAAaiADQcC0gIAAaiIFNgIAIAUgBDYCACADQdS0gIAAaiADQci0gIAAaiIENgIAIAQgBTYCACADQdC0gIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGIANrQUhqIgNBAXI2AgRBAEEAKALwt4CAADYCpLSAgABBACAENgKgtICAAEEAIAM2ApS0gIAAIAYgAGpBTGpBODYCAAwCCyADLQAMQQhxDQAgBSAESw0AIAAgBE0NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApS0gIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALwt4CAADYCpLSAgABBACAFNgKUtICAAEEAIAA2AqC0gIAAIAsgBGpBBGpBODYCAAwBCwJAIABBACgCmLSAgAAiC08NAEEAIAA2Api0gIAAIAAhCwsgACAGaiEIQci3gIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgCEYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByLeAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiBiACQQNyNgIEIAhBeCAIa0EPcUEAIAhBCGpBD3EbaiIIIAYgAmoiAmshBQJAIAQgCEcNAEEAIAI2AqC0gIAAQQBBACgClLSAgAAgBWoiAzYClLSAgAAgAiADQQFyNgIEDAMLAkBBACgCnLSAgAAgCEcNAEEAIAI2Apy0gIAAQQBBACgCkLSAgAAgBWoiAzYCkLSAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAgoAgQiA0EDcUEBRw0AIANBeHEhBwJAAkAgA0H/AUsNACAIKAIIIgQgA0EDdiILQQN0QbC0gIAAaiIARhoCQCAIKAIMIgMgBEcNAEEAQQAoAoi0gIAAQX4gC3dxNgKItICAAAwCCyADIABGGiADIAQ2AgggBCADNgIMDAELIAgoAhghCQJAAkAgCCgCDCIAIAhGDQAgCyAIKAIIIgNLGiAAIAM2AgggAyAANgIMDAELAkAgCEEUaiIDKAIAIgQNACAIQRBqIgMoAgAiBA0AQQAhAAwBCwNAIAMhCyAEIgBBFGoiAygCACIEDQAgAEEQaiEDIAAoAhAiBA0ACyALQQA2AgALIAlFDQACQAJAIAgoAhwiBEECdEG4toCAAGoiAygCACAIRw0AIAMgADYCACAADQFBAEEAKAKMtICAAEF+IAR3cTYCjLSAgAAMAgsgCUEQQRQgCSgCECAIRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgCCgCECIDRQ0AIAAgAzYCECADIAA2AhgLIAgoAhQiA0UNACAAQRRqIAM2AgAgAyAANgIYCyAHIAVqIQUgCCAHaiEICyAIIAgoAgRBfnE2AgQgAiAFaiAFNgIAIAIgBUEBcjYCBAJAIAVB/wFLDQAgBUEDdiIEQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIFQQEgBHQiBHENAEEAIAUgBHI2Aoi0gIAAIAMhBAwBCyADKAIIIQQLIAQgAjYCDCADIAI2AgggAiADNgIMIAIgBDYCCAwDC0EfIQMCQCAFQf///wdLDQAgBUEIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIAIABBgIAPakEQdkECcSIAdEEPdiADIARyIAByayIDQQF0IAUgA0EVanZBAXFyQRxqIQMLIAIgAzYCHCACQgA3AhAgA0ECdEG4toCAAGohBAJAQQAoAoy0gIAAIgBBASADdCIIcQ0AIAQgAjYCAEEAIAAgCHI2Aoy0gIAAIAIgBDYCGCACIAI2AgggAiACNgIMDAMLIAVBAEEZIANBAXZrIANBH0YbdCEDIAQoAgAhAANAIAAiBCgCBEF4cSAFRg0CIANBHXYhACADQQF0IQMgBCAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBDYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBiADa0FIaiIDQQFyNgIEIAhBTGpBODYCACAEIAVBNyAFa0EPcUEAIAVBSWpBD3EbakFBaiIIIAggBEEQakkbIghBIzYCBEEAQQAoAvC3gIAANgKktICAAEEAIAs2AqC0gIAAQQAgAzYClLSAgAAgCEEQakEAKQLQt4CAADcCACAIQQApAsi3gIAANwIIQQAgCEEIajYC0LeAgABBACAGNgLMt4CAAEEAIAA2Asi3gIAAQQBBADYC1LeAgAAgCEEkaiEDA0AgA0EHNgIAIAUgA0EEaiIDSw0ACyAIIARGDQMgCCAIKAIEQX5xNgIEIAggCCAEayIGNgIAIAQgBkEBcjYCBAJAIAZB/wFLDQAgBkEDdiIFQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIAQQEgBXQiBXENAEEAIAAgBXI2Aoi0gIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAGQf///wdLDQAgBkEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiADIAVyIAByayIDQQF0IAYgA0EVanZBAXFyQRxqIQMLIARCADcCECAEQRxqIAM2AgAgA0ECdEG4toCAAGohBQJAQQAoAoy0gIAAIgBBASADdCIIcQ0AIAUgBDYCAEEAIAAgCHI2Aoy0gIAAIARBGGogBTYCACAEIAQ2AgggBCAENgIMDAQLIAZBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAANAIAAiBSgCBEF4cSAGRg0DIANBHXYhACADQQF0IQMgBSAAQQRxakEQaiIIKAIAIgANAAsgCCAENgIAIARBGGogBTYCACAEIAQ2AgwgBCAENgIIDAMLIAQoAggiAyACNgIMIAQgAjYCCCACQQA2AhggAiAENgIMIAIgAzYCCAsgBkEIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQRhqQQA2AgAgBCAFNgIMIAQgAzYCCAtBACgClLSAgAAiAyACTQ0AQQAoAqC0gIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKUtICAAEEAIAU2AqC0gIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+LeAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG4toCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKMtICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgAyAIakEEaiIDIAMoAgBBAXI2AgAMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEEDdiIEQQN0QbC0gIAAaiEDAkACQEEAKAKItICAACIFQQEgBHQiBHENAEEAIAUgBHI2Aoi0gIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEG4toCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2Aoy0gIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEG4toCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCjLSAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAMgAGpBBGoiAyADKAIAQQFyNgIADAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBA3YiCEEDdEGwtICAAGohAkEAKAKctICAACEDAkACQEEBIAh0IgggBnENAEEAIAggBnI2Aoi0gIAAIAIhCAwBCyACKAIIIQgLIAggAzYCDCACIAM2AgggAyACNgIMIAMgCDYCCAtBACAFNgKctICAAEEAIAQ2ApC0gIAACyAAQQhqIQMLIAFBEGokgICAgAAgAwsKACAAEL2AgIAAC/ANAQd/AkAgAEUNACAAQXhqIgEgAEF8aigCACICQXhxIgBqIQMCQCACQQFxDQAgAkEDcUUNASABIAEoAgAiAmsiAUEAKAKYtICAACIESQ0BIAIgAGohAAJAQQAoApy0gIAAIAFGDQACQCACQf8BSw0AIAEoAggiBCACQQN2IgVBA3RBsLSAgABqIgZGGgJAIAEoAgwiAiAERw0AQQBBACgCiLSAgABBfiAFd3E2Aoi0gIAADAMLIAIgBkYaIAIgBDYCCCAEIAI2AgwMAgsgASgCGCEHAkACQCABKAIMIgYgAUYNACAEIAEoAggiAksaIAYgAjYCCCACIAY2AgwMAQsCQCABQRRqIgIoAgAiBA0AIAFBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAQJAAkAgASgCHCIEQQJ0Qbi2gIAAaiICKAIAIAFHDQAgAiAGNgIAIAYNAUEAQQAoAoy0gIAAQX4gBHdxNgKMtICAAAwDCyAHQRBBFCAHKAIQIAFGG2ogBjYCACAGRQ0CCyAGIAc2AhgCQCABKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgASgCFCICRQ0BIAZBFGogAjYCACACIAY2AhgMAQsgAygCBCICQQNxQQNHDQAgAyACQX5xNgIEQQAgADYCkLSAgAAgASAAaiAANgIAIAEgAEEBcjYCBA8LIAMgAU0NACADKAIEIgJBAXFFDQACQAJAIAJBAnENAAJAQQAoAqC0gIAAIANHDQBBACABNgKgtICAAEEAQQAoApS0gIAAIABqIgA2ApS0gIAAIAEgAEEBcjYCBCABQQAoApy0gIAARw0DQQBBADYCkLSAgABBAEEANgKctICAAA8LAkBBACgCnLSAgAAgA0cNAEEAIAE2Apy0gIAAQQBBACgCkLSAgAAgAGoiADYCkLSAgAAgASAAQQFyNgIEIAEgAGogADYCAA8LIAJBeHEgAGohAAJAAkAgAkH/AUsNACADKAIIIgQgAkEDdiIFQQN0QbC0gIAAaiIGRhoCQCADKAIMIgIgBEcNAEEAQQAoAoi0gIAAQX4gBXdxNgKItICAAAwCCyACIAZGGiACIAQ2AgggBCACNgIMDAELIAMoAhghBwJAAkAgAygCDCIGIANGDQBBACgCmLSAgAAgAygCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0AAkACQCADKAIcIgRBAnRBuLaAgABqIgIoAgAgA0cNACACIAY2AgAgBg0BQQBBACgCjLSAgABBfiAEd3E2Aoy0gIAADAILIAdBEEEUIAcoAhAgA0YbaiAGNgIAIAZFDQELIAYgBzYCGAJAIAMoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyADKAIUIgJFDQAgBkEUaiACNgIAIAIgBjYCGAsgASAAaiAANgIAIAEgAEEBcjYCBCABQQAoApy0gIAARw0BQQAgADYCkLSAgAAPCyADIAJBfnE2AgQgASAAaiAANgIAIAEgAEEBcjYCBAsCQCAAQf8BSw0AIABBA3YiAkEDdEGwtICAAGohAAJAAkBBACgCiLSAgAAiBEEBIAJ0IgJxDQBBACAEIAJyNgKItICAACAAIQIMAQsgACgCCCECCyACIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAFCADcCECABQRxqIAI2AgAgAkECdEG4toCAAGohBAJAAkBBACgCjLSAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjLSAgAAgAUEYaiAENgIAIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCqLSAgABBf2oiAUF/IAEbNgKotICAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Avi3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC44sAQBBgAgLhiwBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgQ1IgYWZ0ZXIgaGVhZGVyIHZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAEludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYCBoZWFkZXIgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AATUtBQ1RJVklUWQBDT1BZAE5PVElGWQBQTEFZAFBVVABDSEVDS09VVABQT1NUAFJFUE9SVABIUEVfSU5WQUxJRF9DT05TVEFOVABHRVQASFBFX1NUUklDVABSRURJUkVDVABDT05ORUNUAEhQRV9JTlZBTElEX1NUQVRVUwBPUFRJT05TAFNFVF9QQVJBTUVURVIAR0VUX1BBUkFNRVRFUgBIUEVfVVNFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAEhQRV9JTlZBTElEX1VSTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAEhQRV9PSwBVTkxJTksAVU5MT0NLAFBSSQBIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gASFBFX0lOVkFMSURfVFJBTlNGRVJfRU5DT0RJTkcARXhwZWN0ZWQgQ1JMRgBIUEVfSU5WQUxJRF9DSFVOS19TSVpFAE1PVkUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9NRVNTQUdFX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUAUEFVU0UAUFVSR0UATUVSR0UASFBFX1BBVVNFRF9VUEdSQURFAEhQRV9QQVVTRURfSDJfVVBHUkFERQBTT1VSQ0UAQU5OT1VOQ0UAVFJBQ0UAREVTQ1JJQkUAVU5TVUJTQ1JJQkUAUkVDT1JEAEhQRV9JTlZBTElEX01FVEhPRABQUk9QRklORABVTkJJTkQAUkVCSU5EAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQASFBFX1BBVVNFRABIRUFEAEV4cGVjdGVkIEhUVFAvANwLAADPCwAA0woAAJkNAAAQDAAAXQsAAF8NAAC1CwAAugoAAHMLAACcCwAA9QsAAHMMAADvCgAA3AwAAEcMAACHCwAAjwwAAL0MAAAvCwAApwwAAKkNAAAEDQAAFw0AACYLAACJDQAA1QwAAM8KAAC0DQAArgoAAKEKAADnCgAAAgsAAD0NAACQCgAA7AsAAMULAACKDAAAcg0AADQMAABADAAA6gsAAIQNAACCDQAAew0AAMsLAACzCgAAhQoAAKUKAAD+DAAAPgwAAJUKAABODQAATA0AADgMAAD4DAAAQwsAAOULAADjCwAALQ0AAPELAABDDQAANA0AAE4LAACcCgAA8gwAAFQLAAAYCwAACgsAAN4KAABYDQAALgwAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv'


/***/ }),

/***/ "../../node_modules/undici/lib/llhttp/utils.js":
/*!*****************************************************!*\
  !*** ../../node_modules/undici/lib/llhttp/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.enumToMap = void 0;
function enumToMap(obj) {
    const res = {};
    Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === 'number') {
            res[key] = value;
        }
    });
    return res;
}
exports.enumToMap = enumToMap;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-agent.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-agent.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kClients } = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const Agent = __webpack_require__(/*! ../agent */ "../../node_modules/undici/lib/agent.js")
const {
  kAgent,
  kMockAgentSet,
  kMockAgentGet,
  kDispatches,
  kIsMockActive,
  kNetConnect,
  kGetNetConnect,
  kOptions,
  kFactory
} = __webpack_require__(/*! ./mock-symbols */ "../../node_modules/undici/lib/mock/mock-symbols.js")
const MockClient = __webpack_require__(/*! ./mock-client */ "../../node_modules/undici/lib/mock/mock-client.js")
const MockPool = __webpack_require__(/*! ./mock-pool */ "../../node_modules/undici/lib/mock/mock-pool.js")
const { matchValue, buildMockOptions } = __webpack_require__(/*! ./mock-utils */ "../../node_modules/undici/lib/mock/mock-utils.js")
const { InvalidArgumentError, UndiciError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const Dispatcher = __webpack_require__(/*! ../dispatcher */ "../../node_modules/undici/lib/dispatcher.js")
const Pluralizer = __webpack_require__(/*! ./pluralizer */ "../../node_modules/undici/lib/mock/pluralizer.js")
const PendingInterceptorsFormatter = __webpack_require__(/*! ./pending-interceptors-formatter */ "../../node_modules/undici/lib/mock/pending-interceptors-formatter.js")

class FakeWeakRef {
  constructor (value) {
    this.value = value
  }

  deref () {
    return this.value
  }
}

class MockAgent extends Dispatcher {
  constructor (opts) {
    super(opts)

    this[kNetConnect] = true
    this[kIsMockActive] = true

    // Instantiate Agent and encapsulate
    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }
    const agent = opts && opts.agent ? opts.agent : new Agent(opts)
    this[kAgent] = agent

    this[kClients] = agent[kClients]
    this[kOptions] = buildMockOptions(opts)
  }

  get (origin) {
    let dispatcher = this[kMockAgentGet](origin)

    if (!dispatcher) {
      dispatcher = this[kFactory](origin)
      this[kMockAgentSet](origin, dispatcher)
    }
    return dispatcher
  }

  dispatch (opts, handler) {
    // Call MockAgent.get to perform additional setup before dispatching as normal
    this.get(opts.origin)
    return this[kAgent].dispatch(opts, handler)
  }

  async close () {
    await this[kAgent].close()
    this[kClients].clear()
  }

  deactivate () {
    this[kIsMockActive] = false
  }

  activate () {
    this[kIsMockActive] = true
  }

  enableNetConnect (matcher) {
    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {
      if (Array.isArray(this[kNetConnect])) {
        this[kNetConnect].push(matcher)
      } else {
        this[kNetConnect] = [matcher]
      }
    } else if (typeof matcher === 'undefined') {
      this[kNetConnect] = true
    } else {
      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')
    }
  }

  disableNetConnect () {
    this[kNetConnect] = false
  }

  // This is required to bypass issues caused by using global symbols - see:
  // https://github.com/nodejs/undici/issues/1447
  get isMockActive () {
    return this[kIsMockActive]
  }

  [kMockAgentSet] (origin, dispatcher) {
    this[kClients].set(origin, new FakeWeakRef(dispatcher))
  }

  [kFactory] (origin) {
    const mockOptions = Object.assign({ agent: this }, this[kOptions])
    return this[kOptions] && this[kOptions].connections === 1
      ? new MockClient(origin, mockOptions)
      : new MockPool(origin, mockOptions)
  }

  [kMockAgentGet] (origin) {
    // First check if we can immediately find it
    const ref = this[kClients].get(origin)
    if (ref) {
      return ref.deref()
    }

    // If the origin is not a string create a dummy parent pool and return to user
    if (typeof origin !== 'string') {
      const dispatcher = this[kFactory]('http://localhost:9999')
      this[kMockAgentSet](origin, dispatcher)
      return dispatcher
    }

    // If we match, create a pool and assign the same dispatches
    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
      const nonExplicitDispatcher = nonExplicitRef.deref()
      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {
        const dispatcher = this[kFactory](origin)
        this[kMockAgentSet](origin, dispatcher)
        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]
        return dispatcher
      }
    }
  }

  [kGetNetConnect] () {
    return this[kNetConnect]
  }

  pendingInterceptors () {
    const mockAgentClients = this[kClients]

    return Array.from(mockAgentClients.entries())
      .flatMap(([origin, scope]) => scope.deref()[kDispatches].map(dispatch => ({ ...dispatch, origin })))
      .filter(({ pending }) => pending)
  }

  assertNoPendingInterceptors ({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
    const pending = this.pendingInterceptors()

    if (pending.length === 0) {
      return
    }

    const pluralizer = new Pluralizer('interceptor', 'interceptors').pluralize(pending.length)

    throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim())
  }
}

module.exports = MockAgent


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-client.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-client.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { promisify } = __webpack_require__(/*! util */ "util")
const Client = __webpack_require__(/*! ../client */ "../../node_modules/undici/lib/client.js")
const { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ "../../node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kMockAgent,
  kClose,
  kOriginalClose,
  kOrigin,
  kOriginalDispatch,
  kConnected
} = __webpack_require__(/*! ./mock-symbols */ "../../node_modules/undici/lib/mock/mock-symbols.js")
const { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ "../../node_modules/undici/lib/mock/mock-interceptor.js")
const Symbols = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")

/**
 * MockClient provides an API that extends the Client to influence the mockDispatches.
 */
class MockClient extends Client {
  constructor (origin, opts) {
    super(origin, opts)

    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }

    this[kMockAgent] = opts.agent
    this[kOrigin] = origin
    this[kDispatches] = []
    this[kConnected] = 1
    this[kOriginalDispatch] = this.dispatch
    this[kOriginalClose] = this.close.bind(this)

    this.dispatch = buildMockDispatch.call(this)
    this.close = this[kClose]
  }

  get [Symbols.kConnected] () {
    return this[kConnected]
  }

  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept (opts) {
    return new MockInterceptor(opts, this[kDispatches])
  }

  async [kClose] () {
    await promisify(this[kOriginalClose])()
    this[kConnected] = 0
    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
  }
}

module.exports = MockClient


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-errors.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-errors.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { UndiciError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")

class MockNotMatchedError extends UndiciError {
  constructor (message) {
    super(message)
    Error.captureStackTrace(this, MockNotMatchedError)
    this.name = 'MockNotMatchedError'
    this.message = message || 'The request does not match any registered mock dispatches'
    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'
  }
}

module.exports = {
  MockNotMatchedError
}


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-interceptor.js":
/*!**************************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-interceptor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { getResponseData, buildKey, addMockDispatch } = __webpack_require__(/*! ./mock-utils */ "../../node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kDispatchKey,
  kDefaultHeaders,
  kDefaultTrailers,
  kContentLength,
  kMockDispatch
} = __webpack_require__(/*! ./mock-symbols */ "../../node_modules/undici/lib/mock/mock-symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")
const { buildURL } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")

/**
 * Defines the scope API for an interceptor reply
 */
class MockScope {
  constructor (mockDispatch) {
    this[kMockDispatch] = mockDispatch
  }

  /**
   * Delay a reply by a set amount in ms.
   */
  delay (waitInMs) {
    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {
      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')
    }

    this[kMockDispatch].delay = waitInMs
    return this
  }

  /**
   * For a defined reply, never mark as consumed.
   */
  persist () {
    this[kMockDispatch].persist = true
    return this
  }

  /**
   * Allow one to define a reply for a set amount of matching requests.
   */
  times (repeatTimes) {
    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')
    }

    this[kMockDispatch].times = repeatTimes
    return this
  }
}

/**
 * Defines an interceptor for a Mock
 */
class MockInterceptor {
  constructor (opts, mockDispatches) {
    if (typeof opts !== 'object') {
      throw new InvalidArgumentError('opts must be an object')
    }
    if (typeof opts.path === 'undefined') {
      throw new InvalidArgumentError('opts.path must be defined')
    }
    if (typeof opts.method === 'undefined') {
      opts.method = 'GET'
    }
    // See https://github.com/nodejs/undici/issues/1245
    // As per RFC 3986, clients are not supposed to send URI
    // fragments to servers when they retrieve a document,
    if (typeof opts.path === 'string') {
      if (opts.query) {
        opts.path = buildURL(opts.path, opts.query)
      } else {
        // Matches https://github.com/nodejs/undici/blob/main/lib/fetch/index.js#L1811
        const parsedURL = new URL(opts.path, 'data://')
        opts.path = parsedURL.pathname + parsedURL.search
      }
    }
    if (typeof opts.method === 'string') {
      opts.method = opts.method.toUpperCase()
    }

    this[kDispatchKey] = buildKey(opts)
    this[kDispatches] = mockDispatches
    this[kDefaultHeaders] = {}
    this[kDefaultTrailers] = {}
    this[kContentLength] = false
  }

  createMockScopeDispatchData (statusCode, data, responseOptions = {}) {
    const responseData = getResponseData(data)
    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}
    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }
    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }

    return { statusCode, data, headers, trailers }
  }

  validateReplyParameters (statusCode, data, responseOptions) {
    if (typeof statusCode === 'undefined') {
      throw new InvalidArgumentError('statusCode must be defined')
    }
    if (typeof data === 'undefined') {
      throw new InvalidArgumentError('data must be defined')
    }
    if (typeof responseOptions !== 'object') {
      throw new InvalidArgumentError('responseOptions must be an object')
    }
  }

  /**
   * Mock an undici request with a defined reply.
   */
  reply (replyData) {
    // Values of reply aren't available right now as they
    // can only be available when the reply callback is invoked.
    if (typeof replyData === 'function') {
      // We'll first wrap the provided callback in another function,
      // this function will properly resolve the data from the callback
      // when invoked.
      const wrappedDefaultsCallback = (opts) => {
        // Our reply options callback contains the parameter for statusCode, data and options.
        const resolvedData = replyData(opts)

        // Check if it is in the right format
        if (typeof resolvedData !== 'object') {
          throw new InvalidArgumentError('reply options callback must return an object')
        }

        const { statusCode, data = '', responseOptions = {} } = resolvedData
        this.validateReplyParameters(statusCode, data, responseOptions)
        // Since the values can be obtained immediately we return them
        // from this higher order function that will be resolved later.
        return {
          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)
        }
      }

      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.
      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)
      return new MockScope(newMockDispatch)
    }

    // We can have either one or three parameters, if we get here,
    // we should have 1-3 parameters. So we spread the arguments of
    // this function to obtain the parameters, since replyData will always
    // just be the statusCode.
    const [statusCode, data = '', responseOptions = {}] = [...arguments]
    this.validateReplyParameters(statusCode, data, responseOptions)

    // Send in-already provided data like usual
    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions)
    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)
    return new MockScope(newMockDispatch)
  }

  /**
   * Mock an undici request with a defined error.
   */
  replyWithError (error) {
    if (typeof error === 'undefined') {
      throw new InvalidArgumentError('error must be defined')
    }

    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })
    return new MockScope(newMockDispatch)
  }

  /**
   * Set default reply headers on the interceptor for subsequent replies
   */
  defaultReplyHeaders (headers) {
    if (typeof headers === 'undefined') {
      throw new InvalidArgumentError('headers must be defined')
    }

    this[kDefaultHeaders] = headers
    return this
  }

  /**
   * Set default reply trailers on the interceptor for subsequent replies
   */
  defaultReplyTrailers (trailers) {
    if (typeof trailers === 'undefined') {
      throw new InvalidArgumentError('trailers must be defined')
    }

    this[kDefaultTrailers] = trailers
    return this
  }

  /**
   * Set reply content length header for replies on the interceptor
   */
  replyContentLength () {
    this[kContentLength] = true
    return this
  }
}

module.exports.MockInterceptor = MockInterceptor
module.exports.MockScope = MockScope


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-pool.js":
/*!*******************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-pool.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { promisify } = __webpack_require__(/*! util */ "util")
const Pool = __webpack_require__(/*! ../pool */ "../../node_modules/undici/lib/pool.js")
const { buildMockDispatch } = __webpack_require__(/*! ./mock-utils */ "../../node_modules/undici/lib/mock/mock-utils.js")
const {
  kDispatches,
  kMockAgent,
  kClose,
  kOriginalClose,
  kOrigin,
  kOriginalDispatch,
  kConnected
} = __webpack_require__(/*! ./mock-symbols */ "../../node_modules/undici/lib/mock/mock-symbols.js")
const { MockInterceptor } = __webpack_require__(/*! ./mock-interceptor */ "../../node_modules/undici/lib/mock/mock-interceptor.js")
const Symbols = __webpack_require__(/*! ../core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const { InvalidArgumentError } = __webpack_require__(/*! ../core/errors */ "../../node_modules/undici/lib/core/errors.js")

/**
 * MockPool provides an API that extends the Pool to influence the mockDispatches.
 */
class MockPool extends Pool {
  constructor (origin, opts) {
    super(origin, opts)

    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {
      throw new InvalidArgumentError('Argument opts.agent must implement Agent')
    }

    this[kMockAgent] = opts.agent
    this[kOrigin] = origin
    this[kDispatches] = []
    this[kConnected] = 1
    this[kOriginalDispatch] = this.dispatch
    this[kOriginalClose] = this.close.bind(this)

    this.dispatch = buildMockDispatch.call(this)
    this.close = this[kClose]
  }

  get [Symbols.kConnected] () {
    return this[kConnected]
  }

  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept (opts) {
    return new MockInterceptor(opts, this[kDispatches])
  }

  async [kClose] () {
    await promisify(this[kOriginalClose])()
    this[kConnected] = 0
    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])
  }
}

module.exports = MockPool


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-symbols.js":
/*!**********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-symbols.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


module.exports = {
  kAgent: Symbol('agent'),
  kOptions: Symbol('options'),
  kFactory: Symbol('factory'),
  kDispatches: Symbol('dispatches'),
  kDispatchKey: Symbol('dispatch key'),
  kDefaultHeaders: Symbol('default headers'),
  kDefaultTrailers: Symbol('default trailers'),
  kContentLength: Symbol('content length'),
  kMockAgent: Symbol('mock agent'),
  kMockAgentSet: Symbol('mock agent set'),
  kMockAgentGet: Symbol('mock agent get'),
  kMockDispatch: Symbol('mock dispatch'),
  kClose: Symbol('close'),
  kOriginalClose: Symbol('original agent close'),
  kOrigin: Symbol('origin'),
  kIsMockActive: Symbol('is mock active'),
  kNetConnect: Symbol('net connect'),
  kGetNetConnect: Symbol('get net connect'),
  kConnected: Symbol('connected')
}


/***/ }),

/***/ "../../node_modules/undici/lib/mock/mock-utils.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/mock-utils.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { MockNotMatchedError } = __webpack_require__(/*! ./mock-errors */ "../../node_modules/undici/lib/mock/mock-errors.js")
const {
  kDispatches,
  kMockAgent,
  kOriginalDispatch,
  kOrigin,
  kGetNetConnect
} = __webpack_require__(/*! ./mock-symbols */ "../../node_modules/undici/lib/mock/mock-symbols.js")
const { buildURL, nop } = __webpack_require__(/*! ../core/util */ "../../node_modules/undici/lib/core/util.js")

function matchValue (match, value) {
  if (typeof match === 'string') {
    return match === value
  }
  if (match instanceof RegExp) {
    return match.test(value)
  }
  if (typeof match === 'function') {
    return match(value) === true
  }
  return false
}

function lowerCaseEntries (headers) {
  return Object.fromEntries(
    Object.entries(headers).map(([headerName, headerValue]) => {
      return [headerName.toLocaleLowerCase(), headerValue]
    })
  )
}

/**
 * @param {import('../../index').Headers|string[]|Record<string, string>} headers
 * @param {string} key
 */
function getHeaderByName (headers, key) {
  if (Array.isArray(headers)) {
    for (let i = 0; i < headers.length; i += 2) {
      if (headers[i] === key) {
        return headers[i + 1]
      }
    }

    return undefined
  } else if (typeof headers.get === 'function') {
    return headers.get(key)
  } else {
    return headers[key]
  }
}

function matchHeaders (mockDispatch, headers) {
  if (typeof mockDispatch.headers === 'function') {
    if (Array.isArray(headers)) { // fetch HeadersList
      const clone = headers.slice()
      const entries = []
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]])
      }
      headers = Object.fromEntries(entries)
    }
    return mockDispatch.headers(headers ? lowerCaseEntries(headers) : {})
  }
  if (typeof mockDispatch.headers === 'undefined') {
    return true
  }
  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {
    return false
  }

  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {
    const headerValue = getHeaderByName(headers, matchHeaderName)

    if (!matchValue(matchHeaderValue, headerValue)) {
      return false
    }
  }
  return true
}

function matchKey (mockDispatch, { path, method, body, headers }) {
  const pathMatch = matchValue(mockDispatch.path, path)
  const methodMatch = matchValue(mockDispatch.method, method)
  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true
  const headersMatch = matchHeaders(mockDispatch, headers)
  return pathMatch && methodMatch && bodyMatch && headersMatch
}

function getResponseData (data) {
  if (Buffer.isBuffer(data)) {
    return data
  } else if (typeof data === 'object') {
    return JSON.stringify(data)
  } else {
    return data.toString()
  }
}

function getMockDispatch (mockDispatches, key) {
  const resolvedPath = key.query ? buildURL(key.path, key.query) : key.path

  // Match path
  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(path, resolvedPath))
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`)
  }

  // Match method
  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)
  }

  // Match body
  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)
  }

  // Match headers
  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))
  if (matchedMockDispatches.length === 0) {
    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)
  }

  return matchedMockDispatches[0]
}

function addMockDispatch (mockDispatches, key, data) {
  const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false }
  const replyData = typeof data === 'function' ? { callback: data } : { ...data }
  const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } }
  mockDispatches.push(newMockDispatch)
  return newMockDispatch
}

function deleteMockDispatch (mockDispatches, key) {
  const index = mockDispatches.findIndex(dispatch => {
    if (!dispatch.consumed) {
      return false
    }
    return matchKey(dispatch, key)
  })
  if (index !== -1) {
    mockDispatches.splice(index, 1)
  }
}

function buildKey (opts) {
  const { path, method, body, headers, query } = opts
  return {
    path,
    method,
    body,
    headers,
    query
  }
}

function generateKeyValues (data) {
  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], [])
}

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
 * @param {number} statusCode
 */
function getStatusText (statusCode) {
  switch (statusCode) {
    case 100: return 'Continue'
    case 101: return 'Switching Protocols'
    case 102: return 'Processing'
    case 103: return 'Early Hints'
    case 200: return 'OK'
    case 201: return 'Created'
    case 202: return 'Accepted'
    case 203: return 'Non-Authoritative Information'
    case 204: return 'No Content'
    case 205: return 'Reset Content'
    case 206: return 'Partial Content'
    case 207: return 'Multi-Status'
    case 208: return 'Already Reported'
    case 226: return 'IM Used'
    case 300: return 'Multiple Choice'
    case 301: return 'Moved Permanently'
    case 302: return 'Found'
    case 303: return 'See Other'
    case 304: return 'Not Modified'
    case 305: return 'Use Proxy'
    case 306: return 'unused'
    case 307: return 'Temporary Redirect'
    case 308: return 'Permanent Redirect'
    case 400: return 'Bad Request'
    case 401: return 'Unauthorized'
    case 402: return 'Payment Required'
    case 403: return 'Forbidden'
    case 404: return 'Not Found'
    case 405: return 'Method Not Allowed'
    case 406: return 'Not Acceptable'
    case 407: return 'Proxy Authentication Required'
    case 408: return 'Request Timeout'
    case 409: return 'Conflict'
    case 410: return 'Gone'
    case 411: return 'Length Required'
    case 412: return 'Precondition Failed'
    case 413: return 'Payload Too Large'
    case 414: return 'URI Too Large'
    case 415: return 'Unsupported Media Type'
    case 416: return 'Range Not Satisfiable'
    case 417: return 'Expectation Failed'
    case 418: return 'I\'m a teapot'
    case 421: return 'Misdirected Request'
    case 422: return 'Unprocessable Entity'
    case 423: return 'Locked'
    case 424: return 'Failed Dependency'
    case 425: return 'Too Early'
    case 426: return 'Upgrade Required'
    case 428: return 'Precondition Required'
    case 429: return 'Too Many Requests'
    case 431: return 'Request Header Fields Too Large'
    case 451: return 'Unavailable For Legal Reasons'
    case 500: return 'Internal Server Error'
    case 501: return 'Not Implemented'
    case 502: return 'Bad Gateway'
    case 503: return 'Service Unavailable'
    case 504: return 'Gateway Timeout'
    case 505: return 'HTTP Version Not Supported'
    case 506: return 'Variant Also Negotiates'
    case 507: return 'Insufficient Storage'
    case 508: return 'Loop Detected'
    case 510: return 'Not Extended'
    case 511: return 'Network Authentication Required'
    default: return 'unknown'
  }
}

async function getResponse (body) {
  const buffers = []
  for await (const data of body) {
    buffers.push(data)
  }
  return Buffer.concat(buffers).toString('utf8')
}

/**
 * Mock dispatch function used to simulate undici dispatches
 */
function mockDispatch (opts, handler) {
  // Get mock dispatch from built key
  const key = buildKey(opts)
  const mockDispatch = getMockDispatch(this[kDispatches], key)

  mockDispatch.timesInvoked++

  // Here's where we resolve a callback if a callback is present for the dispatch data.
  if (mockDispatch.data.callback) {
    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }
  }

  // Parse mockDispatch data
  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch
  const { timesInvoked, times } = mockDispatch

  // If it's used up and not persistent, mark as consumed
  mockDispatch.consumed = !persist && timesInvoked >= times
  mockDispatch.pending = timesInvoked < times

  // If specified, trigger dispatch error
  if (error !== null) {
    deleteMockDispatch(this[kDispatches], key)
    handler.onError(error)
    return true
  }

  // Handle the request with a delay if necessary
  if (typeof delay === 'number' && delay > 0) {
    setTimeout(() => {
      handleReply(this[kDispatches])
    }, delay)
  } else {
    handleReply(this[kDispatches])
  }

  function handleReply (mockDispatches) {
    const responseData = getResponseData(typeof data === 'function' ? data(opts) : data)
    const responseHeaders = generateKeyValues(headers)
    const responseTrailers = generateKeyValues(trailers)

    handler.abort = nop
    handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode))
    handler.onData(Buffer.from(responseData))
    handler.onComplete(responseTrailers)
    deleteMockDispatch(mockDispatches, key)
  }

  function resume () {}

  return true
}

function buildMockDispatch () {
  const agent = this[kMockAgent]
  const origin = this[kOrigin]
  const originalDispatch = this[kOriginalDispatch]

  return function dispatch (opts, handler) {
    if (agent.isMockActive) {
      try {
        mockDispatch.call(this, opts, handler)
      } catch (error) {
        if (error instanceof MockNotMatchedError) {
          const netConnect = agent[kGetNetConnect]()
          if (netConnect === false) {
            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)
          }
          if (checkNetConnect(netConnect, origin)) {
            originalDispatch.call(this, opts, handler)
          } else {
            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)
          }
        } else {
          throw error
        }
      }
    } else {
      originalDispatch.call(this, opts, handler)
    }
  }
}

function checkNetConnect (netConnect, origin) {
  const url = new URL(origin)
  if (netConnect === true) {
    return true
  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
    return true
  }
  return false
}

function buildMockOptions (opts) {
  if (opts) {
    const { agent, ...mockOptions } = opts
    return mockOptions
  }
}

module.exports = {
  getResponseData,
  getMockDispatch,
  addMockDispatch,
  deleteMockDispatch,
  buildKey,
  generateKeyValues,
  matchValue,
  getResponse,
  getStatusText,
  mockDispatch,
  buildMockDispatch,
  checkNetConnect,
  buildMockOptions,
  getHeaderByName
}


/***/ }),

/***/ "../../node_modules/undici/lib/mock/pending-interceptors-formatter.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/undici/lib/mock/pending-interceptors-formatter.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Transform } = __webpack_require__(/*! stream */ "stream")
const { Console } = __webpack_require__(/*! console */ "console")

/**
 * Gets the output of `console.table(…)` as a string.
 */
module.exports = class PendingInterceptorsFormatter {
  constructor ({ disableColors } = {}) {
    this.transform = new Transform({
      transform (chunk, _enc, cb) {
        cb(null, chunk)
      }
    })

    this.logger = new Console({
      stdout: this.transform,
      inspectOptions: {
        colors: !disableColors && !process.env.CI
      }
    })
  }

  format (pendingInterceptors) {
    const withPrettyHeaders = pendingInterceptors.map(
      ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
        Method: method,
        Origin: origin,
        Path: path,
        'Status code': statusCode,
        Persistent: persist ? '✅' : '❌',
        Invocations: timesInvoked,
        Remaining: persist ? Infinity : times - timesInvoked
      }))

    this.logger.table(withPrettyHeaders)
    return this.transform.read().toString()
  }
}


/***/ }),

/***/ "../../node_modules/undici/lib/mock/pluralizer.js":
/*!********************************************************!*\
  !*** ../../node_modules/undici/lib/mock/pluralizer.js ***!
  \********************************************************/
/***/ ((module) => {

"use strict";


const singulars = {
  pronoun: 'it',
  is: 'is',
  was: 'was',
  this: 'this'
}

const plurals = {
  pronoun: 'they',
  is: 'are',
  was: 'were',
  this: 'these'
}

module.exports = class Pluralizer {
  constructor (singular, plural) {
    this.singular = singular
    this.plural = plural
  }

  pluralize (count) {
    const one = count === 1
    const keys = one ? singulars : plurals
    const noun = one ? this.singular : this.plural
    return { ...keys, count, noun }
  }
}


/***/ }),

/***/ "../../node_modules/undici/lib/node/fixed-queue.js":
/*!*********************************************************!*\
  !*** ../../node_modules/undici/lib/node/fixed-queue.js ***!
  \*********************************************************/
/***/ ((module) => {

"use strict";
/* eslint-disable */



// Extracted from node/lib/internal/fixed_queue.js

// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.
const kSize = 2048;
const kMask = kSize - 1;

// The FixedQueue is implemented as a singly-linked list of fixed-size
// circular buffers. It looks something like this:
//
//  head                                                       tail
//    |                                                          |
//    v                                                          v
// +-----------+ <-----\       +-----------+ <------\         +-----------+
// |  [null]   |        \----- |   next    |         \------- |   next    |
// +-----------+               +-----------+                  +-----------+
// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |                  |  [empty]  |
// |   item    |               |   item    |       bottom --> |   item    |
// |   item    |               |   item    |                  |   item    |
// |    ...    |               |    ...    |                  |    ...    |
// |   item    |               |   item    |                  |   item    |
// |   item    |               |   item    |                  |   item    |
// |  [empty]  | <-- top       |   item    |                  |   item    |
// |  [empty]  |               |   item    |                  |   item    |
// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |
// +-----------+               +-----------+                  +-----------+
//
// Or, if there is only one circular buffer, it looks something
// like either of these:
//
//  head   tail                                 head   tail
//    |     |                                     |     |
//    v     v                                     v     v
// +-----------+                               +-----------+
// |  [null]   |                               |  [null]   |
// +-----------+                               +-----------+
// |  [empty]  |                               |   item    |
// |  [empty]  |                               |   item    |
// |   item    | <-- bottom            top --> |  [empty]  |
// |   item    |                               |  [empty]  |
// |  [empty]  | <-- top            bottom --> |   item    |
// |  [empty]  |                               |   item    |
// +-----------+                               +-----------+
//
// Adding a value means moving `top` forward by one, removing means
// moving `bottom` forward by one. After reaching the end, the queue
// wraps around.
//
// When `top === bottom` the current queue is empty and when
// `top + 1 === bottom` it's full. This wastes a single space of storage
// but allows much quicker checks.

class FixedCircularBuffer {
  constructor() {
    this.bottom = 0;
    this.top = 0;
    this.list = new Array(kSize);
    this.next = null;
  }

  isEmpty() {
    return this.top === this.bottom;
  }

  isFull() {
    return ((this.top + 1) & kMask) === this.bottom;
  }

  push(data) {
    this.list[this.top] = data;
    this.top = (this.top + 1) & kMask;
  }

  shift() {
    const nextItem = this.list[this.bottom];
    if (nextItem === undefined)
      return null;
    this.list[this.bottom] = undefined;
    this.bottom = (this.bottom + 1) & kMask;
    return nextItem;
  }
}

module.exports = class FixedQueue {
  constructor() {
    this.head = this.tail = new FixedCircularBuffer();
  }

  isEmpty() {
    return this.head.isEmpty();
  }

  push(data) {
    if (this.head.isFull()) {
      // Head is full: Creates a new queue, sets the old queue's `.next` to it,
      // and sets it as the new main queue.
      this.head = this.head.next = new FixedCircularBuffer();
    }
    this.head.push(data);
  }

  shift() {
    const tail = this.tail;
    const next = tail.shift();
    if (tail.isEmpty() && tail.next !== null) {
      // If there is another queue, it forms the new tail.
      this.tail = tail.next;
    }
    return next;
  }
};


/***/ }),

/***/ "../../node_modules/undici/lib/pool-base.js":
/*!**************************************************!*\
  !*** ../../node_modules/undici/lib/pool-base.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "../../node_modules/undici/lib/dispatcher-base.js")
const FixedQueue = __webpack_require__(/*! ./node/fixed-queue */ "../../node_modules/undici/lib/node/fixed-queue.js")
const { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const PoolStats = __webpack_require__(/*! ./pool-stats */ "../../node_modules/undici/lib/pool-stats.js")

const kClients = Symbol('clients')
const kNeedDrain = Symbol('needDrain')
const kQueue = Symbol('queue')
const kClosedResolve = Symbol('closed resolve')
const kOnDrain = Symbol('onDrain')
const kOnConnect = Symbol('onConnect')
const kOnDisconnect = Symbol('onDisconnect')
const kOnConnectionError = Symbol('onConnectionError')
const kGetDispatcher = Symbol('get dispatcher')
const kAddClient = Symbol('add client')
const kRemoveClient = Symbol('remove client')
const kStats = Symbol('stats')

class PoolBase extends DispatcherBase {
  constructor () {
    super()

    this[kQueue] = new FixedQueue()
    this[kClients] = []
    this[kQueued] = 0

    const pool = this

    this[kOnDrain] = function onDrain (origin, targets) {
      const queue = pool[kQueue]

      let needDrain = false

      while (!needDrain) {
        const item = queue.shift()
        if (!item) {
          break
        }
        pool[kQueued]--
        needDrain = !this.dispatch(item.opts, item.handler)
      }

      this[kNeedDrain] = needDrain

      if (!this[kNeedDrain] && pool[kNeedDrain]) {
        pool[kNeedDrain] = false
        pool.emit('drain', origin, [pool, ...targets])
      }

      if (pool[kClosedResolve] && queue.isEmpty()) {
        Promise
          .all(pool[kClients].map(c => c.close()))
          .then(pool[kClosedResolve])
      }
    }

    this[kOnConnect] = (origin, targets) => {
      pool.emit('connect', origin, [pool, ...targets])
    }

    this[kOnDisconnect] = (origin, targets, err) => {
      pool.emit('disconnect', origin, [pool, ...targets], err)
    }

    this[kOnConnectionError] = (origin, targets, err) => {
      pool.emit('connectionError', origin, [pool, ...targets], err)
    }

    this[kStats] = new PoolStats(this)
  }

  get [kBusy] () {
    return this[kNeedDrain]
  }

  get [kConnected] () {
    return this[kClients].filter(client => client[kConnected]).length
  }

  get [kFree] () {
    return this[kClients].filter(client => client[kConnected] && !client[kNeedDrain]).length
  }

  get [kPending] () {
    let ret = this[kQueued]
    for (const { [kPending]: pending } of this[kClients]) {
      ret += pending
    }
    return ret
  }

  get [kRunning] () {
    let ret = 0
    for (const { [kRunning]: running } of this[kClients]) {
      ret += running
    }
    return ret
  }

  get [kSize] () {
    let ret = this[kQueued]
    for (const { [kSize]: size } of this[kClients]) {
      ret += size
    }
    return ret
  }

  get stats () {
    return this[kStats]
  }

  async [kClose] () {
    if (this[kQueue].isEmpty()) {
      return Promise.all(this[kClients].map(c => c.close()))
    } else {
      return new Promise((resolve) => {
        this[kClosedResolve] = resolve
      })
    }
  }

  async [kDestroy] (err) {
    while (true) {
      const item = this[kQueue].shift()
      if (!item) {
        break
      }
      item.handler.onError(err)
    }

    return Promise.all(this[kClients].map(c => c.destroy(err)))
  }

  [kDispatch] (opts, handler) {
    const dispatcher = this[kGetDispatcher]()

    if (!dispatcher) {
      this[kNeedDrain] = true
      this[kQueue].push({ opts, handler })
      this[kQueued]++
    } else if (!dispatcher.dispatch(opts, handler)) {
      dispatcher[kNeedDrain] = true
      this[kNeedDrain] = !this[kGetDispatcher]()
    }

    return !this[kNeedDrain]
  }

  [kAddClient] (client) {
    client
      .on('drain', this[kOnDrain])
      .on('connect', this[kOnConnect])
      .on('disconnect', this[kOnDisconnect])
      .on('connectionError', this[kOnConnectionError])

    this[kClients].push(client)

    if (this[kNeedDrain]) {
      process.nextTick(() => {
        if (this[kNeedDrain]) {
          this[kOnDrain](client[kUrl], [this, client])
        }
      })
    }

    return this
  }

  [kRemoveClient] (client) {
    client.close(() => {
      const idx = this[kClients].indexOf(client)
      if (idx !== -1) {
        this[kClients].splice(idx, 1)
      }
    })

    this[kNeedDrain] = this[kClients].some(dispatcher => (
      !dispatcher[kNeedDrain] &&
      dispatcher.closed !== true &&
      dispatcher.destroyed !== true
    ))
  }
}

module.exports = {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kRemoveClient,
  kGetDispatcher
}


/***/ }),

/***/ "../../node_modules/undici/lib/pool-stats.js":
/*!***************************************************!*\
  !*** ../../node_modules/undici/lib/pool-stats.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { kFree, kConnected, kPending, kQueued, kRunning, kSize } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const kPool = Symbol('pool')

class PoolStats {
  constructor (pool) {
    this[kPool] = pool
  }

  get connected () {
    return this[kPool][kConnected]
  }

  get free () {
    return this[kPool][kFree]
  }

  get pending () {
    return this[kPool][kPending]
  }

  get queued () {
    return this[kPool][kQueued]
  }

  get running () {
    return this[kPool][kRunning]
  }

  get size () {
    return this[kPool][kSize]
  }
}

module.exports = PoolStats


/***/ }),

/***/ "../../node_modules/undici/lib/pool.js":
/*!*********************************************!*\
  !*** ../../node_modules/undici/lib/pool.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const {
  PoolBase,
  kClients,
  kNeedDrain,
  kAddClient,
  kGetDispatcher
} = __webpack_require__(/*! ./pool-base */ "../../node_modules/undici/lib/pool-base.js")
const Client = __webpack_require__(/*! ./client */ "../../node_modules/undici/lib/client.js")
const {
  InvalidArgumentError
} = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const util = __webpack_require__(/*! ./core/util */ "../../node_modules/undici/lib/core/util.js")
const { kUrl } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const buildConnector = __webpack_require__(/*! ./core/connect */ "../../node_modules/undici/lib/core/connect.js")

const kOptions = Symbol('options')
const kConnections = Symbol('connections')
const kFactory = Symbol('factory')

function defaultFactory (origin, opts) {
  return new Client(origin, opts)
}

class Pool extends PoolBase {
  constructor (origin, {
    connections,
    factory = defaultFactory,
    connect,
    connectTimeout,
    tls,
    maxCachedSessions,
    socketPath,
    ...options
  } = {}) {
    super()

    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
      throw new InvalidArgumentError('invalid connections')
    }

    if (typeof factory !== 'function') {
      throw new InvalidArgumentError('factory must be a function.')
    }

    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {
      throw new InvalidArgumentError('connect must be a function or an object')
    }

    if (typeof connect !== 'function') {
      connect = buildConnector({
        ...tls,
        maxCachedSessions,
        socketPath,
        timeout: connectTimeout == null ? 10e3 : connectTimeout,
        ...connect
      })
    }

    this[kConnections] = connections || null
    this[kUrl] = util.parseOrigin(origin)
    this[kOptions] = { ...util.deepClone(options), connect }
    this[kFactory] = factory
  }

  [kGetDispatcher] () {
    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain])

    if (dispatcher) {
      return dispatcher
    }

    if (!this[kConnections] || this[kClients].length < this[kConnections]) {
      dispatcher = this[kFactory](this[kUrl], this[kOptions])
      this[kAddClient](dispatcher)
    }

    return dispatcher
  }
}

module.exports = Pool


/***/ }),

/***/ "../../node_modules/undici/lib/proxy-agent.js":
/*!****************************************************!*\
  !*** ../../node_modules/undici/lib/proxy-agent.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kClose, kDestroy } = __webpack_require__(/*! ./core/symbols */ "../../node_modules/undici/lib/core/symbols.js")
const Client = __webpack_require__(/*! ./agent */ "../../node_modules/undici/lib/agent.js")
const Agent = __webpack_require__(/*! ./agent */ "../../node_modules/undici/lib/agent.js")
const DispatcherBase = __webpack_require__(/*! ./dispatcher-base */ "../../node_modules/undici/lib/dispatcher-base.js")
const { InvalidArgumentError, RequestAbortedError } = __webpack_require__(/*! ./core/errors */ "../../node_modules/undici/lib/core/errors.js")
const buildConnector = __webpack_require__(/*! ./core/connect */ "../../node_modules/undici/lib/core/connect.js")

const kAgent = Symbol('proxy agent')
const kClient = Symbol('proxy client')
const kProxyHeaders = Symbol('proxy headers')
const kRequestTls = Symbol('request tls settings')
const kProxyTls = Symbol('proxy tls settings')
const kConnectEndpoint = Symbol('connect endpoint function')

function defaultProtocolPort (protocol) {
  return protocol === 'https:' ? 443 : 80
}

class ProxyAgent extends DispatcherBase {
  constructor (opts) {
    super(opts)

    if (typeof opts === 'string') {
      opts = { uri: opts }
    }

    if (!opts || !opts.uri) {
      throw new InvalidArgumentError('Proxy opts.uri is mandatory')
    }

    this[kRequestTls] = opts.requestTls
    this[kProxyTls] = opts.proxyTls
    this[kProxyHeaders] = {}

    if (opts.auth) {
      this[kProxyHeaders]['proxy-authorization'] = `Basic ${opts.auth}`
    }

    const { origin, port } = new URL(opts.uri)

    const connect = buildConnector({ ...opts.proxyTls })
    this[kConnectEndpoint] = buildConnector({ ...opts.requestTls })
    this[kClient] = new Client({ origin: opts.origin, connect })
    this[kAgent] = new Agent({
      ...opts,
      connect: async (opts, callback) => {
        let requestedHost = opts.host
        if (!opts.port) {
          requestedHost += `:${defaultProtocolPort(opts.protocol)}`
        }
        try {
          const { socket, statusCode } = await this[kClient].connect({
            origin,
            port,
            path: requestedHost,
            signal: opts.signal,
            headers: {
              ...this[kProxyHeaders],
              host: opts.host
            }
          })
          if (statusCode !== 200) {
            socket.on('error', () => {}).destroy()
            callback(new RequestAbortedError('Proxy response !== 200 when HTTP Tunneling'))
          }
          if (opts.protocol !== 'https:') {
            callback(null, socket)
            return
          }
          let servername
          if (this[kRequestTls]) {
            servername = this[kRequestTls].servername
          } else {
            servername = opts.servername
          }
          this[kConnectEndpoint]({ ...opts, servername, httpSocket: socket }, callback)
        } catch (err) {
          callback(err)
        }
      }
    })
  }

  dispatch (opts, handler) {
    const { host } = new URL(opts.origin)
    const headers = buildHeaders(opts.headers)
    throwIfProxyAuthIsSent(headers)
    return this[kAgent].dispatch(
      {
        ...opts,
        headers: {
          ...headers,
          host
        }
      },
      handler
    )
  }

  async [kClose] () {
    await this[kAgent].close()
    await this[kClient].close()
  }

  async [kDestroy] () {
    await this[kAgent].destroy()
    await this[kClient].destroy()
  }
}

/**
 * @param {string[] | Record<string, string>} headers
 * @returns {Record<string, string>}
 */
function buildHeaders (headers) {
  // When using undici.fetch, the headers list is stored
  // as an array.
  if (Array.isArray(headers)) {
    /** @type {Record<string, string>} */
    const headersPair = {}

    for (let i = 0; i < headers.length; i += 2) {
      headersPair[headers[i]] = headers[i + 1]
    }

    return headersPair
  }

  return headers
}

/**
 * @param {Record<string, string>} headers
 *
 * Previous versions of ProxyAgent suggests the Proxy-Authorization in request headers
 * Nevertheless, it was changed and to avoid a security vulnerability by end users
 * this check was created.
 * It should be removed in the next major version for performance reasons
 */
function throwIfProxyAuthIsSent (headers) {
  const existProxyAuth = headers && Object.keys(headers)
    .find((key) => key.toLowerCase() === 'proxy-authorization')
  if (existProxyAuth) {
    throw new InvalidArgumentError('Proxy-Authorization should be sent in ProxyAgent constructor')
  }
}

module.exports = ProxyAgent


/***/ }),

/***/ "../../node_modules/urllib/node_modules/mime-db/index.js":
/*!***************************************************************!*\
  !*** ../../node_modules/urllib/node_modules/mime-db/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "../../node_modules/urllib/node_modules/mime-db/db.json")


/***/ }),

/***/ "../../node_modules/urllib/node_modules/mime-types/index.js":
/*!******************************************************************!*\
  !*** ../../node_modules/urllib/node_modules/mime-types/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "../../node_modules/urllib/node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "../../node_modules/web-streams-polyfill/dist/ponyfill.js":
/*!****************************************************************!*\
  !*** ../../node_modules/web-streams-polyfill/dist/ponyfill.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * @license
 * web-streams-polyfill v4.0.0-beta.1
 * Copyright 2021 Mattias Buelens, Diwank Singh Tomer and other contributors.
 * This code is released under the MIT license.
 * SPDX-License-Identifier: MIT
 */
!function(e,t){ true?t(exports):0}(this,(function(e){"use strict";const t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol:e=>`Symbol(${e})`;function r(){}function o(e){return"object"==typeof e&&null!==e||"function"==typeof e}const n=r,a=Promise,i=Promise.prototype.then,l=Promise.resolve.bind(a),s=Promise.reject.bind(a);function u(e){return new a(e)}function c(e){return l(e)}function d(e){return s(e)}function f(e,t,r){return i.call(e,t,r)}function b(e,t,r){f(f(e,t,r),void 0,n)}function _(e,t){b(e,t)}function h(e,t){b(e,void 0,t)}function m(e,t,r){return f(e,t,r)}function p(e){f(e,void 0,n)}let y=e=>{if("function"==typeof queueMicrotask)y=queueMicrotask;else{const e=c(void 0);y=t=>f(e,t)}return y(e)};function g(e,t,r){if("function"!=typeof e)throw new TypeError("Argument is not a function");return Function.prototype.apply.call(e,t,r)}function S(e,t,r){try{return c(g(e,t,r))}catch(e){return d(e)}}class v{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(e){const t=this._back;let r=t;16383===t._elements.length&&(r={_elements:[],_next:void 0}),t._elements.push(e),r!==t&&(this._back=r,t._next=r),++this._size}shift(){const e=this._front;let t=e;const r=this._cursor;let o=r+1;const n=e._elements,a=n[r];return 16384===o&&(t=e._next,o=0),--this._size,this._cursor=o,e!==t&&(this._front=t),n[r]=void 0,a}forEach(e){let t=this._cursor,r=this._front,o=r._elements;for(;!(t===o.length&&void 0===r._next||t===o.length&&(r=r._next,o=r._elements,t=0,0===o.length));)e(o[t]),++t}peek(){const e=this._front,t=this._cursor;return e._elements[t]}}function w(e,t){e._ownerReadableStream=t,t._reader=e,"readable"===t._state?q(e):"closed"===t._state?function(e){q(e),W(e)}(e):P(e,t._storedError)}function R(e,t){return dr(e._ownerReadableStream,t)}function T(e){"readable"===e._ownerReadableStream._state?E(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):function(e,t){P(e,t)}(e,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),e._ownerReadableStream._reader=void 0,e._ownerReadableStream=void 0}function C(e){return new TypeError("Cannot "+e+" a stream using a released reader")}function q(e){e._closedPromise=u(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r}))}function P(e,t){q(e),E(e,t)}function E(e,t){void 0!==e._closedPromise_reject&&(p(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}function W(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0)}const O=t("[[AbortSteps]]"),B=t("[[ErrorSteps]]"),k=t("[[CancelSteps]]"),j=t("[[PullSteps]]"),A=Number.isFinite||function(e){return"number"==typeof e&&isFinite(e)},z=Math.trunc||function(e){return e<0?Math.ceil(e):Math.floor(e)};function F(e,t){if(void 0!==e&&("object"!=typeof(r=e)&&"function"!=typeof r))throw new TypeError(`${t} is not an object.`);var r}function I(e,t){if("function"!=typeof e)throw new TypeError(`${t} is not a function.`)}function L(e,t){if(!function(e){return"object"==typeof e&&null!==e||"function"==typeof e}(e))throw new TypeError(`${t} is not an object.`)}function D(e,t,r){if(void 0===e)throw new TypeError(`Parameter ${t} is required in '${r}'.`)}function $(e,t,r){if(void 0===e)throw new TypeError(`${t} is required in '${r}'.`)}function M(e){return Number(e)}function Q(e){return 0===e?0:e}function Y(e,t){const r=Number.MAX_SAFE_INTEGER;let o=Number(e);if(o=Q(o),!A(o))throw new TypeError(`${t} is not a finite number`);if(o=function(e){return Q(z(e))}(o),o<0||o>r)throw new TypeError(`${t} is outside the accepted range of 0 to ${r}, inclusive`);return A(o)&&0!==o?o:0}function x(e,t){if(!ur(e))throw new TypeError(`${t} is not a ReadableStream.`)}function N(e){return new ReadableStreamDefaultReader(e)}function H(e,t){e._reader._readRequests.push(t)}function V(e,t,r){const o=e._reader._readRequests.shift();r?o._closeSteps():o._chunkSteps(t)}function U(e){return e._reader._readRequests.length}function G(e){const t=e._reader;return void 0!==t&&!!X(t)}class ReadableStreamDefaultReader{constructor(e){if(D(e,1,"ReadableStreamDefaultReader"),x(e,"First parameter"),cr(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");w(this,e),this._readRequests=new v}get closed(){return X(this)?this._closedPromise:d(K("closed"))}cancel(e){return X(this)?void 0===this._ownerReadableStream?d(C("cancel")):R(this,e):d(K("cancel"))}read(){if(!X(this))return d(K("read"));if(void 0===this._ownerReadableStream)return d(C("read from"));let e,t;const r=u(((r,o)=>{e=r,t=o}));return J(this,{_chunkSteps:t=>e({value:t,done:!1}),_closeSteps:()=>e({value:void 0,done:!0}),_errorSteps:e=>t(e)}),r}releaseLock(){if(!X(this))throw K("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");T(this)}}}function X(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_readRequests")&&e instanceof ReadableStreamDefaultReader)}function J(e,t){const r=e._ownerReadableStream;r._disturbed=!0,"closed"===r._state?t._closeSteps():"errored"===r._state?t._errorSteps(r._storedError):r._readableStreamController[j](t)}function K(e){return new TypeError(`ReadableStreamDefaultReader.prototype.${e} can only be used on a ReadableStreamDefaultReader`)}Object.defineProperties(ReadableStreamDefaultReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamDefaultReader.prototype,t.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});class Z{constructor(e,t){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=e,this._preventCancel=t}next(){const e=()=>this._nextSteps();return this._ongoingPromise=this._ongoingPromise?m(this._ongoingPromise,e,e):e(),this._ongoingPromise}return(e){const t=()=>this._returnSteps(e);return this._ongoingPromise?m(this._ongoingPromise,t,t):t()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const e=this._reader;if(void 0===e._ownerReadableStream)return d(C("iterate"));let t,r;const o=u(((e,o)=>{t=e,r=o}));return J(e,{_chunkSteps:e=>{this._ongoingPromise=void 0,y((()=>t({value:e,done:!1})))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,T(e),t({value:void 0,done:!0})},_errorSteps:t=>{this._ongoingPromise=void 0,this._isFinished=!0,T(e),r(t)}}),o}_returnSteps(e){if(this._isFinished)return Promise.resolve({value:e,done:!0});this._isFinished=!0;const t=this._reader;if(void 0===t._ownerReadableStream)return d(C("finish iterating"));if(!this._preventCancel){const r=R(t,e);return T(t),m(r,(()=>({value:e,done:!0})))}return T(t),c({value:e,done:!0})}}const ee={next(){return te(this)?this._asyncIteratorImpl.next():d(re("next"))},return(e){return te(this)?this._asyncIteratorImpl.return(e):d(re("return"))}};function te(e){if(!o(e))return!1;if(!Object.prototype.hasOwnProperty.call(e,"_asyncIteratorImpl"))return!1;try{return e._asyncIteratorImpl instanceof Z}catch(e){return!1}}function re(e){return new TypeError(`ReadableStreamAsyncIterator.${e} can only be used on a ReadableSteamAsyncIterator`)}"symbol"==typeof t.asyncIterator&&Object.defineProperty(ee,t.asyncIterator,{value(){return this},writable:!0,configurable:!0});const oe=Number.isNaN||function(e){return e!=e};function ne(e){return e.slice()}function ae(e,t,r,o,n){new Uint8Array(e).set(new Uint8Array(r,o,n),t)}function ie(e,t,r){if(e.slice)return e.slice(t,r);const o=r-t,n=new ArrayBuffer(o);return ae(n,0,e,t,o),n}function le(e){const t=ie(e.buffer,e.byteOffset,e.byteOffset+e.byteLength);return new Uint8Array(t)}function se(e){const t=e._queue.shift();return e._queueTotalSize-=t.size,e._queueTotalSize<0&&(e._queueTotalSize=0),t.value}function ue(e,t,r){if("number"!=typeof(o=r)||oe(o)||o<0||r===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");var o;e._queue.push({value:t,size:r}),e._queueTotalSize+=r}function ce(e){e._queue=new v,e._queueTotalSize=0}class ReadableStreamBYOBRequest{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!fe(this))throw Ae("view");return this._view}respond(e){if(!fe(this))throw Ae("respond");if(D(e,1,"respond"),e=Y(e,"First parameter"),void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");this._view.buffer,Be(this._associatedReadableByteStreamController,e)}respondWithNewView(e){if(!fe(this))throw Ae("respondWithNewView");if(D(e,1,"respondWithNewView"),!ArrayBuffer.isView(e))throw new TypeError("You can only respond with array buffer views");if(void 0===this._associatedReadableByteStreamController)throw new TypeError("This BYOB request has been invalidated");e.buffer,ke(this._associatedReadableByteStreamController,e)}}Object.defineProperties(ReadableStreamBYOBRequest.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamBYOBRequest.prototype,t.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});class ReadableByteStreamController{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!de(this))throw ze("byobRequest");return We(this)}get desiredSize(){if(!de(this))throw ze("desiredSize");return Oe(this)}close(){if(!de(this))throw ze("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const e=this._controlledReadableByteStream._state;if("readable"!==e)throw new TypeError(`The stream (in ${e} state) is not in the readable state and cannot be closed`);qe(this)}enqueue(e){if(!de(this))throw ze("enqueue");if(D(e,1,"enqueue"),!ArrayBuffer.isView(e))throw new TypeError("chunk must be an array buffer view");if(0===e.byteLength)throw new TypeError("chunk must have non-zero byteLength");if(0===e.buffer.byteLength)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const t=this._controlledReadableByteStream._state;if("readable"!==t)throw new TypeError(`The stream (in ${t} state) is not in the readable state and cannot be enqueued to`);Pe(this,e)}error(e){if(!de(this))throw ze("error");Ee(this,e)}[k](e){_e(this),ce(this);const t=this._cancelAlgorithm(e);return Ce(this),t}[j](e){const t=this._controlledReadableByteStream;if(this._queueTotalSize>0){const t=this._queue.shift();this._queueTotalSize-=t.byteLength,Se(this);const r=new Uint8Array(t.buffer,t.byteOffset,t.byteLength);return void e._chunkSteps(r)}const r=this._autoAllocateChunkSize;if(void 0!==r){let t;try{t=new ArrayBuffer(r)}catch(t){return void e._errorSteps(t)}const o={buffer:t,bufferByteLength:r,byteOffset:0,byteLength:r,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(o)}H(t,e),be(this)}}function de(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableByteStream")&&e instanceof ReadableByteStreamController)}function fe(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_associatedReadableByteStreamController")&&e instanceof ReadableStreamBYOBRequest)}function be(e){if(!function(e){const t=e._controlledReadableByteStream;if("readable"!==t._state)return!1;if(e._closeRequested)return!1;if(!e._started)return!1;if(G(t)&&U(t)>0)return!0;if(De(t)&&Le(t)>0)return!0;if(Oe(e)>0)return!0;return!1}(e))return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;b(e._pullAlgorithm(),(()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,be(e))}),(t=>{Ee(e,t)}))}function _e(e){ve(e),e._pendingPullIntos=new v}function he(e,t){let r=!1;"closed"===e._state&&(r=!0);const o=me(t);"default"===t.readerType?V(e,o,r):function(e,t,r){const o=e._reader._readIntoRequests.shift();r?o._closeSteps(t):o._chunkSteps(t)}(e,o,r)}function me(e){const t=e.bytesFilled,r=e.elementSize;return new e.viewConstructor(e.buffer,e.byteOffset,t/r)}function pe(e,t,r,o){e._queue.push({buffer:t,byteOffset:r,byteLength:o}),e._queueTotalSize+=o}function ye(e,t){const r=t.elementSize,o=t.bytesFilled-t.bytesFilled%r,n=Math.min(e._queueTotalSize,t.byteLength-t.bytesFilled),a=t.bytesFilled+n,i=a-a%r;let l=n,s=!1;i>o&&(l=i-t.bytesFilled,s=!0);const u=e._queue;for(;l>0;){const r=u.peek(),o=Math.min(l,r.byteLength),n=t.byteOffset+t.bytesFilled;ae(t.buffer,n,r.buffer,r.byteOffset,o),r.byteLength===o?u.shift():(r.byteOffset+=o,r.byteLength-=o),e._queueTotalSize-=o,ge(e,o,t),l-=o}return s}function ge(e,t,r){r.bytesFilled+=t}function Se(e){0===e._queueTotalSize&&e._closeRequested?(Ce(e),fr(e._controlledReadableByteStream)):be(e)}function ve(e){null!==e._byobRequest&&(e._byobRequest._associatedReadableByteStreamController=void 0,e._byobRequest._view=null,e._byobRequest=null)}function we(e){for(;e._pendingPullIntos.length>0;){if(0===e._queueTotalSize)return;const t=e._pendingPullIntos.peek();ye(e,t)&&(Te(e),he(e._controlledReadableByteStream,t))}}function Re(e,t){const r=e._pendingPullIntos.peek();ve(e);"closed"===e._controlledReadableByteStream._state?function(e,t){const r=e._controlledReadableByteStream;if(De(r))for(;Le(r)>0;)he(r,Te(e))}(e):function(e,t,r){if(ge(0,t,r),r.bytesFilled<r.elementSize)return;Te(e);const o=r.bytesFilled%r.elementSize;if(o>0){const t=r.byteOffset+r.bytesFilled,n=ie(r.buffer,t-o,t);pe(e,n,0,n.byteLength)}r.bytesFilled-=o,he(e._controlledReadableByteStream,r),we(e)}(e,t,r),be(e)}function Te(e){return e._pendingPullIntos.shift()}function Ce(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0}function qe(e){const t=e._controlledReadableByteStream;if(!e._closeRequested&&"readable"===t._state)if(e._queueTotalSize>0)e._closeRequested=!0;else{if(e._pendingPullIntos.length>0){if(e._pendingPullIntos.peek().bytesFilled>0){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");throw Ee(e,t),t}}Ce(e),fr(t)}}function Pe(e,t){const r=e._controlledReadableByteStream;if(e._closeRequested||"readable"!==r._state)return;const o=t.buffer,n=t.byteOffset,a=t.byteLength,i=o;if(e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek();t.buffer,0,t.buffer=t.buffer}if(ve(e),G(r))if(0===U(r))pe(e,i,n,a);else{V(r,new Uint8Array(i,n,a),!1)}else De(r)?(pe(e,i,n,a),we(e)):pe(e,i,n,a);be(e)}function Ee(e,t){const r=e._controlledReadableByteStream;"readable"===r._state&&(_e(e),ce(e),Ce(e),br(r,t))}function We(e){if(null===e._byobRequest&&e._pendingPullIntos.length>0){const t=e._pendingPullIntos.peek(),r=new Uint8Array(t.buffer,t.byteOffset+t.bytesFilled,t.byteLength-t.bytesFilled),o=Object.create(ReadableStreamBYOBRequest.prototype);!function(e,t,r){e._associatedReadableByteStreamController=t,e._view=r}(o,e,r),e._byobRequest=o}return e._byobRequest}function Oe(e){const t=e._controlledReadableByteStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function Be(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(0===t)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(r.bytesFilled+t>r.byteLength)throw new RangeError("bytesWritten out of range")}r.buffer=r.buffer,Re(e,t)}function ke(e,t){const r=e._pendingPullIntos.peek();if("closed"===e._controlledReadableByteStream._state){if(0!==t.byteLength)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(0===t.byteLength)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(r.byteOffset+r.bytesFilled!==t.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(r.bufferByteLength!==t.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(r.bytesFilled+t.byteLength>r.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");r.buffer=t.buffer,Re(e,t.byteLength)}function je(e,t,r,o,n,a,i){t._controlledReadableByteStream=e,t._pullAgain=!1,t._pulling=!1,t._byobRequest=null,t._queue=t._queueTotalSize=void 0,ce(t),t._closeRequested=!1,t._started=!1,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,t._autoAllocateChunkSize=i,t._pendingPullIntos=new v,e._readableStreamController=t;b(c(r()),(()=>{t._started=!0,be(t)}),(e=>{Ee(t,e)}))}function Ae(e){return new TypeError(`ReadableStreamBYOBRequest.prototype.${e} can only be used on a ReadableStreamBYOBRequest`)}function ze(e){return new TypeError(`ReadableByteStreamController.prototype.${e} can only be used on a ReadableByteStreamController`)}function Fe(e){return new ReadableStreamBYOBReader(e)}function Ie(e,t){e._reader._readIntoRequests.push(t)}function Le(e){return e._reader._readIntoRequests.length}function De(e){const t=e._reader;return void 0!==t&&!!$e(t)}Object.defineProperties(ReadableByteStreamController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableByteStreamController.prototype,t.toStringTag,{value:"ReadableByteStreamController",configurable:!0});class ReadableStreamBYOBReader{constructor(e){if(D(e,1,"ReadableStreamBYOBReader"),x(e,"First parameter"),cr(e))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!de(e._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");w(this,e),this._readIntoRequests=new v}get closed(){return $e(this)?this._closedPromise:d(Qe("closed"))}cancel(e){return $e(this)?void 0===this._ownerReadableStream?d(C("cancel")):R(this,e):d(Qe("cancel"))}read(e){if(!$e(this))return d(Qe("read"));if(!ArrayBuffer.isView(e))return d(new TypeError("view must be an array buffer view"));if(0===e.byteLength)return d(new TypeError("view must have non-zero byteLength"));if(0===e.buffer.byteLength)return d(new TypeError("view's buffer must have non-zero byteLength"));if(e.buffer,void 0===this._ownerReadableStream)return d(C("read from"));let t,r;const o=u(((e,o)=>{t=e,r=o}));return Me(this,e,{_chunkSteps:e=>t({value:e,done:!1}),_closeSteps:e=>t({value:e,done:!0}),_errorSteps:e=>r(e)}),o}releaseLock(){if(!$e(this))throw Qe("releaseLock");if(void 0!==this._ownerReadableStream){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");T(this)}}}function $e(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_readIntoRequests")&&e instanceof ReadableStreamBYOBReader)}function Me(e,t,r){const o=e._ownerReadableStream;o._disturbed=!0,"errored"===o._state?r._errorSteps(o._storedError):function(e,t,r){const o=e._controlledReadableByteStream;let n=1;t.constructor!==DataView&&(n=t.constructor.BYTES_PER_ELEMENT);const a=t.constructor,i=t.buffer,l={buffer:i,bufferByteLength:i.byteLength,byteOffset:t.byteOffset,byteLength:t.byteLength,bytesFilled:0,elementSize:n,viewConstructor:a,readerType:"byob"};if(e._pendingPullIntos.length>0)return e._pendingPullIntos.push(l),void Ie(o,r);if("closed"!==o._state){if(e._queueTotalSize>0){if(ye(e,l)){const t=me(l);return Se(e),void r._chunkSteps(t)}if(e._closeRequested){const t=new TypeError("Insufficient bytes to fill elements in the given buffer");return Ee(e,t),void r._errorSteps(t)}}e._pendingPullIntos.push(l),Ie(o,r),be(e)}else{const e=new a(l.buffer,l.byteOffset,0);r._closeSteps(e)}}(o._readableStreamController,t,r)}function Qe(e){return new TypeError(`ReadableStreamBYOBReader.prototype.${e} can only be used on a ReadableStreamBYOBReader`)}function Ye(e,t){const{highWaterMark:r}=e;if(void 0===r)return t;if(oe(r)||r<0)throw new RangeError("Invalid highWaterMark");return r}function xe(e){const{size:t}=e;return t||(()=>1)}function Ne(e,t){F(e,t);const r=null==e?void 0:e.highWaterMark,o=null==e?void 0:e.size;return{highWaterMark:void 0===r?void 0:M(r),size:void 0===o?void 0:He(o,`${t} has member 'size' that`)}}function He(e,t){return I(e,t),t=>M(e(t))}function Ve(e,t,r){return I(e,r),r=>S(e,t,[r])}function Ue(e,t,r){return I(e,r),()=>S(e,t,[])}function Ge(e,t,r){return I(e,r),r=>g(e,t,[r])}function Xe(e,t,r){return I(e,r),(r,o)=>S(e,t,[r,o])}function Je(e,t){if(!tt(e))throw new TypeError(`${t} is not a WritableStream.`)}Object.defineProperties(ReadableStreamBYOBReader.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamBYOBReader.prototype,t.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});const Ke="function"==typeof AbortController;class WritableStream{constructor(e={},t={}){void 0===e?e=null:L(e,"First parameter");const r=Ne(t,"Second parameter"),o=function(e,t){F(e,t);const r=null==e?void 0:e.abort,o=null==e?void 0:e.close,n=null==e?void 0:e.start,a=null==e?void 0:e.type,i=null==e?void 0:e.write;return{abort:void 0===r?void 0:Ve(r,e,`${t} has member 'abort' that`),close:void 0===o?void 0:Ue(o,e,`${t} has member 'close' that`),start:void 0===n?void 0:Ge(n,e,`${t} has member 'start' that`),write:void 0===i?void 0:Xe(i,e,`${t} has member 'write' that`),type:a}}(e,"First parameter");et(this);if(void 0!==o.type)throw new RangeError("Invalid type is specified");const n=xe(r);!function(e,t,r,o){const n=Object.create(WritableStreamDefaultController.prototype);let a=()=>{},i=()=>c(void 0),l=()=>c(void 0),s=()=>c(void 0);void 0!==t.start&&(a=()=>t.start(n));void 0!==t.write&&(i=e=>t.write(e,n));void 0!==t.close&&(l=()=>t.close());void 0!==t.abort&&(s=e=>t.abort(e));gt(e,n,a,i,l,s,r,o)}(this,o,Ye(r,1),n)}get locked(){if(!tt(this))throw qt("locked");return rt(this)}abort(e){return tt(this)?rt(this)?d(new TypeError("Cannot abort a stream that already has a writer")):ot(this,e):d(qt("abort"))}close(){return tt(this)?rt(this)?d(new TypeError("Cannot close a stream that already has a writer")):st(this)?d(new TypeError("Cannot close an already-closing stream")):nt(this):d(qt("close"))}getWriter(){if(!tt(this))throw qt("getWriter");return Ze(this)}}function Ze(e){return new WritableStreamDefaultWriter(e)}function et(e){e._state="writable",e._storedError=void 0,e._writer=void 0,e._writableStreamController=void 0,e._writeRequests=new v,e._inFlightWriteRequest=void 0,e._closeRequest=void 0,e._inFlightCloseRequest=void 0,e._pendingAbortRequest=void 0,e._backpressure=!1}function tt(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_writableStreamController")&&e instanceof WritableStream)}function rt(e){return void 0!==e._writer}function ot(e,t){var r;if("closed"===e._state||"errored"===e._state)return c(void 0);e._writableStreamController._abortReason=t,null===(r=e._writableStreamController._abortController)||void 0===r||r.abort();const o=e._state;if("closed"===o||"errored"===o)return c(void 0);if(void 0!==e._pendingAbortRequest)return e._pendingAbortRequest._promise;let n=!1;"erroring"===o&&(n=!0,t=void 0);const a=u(((r,o)=>{e._pendingAbortRequest={_promise:void 0,_resolve:r,_reject:o,_reason:t,_wasAlreadyErroring:n}}));return e._pendingAbortRequest._promise=a,n||it(e,t),a}function nt(e){const t=e._state;if("closed"===t||"errored"===t)return d(new TypeError(`The stream (in ${t} state) is not in the writable state and cannot be closed`));const r=u(((t,r)=>{const o={_resolve:t,_reject:r};e._closeRequest=o})),o=e._writer;var n;return void 0!==o&&e._backpressure&&"writable"===t&&Lt(o),ue(n=e._writableStreamController,pt,0),wt(n),r}function at(e,t){"writable"!==e._state?lt(e):it(e,t)}function it(e,t){const r=e._writableStreamController;e._state="erroring",e._storedError=t;const o=e._writer;void 0!==o&&_t(o,t),!function(e){if(void 0===e._inFlightWriteRequest&&void 0===e._inFlightCloseRequest)return!1;return!0}(e)&&r._started&&lt(e)}function lt(e){e._state="errored",e._writableStreamController[B]();const t=e._storedError;if(e._writeRequests.forEach((e=>{e._reject(t)})),e._writeRequests=new v,void 0===e._pendingAbortRequest)return void ut(e);const r=e._pendingAbortRequest;if(e._pendingAbortRequest=void 0,r._wasAlreadyErroring)return r._reject(t),void ut(e);b(e._writableStreamController[O](r._reason),(()=>{r._resolve(),ut(e)}),(t=>{r._reject(t),ut(e)}))}function st(e){return void 0!==e._closeRequest||void 0!==e._inFlightCloseRequest}function ut(e){void 0!==e._closeRequest&&(e._closeRequest._reject(e._storedError),e._closeRequest=void 0);const t=e._writer;void 0!==t&&kt(t,e._storedError)}function ct(e,t){const r=e._writer;void 0!==r&&t!==e._backpressure&&(t?function(e){At(e)}(r):Lt(r)),e._backpressure=t}Object.defineProperties(WritableStream.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(WritableStream.prototype,t.toStringTag,{value:"WritableStream",configurable:!0});class WritableStreamDefaultWriter{constructor(e){if(D(e,1,"WritableStreamDefaultWriter"),Je(e,"First parameter"),rt(e))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=e,e._writer=this;const t=e._state;if("writable"===t)!st(e)&&e._backpressure?At(this):Ft(this),Ot(this);else if("erroring"===t)zt(this,e._storedError),Ot(this);else if("closed"===t)Ft(this),Ot(r=this),jt(r);else{const t=e._storedError;zt(this,t),Bt(this,t)}var r}get closed(){return dt(this)?this._closedPromise:d(Et("closed"))}get desiredSize(){if(!dt(this))throw Et("desiredSize");if(void 0===this._ownerWritableStream)throw Wt("desiredSize");return function(e){const t=e._ownerWritableStream,r=t._state;if("errored"===r||"erroring"===r)return null;if("closed"===r)return 0;return vt(t._writableStreamController)}(this)}get ready(){return dt(this)?this._readyPromise:d(Et("ready"))}abort(e){return dt(this)?void 0===this._ownerWritableStream?d(Wt("abort")):function(e,t){return ot(e._ownerWritableStream,t)}(this,e):d(Et("abort"))}close(){if(!dt(this))return d(Et("close"));const e=this._ownerWritableStream;return void 0===e?d(Wt("close")):st(e)?d(new TypeError("Cannot close an already-closing stream")):ft(this)}releaseLock(){if(!dt(this))throw Et("releaseLock");void 0!==this._ownerWritableStream&&ht(this)}write(e){return dt(this)?void 0===this._ownerWritableStream?d(Wt("write to")):mt(this,e):d(Et("write"))}}function dt(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_ownerWritableStream")&&e instanceof WritableStreamDefaultWriter)}function ft(e){return nt(e._ownerWritableStream)}function bt(e,t){"pending"===e._closedPromiseState?kt(e,t):function(e,t){Bt(e,t)}(e,t)}function _t(e,t){"pending"===e._readyPromiseState?It(e,t):function(e,t){zt(e,t)}(e,t)}function ht(e){const t=e._ownerWritableStream,r=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");_t(e,r),bt(e,r),t._writer=void 0,e._ownerWritableStream=void 0}function mt(e,t){const r=e._ownerWritableStream,o=r._writableStreamController,n=function(e,t){try{return e._strategySizeAlgorithm(t)}catch(t){return Rt(e,t),1}}(o,t);if(r!==e._ownerWritableStream)return d(Wt("write to"));const a=r._state;if("errored"===a)return d(r._storedError);if(st(r)||"closed"===a)return d(new TypeError("The stream is closing or closed and cannot be written to"));if("erroring"===a)return d(r._storedError);const i=function(e){return u(((t,r)=>{const o={_resolve:t,_reject:r};e._writeRequests.push(o)}))}(r);return function(e,t,r){try{ue(e,t,r)}catch(t){return void Rt(e,t)}const o=e._controlledWritableStream;if(!st(o)&&"writable"===o._state){ct(o,Tt(e))}wt(e)}(o,t,n),i}Object.defineProperties(WritableStreamDefaultWriter.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(WritableStreamDefaultWriter.prototype,t.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});const pt={};class WritableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!yt(this))throw Pt("abortReason");return this._abortReason}get signal(){if(!yt(this))throw Pt("signal");if(void 0===this._abortController)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(e){if(!yt(this))throw Pt("error");"writable"===this._controlledWritableStream._state&&Ct(this,e)}[O](e){const t=this._abortAlgorithm(e);return St(this),t}[B](){ce(this)}}function yt(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_controlledWritableStream")&&e instanceof WritableStreamDefaultController)}function gt(e,t,r,o,n,a,i,l){t._controlledWritableStream=e,e._writableStreamController=t,t._queue=void 0,t._queueTotalSize=void 0,ce(t),t._abortReason=void 0,t._abortController=function(){if(Ke)return new AbortController}(),t._started=!1,t._strategySizeAlgorithm=l,t._strategyHWM=i,t._writeAlgorithm=o,t._closeAlgorithm=n,t._abortAlgorithm=a;const s=Tt(t);ct(e,s);b(c(r()),(()=>{t._started=!0,wt(t)}),(r=>{t._started=!0,at(e,r)}))}function St(e){e._writeAlgorithm=void 0,e._closeAlgorithm=void 0,e._abortAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function vt(e){return e._strategyHWM-e._queueTotalSize}function wt(e){const t=e._controlledWritableStream;if(!e._started)return;if(void 0!==t._inFlightWriteRequest)return;if("erroring"===t._state)return void lt(t);if(0===e._queue.length)return;const r=e._queue.peek().value;r===pt?function(e){const t=e._controlledWritableStream;(function(e){e._inFlightCloseRequest=e._closeRequest,e._closeRequest=void 0})(t),se(e);const r=e._closeAlgorithm();St(e),b(r,(()=>{!function(e){e._inFlightCloseRequest._resolve(void 0),e._inFlightCloseRequest=void 0,"erroring"===e._state&&(e._storedError=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._resolve(),e._pendingAbortRequest=void 0)),e._state="closed";const t=e._writer;void 0!==t&&jt(t)}(t)}),(e=>{!function(e,t){e._inFlightCloseRequest._reject(t),e._inFlightCloseRequest=void 0,void 0!==e._pendingAbortRequest&&(e._pendingAbortRequest._reject(t),e._pendingAbortRequest=void 0),at(e,t)}(t,e)}))}(e):function(e,t){const r=e._controlledWritableStream;!function(e){e._inFlightWriteRequest=e._writeRequests.shift()}(r);b(e._writeAlgorithm(t),(()=>{!function(e){e._inFlightWriteRequest._resolve(void 0),e._inFlightWriteRequest=void 0}(r);const t=r._state;if(se(e),!st(r)&&"writable"===t){const t=Tt(e);ct(r,t)}wt(e)}),(t=>{"writable"===r._state&&St(e),function(e,t){e._inFlightWriteRequest._reject(t),e._inFlightWriteRequest=void 0,at(e,t)}(r,t)}))}(e,r)}function Rt(e,t){"writable"===e._controlledWritableStream._state&&Ct(e,t)}function Tt(e){return vt(e)<=0}function Ct(e,t){const r=e._controlledWritableStream;St(e),it(r,t)}function qt(e){return new TypeError(`WritableStream.prototype.${e} can only be used on a WritableStream`)}function Pt(e){return new TypeError(`WritableStreamDefaultController.prototype.${e} can only be used on a WritableStreamDefaultController`)}function Et(e){return new TypeError(`WritableStreamDefaultWriter.prototype.${e} can only be used on a WritableStreamDefaultWriter`)}function Wt(e){return new TypeError("Cannot "+e+" a stream using a released writer")}function Ot(e){e._closedPromise=u(((t,r)=>{e._closedPromise_resolve=t,e._closedPromise_reject=r,e._closedPromiseState="pending"}))}function Bt(e,t){Ot(e),kt(e,t)}function kt(e,t){void 0!==e._closedPromise_reject&&(p(e._closedPromise),e._closedPromise_reject(t),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="rejected")}function jt(e){void 0!==e._closedPromise_resolve&&(e._closedPromise_resolve(void 0),e._closedPromise_resolve=void 0,e._closedPromise_reject=void 0,e._closedPromiseState="resolved")}function At(e){e._readyPromise=u(((t,r)=>{e._readyPromise_resolve=t,e._readyPromise_reject=r})),e._readyPromiseState="pending"}function zt(e,t){At(e),It(e,t)}function Ft(e){At(e),Lt(e)}function It(e,t){void 0!==e._readyPromise_reject&&(p(e._readyPromise),e._readyPromise_reject(t),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="rejected")}function Lt(e){void 0!==e._readyPromise_resolve&&(e._readyPromise_resolve(void 0),e._readyPromise_resolve=void 0,e._readyPromise_reject=void 0,e._readyPromiseState="fulfilled")}Object.defineProperties(WritableStreamDefaultController.prototype,{error:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(WritableStreamDefaultController.prototype,t.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});const Dt="undefined"!=typeof DOMException?DOMException:void 0;const $t=function(e){if("function"!=typeof e&&"object"!=typeof e)return!1;try{return new e,!0}catch(e){return!1}}(Dt)?Dt:function(){const e=function(e,t){this.message=e||"",this.name=t||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)};return e.prototype=Object.create(Error.prototype),Object.defineProperty(e.prototype,"constructor",{value:e,writable:!0,configurable:!0}),e}();function Mt(e,t,o,n,a,i){const l=N(e),s=Ze(t);e._disturbed=!0;let m=!1,y=c(void 0);return u(((g,S)=>{let v;if(void 0!==i){if(v=()=>{const r=new $t("Aborted","AbortError"),o=[];n||o.push((()=>"writable"===t._state?ot(t,r):c(void 0))),a||o.push((()=>"readable"===e._state?dr(e,r):c(void 0))),E((()=>Promise.all(o.map((e=>e())))),!0,r)},i.aborted)return void v();i.addEventListener("abort",v)}var w,R,C;if(P(e,l._closedPromise,(e=>{n?W(!0,e):E((()=>ot(t,e)),!0,e)})),P(t,s._closedPromise,(t=>{a?W(!0,t):E((()=>dr(e,t)),!0,t)})),w=e,R=l._closedPromise,C=()=>{o?W():E((()=>function(e){const t=e._ownerWritableStream,r=t._state;return st(t)||"closed"===r?c(void 0):"errored"===r?d(t._storedError):ft(e)}(s)))},"closed"===w._state?C():_(R,C),st(t)||"closed"===t._state){const t=new TypeError("the destination writable stream closed before all data could be piped to it");a?W(!0,t):E((()=>dr(e,t)),!0,t)}function q(){const e=y;return f(y,(()=>e!==y?q():void 0))}function P(e,t,r){"errored"===e._state?r(e._storedError):h(t,r)}function E(e,r,o){function n(){b(e(),(()=>O(r,o)),(e=>O(!0,e)))}m||(m=!0,"writable"!==t._state||st(t)?n():_(q(),n))}function W(e,r){m||(m=!0,"writable"!==t._state||st(t)?O(e,r):_(q(),(()=>O(e,r))))}function O(e,t){ht(s),T(l),void 0!==i&&i.removeEventListener("abort",v),e?S(t):g(void 0)}p(u(((e,t)=>{!function o(n){n?e():f(m?c(!0):f(s._readyPromise,(()=>u(((e,t)=>{J(l,{_chunkSteps:t=>{y=f(mt(s,t),void 0,r),e(!1)},_closeSteps:()=>e(!0),_errorSteps:t})})))),o,t)}(!1)})))}))}class ReadableStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Qt(this))throw Kt("desiredSize");return Gt(this)}close(){if(!Qt(this))throw Kt("close");if(!Xt(this))throw new TypeError("The stream is not in a state that permits close");Ht(this)}enqueue(e){if(!Qt(this))throw Kt("enqueue");if(!Xt(this))throw new TypeError("The stream is not in a state that permits enqueue");return Vt(this,e)}error(e){if(!Qt(this))throw Kt("error");Ut(this,e)}[k](e){ce(this);const t=this._cancelAlgorithm(e);return Nt(this),t}[j](e){const t=this._controlledReadableStream;if(this._queue.length>0){const r=se(this);this._closeRequested&&0===this._queue.length?(Nt(this),fr(t)):Yt(this),e._chunkSteps(r)}else H(t,e),Yt(this)}}function Qt(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_controlledReadableStream")&&e instanceof ReadableStreamDefaultController)}function Yt(e){if(!xt(e))return;if(e._pulling)return void(e._pullAgain=!0);e._pulling=!0;b(e._pullAlgorithm(),(()=>{e._pulling=!1,e._pullAgain&&(e._pullAgain=!1,Yt(e))}),(t=>{Ut(e,t)}))}function xt(e){const t=e._controlledReadableStream;if(!Xt(e))return!1;if(!e._started)return!1;if(cr(t)&&U(t)>0)return!0;return Gt(e)>0}function Nt(e){e._pullAlgorithm=void 0,e._cancelAlgorithm=void 0,e._strategySizeAlgorithm=void 0}function Ht(e){if(!Xt(e))return;const t=e._controlledReadableStream;e._closeRequested=!0,0===e._queue.length&&(Nt(e),fr(t))}function Vt(e,t){if(!Xt(e))return;const r=e._controlledReadableStream;if(cr(r)&&U(r)>0)V(r,t,!1);else{let r;try{r=e._strategySizeAlgorithm(t)}catch(t){throw Ut(e,t),t}try{ue(e,t,r)}catch(t){throw Ut(e,t),t}}Yt(e)}function Ut(e,t){const r=e._controlledReadableStream;"readable"===r._state&&(ce(e),Nt(e),br(r,t))}function Gt(e){const t=e._controlledReadableStream._state;return"errored"===t?null:"closed"===t?0:e._strategyHWM-e._queueTotalSize}function Xt(e){const t=e._controlledReadableStream._state;return!e._closeRequested&&"readable"===t}function Jt(e,t,r,o,n,a,i){t._controlledReadableStream=e,t._queue=void 0,t._queueTotalSize=void 0,ce(t),t._started=!1,t._closeRequested=!1,t._pullAgain=!1,t._pulling=!1,t._strategySizeAlgorithm=i,t._strategyHWM=a,t._pullAlgorithm=o,t._cancelAlgorithm=n,e._readableStreamController=t;b(c(r()),(()=>{t._started=!0,Yt(t)}),(e=>{Ut(t,e)}))}function Kt(e){return new TypeError(`ReadableStreamDefaultController.prototype.${e} can only be used on a ReadableStreamDefaultController`)}function Zt(e,t){return de(e._readableStreamController)?function(e){let t,r,o,n,a,i=N(e),l=!1,s=!1,d=!1;const f=u((e=>{a=e}));function b(e){h(e._closedPromise,(t=>{e===i&&(Ee(o._readableStreamController,t),Ee(n._readableStreamController,t),s&&d||a(void 0))}))}function _(){$e(i)&&(T(i),i=N(e),b(i));J(i,{_chunkSteps:t=>{y((()=>{l=!1;const r=t;let i=t;if(!s&&!d)try{i=le(t)}catch(t){return Ee(o._readableStreamController,t),Ee(n._readableStreamController,t),void a(dr(e,t))}s||Pe(o._readableStreamController,r),d||Pe(n._readableStreamController,i)}))},_closeSteps:()=>{l=!1,s||qe(o._readableStreamController),d||qe(n._readableStreamController),o._readableStreamController._pendingPullIntos.length>0&&Be(o._readableStreamController,0),n._readableStreamController._pendingPullIntos.length>0&&Be(n._readableStreamController,0),s&&d||a(void 0)},_errorSteps:()=>{l=!1}})}function m(t,r){X(i)&&(T(i),i=Fe(e),b(i));const u=r?n:o,c=r?o:n;Me(i,t,{_chunkSteps:t=>{y((()=>{l=!1;const o=r?d:s;if(r?s:d)o||ke(u._readableStreamController,t);else{let r;try{r=le(t)}catch(t){return Ee(u._readableStreamController,t),Ee(c._readableStreamController,t),void a(dr(e,t))}o||ke(u._readableStreamController,t),Pe(c._readableStreamController,r)}}))},_closeSteps:e=>{l=!1;const t=r?d:s,o=r?s:d;t||qe(u._readableStreamController),o||qe(c._readableStreamController),void 0!==e&&(t||ke(u._readableStreamController,e),!o&&c._readableStreamController._pendingPullIntos.length>0&&Be(c._readableStreamController,0)),t&&o||a(void 0)},_errorSteps:()=>{l=!1}})}function p(){if(l)return c(void 0);l=!0;const e=We(o._readableStreamController);return null===e?_():m(e._view,!1),c(void 0)}function g(){if(l)return c(void 0);l=!0;const e=We(n._readableStreamController);return null===e?_():m(e._view,!0),c(void 0)}function S(o){if(s=!0,t=o,d){const o=ne([t,r]),n=dr(e,o);a(n)}return f}function v(o){if(d=!0,r=o,s){const o=ne([t,r]),n=dr(e,o);a(n)}return f}function w(){}return o=lr(w,p,S),n=lr(w,g,v),b(i),[o,n]}(e):function(e,t){const r=N(e);let o,n,a,i,l,s=!1,d=!1,f=!1;const b=u((e=>{l=e}));function _(){if(s)return c(void 0);s=!0;return J(r,{_chunkSteps:e=>{y((()=>{s=!1;const t=e,r=e;d||Vt(a._readableStreamController,t),f||Vt(i._readableStreamController,r)}))},_closeSteps:()=>{s=!1,d||Ht(a._readableStreamController),f||Ht(i._readableStreamController),d&&f||l(void 0)},_errorSteps:()=>{s=!1}}),c(void 0)}function m(t){if(d=!0,o=t,f){const t=ne([o,n]),r=dr(e,t);l(r)}return b}function p(t){if(f=!0,n=t,d){const t=ne([o,n]),r=dr(e,t);l(r)}return b}function g(){}return a=ir(g,_,m),i=ir(g,_,p),h(r._closedPromise,(e=>{Ut(a._readableStreamController,e),Ut(i._readableStreamController,e),d&&f||l(void 0)})),[a,i]}(e)}function er(e,t,r){return I(e,r),r=>S(e,t,[r])}function tr(e,t,r){return I(e,r),r=>S(e,t,[r])}function rr(e,t,r){return I(e,r),r=>g(e,t,[r])}function or(e,t){if("bytes"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamType`);return e}function nr(e,t){if("byob"!==(e=`${e}`))throw new TypeError(`${t} '${e}' is not a valid enumeration value for ReadableStreamReaderMode`);return e}function ar(e,t){F(e,t);const r=null==e?void 0:e.preventAbort,o=null==e?void 0:e.preventCancel,n=null==e?void 0:e.preventClose,a=null==e?void 0:e.signal;return void 0!==a&&function(e,t){if(!function(e){if("object"!=typeof e||null===e)return!1;try{return"boolean"==typeof e.aborted}catch(e){return!1}}(e))throw new TypeError(`${t} is not an AbortSignal.`)}(a,`${t} has member 'signal' that`),{preventAbort:Boolean(r),preventCancel:Boolean(o),preventClose:Boolean(n),signal:a}}Object.defineProperties(ReadableStreamDefaultController.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableStreamDefaultController.prototype,t.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});class ReadableStream{constructor(e={},t={}){void 0===e?e=null:L(e,"First parameter");const r=Ne(t,"Second parameter"),o=function(e,t){F(e,t);const r=e,o=null==r?void 0:r.autoAllocateChunkSize,n=null==r?void 0:r.cancel,a=null==r?void 0:r.pull,i=null==r?void 0:r.start,l=null==r?void 0:r.type;return{autoAllocateChunkSize:void 0===o?void 0:Y(o,`${t} has member 'autoAllocateChunkSize' that`),cancel:void 0===n?void 0:er(n,r,`${t} has member 'cancel' that`),pull:void 0===a?void 0:tr(a,r,`${t} has member 'pull' that`),start:void 0===i?void 0:rr(i,r,`${t} has member 'start' that`),type:void 0===l?void 0:or(l,`${t} has member 'type' that`)}}(e,"First parameter");if(sr(this),"bytes"===o.type){if(void 0!==r.size)throw new RangeError("The strategy for a byte stream cannot have a size function");!function(e,t,r){const o=Object.create(ReadableByteStreamController.prototype);let n=()=>{},a=()=>c(void 0),i=()=>c(void 0);void 0!==t.start&&(n=()=>t.start(o)),void 0!==t.pull&&(a=()=>t.pull(o)),void 0!==t.cancel&&(i=e=>t.cancel(e));const l=t.autoAllocateChunkSize;if(0===l)throw new TypeError("autoAllocateChunkSize must be greater than 0");je(e,o,n,a,i,r,l)}(this,o,Ye(r,0))}else{const e=xe(r);!function(e,t,r,o){const n=Object.create(ReadableStreamDefaultController.prototype);let a=()=>{},i=()=>c(void 0),l=()=>c(void 0);void 0!==t.start&&(a=()=>t.start(n)),void 0!==t.pull&&(i=()=>t.pull(n)),void 0!==t.cancel&&(l=e=>t.cancel(e)),Jt(e,n,a,i,l,r,o)}(this,o,Ye(r,1),e)}}get locked(){if(!ur(this))throw _r("locked");return cr(this)}cancel(e){return ur(this)?cr(this)?d(new TypeError("Cannot cancel a stream that already has a reader")):dr(this,e):d(_r("cancel"))}getReader(e){if(!ur(this))throw _r("getReader");return void 0===function(e,t){F(e,t);const r=null==e?void 0:e.mode;return{mode:void 0===r?void 0:nr(r,`${t} has member 'mode' that`)}}(e,"First parameter").mode?N(this):Fe(this)}pipeThrough(e,t={}){if(!ur(this))throw _r("pipeThrough");D(e,1,"pipeThrough");const r=function(e,t){F(e,t);const r=null==e?void 0:e.readable;$(r,"readable","ReadableWritablePair"),x(r,`${t} has member 'readable' that`);const o=null==e?void 0:e.writable;return $(o,"writable","ReadableWritablePair"),Je(o,`${t} has member 'writable' that`),{readable:r,writable:o}}(e,"First parameter"),o=ar(t,"Second parameter");if(cr(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(rt(r.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");return p(Mt(this,r.writable,o.preventClose,o.preventAbort,o.preventCancel,o.signal)),r.readable}pipeTo(e,t={}){if(!ur(this))return d(_r("pipeTo"));if(void 0===e)return d("Parameter 1 is required in 'pipeTo'.");if(!tt(e))return d(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let r;try{r=ar(t,"Second parameter")}catch(e){return d(e)}return cr(this)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):rt(e)?d(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Mt(this,e,r.preventClose,r.preventAbort,r.preventCancel,r.signal)}tee(){if(!ur(this))throw _r("tee");return ne(Zt(this))}values(e){if(!ur(this))throw _r("values");return function(e,t){const r=N(e),o=new Z(r,t),n=Object.create(ee);return n._asyncIteratorImpl=o,n}(this,function(e,t){F(e,t);const r=null==e?void 0:e.preventCancel;return{preventCancel:Boolean(r)}}(e,"First parameter").preventCancel)}}function ir(e,t,r,o=1,n=(()=>1)){const a=Object.create(ReadableStream.prototype);sr(a);return Jt(a,Object.create(ReadableStreamDefaultController.prototype),e,t,r,o,n),a}function lr(e,t,r){const o=Object.create(ReadableStream.prototype);sr(o);return je(o,Object.create(ReadableByteStreamController.prototype),e,t,r,0,void 0),o}function sr(e){e._state="readable",e._reader=void 0,e._storedError=void 0,e._disturbed=!1}function ur(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_readableStreamController")&&e instanceof ReadableStream)}function cr(e){return void 0!==e._reader}function dr(e,t){if(e._disturbed=!0,"closed"===e._state)return c(void 0);if("errored"===e._state)return d(e._storedError);fr(e);const o=e._reader;void 0!==o&&$e(o)&&(o._readIntoRequests.forEach((e=>{e._closeSteps(void 0)})),o._readIntoRequests=new v);return m(e._readableStreamController[k](t),r)}function fr(e){e._state="closed";const t=e._reader;void 0!==t&&(W(t),X(t)&&(t._readRequests.forEach((e=>{e._closeSteps()})),t._readRequests=new v))}function br(e,t){e._state="errored",e._storedError=t;const r=e._reader;void 0!==r&&(E(r,t),X(r)?(r._readRequests.forEach((e=>{e._errorSteps(t)})),r._readRequests=new v):(r._readIntoRequests.forEach((e=>{e._errorSteps(t)})),r._readIntoRequests=new v))}function _r(e){return new TypeError(`ReadableStream.prototype.${e} can only be used on a ReadableStream`)}function hr(e,t){F(e,t);const r=null==e?void 0:e.highWaterMark;return $(r,"highWaterMark","QueuingStrategyInit"),{highWaterMark:M(r)}}Object.defineProperties(ReadableStream.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ReadableStream.prototype,t.toStringTag,{value:"ReadableStream",configurable:!0}),"symbol"==typeof t.asyncIterator&&Object.defineProperty(ReadableStream.prototype,t.asyncIterator,{value:ReadableStream.prototype.values,writable:!0,configurable:!0});const mr=e=>e.byteLength;Object.defineProperty(mr,"name",{value:"size",configurable:!0});class ByteLengthQueuingStrategy{constructor(e){D(e,1,"ByteLengthQueuingStrategy"),e=hr(e,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!yr(this))throw pr("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!yr(this))throw pr("size");return mr}}function pr(e){return new TypeError(`ByteLengthQueuingStrategy.prototype.${e} can only be used on a ByteLengthQueuingStrategy`)}function yr(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_byteLengthQueuingStrategyHighWaterMark")&&e instanceof ByteLengthQueuingStrategy)}Object.defineProperties(ByteLengthQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(ByteLengthQueuingStrategy.prototype,t.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});const gr=()=>1;Object.defineProperty(gr,"name",{value:"size",configurable:!0});class CountQueuingStrategy{constructor(e){D(e,1,"CountQueuingStrategy"),e=hr(e,"First parameter"),this._countQueuingStrategyHighWaterMark=e.highWaterMark}get highWaterMark(){if(!vr(this))throw Sr("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!vr(this))throw Sr("size");return gr}}function Sr(e){return new TypeError(`CountQueuingStrategy.prototype.${e} can only be used on a CountQueuingStrategy`)}function vr(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_countQueuingStrategyHighWaterMark")&&e instanceof CountQueuingStrategy)}function wr(e,t,r){return I(e,r),r=>S(e,t,[r])}function Rr(e,t,r){return I(e,r),r=>g(e,t,[r])}function Tr(e,t,r){return I(e,r),(r,o)=>S(e,t,[r,o])}Object.defineProperties(CountQueuingStrategy.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(CountQueuingStrategy.prototype,t.toStringTag,{value:"CountQueuingStrategy",configurable:!0});class TransformStream{constructor(e={},t={},r={}){void 0===e&&(e=null);const o=Ne(t,"Second parameter"),n=Ne(r,"Third parameter"),a=function(e,t){F(e,t);const r=null==e?void 0:e.flush,o=null==e?void 0:e.readableType,n=null==e?void 0:e.start,a=null==e?void 0:e.transform,i=null==e?void 0:e.writableType;return{flush:void 0===r?void 0:wr(r,e,`${t} has member 'flush' that`),readableType:o,start:void 0===n?void 0:Rr(n,e,`${t} has member 'start' that`),transform:void 0===a?void 0:Tr(a,e,`${t} has member 'transform' that`),writableType:i}}(e,"First parameter");if(void 0!==a.readableType)throw new RangeError("Invalid readableType specified");if(void 0!==a.writableType)throw new RangeError("Invalid writableType specified");const i=Ye(n,0),l=xe(n),s=Ye(o,1),f=xe(o);let b;!function(e,t,r,o,n,a){function i(){return t}function l(t){return function(e,t){const r=e._transformStreamController;if(e._backpressure){return m(e._backpressureChangePromise,(()=>{const o=e._writable;if("erroring"===o._state)throw o._storedError;return kr(r,t)}))}return kr(r,t)}(e,t)}function s(t){return function(e,t){return qr(e,t),c(void 0)}(e,t)}function u(){return function(e){const t=e._readable,r=e._transformStreamController,o=r._flushAlgorithm();return Or(r),m(o,(()=>{if("errored"===t._state)throw t._storedError;Ht(t._readableStreamController)}),(r=>{throw qr(e,r),t._storedError}))}(e)}function d(){return function(e){return Er(e,!1),e._backpressureChangePromise}(e)}function f(t){return Pr(e,t),c(void 0)}e._writable=function(e,t,r,o,n=1,a=(()=>1)){const i=Object.create(WritableStream.prototype);return et(i),gt(i,Object.create(WritableStreamDefaultController.prototype),e,t,r,o,n,a),i}(i,l,u,s,r,o),e._readable=ir(i,d,f,n,a),e._backpressure=void 0,e._backpressureChangePromise=void 0,e._backpressureChangePromise_resolve=void 0,Er(e,!0),e._transformStreamController=void 0}(this,u((e=>{b=e})),s,f,i,l),function(e,t){const r=Object.create(TransformStreamDefaultController.prototype);let o=e=>{try{return Br(r,e),c(void 0)}catch(e){return d(e)}},n=()=>c(void 0);void 0!==t.transform&&(o=e=>t.transform(e,r));void 0!==t.flush&&(n=()=>t.flush(r));!function(e,t,r,o){t._controlledTransformStream=e,e._transformStreamController=t,t._transformAlgorithm=r,t._flushAlgorithm=o}(e,r,o,n)}(this,a),void 0!==a.start?b(a.start(this._transformStreamController)):b(void 0)}get readable(){if(!Cr(this))throw Ar("readable");return this._readable}get writable(){if(!Cr(this))throw Ar("writable");return this._writable}}function Cr(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_transformStreamController")&&e instanceof TransformStream)}function qr(e,t){Ut(e._readable._readableStreamController,t),Pr(e,t)}function Pr(e,t){Or(e._transformStreamController),Rt(e._writable._writableStreamController,t),e._backpressure&&Er(e,!1)}function Er(e,t){void 0!==e._backpressureChangePromise&&e._backpressureChangePromise_resolve(),e._backpressureChangePromise=u((t=>{e._backpressureChangePromise_resolve=t})),e._backpressure=t}Object.defineProperties(TransformStream.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(TransformStream.prototype,t.toStringTag,{value:"TransformStream",configurable:!0});class TransformStreamDefaultController{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Wr(this))throw jr("desiredSize");return Gt(this._controlledTransformStream._readable._readableStreamController)}enqueue(e){if(!Wr(this))throw jr("enqueue");Br(this,e)}error(e){if(!Wr(this))throw jr("error");var t;t=e,qr(this._controlledTransformStream,t)}terminate(){if(!Wr(this))throw jr("terminate");!function(e){const t=e._controlledTransformStream;Ht(t._readable._readableStreamController);const r=new TypeError("TransformStream terminated");Pr(t,r)}(this)}}function Wr(e){return!!o(e)&&(!!Object.prototype.hasOwnProperty.call(e,"_controlledTransformStream")&&e instanceof TransformStreamDefaultController)}function Or(e){e._transformAlgorithm=void 0,e._flushAlgorithm=void 0}function Br(e,t){const r=e._controlledTransformStream,o=r._readable._readableStreamController;if(!Xt(o))throw new TypeError("Readable side is not in a state that permits enqueue");try{Vt(o,t)}catch(e){throw Pr(r,e),r._readable._storedError}(function(e){return!xt(e)})(o)!==r._backpressure&&Er(r,!0)}function kr(e,t){return m(e._transformAlgorithm(t),void 0,(t=>{throw qr(e._controlledTransformStream,t),t}))}function jr(e){return new TypeError(`TransformStreamDefaultController.prototype.${e} can only be used on a TransformStreamDefaultController`)}function Ar(e){return new TypeError(`TransformStream.prototype.${e} can only be used on a TransformStream`)}Object.defineProperties(TransformStreamDefaultController.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),"symbol"==typeof t.toStringTag&&Object.defineProperty(TransformStreamDefaultController.prototype,t.toStringTag,{value:"TransformStreamDefaultController",configurable:!0}),e.ByteLengthQueuingStrategy=ByteLengthQueuingStrategy,e.CountQueuingStrategy=CountQueuingStrategy,e.ReadableByteStreamController=ReadableByteStreamController,e.ReadableStream=ReadableStream,e.ReadableStreamBYOBReader=ReadableStreamBYOBReader,e.ReadableStreamBYOBRequest=ReadableStreamBYOBRequest,e.ReadableStreamDefaultController=ReadableStreamDefaultController,e.ReadableStreamDefaultReader=ReadableStreamDefaultReader,e.TransformStream=TransformStream,e.TransformStreamDefaultController=TransformStreamDefaultController,e.WritableStream=WritableStream,e.WritableStreamDefaultController=WritableStreamDefaultController,e.WritableStreamDefaultWriter=WritableStreamDefaultWriter,Object.defineProperty(e,"__esModule",{value:!0})}));


/***/ }),

/***/ "../../node_modules/win-release/index.js":
/*!***********************************************!*\
  !*** ../../node_modules/win-release/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var os = __webpack_require__(/*! os */ "os");
var semver = __webpack_require__(/*! semver */ "../../node_modules/win-release/node_modules/semver/semver.js");

var nameMap = {
	'10.0': '10',
	'6.3': '8.1',
	'6.2': '8',
	'6.1': '7',
	'6.0': 'Vista',
	'5.1': 'XP',
	'5.0': '2000',
	'4.9': 'ME',
	'4.1': '98',
	'4.0': '95'
};

module.exports = function (release) {
	var verRe = /\d+\.\d+/;
	var version = verRe.exec(release || os.release());

	// workaround for Windows 10 on node < 3.1.0
	if (!release && process.platform === 'win32' &&
		semver.satisfies(process.version, '>=0.12.0 <3.1.0')) {
		try {
			version = verRe.exec(String((__webpack_require__(/*! child_process */ "child_process").execSync)('ver.exe', {timeout: 2000})));
		} catch (err) {}
	}

	if (release && !version) {
		throw new Error('`release` argument doesn\'t match `n.n`');
	}

	return nameMap[(version || [])[0]];
};


/***/ }),

/***/ "../../node_modules/win-release/node_modules/semver/semver.js":
/*!********************************************************************!*\
  !*** ../../node_modules/win-release/node_modules/semver/semver.js ***!
  \********************************************************************/
/***/ ((module, exports) => {

exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}


/***/ }),

/***/ "../../node_modules/wrappy/wrappy.js":
/*!*******************************************!*\
  !*** ../../node_modules/wrappy/wrappy.js ***!
  \*******************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "../shared/lib/command/index.js":
/*!**************************************!*\
  !*** ../shared/lib/command/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/config/index.js":
/*!*************************************!*\
  !*** ../shared/lib/config/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AppxLspConfig = void 0;
var AppxLspConfig;
(function (AppxLspConfig) {
    AppxLspConfig.disableAutoUpdateTypings = 'disableAutoUpdateTypings';
    AppxLspConfig.disableAutoUpdateResources = 'disableAutoUpdateResources';
    AppxLspConfig.enabledJSAPIComplete = 'enabledJSAPIComplete';
})(AppxLspConfig = exports.AppxLspConfig || (exports.AppxLspConfig = {}));


/***/ }),

/***/ "../shared/lib/constants.js":
/*!**********************************!*\
  !*** ../shared/lib/constants.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/data/NativeAPI.js":
/*!***************************************!*\
  !*** ../shared/lib/data/NativeAPI.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NativeAPI = void 0;
// generated by scripts/update-essentials.ts
// prettier-ignore
const NativeAPI = [{ "apiName": "a11yAnnouncement", "description": "读屏模式下主动朗读文本（如人脸识别时文字提示需要在读屏状态下主动朗读提示文字）", "documentation": "读屏模式下主动朗读文本", "name": "a11yAnnouncement", "parameters": { "in": [{ "documentation": "无障碍模式下需要提示的文本", "name": "text", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "ABTestExperimentParam", "name": "ABTestExperimentParam", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "appName", "optional": false, "type": "string" }, { "documentation": "", "name": "scenarioEntrance", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "btnHoldText", "optional": true, "type": "string" }, { "documentation": "", "name": "btnHoldNum", "optional": true, "type": "string" }, { "documentation": "", "name": "btnType", "optional": true, "type": "string" }, { "documentation": "", "name": "showName", "optional": true, "type": "string" }, { "documentation": "", "name": "channel", "optional": true, "type": "string" }, { "documentation": "", "name": "name", "optional": true, "type": "string" }, { "documentation": "", "name": "version", "optional": true, "type": "string" }, { "documentation": "", "name": "darId", "optional": true, "type": "string" }, { "documentation": "", "name": "mainTitle", "optional": true, "type": "string" }, { "documentation": "", "name": "subTitle", "optional": true, "type": "string" }, { "documentation": "", "name": "result", "optional": true }, { "documentation": "", "name": "showVersion", "optional": true, "type": "string" }, { "documentation": "", "name": "type", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "actionSheet", "documentation": "显示操作菜单的 API", "name": "actionSheet", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "菜单标题", "name": "title", "optional": true, "type": "string" }, { "documentation": "菜单按钮文字数组", "name": "btns", "optional": false, "type": "string[]" }, { "defaultValue": "取消", "documentation": "取消按钮文案。注：`Android` 平台此字段无效，不会显示取消按钮", "name": "cancelBtn", "optional": true, "type": "string" }, { "documentation": "（`iOS 特殊处理`）指定按钮的索引号，从 `0` 开始。使用场景：需要删除或清除数据等类似场景，默认为红色", "name": "destructiveBtnIndex", "optional": true, "type": "number" }, { "documentation": "需飘红选项的数组", "name": "badges", "optional": true, "type": "object" }], "type": "Object" }], "out": [] } }, { "apiName": "add2Favorite", "name": "add2Favorite", "parameters": { "in": [{ "name": "callSource", "optional": true, "type": "string" }], "out": [{}] } }, { "apiName": "addAppToHomeStage", "description": "", "documentation": "添加到首页", "name": "addAppToHomeStage", "parameters": { "in": [{ "documentation": "", "name": "appId", "optional": true, "type": "number" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "addCoupon", "name": "addCoupon", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "userId", "optional": true, "type": "string" }, { "documentation": "", "name": "templateId", "optional": true, "type": "string" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }, { "documentation": "", "name": "templateParams", "optional": true, "type": "string" }, { "documentation": "", "name": "title", "optional": true, "type": "string" }, { "documentation": "", "name": "subTitle", "optional": true, "type": "string" }, { "documentation": "", "name": "itemList", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "passId", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "addEventCal", "description": "startDate 和 endDate 要写成 YYYY-MM-DD hh:mm:ss 的形式", "documentation": "添加重要日", "name": "addEventCal", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "日历标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "开始时间", "name": "startDate", "optional": false, "type": "string" }, { "documentation": "结束时间", "name": "endDate", "optional": false, "type": "string" }, { "defaultValue": "0", "documentation": "循环发生次数，结合frequency一起使用", "name": "recurrenceTimes", "optional": true, "type": "number" }, { "documentation": "循环频率，结合recurrenceTimes一起使用", "name": "frequency", "optional": true, "type": "void | #$#" }, { "documentation": "事件发生地点", "name": "location", "optional": true, "type": "string" }, { "documentation": "事件内容", "name": "notes", "optional": true, "type": "string" }, { "defaultValue": "15", "documentation": "事件开始前多少分钟提醒", "name": "alarmOffset", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "addEventCalendar", "documentation": "添加日历事件", "name": "addEventCalendar", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "日历标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "优先将 startDate 按照日期转换到 UNIX 时间戳", "name": "startDate", "optional": true, "type": "string" }, { "documentation": "UNIX 时间戳", "name": "startTime", "optional": true, "type": "number" }, { "documentation": "结束日期", "name": "endDate", "optional": true, "type": "string" }, { "documentation": "优先将 startDate 按照日期转换到 UNIX 时间戳", "name": "endTime", "optional": true, "type": "number" }, { "documentation": "日历位置", "name": "location", "optional": true, "type": "string" }, { "documentation": "全天", "name": "allDay", "optional": true, "type": "boolean" }, { "documentation": "日历说明信息", "name": "notes", "optional": true, "type": "string" }, { "documentation": "日历说明信息", "name": "description", "optional": true, "type": "string" }, { "documentation": "日历提醒频率", "name": "frequency", "optional": true, "type": "string" }, { "documentation": "日历提醒频率\t", "name": "repeatInterval", "optional": true, "type": "string" }, { "documentation": "重复日历时间", "name": "recurrenceTimes", "optional": true, "type": "number" }, { "documentation": "停止重复时间", "name": "repeatEndTime", "optional": true, "type": "number" }, { "documentation": "是否开启闹钟", "name": "alarm", "optional": true, "type": "boolean" }, { "documentation": "闹钟提醒偏移量", "name": "alarmOffset", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "addFavorite", "name": "addFavorite", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "appIds", "optional": true, "type": "string[]" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "addFeedbackExtParams", "name": "addFeedbackExtParams", "parameters": { "in": [{ "documentation": "", "name": "params", "optional": true, "type": "object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "addFollow", "name": "addFollow", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": true, "type": "string" }, { "documentation": "", "name": "source", "optional": true, "type": "string" }, { "documentation": "", "name": "sourceId", "optional": true, "type": "string" }, { "documentation": "", "name": "extArgs", "optional": true, "type": "Record<string, string>" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "string" }] } }, { "apiName": "addFuCard", "description": "新春五福", "documentation": "新春五福", "name": "addFuCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "addMcdpModuleInfos", "description": "https://yuque.antfin-inc.com/wr08f6/ibwcqk/bl4h9m\n", "documentation": "添加本地存储的会场营销组件数据", "name": "addMcdpModuleInfos", "parameters": { "in": [{ "documentation": "需要缓存的批量组件数据，[moduleInfo1,moduleInfo2]", "name": "moduleInfoList", "optional": false, "type": "object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "存储是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "存储数据关键字段错误", "name": "errorMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "addMcdpModuleInfosMain", "name": "addMcdpModuleInfosMain", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "addMediaCreatorTaskAction", "name": "addMediaCreatorTaskAction", "parameters": { "in": [{}], "out": [] } }, { "apiName": "addNotifyListener", "description": "- 如果需要关闭监听，需要手动调用 [removeNotifyListener]()，为了保险，建议先做一次 remove 操作，避免多次 add 报错。\n- 通知监听仅在当前页面生效", "documentation": "监听客户端内全局通知", "name": "addNotifyListener", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "通知名一般必须以 `NEBULANOTIFY_` 为前缀", "documentation": "需要监听的通知名称", "name": "name", "optional": false, "type": "string" }, { "defaultValue": "true", "description": "- 如果为 false，则回调触发后将不会再监听同名通知，需要重新调用监听\n- 该属性在小程序上不支持，必须重新监听", "documentation": "回调是否允许触发多次", "name": "keep", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "被监听的通知事件结果", "name": "data", "optional": false, "type": "Record<string,any>" }] } }, { "apiName": "addPeripheralService", "documentation": "新增一个蓝牙外设服务", "name": "addPeripheralService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "服务 id。", "name": "serviceId", "optional": false, "type": "string" }, { "documentation": "特征值列表。", "name": "characteristics", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "addPhoneContact", "name": "addPhoneContact", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "姓氏", "name": "lastName", "optional": true, "type": "string" }, { "documentation": "中间名", "name": "middleName", "optional": true, "type": "string" }, { "documentation": "名字", "name": "firstName", "optional": true, "type": "string" }, { "documentation": "昵称", "name": "nickName", "optional": true, "type": "string" }, { "documentation": "备注", "name": "remark", "optional": true, "type": "string" }, { "documentation": "手机号", "name": "mobilePhoneNumber", "optional": true, "type": "string" }, { "documentation": "工作传真", "name": "workFaxNumber", "optional": true, "type": "string" }, { "documentation": "工作电话", "name": "workPhoneNumber", "optional": true, "type": "string" }, { "documentation": "公司电话", "name": "hostNumber", "optional": true, "type": "string" }, { "documentation": "住宅传真", "name": "homeFaxNumber", "optional": true, "type": "string" }, { "documentation": "住宅电话", "name": "homePhoneNumber", "optional": true, "type": "string" }, { "documentation": "微信号", "name": "weChatNumber", "optional": true, "type": "string" }, { "documentation": "支付宝账号", "name": "alipayAccount", "optional": true, "type": "string" }, { "name": "organization", "optional": true, "type": "string" }, { "name": "title", "optional": true, "type": "string" }, { "name": "email", "optional": true, "type": "string" }, { "name": "url", "optional": true, "type": "string" }, { "name": "addressCountry", "optional": true, "type": "string" }, { "name": "addressState", "optional": true, "type": "string" }, { "name": "addressCity", "optional": true, "type": "string" }, { "name": "addressStreet", "optional": true, "type": "string" }, { "name": "addressPostalCode", "optional": true, "type": "string" }, { "name": "workCountry", "optional": true, "type": "string" }, { "name": "workState", "optional": true, "type": "string" }, { "name": "workCity", "optional": true, "type": "string" }, { "name": "workStreet", "optional": true, "type": "string" }, { "name": "workPostalCode", "optional": true, "type": "string" }, { "name": "homeCountry", "optional": true, "type": "string" }, { "name": "homeState", "optional": true, "type": "string" }, { "name": "homeCity", "optional": true, "type": "string" }, { "name": "homeStreet", "optional": true, "type": "string" }, { "name": "homePostalCode", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "addPkgRes", "documentation": "加载指定 appId 的离线包", "name": "addPkgRes", "parameters": { "in": [{ "documentation": "离线包 appId", "name": "resAppId", "optional": false, "type": "string" }], "out": [{ "documentation": "资源包资源路径数组", "name": "urls", "optional": false, "type": "string[]" }] } }, { "apiName": "addScreenshotListener", "documentation": "监听用户截屏事件", "name": "addScreenshotListener", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "addTabBarItem", "name": "addTabBarItem", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "index", "optional": false, "type": "number" }, { "name": "text", "optional": false, "type": "string" }, { "name": "tag", "optional": false, "type": "string" }, { "name": "icon", "optional": false, "type": "string" }, { "name": "activeIcon", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "addToHomeFromMarket", "documentation": "添加到首页，没有疲劳度限制", "name": "addToHomeFromMarket", "parameters": { "in": [{}], "out": [] } }, { "apiName": "agreementConfirm", "name": "agreementConfirm", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "title", "optional": false, "type": "string" }, { "name": "message", "optional": false, "type": "string" }, { "name": "agreements", "optional": false, "type": "string[]" }, { "defaultValue": "left", "documentation": "显示内容的对齐方式", "name": "align", "optional": false, "type": "enum" }, { "defaultValue": "确定", "name": "okButton", "optional": true, "type": "string" }, { "defaultValue": "取消", "name": "cancelButton", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "alert", "documentation": "弹出警告框", "name": "alert", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "标题", "exampleValue": "测试标题", "name": "title", "optional": true, "supportInfo": {}, "type": "string" }, { "exampleValue": "测试信息", "name": "message", "optional": true, "type": "string" }, { "documentation": "对齐方式", "exampleValue": "center", "name": "align", "optional": true, "supportInfo": { "iosMinVersion": 10000005 }, "type": "enum" }, { "defaultValue": "确定", "documentation": "按钮文字", "exampleValue": "确定", "name": "button", "optional": true, "type": "string" }, { "documentation": "\"确认\" 按钮颜色，HEX 格式", "name": "confirmColor", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "alertImage", "documentation": "带图片的弹框组件", "name": "alertImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "标题（单图模式时传入无效）", "name": "title", "optional": true, "type": "string" }, { "documentation": "图片url，强制判断如果不传则回调无效参数", "name": "url", "optional": false, "type": "string" }, { "documentation": "信息（单图模式时传入无效）", "name": "message", "optional": true, "type": "string" }, { "documentation": "按钮文案（单图模式时传入无效）", "name": "buttons", "optional": true, "type": "string[]" }, { "defaultValue": "normalType", "documentation": "", "name": "type", "optional": false, "type": "enum" }], "type": "Object" }], "out": [] } }, { "apiName": "aliAutoLogin", "documentation": "淘系免登（包含淘宝、1688、微博等URL类型）", "name": "aliAutoLogin", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要免登的URL", "name": "H5AutoLoginUrl", "optional": false, "type": "string" }, { "description": "- 如果配置为 'NO' , 如果帐号没有绑定淘宝, 免登失败。接口要求帐号必须绑定过淘宝才算免登成功。\n- 10.1.2 及以上默认 'YES'\n- 10.1.2 几下默认 'NO'", "documentation": "是否允许出现绑定界面", "name": "H5AutoLoginNeedBindingPage", "optional": true, "type": "enum" }, { "documentation": "是否使用免登缓存", "name": "useCache", "optional": true, "supportInfo": { "androidMinVersion": 10000005, "iosMinVersion": 10000005 }, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "resultCode", "optional": false, "type": "string" }, { "name": "resultMemo", "optional": false, "type": "string" }, { "name": "sid", "optional": false, "type": "string" }, { "name": "ecode", "optional": false, "type": "string" }, { "name": "tbUserId", "optional": false, "type": "string" }, { "name": "tbNick", "optional": false, "type": "string" }, { "name": "redirectUrl", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "alipayContact", "name": "alipayContact", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayFavorite.addFavoriteItem", "documentation": "将指定 URL 添加到收藏", "name": "AlipayFavorite.addFavoriteItem", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "收藏的 URL", "name": "url", "optional": false, "type": "string" }, { "documentation": "标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "描述", "name": "desc", "optional": false, "type": "string" }, { "documentation": "头图", "name": "thumb", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "收藏结果是否成功", "name": "state", "optional": false, "type": "boolean" }] } }, { "apiName": "AlipayFavorite.deleteItem", "name": "AlipayFavorite.deleteItem", "parameters": { "in": [{ "documentation": "被收藏的 URL", "name": "url", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "删除是否成功", "name": "state", "optional": false, "type": "boolean" }, { "documentation": "删除结果", "name": "code", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "AlipayFavorite.isItemAdded", "documentation": "查询一个 URL 是否被收藏", "name": "AlipayFavorite.isItemAdded", "parameters": { "in": [{ "documentation": "被查询的 URL", "name": "url", "optional": false, "type": "string" }], "out": [{ "documentation": "该 URL 是否已经被收藏", "name": "state", "optional": false, "type": "boolean" }] } }, { "apiName": "AlipayNewYearNebulaPlugin.addFuCard", "description": "新春五福JSAPI", "documentation": "新春五福JSAPI", "name": "AlipayNewYearNebulaPlugin.addFuCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.fuCardList", "description": "新春五福", "documentation": "新春五福", "name": "AlipayNewYearNebulaPlugin.fuCardList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.fuCardTasks", "description": "新春五福", "documentation": "新春五福", "name": "AlipayNewYearNebulaPlugin.fuCardTasks", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.getUserFuCardStatus", "description": "新春五福接口，新春专用", "documentation": "新春五福接口，新春专用", "name": "AlipayNewYearNebulaPlugin.getUserFuCardStatus", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.refreshFuCardPage", "description": "新春五福", "documentation": "新春五福", "name": "AlipayNewYearNebulaPlugin.refreshFuCardPage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.removeFuCard", "description": "新春专用jsapi", "documentation": "新春专用jsapi", "name": "AlipayNewYearNebulaPlugin.removeFuCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayNewYearNebulaPlugin.showFuCard", "description": "五福jsapi", "documentation": "展示福卡", "name": "AlipayNewYearNebulaPlugin.showFuCard", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "base64之后的新pb序列化的字符串，由服务端下发", "documentation": "福卡序列化字符串", "name": "showFuCard", "optional": false, "type": "string" }, { "description": "用于区分来源，并且进行埋点统计", "documentation": "来源类型", "name": "sourceType", "optional": false, "type": "string" }, { "documentation": "是否关闭收下福卡后的toast", "name": "hideToast", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "福卡 toast 消失类型", "name": "toastViewDimiss", "optional": false, "type": "object" }, { "documentation": "收取福卡结果\n- true(或者YES、1) 表示点击收下\n- false(或者NO或者0) 表示关闭了弹窗", "name": "success", "optional": false, "type": "boolean | number | \"YES\" | \"NO\"" }], "type": "Object" }] } }, { "apiName": "AlipayNewYearNebulaPlugin.zodiacAwardStr", "description": "新春五福", "documentation": "新春五福", "name": "AlipayNewYearNebulaPlugin.zodiacAwardStr", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "AlipayTransfer.validateName", "documentation": "唤起姓名校验组件", "name": "AlipayTransfer.validateName", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要校验的账户 ID", "name": "userId", "optional": false, "type": "string" }, { "documentation": "需要校验的 \"名\"", "name": "userPartName", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "状态码", "name": "code", "optional": false, "type": "enum" }, { "documentation": "提示信息", "name": "message", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "allowSystemSnapshot", "name": "allowSystemSnapshot", "parameters": { "in": [{ "documentation": "是否运行截屏/录屏", "name": "allow", "optional": false, "type": "boolean" }], "out": [{ "documentation": "执行结果", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "AntManInsideMock", "documentation": "antman用来扫码mock的接口，不上线，慎用", "name": "AntManInsideMock", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "appendUCCorePerformanceData", "name": "appendUCCorePerformanceData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "applyPassFunc", "name": "applyPassFunc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "eventId", "optional": true, "type": "string" }, { "documentation": "", "name": "bizData", "optional": true, "type": "object" }, { "documentation": "", "name": "templateDic", "optional": true, "type": "object" }, { "documentation": "", "name": "traceInfo", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "needReload", "optional": false, "type": "boolean" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "applyUpdate", "name": "applyUpdate", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "appxrpc", "name": "appxrpc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "protocolParams", "optional": true, "type": "unknown" }, { "name": "protocols", "optional": true, "type": "Record<string,unknown>" }, { "documentation": "开关值: ta_appx_rpc_whitelist_cfg", "name": "operationType", "optional": false, "type": "string" }, { "documentation": "请求参数。", "name": "requestData", "optional": false, "type": "unknown[]" }, { "documentation": "请求头。", "name": "headers", "optional": true, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "documentation": "返回数据", "name": "property", "optional": false, "type": "unknown" }] } }, { "apiName": "APSocialNebulaPlugin.addFriend", "name": "APSocialNebulaPlugin.addFriend", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "来源", "name": "source", "optional": false, "type": "string" }, { "documentation": "对方的userId", "name": "userId", "optional": false, "type": "string" }, { "documentation": "对方的loginId", "name": "loginId", "optional": false, "type": "string" }, { "documentation": "场景名", "name": "sceneName", "optional": true, "type": "string" }], "type": "Object" }], "out": [] } }, { "apiName": "APSocialNebulaPlugin.clearHiChatSessionMsg", "documentation": "清空bc聊天盒子入口", "name": "APSocialNebulaPlugin.clearHiChatSessionMsg", "parameters": { "in": [{ "documentation": "要清空的盒子类型。 比如我的顾客盒子，就填115", "name": "sessionType", "optional": false, "type": "unknown" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "APSocialNebulaPlugin.getGeneralPageSettings", "description": "包括useMic、useRefreshSound、useBackKey（仅安卓）", "documentation": "获取通用设置页相关开关状态", "name": "APSocialNebulaPlugin.getGeneralPageSettings", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "resultCode", "optional": false, "type": "number" }, { "name": "useMic", "optional": true, "type": "boolean" }, { "name": "useRefreshSound", "optional": true, "type": "boolean" }, { "name": "useBackKey", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.getHiChatItemInfo", "name": "APSocialNebulaPlugin.getHiChatItemInfo", "parameters": { "in": [{}], "out": [] } }, { "apiName": "APSocialNebulaPlugin.getHiChatSessionInfo", "documentation": "获取生活小贴士会话信息", "name": "APSocialNebulaPlugin.getHiChatSessionInfo", "parameters": { "in": [{}], "out": [] } }, { "apiName": "APSocialNebulaPlugin.isMyFriend", "documentation": "查询一个用户是否是当前用户好友", "name": "APSocialNebulaPlugin.isMyFriend", "parameters": { "in": [{ "documentation": "被查询的用户userId", "name": "userId", "optional": false, "type": "string" }], "out": [{ "documentation": "被查询的用户是否是当前用户好友", "name": "isMyFriend", "optional": false, "type": "boolean" }] } }, { "apiName": "APSocialNebulaPlugin.isNotificationDialogAllowed", "name": "APSocialNebulaPlugin.isNotificationDialogAllowed", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "result", "optional": false, "type": "number | string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.mockChatMessage", "documentation": "业务可以通过mobilechat返回的mock会话消息jsonString，在客户端mock一条本地消息", "name": "APSocialNebulaPlugin.mockChatMessage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "APSocialNebulaPlugin.modifyMerchantMsgSubscribeStatus", "documentation": "已废弃，代码已删除", "name": "APSocialNebulaPlugin.modifyMerchantMsgSubscribeStatus", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultDesc", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.queryAllGtd", "name": "APSocialNebulaPlugin.queryAllGtd", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "string" }, { "documentation": "", "name": "gtdDicArray", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.queryAndSelectAccount", "name": "APSocialNebulaPlugin.queryAndSelectAccount", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "queryStr", "optional": false, "type": "string" }, { "documentation": "", "name": "hideErrorTips", "optional": true, "type": "string" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }, { "documentation": "", "name": "hideErrorTip", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "contactsDicArray", "optional": false, "type": "object" }] } }, { "apiName": "APSocialNebulaPlugin.queryBCChatSchema", "name": "APSocialNebulaPlugin.queryBCChatSchema", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "businessId", "optional": false, "type": "string" }, { "documentation": "", "name": "bcRoleType", "optional": false, "type": "string" }, { "documentation": "", "name": "relationType", "optional": false, "type": "string" }, { "documentation": "", "name": "showLoading", "optional": true, "type": "string" }, { "documentation": "", "name": "shouldJump", "optional": true, "type": "string" }, { "documentation": "", "name": "extInfo", "optional": false, "type": "string" }, { "documentation": "", "name": "source", "optional": true, "type": "string" }, { "documentation": "", "name": "userId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "memo", "optional": false, "type": "string" }, { "documentation": "", "name": "resultStatus", "optional": false, "type": "number" }, { "documentation": "", "name": "targetSchema", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.queryExistingAccounts", "documentation": "查询社交本地联系人", "name": "APSocialNebulaPlugin.queryExistingAccounts", "parameters": { "in": [{ "documentation": "用户 userId", "name": "uids", "optional": false, "type": "string[]" }], "out": [{ "documentation": "", "name": "contactsDicArray", "optional": false, "type": "object" }] } }, { "apiName": "APSocialNebulaPlugin.queryFriendAndKnownMobileContactList", "documentation": "H5调用查询双向混合联系人", "name": "APSocialNebulaPlugin.queryFriendAndKnownMobileContactList", "parameters": { "in": [{ "name": "new0", "optional": false, "type": "unknown" }], "out": [{ "documentation": "", "name": "contactsDicArray", "optional": false, "type": "object" }] } }, { "apiName": "APSocialNebulaPlugin.queryMobileContactAuthStatus", "description": "目前无业务调用", "documentation": "查询是否有读取手机联系人权限", "name": "APSocialNebulaPlugin.queryMobileContactAuthStatus", "parameters": { "in": [{}], "out": [{ "documentation": "1：已授权，2：没授权", "name": "authStatus", "optional": false, "type": "number" }] } }, { "apiName": "APSocialNebulaPlugin.queryRecentAutoFold", "documentation": "已废弃，代码已删除", "name": "APSocialNebulaPlugin.queryRecentAutoFold", "parameters": { "in": [{}], "out": [] } }, { "apiName": "APSocialNebulaPlugin.queryRecentSession", "description": "五福福卡榜使用", "documentation": "获取最近联系人", "name": "APSocialNebulaPlugin.queryRecentSession", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "联系人类型：\ncontact：联系人\ngroup：群\nboth：两者皆有", "name": "contactsType", "optional": false, "type": "string" }, { "documentation": "业务来源", "name": "source", "optional": false, "type": "string" }], "type": "Object" }], "out": [] } }, { "apiName": "APSocialNebulaPlugin.queryRecentStatusExternal", "name": "APSocialNebulaPlugin.queryRecentStatusExternal", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "itemType", "optional": false, "type": "string" }, { "documentation": "", "name": "itemId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "gtdLabelType", "optional": false, "type": "number" }, { "documentation": "", "name": "itemType", "optional": false, "type": "string" }, { "documentation": "", "name": "highlightBizMemo", "optional": false, "type": "boolean" }, { "documentation": "", "name": "gtdShow", "optional": false, "type": "boolean" }, { "documentation": "", "name": "bizMemoColor", "optional": false, "type": "string" }, { "documentation": "", "name": "itemId", "optional": false, "type": "string" }, { "documentation": "", "name": "gtdExpireTime", "optional": false, "type": "number" }, { "documentation": "", "name": "hasFoldRedPoint", "optional": false, "type": "boolean" }, { "documentation": "", "name": "displayName", "optional": false, "type": "string" }, { "documentation": "", "name": "icon", "optional": false, "type": "string" }, { "documentation": "", "name": "recentDisplayType", "optional": false, "type": "string" }, { "documentation": "", "name": "unreadAcc", "optional": false, "type": "boolean" }, { "documentation": "", "name": "lastClickTime", "optional": false, "type": "number" }, { "documentation": "", "name": "uri", "optional": false, "type": "string" }, { "documentation": "", "name": "clientMsgID", "optional": false, "type": "string" }, { "documentation": "", "name": "messageArrivedTime", "optional": false, "type": "number" }, { "documentation": "", "name": "gtdCreateTime", "optional": false, "type": "number" }, { "documentation": "", "name": "itemLabelStartTime", "optional": false, "type": "number" }, { "documentation": "", "name": "redPointStyle", "optional": false, "type": "string" }, { "documentation": "", "name": "unread", "optional": false, "type": "number" }, { "documentation": "", "name": "itemLabelExpireTime", "optional": false, "type": "number" }, { "documentation": "", "name": "notDisturb", "optional": false, "type": "boolean" }, { "documentation": "", "name": "bizMemo", "optional": false, "type": "string" }, { "documentation": "", "name": "messageSide", "optional": false, "type": "number" }, { "documentation": "", "name": "gtdLabelPriority", "optional": false, "type": "number" }, { "documentation": "", "name": "statusCode", "optional": false, "type": "number" }, { "documentation": "", "name": "hasManualConfigedShowInTab", "optional": false, "type": "boolean" }, { "documentation": "", "name": "createTime", "optional": false, "type": "number" }, { "documentation": "", "name": "needCheckSubscribe", "optional": false, "type": "boolean" }, { "documentation": "", "name": "redPointStyleV2", "optional": false, "type": "number" }, { "documentation": "", "name": "version", "optional": true, "type": "string" }, { "documentation": "", "name": "extraInfo", "optional": true, "type": "string" }, { "documentation": "", "name": "lifeFollowStatus", "optional": true, "type": "string" }, { "documentation": "", "name": "subscribeMap", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.rewardJsApi", "documentation": "H5打赏接口", "name": "APSocialNebulaPlugin.rewardJsApi", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务Id", "name": "bizNo", "optional": false, "type": "string" }, { "documentation": "业务类型，新业务接入由打赏服务端指定该值", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "业务子类型，新业务接入由打赏服务端指定该值", "name": "bizSubType", "optional": false, "type": "string" }, { "documentation": "被打赏人的性别", "name": "gender", "optional": false, "type": "string" }, { "documentation": "被打赏人的头像", "name": "headIconUrl", "optional": false, "type": "string" }, { "documentation": "场景id，新业务接入由打赏服务端指定该值", "name": "rewardSceneId", "optional": false, "type": "string" }, { "documentation": "业务方透传给业务服务端的字段（json格式）", "name": "ext", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "打赏结果，\"1\"成功，其他失败", "name": "resState", "optional": false, "type": "string" }, { "documentation": "调用打赏服务端创建订单的结果状态吗", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "打赏失败错误提示文案", "name": "erroMemo", "optional": false, "type": "string" }, { "documentation": "服务端协议的打赏Id", "name": "rewardId", "optional": false, "type": "string" }, { "documentation": "打赏人Id", "name": "userId", "optional": false, "type": "string" }, { "documentation": "打赏人loginId", "name": "logonId", "optional": false, "type": "string" }, { "name": "topic", "optional": false, "type": "string" }, { "documentation": "打赏订单号", "name": "bill_no", "optional": false, "type": "string" }, { "documentation": "打赏金额", "name": "rewardMoney", "optional": false, "type": "string" }, { "name": "clientId", "optional": false, "type": "string" }, { "name": "bizType", "optional": false, "type": "string" }, { "name": "timeResp", "optional": false, "type": "string" }, { "name": "sceneCode", "optional": false, "type": "string" }, { "documentation": "其他预留参数（Map）", "name": "extend", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.selectContactJSAPI", "description": "", "documentation": "选择支付宝联系人", "name": "APSocialNebulaPlugin.selectContactJSAPI", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "single", "documentation": "选择类型", "name": "type", "optional": true, "type": "object" }, { "name": "model", "optional": true, "type": "\"friend\"" }, { "documentation": "是否包含自己", "name": "withMe", "optional": true, "type": "boolean" }, { "documentation": "最大选择人数，仅 `type=multi` 的时候有效", "name": "multiMax", "optional": true, "type": "number" }, { "documentation": "多选达到上限的提示内容", "name": "multiMaxTips", "optional": true, "type": "string" }, { "name": "multiChooseMaxTips", "optional": true, "type": "string" }, { "documentation": "是否包含双向手机联系人", "name": "showKnownMobileContact", "optional": true, "type": "boolean" }, { "documentation": "是否包含手机联系人，showKnownMobileContact 优先级更高", "name": "showMobileContact", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "返回用户信息", "name": "contactsDicArray", "optional": false, "type": "object" }] } }, { "apiName": "APSocialNebulaPlugin.sendSocialMsgDialog", "description": "弹窗仅支持 文字、图片+文字描述两种样式", "documentation": "发送消息组件", "name": "APSocialNebulaPlugin.sendSocialMsgDialog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "用户 id", "name": "targetId", "optional": false, "type": "string" }, { "documentation": "用户 类型", "name": "targetType", "optional": false, "type": "string" }, { "documentation": "弹窗类型", "name": "dialogType", "optional": false, "type": "string" }, { "documentation": "预览图片", "name": "imageUrl", "optional": false, "type": "string" }, { "documentation": "描述", "name": "desc", "optional": false, "type": "string" }, { "documentation": "标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "业务来源", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "盒子透出memo", "name": "bizMemo", "optional": false, "type": "string" }, { "documentation": "消息模版类型", "name": "templateCode", "optional": false, "type": "string" }, { "documentation": "消息体展示", "name": "templateData", "optional": false, "type": "string" }, { "documentation": "跳转链接", "name": "link", "optional": true, "type": "string" }, { "documentation": "push配置", "name": "notifyParam", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "errorCode", "optional": false, "type": "number" }, { "documentation": "", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.setGeneralPageSetting", "description": "包括useMic、useRefreshSound、useBackKey（仅安卓）", "documentation": "设置通用设置页相关开关状态", "name": "APSocialNebulaPlugin.setGeneralPageSetting", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "使用听筒播放语音\n\"true\"/\"false\"", "name": "useMic", "optional": true, "type": "string" }, { "documentation": "刷新音效\n\"true\"/\"false\"", "name": "useRefreshSound", "optional": true, "type": "string" }, { "documentation": "回车键发送消息\n\"true\"/\"false\"", "name": "useBackKey", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "成功：100\n失败：错误码 400", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "resultCode=400 的时返回：\n\"检查传参正确性，useMic || useRefreshSound || useBackKey\"", "name": "resultDesc", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.setHiChatSessionBlacked", "documentation": "设置BC会话黑名单JSAPI", "name": "APSocialNebulaPlugin.setHiChatSessionBlacked", "parameters": { "in": [{}], "out": [] } }, { "apiName": "APSocialNebulaPlugin.setNotificationDialogShowed", "name": "APSocialNebulaPlugin.setNotificationDialogShowed", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "APSocialNebulaPlugin.setRecentAutoFold", "name": "APSocialNebulaPlugin.setRecentAutoFold", "parameters": { "in": [{}], "out": [] } }, { "apiName": "APSocialNebulaPlugin.shareMessageDirect", "documentation": "H5页面发送消息的接口", "name": "APSocialNebulaPlugin.shareMessageDirect", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "目标的id，群/讨论组（groupId）、个人（userId）", "name": "targetId", "optional": false, "type": "string" }, { "documentation": "目标的类型，群（”2“）、个人（”1“），讨论组（“3”）", "name": "targetType", "optional": false, "type": "string" }, { "documentation": "目标的loginId，个人的话才有此字段", "name": "loginId", "optional": false, "type": "string" }, { "documentation": "是否显示弹框，“0”不弹框，“1”弹框（默认弹框", "name": "showAlert", "optional": false, "type": "string" }, { "documentation": "弹框上的名字描述，个人（个人的名字）、群/讨论组（名字） ，showAlert为“1”时，这个字段才有意义", "name": "targetName", "optional": false, "type": "string" }, { "documentation": "弹框的logo，个人（头像）、群/讨论组（群头像），showAlert为“1”时，这个字段才有意义", "name": "targetLogo", "optional": false, "type": "string" }, { "documentation": "目标的个数，群和讨论组的话才有此字段，showAlert为“1”时，这个字段才有意义", "name": "memberCount", "optional": false, "type": "string" }, { "documentation": "文本消息类型:text，普通图片类型：image，GIF图片类型：gif，", "name": "messageType", "optional": false, "type": "string" }, { "documentation": "messageType为image，且emoji为y时，图片当成表情发送。", "name": "emoji", "optional": false, "type": "string" }, { "documentation": "如果是text类型，就是文本的内容，如果是普通图片和gif就是图片字节数据（经Base64编码后的字符串）", "name": "message", "optional": false, "type": "string" }, { "documentation": "小尾巴的logo", "name": "appIcon", "optional": false, "type": "string" }, { "documentation": "小尾巴后面的名字或者描述", "name": "appName", "optional": false, "type": "string" }, { "documentation": "点击小尾巴后跳转的链接\t可选", "name": "appLink", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultDesc", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.shouldShowAcceptFriendWithUserId", "documentation": "是否显示接受好友请求", "name": "APSocialNebulaPlugin.shouldShowAcceptFriendWithUserId", "parameters": { "in": [{ "documentation": "对方userId", "name": "userId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "shouldShowAcceptFriend", "optional": false, "type": "boolean" }, { "documentation": "", "name": "checkDefaultValue", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.showShareDialog", "description": "弹窗仅支持 文字、图片、链接、图片+文字描述四种样式", "documentation": "用于展示同分享、转发一致样式的弹窗", "name": "APSocialNebulaPlugin.showShareDialog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "canInputExtra", "optional": false, "type": "boolean" }, { "documentation": "", "name": "shareObject", "optional": false, "type": "object" }, { "documentation": "", "name": "shareTargets", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "action", "optional": false, "type": "string" }, { "documentation": "", "name": "userInput", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.subscribeMsg", "description": "- 开发者应在用户操作后拉起订阅组件，不应在加载页面过程中拉起，保证良好的用户体验\n- 订阅组件支持内部H5调用，调用方为可信任的一二方H5，订阅消息的主体需要在参数内指定（appId）\n- 根据模板类型和具体case，如无需用户选择，则不会弹出订阅组件弹窗，直接返回，h5端不感知\n- 取消订阅可以使用 [APSocialNebulaPlugin.unsubscribeMsg]()", "documentation": "消息订阅弹窗组件", "name": "APSocialNebulaPlugin.subscribeMsg", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "订阅者主体 appId", "name": "appId", "optional": false, "type": "string" }, { "description": "- 一次性最多传入三个模板id\n- 一次性模板 id 和长期性模板 id 不可同时使用", "documentation": "模板ID列表", "name": "entityIds", "optional": false, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "- 用户点击 \"取消\" 返回 false\n- 用户点击 \"拒绝\" 返回 true（点击拒绝实际上也执行了订阅的过程，只不过提交的类型是 \"不订阅\"）\n- 其他异常返回 false", "documentation": "本次订阅动作是否成功", "name": "success", "optional": false, "type": "boolean" }, { "description": "- 订阅的所有模板此前已勾选或者点击了 \"不再询问\"，再次调用订阅组件则不会弹出订阅弹层", "documentation": "本次订阅过程是否弹出订阅组件弹层", "name": "show", "optional": true, "supportInfo": { "androidMinVersion": 10002003, "iosMinVersion": 10002003 }, "type": "boolean" }, { "documentation": "订阅单次模板时操作 \"记住以上选择，不再询问\"+\"同意\"", "name": "keep", "optional": true, "supportInfo": { "androidMinVersion": 10002003, "iosMinVersion": 10002003 }, "type": "boolean" }, { "documentation": "订阅长期模板时操作 \"拒绝不在询问\"", "name": "reject", "optional": true, "supportInfo": { "androidMinVersion": 10002003, "iosMinVersion": 10002003 }, "type": "boolean" }, { "documentation": "模板ID对应状态", "name": "entityId", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "APSocialNebulaPlugin.subscribleMsg", "description": "", "documentation": "消息订阅弹窗组件", "name": "APSocialNebulaPlugin.subscribleMsg", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "订阅者主体 appId", "name": "appId", "optional": false, "type": "string" }, { "description": "- 一次性最多传入三个模板id\n- 一次性模板 id 和长期性模板 id 不可同时使用", "documentation": "模板ID列表", "name": "entityIds", "optional": false, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "本次订阅动作是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "APSocialNebulaPlugin.unsubscribeMsg", "name": "APSocialNebulaPlugin.unsubscribeMsg", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "订阅者主体 appId", "name": "appId", "optional": false, "type": "string" }, { "description": "- 一次性最多传入三个模板id", "documentation": "需要退订的模板ID列表", "name": "entityIds", "optional": false, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "本次退订动作是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "APSocialNebulaPlugin.updateGtd", "description": "点击待办card，需要标记为已处理时，需要修改本地数据", "documentation": "更新某一条待办", "name": "APSocialNebulaPlugin.updateGtd", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "消息体里groupId", "name": "groupId", "optional": false, "type": "string" }, { "documentation": "消息体里的msgId", "name": "msgId", "optional": false, "type": "string" }, { "defaultValue": "1", "documentation": "1：已处理(目前只支持传1)", "name": "operationState", "optional": false, "type": "number" }], "type": "Object" }], "out": [{}] } }, { "apiName": "APSocialNebulaPlugin.updateMockChatMessage", "name": "APSocialNebulaPlugin.updateMockChatMessage", "parameters": { "in": [{}], "out": [] } }, { "apiName": "archiveRpc", "documentation": "档案rpc接口，内部有封装核身和数据加密逻辑", "name": "archiveRpc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "{}", "documentation": "跟调用my.call('rpc')的传参一样", "exampleValue": "{ \toperationType: 'com.alipay.govdataprod.service.votemng.verifyCheck', \trequestData: [{ \t\taaa: xxx, \t}] }", "name": "rpcParams", "optional": false, "type": "unknown" }, { "defaultValue": "false", "documentation": "是否需要加密数据", "exampleValue": "true", "name": "needEncrypt", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "1000\trpc请求成功，会返回rpcResultData\n1001\trpc发生错误，具体错误码为rpcCode\n1002\t核身发生错误，具体错误码为verifyCode。\n1003\t入参格式错误\n1004\t在核身页面点击返回,需要0.3s后popWindow", "exampleValue": "1000", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "rpc错误码", "exampleValue": "1002", "name": "rpcCode", "optional": false, "type": "string" }, { "documentation": "核身错误码", "exampleValue": "1003", "name": "verifyCode", "optional": false, "type": "string" }, { "documentation": "结果描述", "exampleValue": "核身错误", "name": "resultDesc", "optional": false, "type": "string" }, { "documentation": "rpc返回数据", "exampleValue": "{success: false, errCode: 1003}", "name": "rpcResultData", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "archiveService", "description": "目前暂不支持加密，只有rpc+核身", "documentation": "档案服务JSAPI，主要用于加密rpc和核身", "name": "archiveService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "{}", "documentation": "调用my.call('rpc')的传参", "exampleValue": "{ \toperationType: 'com.alipay.govdataprod.service.votemng.verifyCheck', \trequestData: [{ \t\taaa: xxx, \t}] }", "name": "rpcParams", "optional": false, "type": "unknown" }, { "defaultValue": "false", "documentation": "是否需要加密", "exampleValue": "false", "name": "needEncrypt", "optional": false, "type": "boolean" }, { "defaultValue": "", "documentation": "核身页面的title", "exampleValue": "个人信息", "name": "title", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "1000\trpc请求成功，会返回rpcResultData\n1001\trpc发生错误\n1002\t核身发生错误，具体错误码为verifyCode。\n1003\t入参格式错误\n1004\t在核身页面点击返回,需要0.3s后popWindow\n1005\t该rpc请求被放弃（目前archiveRpc-jsapi，不支持并发处理rpc）", "exampleValue": "1000", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "具体参考verifyIdentity的结果码", "exampleValue": "1001", "name": "verifyCode", "optional": false, "type": "string" }, { "documentation": "结果描述，但不可直接展示给用户", "exampleValue": "系统异常，请稍后再试", "name": "resultDesc", "optional": false, "type": "string" }, { "documentation": "rpc返回数据", "exampleValue": "{success: true}", "name": "rpcResultData", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "aTripGetDensity", "name": "aTripGetDensity", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "aTripGetSHMetroCode", "documentation": "获取上海地铁乘车码码值", "name": "aTripGetSHMetroCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定票种，无参或者传空返回单人票的码值", "name": "ticketType", "optional": true, "type": "string" }, { "documentation": "卡类型", "name": "cardType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "码值", "name": "code", "optional": true, "type": "string" }] } }, { "apiName": "aTripGetTrainDate", "name": "aTripGetTrainDate", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "dateStr", "optional": false, "type": "string" }] } }, { "apiName": "aTripGetTrainScheduleList", "name": "aTripGetTrainScheduleList", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "scheduleList", "optional": false, "type": "object" }] } }, { "apiName": "aTripSetTrainDate", "name": "aTripSetTrainDate", "parameters": { "in": [{ "documentation": "", "name": "dateStr", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "string | boolean" }] } }, { "apiName": "aTripSetTrainScheduleList", "name": "aTripSetTrainScheduleList", "parameters": { "in": [{ "documentation": "", "name": "scheduleList", "optional": false, "type": "object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "aTripSHMetroBOM", "documentation": "上海地铁乘车码数据回写", "name": "aTripSHMetroBOM", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用区数据", "name": "data", "optional": false, "type": "string" }, { "documentation": "票种", "name": "ticketType", "optional": true, "type": "string" }, { "documentation": "卡类型", "name": "cardType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "aTripStationHistory", "name": "aTripStationHistory", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "action", "optional": false, "type": "string" }, { "documentation": "", "name": "stationList", "optional": true, "type": "string | #$#" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "stationList", "optional": true, "type": "object" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "authMapLocation", "name": "authMapLocation", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "authorize", "name": "authorize", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "beehiveGetPOI", "documentation": "使用支付宝内置地图选择地理位置", "name": "beehiveGetPOI", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "是否显示tab页", "name": "showTab", "optional": true, "type": "boolean" }, { "documentation": "发送按钮文案", "name": "sendBtnText", "optional": true, "type": "string" }, { "documentation": "页面显示标题", "name": "title", "optional": true, "type": "string" }, { "documentation": "预设纬度 传入该参数将自动定位到该点", "name": "latitude", "optional": true, "type": "number" }, { "documentation": "预设经度 传入该参数将自动定位到该点", "name": "longitude", "optional": true, "type": "number" }, { "documentation": "", "name": "mode", "optional": false, "type": "enum" }, { "documentation": "mode为noMap时, 是否展示\"不显示位置\"", "name": "showHideLocation", "optional": true, "type": "boolean" }, { "documentation": "mode为noMap时, 是否展示模糊城市名", "name": "showLocatedCity", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "兴趣点id", "name": "poiId", "optional": true, "type": "string" }, { "documentation": "简要地址信息", "name": "snippet", "optional": false, "type": "string" }, { "documentation": "兴趣点名称 ", "name": "title", "optional": false, "type": "string" }, { "documentation": "区域编码 ", "name": "adCode", "optional": false, "type": "string" }, { "documentation": "经纬度信息", "name": "latLonPoint", "optional": true, "type": "object" }, { "documentation": "区域名称", "name": "adName", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "beehiveMultilevelSelect", "description": "主要使用于多级关联数据选择，比如说省市区的信息选择。", "documentation": "级联选择功能", "name": "beehiveMultilevelSelect", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "标题", "name": "title", "optional": true, "type": "string" }, { "documentation": "上一次选择的值", "name": "result", "optional": true, "type": "object" }, { "documentation": "选择数据列表。\n注：数据限制小于 200KB，超出请使用 path 参数", "name": "list", "optional": false, "type": "object" }, { "documentation": "list过大时，建议使用资源方式设置数据源； \npath 支持 apFilePath 或小程序内置路径", "name": "path", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "result", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "beehiveOptionsPicker", "documentation": "类似于 safari  原生 select  的组件，但是功能更加强大 一般用来替代 select，或者2级数据的选择，注意不支持2级数据之间的联动。", "name": "beehiveOptionsPicker", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "title", "optional": true, "type": "string" }, { "name": "optionsOne", "optional": false, "type": "string[]" }, { "name": "optionsTwo", "optional": true, "type": "string[]" }, { "defaultValue": "0", "name": "selectedOneIndex", "optional": true, "type": "number" }, { "defaultValue": "0", "name": "selectedTwoIndex", "optional": true, "type": "number" }, { "defaultValue": "确定", "name": "positiveString", "optional": true, "type": "string" }, { "defaultValue": "取消", "name": "negativeString", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "selectedOneIndex", "optional": false, "type": "number" }, { "name": "selectedTwoIndex", "optional": true, "type": "number" }, { "name": "selectedOneOption", "optional": false, "type": "string" }, { "name": "selectedTwoOption", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "bindAccount", "description": "https://yuque.antfin-inc.com/docs/share/89416140-57ee-4b58-988e-3e277b038b3c", "documentation": "提供绑定淘宝、绑定集团 Havana 账号的 JSAPI 给前端 H5、小程序业务调用", "name": "bindAccount", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "请求绑定的 havana 账号类型（必传）\n\"taobao\" 、\"eleme\"", "name": "site", "optional": false, "type": "string" }, { "documentation": "是否仅使用端内 H5 绑定淘宝，默认为 \"false\" 如果为 false：则有安装淘宝 app 优先走唤端授权绑定，未安装淘宝 app 走 H5 链路； 如果为 true：则不管有没有安装淘宝 app，都走端内打开 H5 绑定链路；", "name": "h5Only", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "绑定结果码", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "绑定结果提示文案", "name": "resultMemo", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "bindCard", "description": "绑卡是指会员在支付宝端输入个人信息和卡信息等直接完成信息验证， 并完成银行卡和支付宝账号绑定的过程，用户签约之后只需支付密码即可完成支付，具有快捷、安全、额度高的特点", "documentation": "发起独立绑卡", "name": "bindCard", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "请求来源", "documentation": "需要向绑卡PD发起申请流程", "exampleValue": "exteralApp", "name": "source", "optional": false, "type": "string" }, { "defaultValue": "卡号", "documentation": "携带该字段后，在绑卡流程中用户无法更改该卡号", "exampleValue": "622674551414148691", "name": "cardNo", "optional": true, "type": "string" }, { "defaultValue": "透传字段", "documentation": "是\t该字段是由绑卡服务端消费，格式为ExtInfo，见下表", "exampleValue": "{\"specified_card_info\":[{\"cardType\":\"CC\",\"instId\":\"SHBANK\"}],\"specified_scene\":\"expressSignDefaultCardNo\"}", "name": "extInfo", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "流程中断的常用 resultCode 如下：\n半屏的简化流程独有：\n6001 未成功展示半屏组件\n6007 用户点击四要素页右上角按钮\n6008  进入绑卡流程主动退出\n6009 用户点击四要素页副行动点按钮\n所有流程共用：\n6002 网络连接异常\n\n流程成功的resultCode：\n所有流程共用:\n9000 绑卡成功\n\n流程结束时，会把收银台内部的使用的endcode标识转为resultCode标识", "exampleValue": "6001", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "附加信息", "name": "memo", "optional": false, "type": "string" }, { "documentation": "签约号\n仅绑卡成功后有值", "name": "signId", "optional": true, "type": "string" }, { "documentation": "卡类型\n仅绑卡成功后有值", "exampleValue": "DC", "name": "cardType", "optional": true, "type": "string" }, { "documentation": "频道类型\n仅绑卡成功后有值", "name": "channelType", "optional": true, "type": "string" }, { "documentation": "服务端下发的整个result字段", "name": "result", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "bindTB", "description": "", "documentation": "创建淘宝Q账号", "name": "bindTB", "parameters": { "in": [{}], "out": [{ "documentation": "淘宝 ID", "name": "TBId", "optional": false, "type": "string" }] } }, { "apiName": "bindUDPSocket", "name": "bindUDPSocket", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "socketId", "optional": false, "type": "string" }, { "documentation": "目标端口号", "name": "port", "optional": true, "type": "number" }, { "name": "broadcast", "optional": true, "type": "boolean" }, { "name": "tag", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "buildUrl", "name": "buildUrl", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "id", "optional": true, "type": "string" }, { "documentation": "", "name": "match", "optional": true, "type": "number" }, { "documentation": "", "name": "width", "optional": true, "type": "number" }, { "documentation": "", "name": "height", "optional": true, "type": "number" }, { "documentation": "", "name": "https", "optional": true, "type": "boolean" }, { "documentation": "", "name": "quality", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "", "name": "url", "optional": false, "type": "string" }] } }, { "apiName": "cacheSpareFile", "name": "cacheSpareFile", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "speaker", "optional": true, "type": "string" }, { "documentation": "", "name": "spareFileUrl", "optional": true, "type": "string" }, { "documentation": "", "name": "timeout", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "number" }] } }, { "apiName": "calculateRoute", "description": "目前步行最多支持 100 公里的规划路线。", "documentation": "根据目的地计算出距离和所需时间，默认规划步行路线，支持规划步行、公交、骑行和驾车四种路线。", "name": "calculateRoute", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "walk", "documentation": "搜索类型。", "name": "searchType", "optional": true, "type": "enum" }, { "documentation": "起点纬度。", "name": "startLat", "optional": false, "type": "number" }, { "documentation": "起点经度。", "name": "startLng", "optional": false, "type": "number" }, { "documentation": "终点纬度。", "name": "endLat", "optional": false, "type": "number" }, { "documentation": "终点经度。", "name": "endLng", "optional": false, "type": "number" }, { "documentation": "途径点，仅驾车规划有效，即 `searchType=\"drive\"` 时有效。", "name": "throughPoints", "optional": true, "type": "object" }, { "documentation": "仅在 驾车模式（`searchType=\"drive\"`）和 公交模式（`searchType=\"bus\"`）支持，具体值见 mode 参数列表。", "name": "mode", "optional": true, "type": "enum" }, { "documentation": "公交模式（`searchType=\"bus\"`）下必填。传参可填写城市中文名称或城市名称拼音。例如：`city:'hangzhou'` 或 `city: '杭州'`。", "name": "city", "optional": true, "type": "string" }, { "documentation": "公交跨城模式下必填。", "name": "destinationCity", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功，失败时不会返回其他字段", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "距离，单位为 米。", "name": "distance", "optional": false, "type": "number" }, { "documentation": "时间，单位为 秒。", "name": "duration", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "callJsApi", "name": "callJsApi", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "callMyLiveH5Command", "name": "callMyLiveH5Command", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "命令，具体见https://yuque.antfin.com/gqy9t6/bvt714/dkdtsv\n第三部分", "name": "cmd", "optional": false, "type": "string" }, { "documentation": "直播id", "name": "liveId", "optional": false, "type": "string" }, { "documentation": "StringArray[]，cmd=h5PanelSubscribeEvent和h5PanelUnsubscribeEvent使用", "name": "types", "optional": true, "type": "object" }, { "documentation": "发送内容，cmd=sendComment使用", "name": "content", "optional": true, "type": "string" }, { "documentation": "是否已关注，cmd=updateFollowStatus使用", "name": "isFollowed", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "true｜false", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "其他结果参数，如评论内容", "name": "data", "optional": true, "type": "object" }, { "documentation": "错误码", "name": "error", "optional": true, "type": "number" }, { "documentation": "错误描述", "name": "errorMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "callPullDown", "name": "callPullDown", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "canAppAddToHomeStage", "description": "能添加到首页 规则：在「更多应用」中 && 不在首页", "documentation": "指定应用是否可以添加到首页展台", "name": "canAppAddToHomeStage", "parameters": { "in": [{ "documentation": "", "name": "appId", "optional": true, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "cancelAudioRecord", "name": "cancelAudioRecord", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "cancelBluetoothPair", "name": "cancelBluetoothPair", "parameters": { "in": [{ "documentation": "蓝牙设备 id", "name": "deviceId", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "cancelFavorite", "name": "cancelFavorite", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "appIds", "optional": true, "type": "string[]" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "cancelKeepFavorite", "name": "cancelKeepFavorite", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "resultCode", "optional": false, "type": "number" }, { "name": "resultMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "cancelShare", "name": "cancelShare", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "cancelSpeech", "documentation": "取消语音识别", "name": "cancelSpeech", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "canFavorite", "documentation": "查询当前小程序是否可以收藏。", "name": "canFavorite", "parameters": { "in": [{ "documentation": "查询是否可收藏的 appId", "name": "appId", "optional": true, "type": "string" }], "out": [{ "documentation": "查询当前小程序是否能被收藏", "name": "canFavorite", "optional": false, "type": "boolean" }] } }, { "apiName": "canJumpToSystemSettings", "name": "canJumpToSystemSettings", "parameters": { "in": [{ "documentation": "", "name": "intent", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "number" }] } }, { "apiName": "canShowAddToHomeComponent", "description": "有疲劳度控制、访问频次控制", "documentation": "是否能展示添加到首页的组件", "name": "canShowAddToHomeComponent", "parameters": { "in": [{ "documentation": "事件类型", "name": "eventName", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "应用icon地址，success为true时有值", "name": "iconUrl", "optional": false, "type": "string" }, { "documentation": "组件文案，success为true时有值", "name": "componentText", "optional": false, "type": "string" }, { "documentation": "true: 可以展示false: 不可展示", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "canShowAddToHomeTips", "description": "小程序会调用", "documentation": "是否能展示添加到首页的框架提示组件（tips）", "name": "canShowAddToHomeTips", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码，success为false时有值", "name": "error", "optional": true, "type": "number" }, { "documentation": "错误码对应的描述文案，success为false时有值", "name": "errorMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "ccdnGetResource", "documentation": "内部测试小程序使用，不对外开放", "name": "ccdnGetResource", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ccdnIsResourceCached", "documentation": "用于检查指定资源是否已完成预下载到 CCDN 缓存", "name": "ccdnIsResourceCached", "parameters": { "in": [{ "documentation": "待查询的资源url", "name": "url", "optional": false, "type": "string" }], "out": [{ "documentation": "结果码：0表示已预下载，非0表未预下载", "name": "code", "optional": false, "type": "string" }] } }, { "apiName": "ccdnPreload", "documentation": "仅内部测试小程序使用，不对外开放", "name": "ccdnPreload", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ccdnPrepareResource", "description": "- 原则上一次预下载最多不超过10个，同时会限制缓存的有效期，默认未指定情况下默认14天，最长2个月；缓存清理的策略由ccdn内部决定；异步返回下载情况，返回下载url、状态码及结果描述信息。\n- 由于是批量下载多次回调，在正常网络下载后多次回调需要监听 [ccdnBatchPredownEvent](nativeevent) 事件，如果是权限或参数等错误则不需要监听此事件回调。如果资源已存在，多次调用预加载接口加载相同资源时，不会重复下载，同时更新资源过期时间", "documentation": "用于前端触发资源异步预下载并存入ccdn缓存", "name": "ccdnPrepareResource", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "网络资源列表，默认最大只下载10个", "name": "urls", "optional": false, "type": "string" }, { "documentation": "资源有效期(绝对时间，单位ms，double类型)，默认14天，最长不超过2个月", "name": "expiredTime", "optional": true, "type": "number" }, { "defaultValue": "", "documentation": "业务的appId（此参数仅限于10.2.70版本使用），不能为空，且必须跟实际运行的应用appid一致", "name": "appId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "下载资源url", "name": "url", "optional": true, "type": "string" }, { "documentation": "结果码", "name": "code", "optional": false, "type": "string" }, { "documentation": "结果描述信息", "name": "message", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "ccdnRemoveResource", "description": "- 原则上一次删除不超过100个，且待删除的资源需跟业务一致，不能跨应用删除。\n- 支持按url维度清理，也支持按业务维度全清", "documentation": "用于前端自行管理预下载缓存资源", "name": "ccdnRemoveResource", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "待删除资源url列表，默认最多100个", "name": "urls", "optional": false, "type": "string" }, { "defaultValue": "0", "documentation": "int型，0表示按照url清理，1表示全清", "name": "cleanMode", "optional": true, "type": "number" }, { "documentation": "业务的appId（此参数仅限10.2.70版本上使用），不能为空，且必须跟实际运行的应用appid一致", "name": "appId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "结果码", "name": "code", "optional": false, "type": "string" }] } }, { "apiName": "cdpFeedback", "description": "投放数据是通过getCdpSpaceInfos/getCdpSpaceInfo接口获取的\n辅助文档：https://yuque.antfin-inc.com/wr08f6/winme4/gon9ut", "documentation": "投放数据上报接口", "name": "cdpFeedback", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "投放展位码", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "投放创意ID", "name": "objectId", "optional": false, "type": "string" }, { "documentation": "用户行为：SHOW、CLICK、CLOSE", "name": "behavior", "optional": false, "type": "\"SHOW\" | \"CLICK\" | \"CLOSE\"" }], "type": "Object" }], "out": [{ "documentation": "数据上报是否成功", "name": "success", "optional": false, "type": "\"true\" | \"false\"" }] } }, { "apiName": "cdpFeedbackForServer", "description": "服务端接入的tr接口为：alipay.cdp.space.queryBySpaceCode4Pb\n\n其他说明参考：\nhttps://yuque.antfin-inc.com/wr08f6/winme4/vdkqx3", "documentation": "通过服务端接入方式对接投放平台，获取投放数据后，疲劳度与埋点数据上报使用该接口", "name": "cdpFeedbackForServer", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "需要上报的spaceInfo", "name": "spaceInfo", "optional": false, "type": "boolean | #$#" }, { "description": "", "documentation": "需要上报的创意ID", "name": "objectId", "optional": false, "type": "string" }, { "description": "", "documentation": "需要上报的用户行为：SHOW、CLICK、CLOSE", "name": "behavior", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "数据上报是否成功", "name": "success", "optional": false, "type": "boolean | string" }] } }, { "apiName": "certDocCenterSelectResult", "name": "certDocCenterSelectResult", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "changeTitleBar", "description": "惠出境H5", "documentation": "修改标题栏", "name": "changeTitleBar", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "changeUserSportAuthorize", "description": "修改用户系统/传感器 授权行为jsapi", "documentation": "修改用户系统/传感器 授权行为jsapi", "name": "changeUserSportAuthorize", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "sensor系统传感器，sdk厂商sdk", "name": "authType", "optional": false, "type": "string" }, { "documentation": "变更值", "name": "isOpen", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "变更后当前授权状态", "name": "resultState", "optional": false, "type": "boolean" }, { "documentation": "1000 修改成功\n2001 执行报错\n2002 系统权限未开启\n2003 参数错误\n2004 开关不可用(隐藏开关入口)\n2005 用户档次操作无法系统无法获取操作结果，需要页面onShow再次查询\n2006 苹果SDK授权弹窗已经被苹果判定疲劳，无法展现，也无法跳转，必须前端 Toast 特定文案引导用户自行设置", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "厂商名字", "name": "dataSource", "optional": false, "type": "string" }, { "documentation": "结果描述", "name": "resultMessage", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "checkAndShowCdpView", "name": "checkAndShowCdpView", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "", "name": "type", "optional": false, "type": "string" }, { "documentation": "", "name": "extInfo", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "hasShown", "optional": true, "type": "string" }, { "documentation": "", "name": "spaceCode", "optional": true, "type": "string" }, { "documentation": "", "name": "success", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "checkApp", "name": "checkApp", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "checkBizPermission", "documentation": "权限堡垒，业务授权查询", "name": "checkBizPermission", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "exampleValue": "{   \"appId\": \"20000007\",   \"url\": \"https://www.alipay.com/index.html\",   \"bizId\": \"IAmGod\" }", "name": "bizContext", "optional": false, "type": "string" }, { "documentation": "", "exampleValue": "LBS", "name": "permissionType", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "exampleValue": "0", "name": "sysAbilityStatus", "optional": false, "type": "number" }, { "exampleValue": "0", "name": "sysAuthStatus", "optional": false, "type": "number" }, { "exampleValue": "0", "name": "bizAuthStatus", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "checkFloatingWindowPermission", "name": "checkFloatingWindowPermission", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "permission", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "checkIfAppIsHiddenByUser", "description": "由于Android我的tab在懒加载模式下，在不主动点击进入我的tab页面前，不会触发RPC，因此，当切换账号后，由于本地缓存被清理，在未主动进入我的tab前，调用JSAPI，查询到的结果将会是false（未被隐藏）。\n在调用JSAPI前会检查缓存是否有效，如果缓存无效，将会异步补发一次RPC（不会阻塞等待），以便业务在后续调用JSAPI时获得正确的结果。\n该问题仅在Android上存在。", "documentation": "查询我的Tab下指定应用是否被用户在功能管理页设置为隐藏状态", "name": "checkIfAppIsHiddenByUser", "parameters": { "in": [{ "documentation": "待查询应用id数组，例：\n{\n  \"appIds\": [\n    \"124875\",\n    \"314159\"\n  ]\n}", "name": "appIds", "optional": false, "type": "array" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "与入参一一对应，查询获取到的应用隐藏状态。false（默认）：未被用户隐藏。例：\n{\n  \"success\": true,\n  \"resultCode\"：\"1000\"，\n  \"hiddenByUser\": {\n    \"124875\": true,\n    \"314159\": false\n  }\n}", "name": "hiddenByUser", "optional": false, "type": "object" }, { "documentation": "JSAPI是否调用成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "JSAPI执行状态码。\n\"1000\": 成功\n\"60001\": 参数异常\n\"60002\": 未知错误", "name": "resultCode", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "checkIsIfaaEnrolledInDevice", "description": "获取设备内是否录入如指纹等生物信息的接口", "documentation": "获取设备内是否录入如指纹等生物信息的接口", "name": "checkIsIfaaEnrolledInDevice", "parameters": { "in": [{ "documentation": "", "name": "checkAuthMode", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }, { "documentation": "", "name": "isEnrolled", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "checkIsSupportIfaaAuthentication", "description": "获取本机支持的IFAA生物认证方式", "documentation": "获取本机支持的IFAA生物认证方式", "name": "checkIsSupportIfaaAuthentication", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "supportMode", "optional": true, "type": "string[]" }, { "documentation": "", "name": "success", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "checkJSAPI", "documentation": "检查指定 JSAPI 是否存在", "name": "checkJSAPI", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要检查的 JSAPI 名称", "name": "api", "optional": false, "type": "string" }, { "name": "isFromDynamicLibray", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "是否存在 (不代表拥有权限)", "name": "available", "optional": false, "type": "boolean" }] } }, { "apiName": "checkPedometerAppInfo", "name": "checkPedometerAppInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "checkPedometerStatus", "documentation": "检测计步器状态", "name": "checkPedometerStatus", "parameters": { "in": [{ "documentation": "值为sensor/sdk", "name": "dataSource", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }, { "documentation": "数据源是否可用", "name": "isAvailable", "optional": false, "type": "boolean" }, { "documentation": "数据源权限", "name": "permission", "optional": true, "type": "enum" }, { "documentation": "传感器是否异常", "name": "isAbnormal", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "checkRtcEnv", "description": "细节比较多，只开放给内部业务，参考接入文档，和开发确认后再使用，后续会扩展网络可用性等方向的判断", "documentation": "提前检测音视频通话的环境，例如摄像头，麦克风权限，是否被占用", "name": "checkRtcEnv", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "false", "documentation": "通话中会用到麦克风", "name": "useMicrophone", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "通话中会用到摄像头", "name": "useCamera", "optional": true, "type": "boolean" }, { "defaultValue": "true", "documentation": "允许启动一次麦克风以检查可用性", "name": "eanbleStartMicForCheck", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "麦克风子项的检查结论，整数枚举类型", "name": "microphone", "optional": true, "type": "number" }, { "documentation": "麦克风错误描述", "name": "microphoneErrMsg", "optional": true, "type": "string" }, { "documentation": "摄像头子项的检查结论，整数枚举类型", "name": "camera", "optional": true, "type": "number" }, { "documentation": "摄像头错误描述", "name": "cameraErrMsg", "optional": true, "type": "string" }, { "documentation": "传统电话对通话的影响", "name": "phoneState", "optional": true, "type": "number" }], "type": "Object" }] } }, { "apiName": "checkStepDetectAvailable", "documentation": "判断步数异常检测的功能开关是否打开", "name": "checkStepDetectAvailable", "parameters": { "in": [{}], "out": [{ "documentation": "步数异常检测功能是否可用", "name": "available", "optional": false, "type": "boolean" }] } }, { "apiName": "checkWhiteScreen", "description": "通过屏幕截图分析图片中的主色及主色占比，从而判断是否白屏/黑屏/纯色屏", "documentation": "体感白屏检测", "name": "checkWhiteScreen", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "0", "documentation": "检测图片时，裁剪顶部高度", "exampleValue": "0", "name": "top", "optional": false, "type": "number" }, { "defaultValue": "0", "documentation": "检测图片时，裁剪顶部高度", "exampleValue": "0", "name": "bottom", "optional": false, "type": "number" }, { "defaultValue": "0", "documentation": "检测图片时，裁剪右侧长度", "exampleValue": "0", "name": "left", "optional": false, "type": "number" }, { "defaultValue": "0", "documentation": "检测图片时，裁剪右侧长度", "exampleValue": "0", "name": "right", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否调用成功\n\n0: 成功\n\n60001: 检测参数不合法\n\n60002: 内部错误", "exampleValue": "0", "name": "error", "optional": false, "type": "number" }, { "documentation": "是否白屏\n\nfalse: 非白屏 true: 白屏", "exampleValue": "true", "name": "isWhiteScreen", "optional": false, "type": "boolean" }, { "documentation": "白屏类型\n\n1:白屏\n\n2:黑屏\n\n3:其他", "exampleValue": "0", "name": "type", "optional": false, "type": "number" }, { "documentation": "主色占比，例如 0.996；非主色判断模式，值为 -1", "exampleValue": "0.99", "name": "proportion", "optional": false, "type": "number" }, { "documentation": "耗时，单位毫秒", "exampleValue": "10", "name": "cost", "optional": false, "type": "number" }, { "documentation": "错误信息描述", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "chooseContact", "documentation": "选择联系人", "name": "chooseContact", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "type", "optional": false, "type": "\"single\"" }, { "name": "multiMax", "optional": true, "type": "void" }], "type": "Object" }], "out": [{ "documentation": "选中的支付宝联系人数组。", "name": "contacts", "optional": false, "type": "object" }] } }, { "apiName": "chooseDistrict", "documentation": "使用支付宝统一样式的地区选择 API。", "name": "chooseDistrict", "parameters": { "in": [], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "城市名称。", "name": "name", "optional": false, "type": "string" }, { "documentation": "城市编码。", "name": "adCode", "optional": false, "type": "string" }, { "documentation": "自定义扩展字段透传。", "name": "ext", "optional": true, "type": "Record<string,string>" }], "type": "Object" }] } }, { "apiName": "chooseFileFromDisk", "description": "选择的文件会拷贝到对应的appid的临时目录中", "documentation": "从手机文件系统选择文件", "name": "chooseFileFromDisk", "parameters": { "in": [{ "documentation": "对应的appid，选择的文件会拷贝到这个appid对应的临时目录中，小程序默认从上下文获取", "name": "appId", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "apFilePath", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "chooseImage", "name": "chooseImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "最大可选照片数，默认为 1 张", "name": "count", "optional": true, "type": "number" }, { "defaultValue": "[\"original\",\"compressed\"]", "documentation": "图片类型。", "name": "sizeType", "optional": true, "type": "object" }, { "defaultValue": "[\"camera\",\"album\"]", "documentation": "图片类型。", "name": "sourceType", "optional": true, "type": "object" }, { "documentation": "选图过程中拍摄的照片是否落相册（默认不落相册）", "name": "storeToAlbum", "optional": true, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "localIds", "optional": true, "type": "string | string" }, { "name": "tempFilePaths", "optional": true, "type": "string | string" }, { "documentation": "图片的本地临时文件列表", "name": "tempFiles", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "chooseLocation", "name": "chooseLocation", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "chooseVideo", "name": "chooseVideo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "['album','camera']", "name": "sourceType", "optional": true, "type": "object" }, { "defaultValue": "['front','back']", "name": "camera", "optional": true, "type": "object" }, { "defaultValue": "60", "description": "- 最小 1 秒\n- 最大 600 秒（开关配置）", "documentation": "最大视频时长，单位秒", "name": "maxDuration", "optional": true, "type": "number" }, { "documentation": "是否压缩", "name": "compressed", "optional": true, "type": "boolean" }, { "documentation": "是否允许编辑", "name": "enableEdit", "optional": true, "type": "boolean" }, { "defaultValue": "true", "name": "enableVideoRecordFilter", "optional": true, "type": "boolean" }, { "defaultValue": "false", "name": "enableVideoEditFilter", "optional": true, "type": "boolean" }, { "defaultValue": "true", "name": "needLocalId", "optional": true, "type": "boolean" }, { "name": "isShowVideoTimeIndicator", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "error", "optional": true, "type": "0" }, { "name": "localId", "optional": false, "type": "string" }, { "name": "tempFilePath", "optional": false, "type": "string" }, { "name": "tempFile", "optional": false, "type": "string" }, { "name": "filePath", "optional": true, "type": "string" }, { "name": "apFilePath", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "clearAPDataStorage", "documentation": "清除本地对应的business下的所有缓存", "name": "clearAPDataStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "type", "optional": true, "type": "string" }, { "documentation": "", "name": "business", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean | string" }, { "documentation": "", "name": "error", "optional": true, "type": "number" }], "type": "Object" }] } }, { "apiName": "clearRender", "documentation": "清除 WebView 预渲染队列", "name": "clearRender", "parameters": { "in": [{ "documentation": "将要清除的预渲染队列位置", "name": "range", "optional": false, "type": "object" }], "out": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "clearTinyLocalStorage", "documentation": "清除本地缓存信息", "name": "clearTinyLocalStorage", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "closeAllFloatingWindow", "name": "closeAllFloatingWindow", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeBLEPeripheral", "name": "closeBLEPeripheral", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeBluetoothAdapter", "documentation": "关闭蓝牙适配器", "name": "closeBluetoothAdapter", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeBluetoothSocket", "name": "closeBluetoothSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeNFC", "name": "closeNFC", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "closeSocialComment", "name": "closeSocialComment", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeSocket", "name": "closeSocket", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "socketTaskID", "optional": true, "type": "string" }, { "defaultValue": "1000", "name": "code", "optional": true, "type": "number" }, { "name": "reason", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "message", "optional": false, "type": "string" }] } }, { "apiName": "closeTCPSocket", "name": "closeTCPSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeUDPSocket", "name": "closeUDPSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "closeWebview", "description": "- 退出行为同 popWindow（但是不能携带 data)", "documentation": "关闭应用当前页面", "name": "closeWebview", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "cloudCallContainer", "description": "使用callContainer之前，需要首先调用init完成云环境初始化", "documentation": "云托管小程序专用接口，用于请求网络接口", "name": "cloudCallContainer", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "云环境服务路径", "name": "path", "optional": false, "type": "string" }, { "documentation": "调用header，传输云环境等信息", "name": "header", "optional": false, "type": "object" }, { "defaultValue": "GET", "documentation": "GET\t云服务器请求方法", "name": "method", "optional": true, "type": "string" }, { "documentation": "请求数据，可以是json对象，也可传字符串", "name": "data", "optional": true, "type": "object" }, { "documentation": "业务自定义超时时间，默认60秒", "name": "timeout", "optional": true, "type": "number" }, { "defaultValue": "json", "documentation": "入参的data 是什么类型，可选值：json、text", "name": "dataType", "optional": true, "type": "string" }, { "defaultValue": "text", "documentation": "text\t返回的resultData字段数据类型，可选text和json", "name": "responseType", "optional": true, "type": "string" }, { "documentation": "云调用配置", "name": "config", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "服务端返回数据", "name": "resultData", "optional": false, "type": "object" }, { "documentation": "云调用返回的httpCode", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "云调用返回的header", "name": "resultHeader", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "cloudInit", "description": "初始化云环境，拿到相应的云托管环境配置", "documentation": "云托管小程序专用JSAPI，用于初始化云托管小程序环境", "name": "cloudInit", "parameters": { "in": [{ "documentation": "云托管的环境ID", "name": "env", "optional": true, "type": "string" }], "out": [{ "documentation": "是否初始化成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "cmplCVVerifyContent", "documentation": "防篡改图片进行验真JSAPI", "name": "cmplCVVerifyContent", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "使用场景", "name": "scene", "optional": false, "type": "string" }, { "documentation": "文件路径", "name": "filePath", "optional": false, "type": "string" }, { "documentation": "文件类型，目前只有 FILE和IMAGE", "name": "contentTypeEnum", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "contentVerifyResultEnum", "optional": false, "type": "string" }, { "documentation": "前端请只使用这个判断返回结果", "name": "contentVerifyResultIndex", "optional": false, "type": "number" }, { "name": "timestamp", "optional": false, "type": "number" }, { "documentation": "{\n\"appId\": \"appId\",\n\"pageId\": \"pageId\",\n\"appName\":\"appName\"\n\n}\n", "name": "contextMap", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "cmplEEEnterScene", "name": "cmplEEEnterScene", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizId", "optional": false, "type": "string" }, { "documentation": "", "name": "uniqueId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }, { "documentation": "", "name": "enterExitContext", "optional": true, "type": "object" }, { "documentation": "", "name": "enterExitResult", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "cmplEEIsManageRuleExist", "name": "cmplEEIsManageRuleExist", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizId", "optional": false, "type": "string" }, { "documentation": "", "name": "uniqueId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "isManageRuleExist", "optional": false, "type": "boolean | string" }] } }, { "apiName": "cmplEELeaveScene", "name": "cmplEELeaveScene", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizId", "optional": false, "type": "string" }, { "documentation": "", "name": "uniqueId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }, { "documentation": "", "name": "enterExitContext", "optional": true, "type": "object" }, { "documentation": "", "name": "enterExitResult", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "codeLoopService", "name": "codeLoopService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "action", "optional": true, "type": "string" }, { "documentation": "", "name": "code", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "number" }] } }, { "apiName": "compositeImage", "documentation": "将给定图像合并到另一张图像的指定区域", "name": "compositeImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "图片在APMultiMedia中的identifier", "name": "multimediaID", "optional": false, "type": "string" }, { "description": "- 不能够包含 'data:image/png;base64' 字段前缀", "documentation": "待合并图片的base64编码", "name": "overlapImage", "optional": false, "type": "string" }, { "documentation": "合并区域左上角的x点坐标，单位px", "name": "x", "optional": false, "type": "number" }, { "documentation": "合并区域左上角的y点坐标，单位px", "name": "y", "optional": false, "type": "number" }, { "documentation": "合并区域的宽度，单位px", "name": "width", "optional": false, "type": "number" }, { "documentation": "合并区域的高度，单位px", "name": "height", "optional": false, "type": "number" }, { "documentation": "业务存储标识", "name": "business", "optional": true, "type": "string" }, { "defaultValue": "2", "documentation": "压缩等级", "name": "compress", "optional": true, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "合并后新生成的base64编码数据", "name": "data", "optional": false, "type": "string" }] } }, { "apiName": "compressImage", "documentation": "压缩图片", "name": "compressImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "apFilePaths", "optional": false, "type": "string[]" }, { "defaultValue": "4", "documentation": "压缩质量", "name": "compressLevel", "optional": true, "type": "enum" }, { "documentation": "图像最大宽度", "name": "maxWidth", "optional": true, "type": "number" }, { "documentation": "图像最大高度", "name": "maxHeight", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "压缩后的图片路径数组。", "name": "apFilePaths", "optional": false, "type": "string[]" }] } }, { "apiName": "compressVideo", "documentation": "压缩相册视频", "name": "compressVideo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "视频的路径", "name": "videoPath", "optional": false, "type": "string" }, { "defaultValue": "1", "description": "", "documentation": "", "name": "level", "optional": true, "type": "enum" }, { "description": "", "documentation": "业务标识", "name": "business", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "type", "optional": true, "supportInfo": { "androidMinVersion": 10001090, "iosMinVersion": 10001090 }, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "视频的时长", "name": "duration", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "error", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "height", "optional": false, "type": "number" }, { "description": "", "documentation": "压缩成功后得到的一个本地可以用于上传的标识", "name": "identifier", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "rotation", "optional": false, "type": "number" }, { "description": "", "documentation": "压缩后的视频大小", "name": "size", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "tempPath", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "width", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "configService.getConfig", "documentation": "获取开关配置信息", "name": "configService.getConfig", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "开关名", "name": "configKey", "optional": false, "type": "string" }, { "documentation": "用于获取 AB 值", "name": "spm", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "开关值", "name": "configKey", "optional": false, "type": "string" }] } }, { "apiName": "configService.loadRealtimeConfig", "documentation": "目前只提供给体验官小程序，实时获取体验官的开关（不会获取其他开关）", "name": "configService.loadRealtimeConfig", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "error 为错误码，成功时为 0，错误时候为网络错误码", "exampleValue": "0", "name": "error", "optional": false, "type": "string" }, { "exampleValue": "网络异常", "name": "errorMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "confirm", "description": "可以配置确认框的标题、内容、确认或取消按钮的文字等", "documentation": "显示确认框", "name": "confirm", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "title", "optional": true, "type": "string" }, { "name": "message", "optional": true, "type": "string" }, { "documentation": "对齐方式", "name": "align", "optional": true, "supportInfo": { "androidMinVersion": 10000005, "iosMinVersion": 10000005 }, "type": "enum" }, { "documentation": "\"确定\"", "name": "okButton", "optional": true, "type": "string" }, { "documentation": "\"取消\"", "name": "cancelButton", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "ok", "optional": false, "type": "boolean" }] } }, { "apiName": "connectBLEDevice", "description": "", "documentation": "连接低功耗蓝牙设备", "name": "connectBLEDevice", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "超时时间（单位毫秒）", "name": "timeout", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "错误码", "name": "error", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "connectBluetoothSocket", "name": "connectBluetoothSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "connectNFC", "documentation": "链接NFC标签", "name": "connectNFC", "parameters": { "in": [{ "documentation": "tag对应的实例id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "connectSocket", "documentation": "创建 WebSocket 连接", "name": "connectSocket", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "multiple", "optional": true, "type": "boolean" }, { "documentation": "目标服务器接口地址。\n- 部分新发布的小程序只支持 wss 协议。", "name": "url", "optional": false, "type": "string" }, { "documentation": "请求的参数。", "name": "data", "optional": true, "type": "Record<string,unknown>" }, { "documentation": "设置请求的头部。", "name": "header", "optional": true, "type": "Record<string,string>" }, { "name": "bizIdentifier", "optional": false, "type": "string" }, { "name": "socketTaskID", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "connectTCPSocket", "name": "connectTCPSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "connectWifi", "description": "若已知 Wi-Fi 信息，可以直接利用该接口连接。\n仅 Android 与 iOS 11 以上版本支持。", "documentation": "连接 Wi-Fi。", "name": "connectWifi", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "Wi-Fi 设备 SSID。", "name": "SSID", "optional": true, "type": "string" }, { "documentation": "Wi-Fi 设备 BSSID。", "name": "BSSID", "optional": true, "type": "string" }, { "name": "maunal", "optional": true, "type": "boolean" }, { "documentation": "Wi-Fi 是 WEP Wi-Fi 还是 WPA or WPA2 personal Wi-Fi。\n默认是 false。", "name": "isWEP", "optional": true, "type": "boolean" }, { "documentation": "Wi-Fi 设备密码。", "name": "password", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "contact", "documentation": "选择系统通讯录，没有权限时直接弹窗提示", "name": "contact", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "选中的联系人姓名", "name": "name", "optional": false, "type": "string" }, { "documentation": "选中的联系人手机号", "name": "mobile", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "courierCoreQuery", "name": "courierCoreQuery", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "data", "optional": false, "type": "object" }, { "documentation": "", "name": "succ", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "createBluetoothSocket", "name": "createBluetoothSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "createSharedBiz", "description": "可以跨小程序/H5的存储区名", "documentation": "创建跨应用统一存储区", "name": "createSharedBiz", "parameters": { "in": [{ "documentation": "统一存储数据有效期，单位分钟", "name": "validTime", "optional": false, "type": "number" }], "out": [{ "documentation": "统一存储区名", "name": "sharedBiz", "optional": false, "type": "string" }] } }, { "apiName": "createTCPSocket", "name": "createTCPSocket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "createUDPSocket", "name": "createUDPSocket", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "socketId", "optional": false, "type": "string" }, { "documentation": "是否开启广播", "name": "broadcast", "optional": true, "type": "boolean" }, { "documentation": "是否开启组播", "name": "multicast", "optional": true, "type": "boolean" }, { "documentation": "绑定到当前 WiFi; 用于 WiFi 无法上网，仍需要与 WiFi 通信的场景", "name": "bindToWifi", "optional": true, "supportInfo": { "androidMinVersion": 10001082 }, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "createWorker", "documentation": "创建多线程Worker", "name": "createWorker", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "workerId", "optional": false, "type": "string" }, { "name": "scriptPath", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "customWhiteScreen", "name": "customWhiteScreen", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "dapControl", "documentation": "Apple Pay 被动唤起控制", "name": "dapControl", "parameters": { "in": [{ "documentation": "是否抑制唤起Apple Pay", "name": "dap", "optional": false, "type": "boolean" }], "out": [] } }, { "apiName": "datePicker", "documentation": "打开日期选择列表", "name": "datePicker", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "1", "documentation": "- 0: HH:mm:ss\n- 1: yyyy-MM-dd\n- 2: yyyy-MM-dd HH:mm:ss\n- 3: yyyy-MM\n- 4: yyyy", "name": "mode", "optional": false, "type": "0 | 1 | 2 | 3 | 4" }, { "documentation": "默认选择的日期/时间", "name": "beginDate", "optional": true, "type": "string" }, { "name": "minDate", "optional": true, "type": "string" }, { "name": "maxDate", "optional": true, "type": "string" }, { "documentation": "是否是身份证模式", "name": "isIDCard", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "date", "optional": false, "type": "string" }] } }, { "apiName": "DCEPWalletProcess", "name": "DCEPWalletProcess", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "cmd", "optional": false, "type": "string" }, { "documentation": "", "name": "param", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "resultView", "optional": true, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "hasOpenTrade", "optional": true, "type": "boolean" }, { "documentation": "", "name": "status", "optional": true, "type": "string" }, { "documentation": "", "name": "payee", "optional": true, "type": "string" }, { "documentation": "", "name": "walletInfo", "optional": true, "type": "Record<string, string>" }, { "documentation": "", "name": "mobileCode", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "deactivateStatusView", "name": "deactivateStatusView", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "deleteAllVisitHistory", "documentation": "端用户行为的数据中心 删除全部历史", "name": "deleteAllVisitHistory", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "@布洛", "name": "biz", "optional": false, "type": "string" }, { "name": "resultExt", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "true false", "name": "deleteSuccess", "optional": false, "type": "string" }, { "documentation": "入参的resultExt", "name": "resultExt", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "deleteFloatingWindow", "name": "deleteFloatingWindow", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "id", "optional": true, "type": "object" }, { "documentation": "", "name": "serId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "error", "optional": true, "type": "number" }, { "documentation": "", "name": "errorMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "deleteMcdpCacheModuleInfos", "documentation": "删除本地缓存的组件数据。", "name": "deleteMcdpCacheModuleInfos", "parameters": { "in": [{ "documentation": "[moduleId1,moduleId2]", "name": "moduleIdList", "optional": false, "type": "object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否删除成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "入参为空时", "name": "errorMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "deleteOfflinePkgs", "name": "deleteOfflinePkgs", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "deleteSkin", "documentation": "删除皮肤", "name": "deleteSkin", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "用户皮肤主键id，\n默认皮肤为DEFAULT", "name": "userSkinId", "optional": false, "type": "string" }, { "documentation": "皮肤的业务场景，默认为空", "name": "operateSource", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "deleteSnapshot", "name": "deleteSnapshot", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "deleteVisitHistoryBySourceId", "documentation": "端用户行为数据中心，根据sourceid删除接口", "name": "deleteVisitHistoryBySourceId", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "sourceId", "name": "sourceId", "optional": false, "type": "string" }, { "documentation": "resultExt 原路返回", "name": "resultExt", "optional": true, "type": "unknown" }, { "documentation": "@布洛", "name": "biz", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "true、false", "name": "deleteSuccess", "optional": false, "type": "string" }, { "documentation": "入参sourceId", "name": "sourceId", "optional": false, "type": "string" }, { "documentation": "入参resultext", "name": "resultExt", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "destroyForegroundAudio", "name": "destroyForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "deviceAuthByTerminalType", "documentation": "设备鉴权", "name": "deviceAuthByTerminalType", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务标识", "exampleValue": "DCCodeOpen", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "json（K-V）业务扩展参数，透传到服务端", "name": "bizParams", "optional": true, "type": "unknown" }, { "documentation": "json（K-V）扩展参数，可对过程中的核身定制部分文案", "name": "extParams", "optional": true, "type": "unknown" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "结果：\nresultStatus有三个值：\"1000\"、\"2000\"、\"3000\"，分别对应：链路成功/链路过程中的失败/用户主动行为取消", "name": "resultStatus", "optional": false, "type": "string" }, { "documentation": "业务方返回结果", "name": "bizResult", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "disablePageMonitor", "name": "disablePageMonitor", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "disconnectBLEDevice", "documentation": "断开与低功耗蓝牙设备的连接。", "name": "disconnectBLEDevice", "parameters": { "in": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "错误码", "name": "errorCode", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "downgradeFinished", "documentation": "标记统一降级完成", "name": "downgradeFinished", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "downloadApp", "description": "- 下载过程中会触发 downloadAppOnProgress, downloadAppOnInstall 事件", "documentation": "下载指定 apk", "name": "downloadApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用包名", "name": "packageName", "optional": false, "type": "string" }, { "documentation": "下载链接", "name": "downloadUrl", "optional": false, "type": "string" }, { "documentation": "文件名，必须以 .apk 为文件名后缀", "name": "fileName", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "downloadFile", "documentation": "从第三方服务器下载文件到本地", "name": "downloadFile", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "用于 DownloadFileTask.abort 和 DownloadFileTask.onProgress", "name": "downloadTaskId", "optional": true, "type": "number" }, { "documentation": "下载文件的地址或者base64", "name": "url", "optional": false, "type": "string" }, { "description": "该参数无用，会根据 MIME-Type 来决定", "documentation": "支持下载的文件类型", "name": "type", "optional": true, "type": "enum" }, { "name": "header", "optional": true, "type": "Record<string,string>" }, { "documentation": "新增 AppId 和 PluginId 隔离", "name": "plugin_isolation", "optional": true, "supportInfo": { "androidMinVersion": 10002003, "iosMinVersion": 10002003 }, "type": "\"true\"" }, { "documentation": "要上传文件资源的本地路径(https://usr)", "name": "filePath", "optional": true, "supportInfo": { "androidMinVersion": 10002080, "iosMinVersion": 10002080 }, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "tempFilePath", "optional": true, "type": "string" }, { "name": "apFilePath", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "downloadImage", "description": "- 一般配合与`uploadImage`使用", "documentation": "传入图片ID，获取对应图片的 Bae64 编码", "name": "downloadImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 可以是 ID (APMultiMedia)，如 'KrtheKQqRBecSg3IRg9aiAAAACMAAQED'\n- 可以是 URL\n- 可以是 base64，需要带有 'data:image/jpeg;base64' / 'data:image/png;base64' 等前缀\nbase64(带有 ' ')", "documentation": "多媒体标识", "name": "multimediaID", "optional": false, "type": "string" }, { "defaultValue": "NebulaBiz", "documentation": "业务存储标识", "name": "business", "optional": true, "type": "string" }, { "description": "- 不需要乘以屏幕 scale，如@2x、@3x\n- 当 match=0,3 时必填\n- 最大宽度 1280", "documentation": "图片展示区域宽度", "name": "width", "optional": true, "type": "number" }, { "description": "- 不需要乘以屏幕 scale，如@2x、@3x\n- 当 match=0,3 时必填\n- 最大高度 1280", "documentation": "图片展示区域高度", "name": "height", "optional": true, "type": "number" }, { "defaultValue": "0", "description": "- match=2 时 quality 无效", "documentation": "缩放模式", "name": "match", "optional": false, "type": "enum" }, { "defaultValue": "80", "description": "- 30~80 之间的整数值\n- 同size如果访问过高quality的图, 会被缓存到设备，再次访问时低quality无效\n- 当请求size大于图片原有size时，quality无效，强制取80", "documentation": "图像质量", "name": "quality", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "base64编码过的图片数据", "name": "data", "optional": false, "type": "string" }] } }, { "apiName": "dressSkin", "description": "接口封装\n1.皮肤资源下载\n2.请求dress接口\n3.更新本地皮肤数据", "documentation": "设置皮肤", "name": "dressSkin", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "操作来源", "name": "operateSource", "optional": true, "type": "string" }, { "documentation": "选择的场景，用逗号分隔", "name": "usageScene", "optional": false, "type": "string | string" }, { "documentation": "皮肤详情数据", "name": "skinDetailInfo", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "设置成功,跳转场景的链接\n{skinViewEntryMap: {<场景>:<跳转链接>}}", "name": "currentInfo", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "dtxDISProcess", "documentation": "DIS端密钥管理接口", "name": "dtxDISProcess", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "easyShare", "description": "- 老接口 [startShare]()/[shareToChannel]() 不再维护\n- 详询 [支付宝分享前端使用文档](https://yuque.antfin.com/fish-pond/stdlib/share_page)，该接口钉钉群（21937913）", "documentation": "发起分享", "name": "easyShare", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 用于区分业务，从而可用于追溯来源、对一些特殊业务强管控和管理预算等(多媒体资源、码值使用)等。\n- 见 [码平台申请入驻](https://mobileweb.alipay.com/batchPlatform.htm#/sceneManage/sceneInsert)", "documentation": "业务标识", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "分享标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "分享描述", "name": "desc", "optional": true, "type": "string" }, { "description": "不超过6个字符", "documentation": "搜索提示", "name": "searchTip", "optional": true, "supportInfo": { "androidMinVersion": 10001082, "iosMinVersion": 10001082 }, "type": "string" }, { "documentation": "小图icon(djangoId/https)", "name": "iconUrl", "optional": true, "type": "string" }, { "documentation": "小图icon(base64)", "name": "icon", "optional": true, "type": "string" }, { "description": "- 竖屏下，宽高比 1:1.1, 模板(padTemplate=4) 为1:1.36)\n- 横屏下，宽高比 2.17:1", "documentation": "大图icon(djangoId/https)", "name": "imageUrl", "optional": true, "type": "string" }, { "documentation": "大图icon(base64)", "name": "image", "optional": true, "type": "string" }, { "description": "- 建议不超过300个字符\n- 不建议传入chInfo参数，组件内部逻辑会根据不同渠道自动拼接chInfo值", "documentation": "跳转链接", "name": "url", "optional": false, "type": "string" }, { "documentation": "吱口令参数", "name": "tokenParam", "optional": true, "type": "object" }, { "defaultValue": "0", "documentation": "模板类型", "name": "padTemplate", "optional": true, "type": "object" }, { "defaultValue": "default", "documentation": "预设的渠道列表的排列", "name": "chTemplate", "optional": true, "type": "object" }, { "defaultValue": "false", "documentation": "复制链接、短信和微博是否使用短链", "name": "shortenUrl", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "禁用下载按钮", "name": "disableDownloadBtn", "optional": true, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "boolean" }, { "documentation": "扩展字段", "name": "ext", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "succeed", "optional": false, "type": "boolean" }, { "documentation": "用户选择渠道", "name": "channelName", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "editImage", "name": "editImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "apFilePath", "optional": true, "type": "string" }, { "documentation": "", "name": "cropRatios", "optional": true, "type": "string | string" }, { "documentation": "", "name": "editType", "optional": true, "type": "string | string" }, { "documentation": "", "name": "localId", "optional": true, "type": "string" }, { "documentation": "", "name": "localID", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "edited", "optional": false, "type": "boolean" }, { "documentation": "", "name": "apFilePath", "optional": false, "type": "string" }, { "documentation": "", "name": "localId", "optional": false, "type": "string" }, { "documentation": "", "name": "base64", "optional": true, "type": "string" }, { "documentation": "", "name": "outPath", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "editSportAuthState", "name": "editSportAuthState", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "用于新老api切流标记", "name": "apiMode", "optional": true, "type": "string" }, { "documentation": "目标要变更的协议状态\n", "name": "activeness", "optional": false, "type": "boolean" }, { "documentation": "string\t用于前后埋点串流traceId追踪", "name": "spmInfo", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": true, "type": "boolean" }, { "name": "activeness", "optional": true, "type": "boolean" }, { "name": "error", "optional": true, "type": "number" }, { "name": "errorMessage", "optional": true, "type": "string" }, { "documentation": "更多协议相关信息", "name": "extInfo", "optional": true, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "emotionInput", "name": "emotionInput", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "sendBtnType", "optional": true, "type": "string" }, { "documentation": "", "name": "sendBtnName", "optional": true, "type": "string" }, { "documentation": "", "name": "hint", "optional": true, "type": "string" }, { "documentation": "", "name": "maxlength", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "", "name": "content", "optional": false, "type": "string" }] } }, { "apiName": "enableIntegrationTesting", "name": "enableIntegrationTesting", "parameters": { "in": [{}], "out": [] } }, { "apiName": "exitApp", "description": "- 对于以 appId=20000067 打开的页面，会关闭除该页面以外所有 appId=20000067 的页面", "documentation": "退出指定应用", "name": "exitApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "exitTop", "documentation": "退出行为类型", "name": "closeActionType", "optional": true, "type": "enum" }, { "defaultValue": "true", "documentation": "是否开启动画", "name": "animated", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "exitTinyApp", "name": "exitTinyApp", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "extractEventTime", "documentation": "容器自己使用的InternalAPI给h5、小程序使用", "name": "extractEventTime", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "事件ID", "name": "eventId", "optional": true, "type": "string" }, { "defaultValue": "", "exampleValue": "[\"event1\",\"event2\"]", "name": "eventList", "optional": true, "type": "unknown" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "当前时间戳", "name": "timeStamp", "optional": true, "type": "number" }, { "documentation": "1970到现在时间戳 \n用于校准", "name": "currentTimeMillis", "optional": false, "type": "number" }, { "documentation": "开机到现在时间戳\n用于校准", "name": "elapsedRealTime", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "Falcon.CardManager", "name": "Falcon.CardManager", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "materialType", "optional": false, "type": "string" }, { "documentation": "", "name": "uploadId", "optional": false, "type": "string" }, { "documentation": "", "name": "action", "optional": false, "type": "string" }, { "documentation": "", "name": "businessParams", "optional": false, "type": "string" }, { "documentation": "", "name": "clientConfig", "optional": false, "type": "string" }, { "documentation": "", "name": "transparent", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "base64images", "optional": false, "type": "object" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "", "name": "ocrResult", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "favoriteNotify", "name": "favoriteNotify", "parameters": { "in": [{ "documentation": "通知类型", "name": "action", "optional": false, "type": "\"removeFavoriteNotification\" | \"addFavoriteNotification\"" }], "out": [{}] } }, { "apiName": "feedbackh5SetMsgJSAPI", "description": "已经下线", "documentation": "客诉，新增自定义客诉消息", "name": "feedbackh5SetMsgJSAPI", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "当前客诉的URL", "name": "url", "optional": false, "type": "string" }, { "documentation": "对应的biz", "name": "bizCode", "optional": false, "type": "string" }, { "documentation": "额外参数", "name": "extParams", "optional": false, "type": "object" }], "type": "Object" }], "out": [] } }, { "apiName": "fetchLiveUrl", "name": "fetchLiveUrl", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "fetchUcInfo", "name": "fetchUcInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "finishRender", "documentation": "标记被 `preRender` 加入预渲染队列的 WebView 完成渲染", "name": "finishRender", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "fltLogBizInfo", "name": "fltLogBizInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "fltLogCost", "description": "将指定耗时时长的耗时，记录到指定的点位集中，根据传入的标志决定如果已经存在该耗时了是否要覆盖", "documentation": "全链路埋点写入耗时点位", "name": "fltLogCost", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "桩点关键字", "name": "key", "optional": false, "type": "string" }, { "documentation": "业务对应AppId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "业务耗时时间，默认为0", "name": "costTime", "optional": false, "type": "number" }, { "documentation": "是否允许桩点位覆盖，为true时，允许覆盖已有的桩点，默认是否", "name": "canOverride", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [] } }, { "apiName": "fltLogEnvInfo", "name": "fltLogEnvInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "fltLogStub", "description": "按照当前时间将桩点位记录到指定的点位集中，如果已经设置过了则不进行覆盖", "documentation": "全链路埋点写入桩点", "name": "fltLogStub", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "桩点关键字", "name": "key", "optional": false, "type": "string" }, { "documentation": "业务对应AppId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "业务指定时间戳，注意：值必须是设备机器时间且单位ms。不传底层将调用时间作为值", "name": "elapsedRealtime", "optional": false, "type": "number" }, { "documentation": "是否允许桩点位覆盖，为true时，允许覆盖已有的桩点，默认是否", "name": "canOverride", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [] } }, { "apiName": "fsManage", "description": "", "documentation": "文件系统相关接口", "name": "fsManage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "action", "optional": false, "type": "\"rmdir\"" }, { "name": "dirPath", "optional": false, "type": "string" }, { "name": "sharedBiz", "optional": false, "type": "string" }, { "name": "recursive", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "fuCardList", "description": "新春五福", "documentation": "新春五福", "name": "fuCardList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "fuCardTasks", "description": "新春五福", "documentation": "新春五福", "name": "fuCardTasks", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "genCodeModule", "name": "genCodeModule", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "codeImageType", "optional": false, "type": "string" }, { "documentation": "", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "", "name": "qrcodeWidth", "optional": false, "type": "number" }, { "documentation": "", "name": "barcodeWidth", "optional": false, "type": "number" }, { "documentation": "", "name": "barcodeHeight", "optional": false, "type": "number" }, { "documentation": "", "name": "extra", "optional": false, "type": "string | #$#" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "BARCODE", "optional": false, "type": "string" }, { "documentation": "", "name": "QRCODE", "optional": false, "type": "string" }, { "documentation": "", "name": "code", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "genDslCode", "name": "genDslCode", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "generateImageFromCode", "name": "generateImageFromCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "二维码内容", "exampleValue": "hello", "name": "code", "optional": false, "type": "string" }, { "documentation": "输出码的格式，当前只支持QRCODE(二维码)。", "exampleValue": "QRCODE", "name": "format", "optional": false, "type": "\"QRCODE\"" }, { "documentation": "生成图片的宽度，单位是px", "exampleValue": "400", "name": "width", "optional": false, "type": "number" }, { "defaultValue": "H", "documentation": "纠错等级", "exampleValue": "H", "name": "correctLevel", "optional": false, "type": "object" }, { "defaultValue": "up", "documentation": "返回图片的方向", "name": "orientation", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "base64 编码的二维码图像", "name": "image", "optional": false, "type": "string" }] } }, { "apiName": "genPassCode", "name": "genPassCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "type", "optional": true, "type": "string" }, { "documentation": "", "name": "passId", "optional": true, "type": "string" }], "type": "Object" }], "out": [] } }, { "apiName": "geoCode", "name": "geoCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务唯一标示。", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "地址信息。", "name": "address", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "纬度。", "name": "longitude", "optional": false, "type": "number" }, { "documentation": "经度。", "name": "latitude", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getAlipaySnapshot", "description": "地址为虚拟地址，时间为原始的毫秒值数据", "documentation": "获取截屏PDF的地址和时间", "name": "getAlipaySnapshot", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "最近一份截屏PDF文件的虚拟地址", "name": "filePath", "optional": false, "type": "string" }, { "documentation": "截屏时间，毫秒值", "name": "snapshotTime", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getAllContacts", "description": "- 以数组方式获取当前所有的手机通讯录联系人数据，一般用于手机号码补全", "documentation": "获取全部联系人", "name": "getAllContacts", "parameters": { "in": [{}], "out": [{ "documentation": "以手机号为键名，姓名为值的对象", "name": "phoneNumber", "optional": false, "type": "string" }] } }, { "apiName": "getAPDataStorage", "description": "该数据存储跨 appId，可以与客户端约定对应存取逻辑", "documentation": "获取统一存储数据", "name": "getAPDataStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "common", "documentation": "数据存储维度", "name": "type", "optional": true, "type": "enum" }, { "defaultValue": "NebulaBiz", "documentation": "自定义的业务标识", "name": "business", "optional": true, "type": "string" }, { "documentation": "自定义数据的key", "name": "key", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "存储的数据", "name": "data", "optional": false, "type": "string" }] } }, { "apiName": "getAppAuthorizeSetting", "documentation": "获取客户端授权设置", "name": "getAppAuthorizeSetting", "parameters": { "in": [{ "documentation": "查询的授权项", "name": "options", "optional": true, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "允许支付宝使用摄像头的开关", "name": "cameraAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝使用定位的开关", "name": "locationAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝使用麦克风的开关", "name": "microphoneAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝通知的开关", "name": "notificationAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝使用相册的开关", "name": "albumAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝使用蓝牙的开关", "name": "bluetoothAuthorized", "optional": true, "type": "boolean" }, { "documentation": "允许支付宝通知带有提醒的开关", "name": "notificationAlertAuthorized", "optional": true, "supportInfo": { "iosMinVersion": 10002058 }, "type": "boolean" }, { "documentation": "允许支付宝通知带有标记的开关", "name": "notificationBadgeAuthorized", "optional": true, "supportInfo": { "iosMinVersion": 10002058 }, "type": "boolean" }, { "documentation": "允许支付宝通知带有声音的开关", "name": "notificationSoundAuthorized", "optional": true, "supportInfo": { "iosMinVersion": 10002058 }, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getAppBaseInfo", "documentation": "获取应用信息", "name": "getAppBaseInfo", "parameters": { "in": [{ "documentation": "需要查询的信息", "name": "options", "optional": false, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "language", "optional": false, "type": "string" }, { "documentation": "", "name": "version", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getAppInfo", "documentation": "获取应用信息", "name": "getAppInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "appId", "optional": false, "type": "string" }, { "description": "- 为保证向下兼容，传空字符串即可", "documentation": "展台码", "name": "stageCode", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "应用名称", "name": "name", "optional": false, "type": "string" }, { "name": "slogan", "optional": false, "type": "string" }, { "documentation": "应用描述", "name": "desc", "optional": false, "type": "string" }, { "name": "iconUrl", "optional": false, "type": "string" }, { "documentation": "nebulamng 包版本号", "name": "version", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getAppLogSize", "description": "获取客户端日志大小", "documentation": "获取客户端日志大小", "name": "getAppLogSize", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "无", "documentation": "起始时间", "exampleValue": "yyyy-MM-dd-HH", "name": "startDate", "optional": false, "type": "string" }, { "defaultValue": "无", "documentation": "截止时间", "exampleValue": "yyyy-MM-dd-HH", "name": "endDate", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "接口结果", "exampleValue": "success", "name": "result", "optional": false, "type": "string" }, { "documentation": "文件大小", "exampleValue": "1024", "name": "logSize", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getAppMode", "documentation": "获取App当前模式", "name": "getAppMode", "parameters": { "in": [{}], "out": [{ "documentation": "app当前模式", "name": "appMode", "optional": false, "type": "enum" }] } }, { "apiName": "getAppToken", "documentation": "获取设备指纹 token", "name": "getAppToken", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "向 俊桦 申请", "name": "appName", "optional": false, "type": "string" }, { "name": "appKey", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "可换取 openId", "name": "appToken", "optional": false, "type": "string" }] } }, { "apiName": "getAuthCode", "documentation": "授权接口，获取用户相关信息，会触发弹窗授权", "name": "getAuthCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "platform", "optional": true, "type": "void | \"TB\"" }, { "name": "showErrorTip", "optional": true, "type": "boolean" }, { "name": "isvAppId", "optional": true, "type": "string" }, { "documentation": "直接将参数塞到rpc请求中，待剑羽补充含义 字段", "name": "extInfo", "optional": true, "type": "Record<string,string>" }, { "name": "scopeNicks", "optional": false, "type": "enum" }, { "documentation": "仅在Native API下生效，小程序/H5调用，传递不生效", "name": "currentPageUrl", "optional": true, "type": "string" }, { "documentation": "授权主体，小程序默认取当前appId，如果是H5，可以传递appId指定授权主体", "name": "appId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "授权码", "name": "authcode", "optional": false, "type": "string" }, { "documentation": "失败的授权类型，key 是授权失败的 scope，value 是对应的错误码", "name": "authErrorScopes", "optional": false, "type": "object" }, { "documentation": "成功的授权 scope", "name": "authSuccessScopes", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "getAuthCodeCrossApp", "name": "getAuthCodeCrossApp", "parameters": { "in": [{ "documentation": "授权类型", "name": "scopes", "optional": false, "type": "string[]" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "授权码", "name": "authCode", "optional": false, "type": "string" }, { "documentation": "失败的授权类型，key 是授权失败的 scope，value 是对应的错误码。", "name": "authErrorScopes", "optional": false, "type": "Record<string,number>" }, { "documentation": "authSuccessScopes", "name": "authSuccessScopes", "optional": false, "type": "string[]" }], "type": "Object" }] } }, { "apiName": "getAuthCodeMO", "name": "getAuthCodeMO", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getAuthorize", "documentation": "获取授权信息，一般使用 getAuthCode", "name": "getAuthorize", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "platform", "optional": true, "type": "\"TB\" | void" }, { "name": "showErrorTip", "optional": true, "type": "boolean" }, { "name": "isvAppId", "optional": true, "type": "string" }, { "name": "extInfo", "optional": true, "type": "Record<string,string>" }, { "name": "scopeNicks", "optional": false, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "授权码", "name": "authcode", "optional": false, "type": "string" }, { "documentation": "失败的授权类型，key 是授权失败的 scope，value 是对应的错误码", "name": "authErrorScopes", "optional": false, "type": "Record<string, string>" }, { "documentation": "成功的授权 scope", "name": "authSuccessScopes", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "getAuthStatus", "documentation": "请求权限业务来源，无需申请，建议与 showAuthGuide 的 bizTyoe 一样。", "name": "getAuthStatus", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "请求权限业务来源，需要申请。", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "引导的权限标识，用于标识该权限类型(如 地理位置信息)。", "name": "authType", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "权限状态。\n- `\"1\"` 为权限打开\n- 其余均为权限关闭", "name": "authStatus", "optional": false, "type": "string" }] } }, { "apiName": "getAuthUserInfo", "documentation": "获取授权用户信息", "name": "getAuthUserInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "授权类型", "name": "scopeNicks", "optional": false, "type": "Array" }, { "documentation": "额外参数", "name": "extInfo", "optional": true, "type": "object" }, { "defaultValue": "false", "documentation": "是否展示错误提示", "name": "showErrorTip", "optional": true, "type": "boolean" }, { "documentation": "平台，可传 \"TB\"", "name": "platform", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "用户昵称。", "name": "nick", "optional": false, "type": "string" }, { "documentation": "用户头像链接。", "name": "userAvatar", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getAvailableAudioSources", "name": "getAvailableAudioSources", "parameters": { "in": [{}], "out": [{ "name": "audioSources", "optional": false, "type": "object" }] } }, { "apiName": "getBackgroundAudioOption", "name": "getBackgroundAudioOption", "parameters": { "in": [{ "name": "optionName", "optional": false, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "src", "optional": false, "type": "string" }, { "name": "playbackRate", "optional": false, "type": "number" }, { "name": "startTime", "optional": false, "type": "number" }, { "name": "title", "optional": false, "type": "string" }, { "name": "epname", "optional": false, "type": "string" }, { "name": "singer", "optional": false, "type": "string" }, { "name": "coverImgUrl", "optional": false, "type": "string" }, { "name": "webUrl", "optional": false, "type": "string" }, { "name": "isRecordAudioPlayState", "optional": false, "type": "boolean" }, { "name": "duration", "optional": false, "type": "number" }, { "name": "currentTime", "optional": false, "type": "number" }, { "name": "buffered", "optional": false, "type": "number" }, { "name": "paused", "optional": false, "type": "boolean" }, { "name": "ccode", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getBackgroundAudioPlayerState", "name": "getBackgroundAudioPlayerState", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "playing or readytoplay", "name": "status", "optional": false, "type": "1" }, { "name": "audioDataUrl", "optional": false, "type": "string" }, { "name": "currentPosition", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getBackgroundFetchData", "documentation": "获取预加载请求数据", "name": "getBackgroundFetchData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "请求参数", "name": "params", "optional": false, "type": "object" }, { "documentation": "校验参数", "name": "checkParams", "optional": false, "type": "object" }, { "defaultValue": "", "description": "请求类型", "documentation": "请求类型", "name": "fetchType", "optional": false, "supportInfo": { "androidMinVersion": 10002038, "iosMinVersion": 10002038 }, "type": "string" }, { "defaultValue": "true", "documentation": "是否等待请求后回调", "name": "wait", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "当前prefetch状态", "name": "status", "optional": false, "type": "enum" }, { "defaultValue": "pre", "description": "请求类型", "name": "type", "optional": false, "type": "string" }, { "defaultValue": "pre", "description": "请求类型", "name": "fetchType", "optional": false, "type": "string" }, { "description": "客户端拿到缓存数据的时间戳", "name": "timestamp", "optional": false, "type": "number" }, { "description": "当前预加载的response数据，\n如果status为2，里面会有具体的请求request的错误error和errorMessage", "name": "fetchedData", "optional": false, "type": "Record<string,unknown>" }, { "name": "prefetch", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getBatteryInfo", "description": "", "documentation": "异步获取当前设备的电量和充电状态。", "name": "getBatteryInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "当前设备电量。", "name": "level", "optional": false, "type": "number" }, { "documentation": "当前设备是否充电中。", "name": "isCharging", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getBeaconList", "name": "getBeaconList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getBeacons", "description": "", "documentation": "获取已经搜索到的 iBeacon 设备。", "name": "getBeacons", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "beacons", "optional": false, "type": "object" }, { "documentation": "errorCode=0，接口调用成功。", "name": "errCode", "optional": false, "type": "string" }, { "documentation": "错误描述信息，成功则为 ok。", "name": "errorMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getBizInnerSource", "description": "获取小程序场景值以及专门用于识别特定渠道打开的渠道场景值", "documentation": "获取内部场景值", "name": "getBizInnerSource", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "示例：`1000appcenter` / `1005searchresult`", "documentation": "内部渠道类型", "name": "bizInnerSource", "optional": false, "type": "string" }, { "description": "-", "documentation": "扫码用渠道类型", "name": "schemeInnerSource", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getBizWhiteListStatus", "name": "getBizWhiteListStatus", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getBLEDeviceCharacteristics", "documentation": "获取蓝牙设备特征值信息", "name": "getBLEDeviceCharacteristics", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值对应 service 的 UUID", "name": "serviceId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "设备特征值列", "name": "characteristics", "optional": false, "type": "typedefname" }] } }, { "apiName": "getBLEDeviceRSSI", "documentation": "获取蓝牙低功耗设备的信号强度", "name": "getBLEDeviceRSSI", "parameters": { "in": [{ "documentation": "蓝牙设备 id", "name": "deviceId", "optional": false, "type": "string" }], "out": [{ "documentation": "信号强度，单位 dBm。", "name": "RSSI", "optional": false, "type": "number" }] } }, { "apiName": "getBLEDeviceServices", "name": "getBLEDeviceServices", "parameters": { "in": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }], "out": [{ "documentation": "已发现的设备服务列表", "name": "services", "optional": false, "type": "object" }] } }, { "apiName": "getBLEDeviceStatus", "description": "", "documentation": "获取设备蓝牙授权和开关状态", "name": "getBLEDeviceStatus", "parameters": { "in": [{ "documentation": "是否允许系统弹窗（仅iOS）", "name": "sysAlert", "optional": true, "type": "boolean" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "- 除 0,2,3三种状态码之外，其他可以认为蓝牙授权状态无法确定", "documentation": "授权状态", "name": "authStatus", "optional": false, "type": "object" }, { "description": "- 除 2,4,5三种状态码之外，其他可以认为蓝牙开关状态无法确定。\n- iOS系统，当authStatus=3(蓝牙已授权）时，powerStatus状态才有效", "documentation": "蓝牙开关状态", "name": "powerStatus", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getBLEMTU", "documentation": "获取低功耗蓝牙设备的最大传输单元（Maximum Transmission Unit, MTU）。", "name": "getBLEMTU", "parameters": { "in": [{ "documentation": "蓝牙设备ID", "name": "deviceId", "optional": false, "type": "string" }], "out": [{ "documentation": "外设的 MTU。", "name": "mtu", "optional": false, "type": "number" }] } }, { "apiName": "getBluetoothAdapterState", "description": "目前不支持在开发者工具上进行调试，需要使用真机才能正常调用蓝牙接口。", "documentation": "获取本机蓝牙模块状态。", "name": "getBluetoothAdapterState", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否正在搜索设备。", "name": "discovering", "optional": false, "type": "boolean" }, { "documentation": "蓝牙模块是否可用（需支持 BLE 并且蓝牙是打开状态）。", "name": "available", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getBluetoothDevices", "documentation": "获取扫描到的蓝牙设备", "name": "getBluetoothDevices", "parameters": { "in": [{}], "out": [{ "documentation": "已发现的设备列表。", "name": "devices", "optional": false, "type": "typedefname" }] } }, { "apiName": "getBluetoothPairs", "documentation": "获取蓝牙配对信息", "name": "getBluetoothPairs", "parameters": { "in": [{}], "out": [{ "name": "devices", "optional": false, "type": "typedefname" }] } }, { "apiName": "getBuildProduct", "documentation": "获取当前客户端安装包相关信息", "name": "getBuildProduct", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "应用程序二进制接口", "name": "abi", "optional": false, "type": "enum" }, { "documentation": "操作系统", "name": "os", "optional": false, "type": "enum" }, { "documentation": "包类型", "name": "appPackageForm", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "getBusinessAuth", "documentation": "获取业务授权", "name": "getBusinessAuth", "parameters": { "in": [{ "name": "scopeNicks", "optional": false, "type": "string[]" }], "out": [{ "documentation": "成功的授权 scope", "name": "authSuccessScopes", "optional": false, "type": "string[]" }] } }, { "apiName": "getCameraAuthorizedStatus", "description": "", "documentation": "获取相机授权状态", "name": "getCameraAuthorizedStatus", "parameters": { "in": [{}], "out": [{ "documentation": "当前授权状态", "name": "authorizedStatus", "optional": false, "type": "enum" }] } }, { "apiName": "getCaprManifest", "documentation": "夜鹰模式下的H5页面可通过该接口获取当前页面对应的夜鹰manifest.json配置", "name": "getCaprManifest", "parameters": { "in": [{}], "out": [] } }, { "apiName": "getCarrierName", "documentation": "获取运营商信息", "name": "getCarrierName", "parameters": { "in": [{}], "out": [{ "documentation": "运营商名称，获取不到返回空", "name": "carrierName", "optional": false, "type": "string" }] } }, { "apiName": "getCdpSpaceInfo", "description": "- 与 [cdpFeedback]() 配合使用，详见 https://yuque.antfin.com/industryprod-hz/np50x6/hmi9p2#44c77a01", "documentation": "获取广告位信息", "name": "getCdpSpaceInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "在投放平台申请的投放占位码", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "是否触发多次回调", "name": "multiCallback", "optional": true, "type": "boolean" }, { "documentation": "传给投放平台的个性化扩展参数", "name": "extInfo", "optional": true, "type": "Record<string,any>" }, { "defaultValue": "false", "description": "- false: 会优先使用缓存数据\n- 如果带了 extInfo 个性化参数则必须传true", "documentation": "是否直接从服务端读取", "name": "immediately", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "spaceObjectList", "optional": false, "type": "object" }, { "name": "spaceCode", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getCdpSpaceInfos", "description": "同时查询多个展位的广告数据，用于数据接入投放的场景\n更多详情：https://yuque.antfin-inc.com/wr08f6/winme4/gon9ut", "documentation": "批量获取广告位消息", "name": "getCdpSpaceInfos", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "nil", "documentation": "展位码组，需投放后台申请", "exampleValue": "['MOBILEHALL_FORM','MOBILEHALL_LIST1']", "name": "spaceCodes", "optional": false, "type": "object" }, { "defaultValue": "nil", "documentation": "业务扩展参数，直接透传投放服务端消费", "exampleValue": "{tradeNo:'123'}", "name": "extInfo", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "map结构返回spaceInfo结果，key=spaceCode, value = spaceInfo", "name": "result", "optional": false, "type": "object" }] } }, { "apiName": "getCities", "description": "使用默认内置数据时，特别关注直辖市场景，对应的adcode返回按照城市维度格式，例如：\n北京，110100\n天津，120100\n上海，310100\n重庆，500100", "documentation": "用于呼出城市选择列表", "name": "getCities", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "自定义城市列表。", "name": "customCities", "optional": true, "type": "typedefname" }, { "documentation": "自定义热门城市列表。", "name": "customHotCities", "optional": true, "type": "typedefname" }, { "documentation": "自定义历史访问城市列表。", "name": "customHistoryCities", "optional": true, "type": "typedefname" }, { "documentation": "是否需要现实热门城市，默认true", "name": "needHotCity", "optional": false, "type": "boolean" }, { "documentation": "传入当前使用中的城市名", "name": "currentCity", "optional": false, "type": "string" }, { "documentation": "传入当前使用中的城市的adcode（如果没有用到adcode，可以传入空字符串）", "name": "adcode", "optional": false, "type": "string" }, { "documentation": "只有设置了currentCity和adcode，才支持修改定位城市", "name": "setLocatedCity", "optional": false, "type": "boolean" }, { "documentation": "标题", "name": "title", "optional": false, "type": "string" }, { "documentation": " 业务修改定位城市时的超时时间", "name": "setLocatedCityTimeout", "optional": false, "type": "number" }, { "documentation": "指定行政区划版本号：\n\n● null、空串：使用老版本（2020Q1）\n\n● UPTODATE：使用最新版\n\n● 2022Q2：使用2022Q2版本\n\n10.3.20开始支持，接入联系百喻", "name": "adVersion", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "城市名。", "name": "city", "optional": false, "type": "string" }, { "documentation": "行政区划代码。", "name": "adcode", "optional": false, "type": "string" }, { "documentation": "经度（注意：仅用户选择当前定位城市才会返回）。", "name": "longitude", "optional": true, "type": "number" }, { "documentation": "纬度（注意：仅用户选择当前定位城市才会返回）。", "name": "latitude", "optional": true, "type": "number" }], "type": "Object" }] } }, { "apiName": "getClientConfig", "documentation": "获取客户端的config开关", "name": "getClientConfig", "parameters": { "in": [{ "documentation": "对应的key值", "name": "configKey", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "configKey", "optional": false, "type": "string" }] } }, { "apiName": "getClientInfo", "description": "- 目前禁止该 API 新增小程序使用 @筱满", "documentation": "获取客户端信息", "name": "getClientInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "支付宝客户端版本号", "name": "client.version", "optional": false, "type": "string" }, { "documentation": "UMID设备指纹", "name": "umidToken", "optional": false, "supportInfo": { "androidMinVersion": 9000000, "iosMinVersion": 9000000 }, "type": "string" }, { "documentation": "客户端系统名称", "name": "os.name", "optional": false, "type": "string" }, { "documentation": "客户端系统版本", "name": "os.verion", "optional": false, "type": "string" }, { "documentation": "客户端IMEI号", "name": "device.id", "optional": false, "type": "string" }, { "documentation": "渠道号", "name": "channelId", "optional": false, "supportInfo": { "androidMinVersion": 9006000, "iosMinVersion": 9006000 }, "type": "string" }, { "documentation": "设备型号", "name": "model", "optional": false, "type": "string" }, { "documentation": "设备名", "name": "device", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getClipboard", "description": "本接口功能可能涉及隐私问题，请谨慎使用。", "documentation": "获取剪贴板数据。", "name": "getClipboard", "parameters": { "in": [{}], "out": [{ "documentation": "剪贴板数据。", "name": "text", "optional": false, "type": "string" }] } }, { "apiName": "getConfig", "documentation": "获取客户端网关及用户设备信息", "name": "getConfig", "parameters": { "in": [{ "documentation": "", "name": "configKeys", "optional": false, "type": "enum" }], "out": [{ "documentation": "", "name": "data", "optional": false, "type": "object" }] } }, { "apiName": "getConfig4Appx", "description": "只能获取key: tinyApLogLevel 的值，不支持获取其他key值的value", "documentation": "appx获取配置信息", "name": "getConfig4Appx", "parameters": { "in": [{ "documentation": "仅支持获取tinyApLogLevel的值", "name": "key", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "configKey", "optional": false, "type": "string" }] } }, { "apiName": "getConnectedBluetoothDevices", "documentation": "获取当前已连接的蓝牙设备", "name": "getConnectedBluetoothDevices", "parameters": { "in": [{}], "out": [{ "documentation": "已连接的设备列表。", "name": "devices", "optional": false, "type": "typedefname" }] } }, { "apiName": "getConnectedWifi", "documentation": "获取链接的wifi信息", "name": "getConnectedWifi", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "wifi", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getContainerTime", "name": "getContainerTime", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "appcreate", "optional": false, "type": "number" }, { "documentation": "", "name": "loadrequest", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getCurrentLocation", "name": "getCurrentLocation", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "水平精度", "name": "horizontalAccuracy", "optional": true, "supportInfo": { "iosMinVersion": 10000000 }, "type": "number" }, { "defaultValue": "0", "description": "0, 只获取经纬度\n1, 获取经纬度和详细到区县级别的逆地理\n2, 获取经纬度和详细到街道级别的逆地理\n3, 获取经纬度和详细到POI级别的逆地理", "documentation": "请求类别（见详细解释）", "name": "requestType", "optional": true, "type": "number" }, { "name": "useDefault", "optional": true, "type": "boolean" }, { "documentation": "高精度（Android)", "name": "isHighAccuracy", "optional": true, "supportInfo": { "androidMinVersion": 10000000 }, "type": "boolean" }, { "documentation": "纯 GPS（Android）", "name": "isNeedCureGps", "optional": true, "supportInfo": { "androidMinVersion": 10000000 }, "type": "boolean" }, { "documentation": "显示速度，用于持续定位", "name": "isNeedSpeed", "optional": true, "supportInfo": { "androidMinVersion": 10000000 }, "type": "boolean" }, { "documentation": "业务唯一标识", "name": "bizType", "optional": true, "supportInfo": { "androidMinVersion": 10000018, "iosMinVersion": 10000018 }, "type": "string" }, { "defaultValue": "30", "documentation": "可接受的缓存时间，单位秒", "name": "cacheTimeout", "optional": true, "supportInfo": { "androidMinVersion": 10000018, "iosMinVersion": 10000018 }, "type": "number" }, { "defaultValue": "10", "description": "iOS 默认值 2s, Android 默认值 10 s", "documentation": "超时时间，单位秒", "name": "timeout", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "city", "optional": true, "type": "string" }, { "name": "province", "optional": true, "type": "string" }, { "name": "latitude", "optional": true, "type": "string" }, { "name": "longitude", "optional": true, "type": "string" }, { "name": "accuracy", "optional": true, "type": "string" }, { "name": "horizontalAccuracy", "optional": true, "type": "string" }, { "name": "speed", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "getCustomCities", "name": "getCustomCities", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getDarkModeSetting", "documentation": "获取钱包当前设置的深色模式状态", "name": "getDarkModeSetting", "parameters": { "in": [{}], "out": [{ "documentation": "当前用户在钱包设置中选择的模式", "name": "currentMode", "optional": false, "type": "object" }] } }, { "apiName": "getDeviceBaseInfo", "documentation": "获取设备基础信息（品牌，型号，操作系统和平台，内存大小）。", "name": "getDeviceBaseInfo", "parameters": { "in": [{ "documentation": "所需要的设备基础信息数组", "name": "options", "optional": true, "type": "Array" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "设备内存大小", "name": "storage", "optional": true, "type": "string" }, { "documentation": "设备品牌", "name": "brand", "optional": true, "type": "string" }, { "documentation": "设备型号（iPhone几）", "name": "model", "optional": true, "type": "string" }, { "documentation": "客户端平台（andriod，iOS）", "name": "platform", "optional": true, "type": "string" }, { "documentation": "操作系统及版本", "name": "system", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "getDeviceID", "documentation": "获取设备唯一标识", "name": "getDeviceID", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "不同系统的值类型见 `type`", "documentation": "设备唯一标识，经过无线保镖加密\n", "name": "data", "optional": false, "type": "string" }, { "description": "", "documentation": "设备唯一标识类型", "name": "type", "optional": false, "supportInfo": { "androidMinVersion": 10002008, "iosMinVersion": 10002008 }, "type": "object" }, { "name": "umidToken", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getDeviceInfo", "documentation": "获取设备idfa、idfv、utdid信息", "name": "getDeviceInfo", "parameters": { "in": [{}], "out": [{ "name": "data", "optional": false, "type": "string" }] } }, { "apiName": "getDowngradeResult", "description": "详见 [语雀：统一降级介绍](https://yuque.antfin.com/docs/share/f74c75d9-b788-4ab2-b3b4-d2fcb6bc6055)", "documentation": "获取客户端统一降级信息", "name": "getDowngradeResult", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 一般是 appId 即可\n- 如果一个 appId 有多个场景需要降级, 那可以 `bizId+sceneId` 组合判断", "documentation": "降级场景 id", "name": "bizId", "optional": false, "type": "string" }, { "description": "- 该字段为 \"位运算值\"\n- 如需获取 \"内存(2=1<<1)\" 和 \"闪退(4=1<<2)\"，需要传入 “6=(1<<1)|(1<<2)”\n", "documentation": "降级场景（位运算值）", "name": "scene", "optional": false, "type": "enum" }, { "documentation": "扩展参数", "name": "ext", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否降级", "name": "resultType", "optional": false, "type": "enum" }, { "documentation": "降级原因", "name": "resultReason", "optional": false, "type": "number" }, { "documentation": "降级原因描述", "name": "resultReasonDesc", "optional": false, "type": "string" }, { "documentation": "机器性能", "name": "deviceLevel", "optional": true, "supportInfo": { "androidMinVersion": 10001098, "iosMinVersion": 10001098 }, "type": "enum" }, { "documentation": "降级原因描述", "name": "uniqueId", "optional": false, "type": "string" }, { "documentation": "降级原因描述", "name": "context", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getDynamicInfos", "documentation": "10.2.18 版本，获取微动效信息", "name": "getDynamicInfos", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "scene", "optional": true, "type": "string" }, { "documentation": "", "name": "filterAppIdList", "optional": true, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "maxPlayTimes", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getEdgeMiningConfig", "name": "getEdgeMiningConfig", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "当前页面的应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "当前页面的URL", "name": "url", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否需要采集当前页面内容", "name": "enabled", "optional": false, "type": "boolean" }, { "documentation": "页面采集内容范围，类型为对象类型。例：{\n      \"text\": [\"size\", \"color\", \"family\", \"xpath\", \"position\", \"spm\"],\n      \"image\" : [\"xpath\", \"spm\", \"position\"]\n    } \n", "name": "scope", "optional": false, "type": "unknown" }, { "documentation": "最长文案采集长度", "name": "maxTextLen", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getEdgeRisk", "name": "getEdgeRisk", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "opType", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "bizToken", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "bizParam", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "status", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "risk", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getExtConfig", "name": "getExtConfig", "parameters": { "in": [{}], "out": [{ "documentation": "ext.json 数据", "name": "property", "optional": false, "type": "unknown" }] } }, { "apiName": "getExternalThrough", "name": "getExternalThrough", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "externalThrough", "optional": false, "type": "string" }] } }, { "apiName": "getFileInfo", "name": "getFileInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "filePath", "optional": true, "type": "string" }, { "name": "apFilePath", "optional": true, "type": "string" }, { "defaultValue": "md5", "name": "digestAlgorithm", "optional": false, "type": "\"md5\" | \"sha1\"" }, { "name": "sharedBiz", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "size", "optional": false, "type": "number" }, { "name": "digest", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getForegroundAudioOption", "name": "getForegroundAudioOption", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "audioPlayerID", "optional": false, "type": "string" }, { "name": "optionName", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }, { "name": "src", "optional": true, "type": "string" }, { "name": "autoPlay", "optional": true, "type": "boolean" }, { "name": "loop", "optional": true, "type": "boolean" }, { "name": "isRecordAudioPlayState", "optional": true, "type": "boolean" }, { "documentation": "开始播放的位置，单位：秒", "name": "startTime", "optional": true, "type": "number" }, { "name": "volume", "optional": true, "type": "number" }, { "name": "duration", "optional": true, "type": "number" }, { "name": "currentTime", "optional": true, "type": "number" }, { "documentation": "获取已经缓冲的时间", "name": "buffered", "optional": true, "type": "number" }, { "name": "paused", "optional": true, "type": "boolean" }, { "documentation": "获取配速设置", "name": "playbackRate", "optional": true, "type": "number" }, { "name": "ccode", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "getGradeInfo", "documentation": "分级体验jsapi。分级体验提供了基于设备、内存、闪退、GPU等维度的降级能力，业务方可根据分级体验的结果实现降级后的逻辑；", "name": "getGradeInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "bizId", "optional": true, "type": "string" }, { "name": "sceneCode", "optional": true, "type": "string" }, { "name": "performanceType", "optional": false, "type": "number" }, { "name": "stabilityParam", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "error", "optional": true, "type": "string" }, { "name": "errorMessage", "optional": true, "type": "string" }, { "name": "resultFlag", "optional": false, "type": "boolean" }, { "name": "performanceCode", "optional": false, "type": "number" }, { "name": "performanceMessage", "optional": true, "type": "string" }, { "name": "stabilityCode", "optional": false, "type": "number" }, { "name": "stabilityMessage", "optional": true, "type": "string" }, { "name": "crashCount", "optional": false, "type": "number" }, { "name": "deviceInfo", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "getGradeSwitchState", "documentation": "获取App极速模式开关状态", "name": "getGradeSwitchState", "parameters": { "in": [{}], "out": [{ "documentation": "0：关闭\n1 ：打开", "name": "switchState", "optional": false, "type": "number" }] } }, { "apiName": "getH5DomUrlFromWasp", "documentation": "蚂蚁众测Native端与前端H5层数据通信的JSAPI，获取h5 dom的url地址", "name": "getH5DomUrlFromWasp", "parameters": { "in": [{}], "out": [{ "documentation": "dom的url，字段内容可空", "name": "domUrl", "optional": false, "type": "string" }] } }, { "apiName": "getHardwareInfo", "documentation": "获取CPU/GPU硬件信息", "name": "getHardwareInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": " ", "documentation": "CPU 信息", "name": "cpu", "optional": false, "type": "object" }, { "description": " ", "documentation": "GPU 信息", "name": "gpu", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getHCEState", "documentation": "判断当前设备是否支持 HCE 能力。", "name": "getHCEState", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "getImageInfo", "name": "getImageInfo", "parameters": { "in": [{ "documentation": "图片路径，目前支持：\n- 网络图片路径\n- apFilePath路径\n- 相对路径", "name": "src", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "图片宽度（单位px）", "name": "width", "optional": false, "type": "number" }, { "documentation": "图片高度（单位px）", "name": "height", "optional": false, "type": "number" }, { "documentation": "图片本地路径", "name": "path", "optional": false, "type": "string" }, { "name": "size", "optional": true, "type": "number" }, { "documentation": "返回图片的格式", "name": "type", "optional": false, "type": "number" }, { "documentation": "返回图片的方向", "name": "orientation", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getIsoDepHistoricalBytes", "documentation": "", "name": "getIsoDepHistoricalBytes", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "documentation": "返回历史二进制数据", "name": "histBytes", "optional": false, "type": "ArrayBuffer" }] } }, { "apiName": "getLastLbsinfo", "name": "getLastLbsinfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getLayoutDirection", "name": "getLayoutDirection", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getLocaleInfo", "name": "getLocaleInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getLoginToken", "name": "getLoginToken", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "token", "optional": false, "type": "string" }, { "name": "encrypted", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getMainSelectedCity", "description": "首页优先获取定位城市信息, 如果用户手动选择过城市, 则替换为用户手动选择的城市, isManualSelected决定是否是手动选择的城市。", "documentation": "获取支付宝首页城市选择信息。", "name": "getMainSelectedCity", "parameters": { "in": [{ "documentation": "是否需要获取城市的全称；\n比如北京的全称为北京市；\n默认返回简称", "name": "needFullName", "optional": true, "type": "boolean" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "城市的全称，比如北京，对应的全称为北京市", "name": "fullName", "optional": true, "type": "string" }, { "documentation": "城市英文名称", "name": "enName", "optional": true, "supportInfo": { "androidMinVersion": 10002018, "iosMinVersion": 10002018 }, "type": "string" }, { "documentation": "区县英文名称", "name": "enDistrictName", "optional": true, "supportInfo": { "androidMinVersion": 10002018, "iosMinVersion": 10002018 }, "type": "string" }, { "documentation": "城市名称", "name": "name", "optional": false, "type": "string" }, { "documentation": "城市编码", "name": "code", "optional": false, "type": "string" }, { "documentation": "是否是中国大陆", "name": "chineseMainLand", "optional": false, "type": "boolean" }, { "documentation": "是否是手动选择", "name": "isManualSelected", "optional": false, "type": "boolean" }, { "documentation": "设置时间", "name": "settingTime", "optional": false, "type": "number" }, { "documentation": "区县名", "name": "districtName", "optional": true, "supportInfo": { "androidMinVersion": 10001099, "iosMinVersion": 10001099 }, "type": "string" }, { "documentation": "区县编码", "name": "districtCode", "optional": true, "supportInfo": { "androidMinVersion": 10001099, "iosMinVersion": 10001099 }, "type": "string" }], "type": "Object" }] } }, { "apiName": "getMapInfo", "documentation": "获取地图属性信息", "name": "getMapInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否是3D地图引擎", "name": "is3d", "optional": false, "type": "boolean" }, { "documentation": "是否支持动画", "name": "isSupportAnim", "optional": false, "type": "boolean" }, { "documentation": "SDK名称", "name": "sdkName", "optional": false, "type": "string" }, { "documentation": "SDK版本号", "name": "sdkVersion", "optional": false, "type": "string" }, { "documentation": "是否支持海外地图", "name": "isSupportOversea", "optional": false, "type": "boolean" }, { "documentation": "需要7.x版本样式文件", "name": "needStyleV7", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getMarketApps", "documentation": "获取应用市场页全部数据，目前只提供给“我的小程序使用”", "name": "getMarketApps", "parameters": { "in": [{ "documentation": "", "name": "recentUseAppType", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "isDisplayRecent", "optional": false, "type": "boolean" }, { "documentation": "", "name": "scale", "optional": false, "type": "number" }, { "documentation": "", "name": "homePageAppCount", "optional": false, "type": "number" }, { "documentation": "", "name": "RPCBaseInfo", "optional": false, "type": "object" }, { "documentation": "", "name": "topApps", "optional": false, "type": "string | #$#" }, { "documentation": "", "name": "timeLimitAppId", "optional": true, "type": "string" }, { "documentation": "", "name": "globalRecommend", "optional": true, "type": "object" }, { "documentation": "", "name": "recentApps", "optional": false, "type": "object" }, { "documentation": "", "name": "myApps", "optional": false, "type": "object" }, { "documentation": "", "name": "arhatTag", "optional": true, "type": "string" }, { "documentation": "", "name": "badgeInfo", "optional": false, "type": "object" }, { "documentation": "", "name": "columnCount", "optional": false, "type": "number" }, { "documentation": "", "name": "unMovableAppList", "optional": false, "type": "string[]" }, { "documentation": "", "name": "addToHomeTagEnable", "optional": false, "type": "boolean" }, { "documentation": "", "name": "hasBubbleTip", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getMcdpCacheModuleInfos", "name": "getMcdpCacheModuleInfos", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getMcdpCacheModuleInfosMain", "name": "getMcdpCacheModuleInfosMain", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getMediaFileEditorCapability", "name": "getMediaFileEditorCapability", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "number" }, { "documentation": "", "name": "videoCollection", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getMemoryInfo", "description": "iOS 内存判断建议同时满足下面两个条件：\n- systemMemoryLevel 大于10\n- 预计使用内存*2 < availableMemory ", "documentation": "获取系统内存情况", "name": "getMemoryInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "系统内存水平\n范围: 0~100, 10 以下有风险", "name": "systemMemoryLevel", "optional": true, "supportInfo": { "iosMinVersion": 10001082 }, "type": "number" }, { "documentation": "支付宝当前占用内存 KB", "name": "currentMemory", "optional": false, "type": "number" }, { "documentation": "当前系统剩余内存 KB", "name": "availableMemory", "optional": false, "type": "number" }, { "documentation": "手机运行时内存(RAM) KB", "name": "totalMemory", "optional": false, "type": "number" }, { "documentation": "判断当前是否处于低内存状态", "name": "isLowMemory", "optional": true, "supportInfo": { "androidMinVersion": 10001082 }, "type": "boolean" }, { "documentation": "系统低内存阈值", "name": "lowMemoryThreshold", "optional": true, "supportInfo": { "androidMinVersion": 10001082 }, "type": "number" }, { "documentation": "系统可为每个应用分配的最大内存 KB", "name": "maxMemory", "optional": true, "supportInfo": { "androidMinVersion": 10001082 }, "type": "number" }], "type": "Object" }] } }, { "apiName": "getMenuButtonBoundingClientRect", "description": "- Android 所有返回数值需要除以 DPR", "documentation": "获取小程序菜单胶囊按钮的布局位置信息", "name": "getMenuButtonBoundingClientRect", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "appId", "name": "appId", "optional": true, "type": "string" }, { "documentation": "sessionId", "name": "sessionId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "宽度，px", "name": "width", "optional": false, "type": "number" }, { "name": "optionMenuWidth", "optional": false, "type": "number" }, { "documentation": "高度，px", "name": "height", "optional": false, "type": "number" }, { "name": "optionMenuHeight", "optional": false, "type": "number" }, { "documentation": "顶部坐标", "name": "top", "optional": false, "type": "number" }, { "name": "optionMenuTop", "optional": false, "type": "number" }, { "documentation": "右边坐标", "name": "right", "optional": false, "type": "number" }, { "name": "optionMenuRight", "optional": false, "type": "number" }, { "documentation": "底部坐标", "name": "bottom", "optional": false, "type": "number" }, { "name": "optionMenuBottom", "optional": false, "type": "number" }, { "documentation": "左边坐标", "name": "left", "optional": false, "type": "number" }, { "name": "optionMenuLeft", "optional": false, "type": "number" }, { "documentation": "小程序 『收藏』 状态", "name": "optionMenuStatus", "optional": false, "supportInfo": { "androidMinVersion": 10002030, "iosMinVersion": 10002015 }, "type": "enum" }], "type": "Object" }] } }, { "apiName": "getMtopToken", "documentation": "获取 mtop 淘宝开放平台令牌", "name": "getMtopToken", "parameters": { "in": [{ "documentation": "要取token的域", "name": "domain", "optional": false, "type": "string" }], "out": [{ "documentation": "返回的token", "name": "token", "optional": false, "type": "string" }] } }, { "apiName": "getMyTabList", "name": "getMyTabList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getNetworkCost", "description": "- 用于小程序 IDE 获取页面内网络相关（httpRequest/resource/rpc）性能数据，仅当 `nbsource=debug` 时可用\n- 调用一次就会清空数据", "documentation": "获取网络性能数据", "name": "getNetworkCost", "parameters": { "in": [{}], "out": [{ "name": "result", "optional": false, "type": "object" }] } }, { "apiName": "getNetworkType", "documentation": "获取当前设备的网络状态", "name": "getNetworkType", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "网络是否可用。", "name": "networkAvailable", "optional": false, "type": "boolean" }, { "documentation": "网络类型值", "name": "networkInfo", "optional": false, "type": "enum" }, { "name": "networkType", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getNfcAAtqa", "name": "getNfcAAtqa", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "documentation": "返回 ATQA/SENS_RES 数据", "name": "atqa", "optional": false, "type": "ArrayBuffer" }] } }, { "apiName": "getNfcASak", "name": "getNfcASak", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "documentation": "返回 SAK/SEL_RES 数据", "name": "sak", "optional": false, "type": "number" }] } }, { "apiName": "getNFCMaxTransceiveLength", "name": "getNFCMaxTransceiveLength", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "documentation": "最大传输长度", "name": "length", "optional": false, "type": "number" }] } }, { "apiName": "getOfflineTabTip", "name": "getOfflineTabTip", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "offlineTabTip", "optional": false, "type": "string" }] } }, { "apiName": "getOpenUserData", "documentation": "获取用户标识（加密的数据）", "name": "getOpenUserData", "parameters": { "in": [{}], "out": [{ "documentation": "加密后的 userId", "name": "uid", "optional": false, "type": "string" }] } }, { "apiName": "getPermissionBizList", "documentation": "权限堡垒，获取指定权限业务名单列表", "name": "getPermissionBizList", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "exampleValue": "APP_HISTORY", "name": "listTypeEnum", "optional": false, "type": "string" }, { "exampleValue": "LBS", "name": "permissionType", "optional": false, "type": "string" }, { "exampleValue": "0", "name": "pageNum", "optional": false, "type": "number" }, { "exampleValue": "10", "name": "pageSize", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "exampleValue": "{   \"20000007\": \"扫一扫\" }", "name": "appIdNameList", "optional": false, "type": "string" }, { "exampleValue": "0", "name": "pageNum", "optional": false, "type": "number" }, { "exampleValue": "10", "name": "pageSize", "optional": false, "type": "number" }, { "exampleValue": "false", "name": "hasNext", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getPermissionGuideContent", "name": "getPermissionGuideContent", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getPopMenuInfo", "documentation": "获取当前小程序popMenu的部分信息", "name": "getPopMenuInfo", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "menu", "optional": true, "type": "object" }] } }, { "apiName": "getPPFollowStatus", "name": "getPPFollowStatus", "parameters": { "in": [{ "name": "publicIds", "optional": false, "type": "string[]" }], "out": [{ "documentation": "对应生活号ID关注状态", "name": "publicId", "optional": false, "type": "enum" }] } }, { "apiName": "getQRCodeImage", "documentation": "离线生成二维码", "name": "getQRCodeImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "待生成的字符串", "name": "content", "optional": false, "type": "string" }, { "defaultValue": "QRCODE", "documentation": "生成码类型", "name": "format", "optional": false, "type": "enum" }, { "description": "为了防止二维码在拉伸后出现半像素问题，实际图片宽度会有不一致", "documentation": "图片宽度", "name": "width", "optional": false, "type": "number" }, { "description": "为了防止二维码在拉伸后出现半像素问题，实际图片高度会有不一致", "documentation": "图片高度", "name": "height", "optional": false, "type": "number" }, { "documentation": "背景色", "name": "bgColor", "optional": false, "supportInfo": { "androidMinVersion": 10000022, "iosMinVersion": 10000022 }, "type": "string" }, { "description": "仅适用于 'QRCODE'", "documentation": "定点色", "name": "cornerColor", "optional": false, "supportInfo": { "androidMinVersion": 10000022, "iosMinVersion": 10000022 }, "type": "string" }, { "description": "base64格式，仅适用于QRCODE", "documentation": "头像", "name": "avatar", "optional": false, "type": "string" }, { "description": "仅适用于条形码", "documentation": "标题", "name": "barcodeText", "optional": false, "type": "string" }, { "defaultValue": "2", "documentation": "冗余度", "name": "erLevel", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "base64 格式的 image", "name": "image", "optional": false, "type": "string" }] } }, { "apiName": "getRecentUsedItems", "name": "getRecentUsedItems", "parameters": { "in": [{ "documentation": "", "name": "source", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "recentApps", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getRunData", "name": "getRunData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "true", "name": "useStep", "optional": true, "type": "boolean" }, { "name": "showTip", "optional": true, "type": "boolean" }, { "name": "countDate", "optional": false, "type": "string" }, { "name": "countDates", "optional": true, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "步数列表", "name": "list", "optional": false, "type": "object" }, { "documentation": "是否加密", "name": "type", "optional": false, "type": "\"decrypt\" | \"encrypt\"" }], "type": "Object" }] } }, { "apiName": "getRunScene", "documentation": "获取当前小程序的运行版本", "name": "getRunScene", "parameters": { "in": [{}], "out": [{ "documentation": "小程序当前运行的版本", "name": "envVersion", "optional": false, "type": "enum" }] } }, { "apiName": "getSavedFileInfo", "name": "getSavedFileInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "filePath", "optional": true, "type": "string" }, { "name": "apFilePath", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "size", "optional": false, "type": "number" }, { "name": "createTime", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getSavedFileList", "name": "getSavedFileList", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "fileList", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getSceneStackInfo", "documentation": "获取当前的页面栈信息", "name": "getSceneStackInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "当前栈内页面总数", "name": "count", "optional": false, "type": "number" }, { "documentation": "当前所在层数", "name": "currentIndex", "optional": false, "type": "number" }, { "documentation": "堆栈对象", "name": "detail", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "getScreenBrightness", "documentation": "获取屏幕亮度", "name": "getScreenBrightness", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "屏幕亮度，取值范围0-1", "name": "brightness", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getScreenOrientation", "documentation": "获取横竖屏状态", "name": "getScreenOrientation", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "横竖屏状态", "name": "orientation", "optional": false, "type": "enum" }], "type": "Object" }] } }, { "apiName": "getSecurityBodyWua", "name": "getSecurityBodyWua", "parameters": { "in": [{ "documentation": "", "name": "flag", "optional": true, "type": "string" }], "out": [{ "documentation": "", "name": "generalWua", "optional": false, "type": "string" }] } }, { "apiName": "getSelectedTextRange", "name": "getSelectedTextRange", "parameters": { "in": [{}], "out": [{ "name": "cursor", "optional": false, "type": "number" }] } }, { "apiName": "getServerTime", "description": "离线情况下无法获取有效时间", "documentation": "获取当前服务器时间", "name": "getServerTime", "parameters": { "in": [{}], "out": [{ "documentation": "服务器时间", "name": "time", "optional": false, "type": "number" }] } }, { "apiName": "getSessionData", "documentation": "读取缓存数据（应用生命周期内）", "name": "getSessionData", "parameters": { "in": [{ "documentation": "要读取的数据的key", "name": "keys", "optional": false, "type": "string[]" }], "out": [{ "documentation": "keys对应的字段数据", "name": "data", "optional": false, "type": "Record<string,string>" }] } }, { "apiName": "getSetting", "name": "getSetting", "parameters": { "in": [{}], "out": [{ "name": "authSetting", "optional": false, "type": "object" }] } }, { "apiName": "getSharedData", "description": "- [getSharedData]()，[setSharedData]() 以及 [removeSharedData]() 可以跨 appId 共享数据\n- 建议换用更可靠的 [getAPDataStorage]()", "documentation": "获取共享数据", "name": "getSharedData", "parameters": { "in": [{ "documentation": "要读取或删除的数据项的键名", "name": "keys", "optional": false, "type": "string[]" }], "out": [{ "documentation": "keys 对应的字段数据", "name": "data", "optional": false, "type": "Object<String, String>" }] } }, { "apiName": "getSiteInfo", "name": "getSiteInfo", "parameters": { "in": [{}], "out": [{ "documentation": "站点名称，支付宝返回ALIPAY_CN", "name": "siteName", "optional": false, "type": "string" }] } }, { "apiName": "getSnapshotConfig", "name": "getSnapshotConfig", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getSpaceInfos", "name": "getSpaceInfos", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getStartupParams", "name": "getStartupParams", "parameters": { "in": [], "out": [{ "documentation": "启动参数键值对", "name": "property", "optional": true, "type": "unknown" }] } }, { "apiName": "getSupportDarkMode", "documentation": "获取是否显示深色默认入口", "name": "getSupportDarkMode", "parameters": { "in": [{}], "out": [{ "documentation": "ture:表示支持深色模式需要显示深色模式入口; false: 不支持深色模式无需显示该入口", "name": "supportDarkMode", "optional": true, "type": "boolean" }] } }, { "apiName": "getSystemInfo", "description": "", "documentation": "获取手机系统信息API", "name": "getSystemInfo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "true", "documentation": "是否需要缓存", "name": "needCache", "optional": true, "supportInfo": { "androidMinVersion": 10001052, "iosMinVersion": 10001052 }, "type": "boolean" }, { "documentation": "是否是整个小程序第一个页面", "name": "isAppFirstPage", "optional": true, "type": "boolean" }, { "defaultValue": "false", "description": "", "documentation": "仅iOS，传递后会返回：bluetoothEnabled，bluetoothAuthorized", "name": "includeBluetooth", "optional": true, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "defaultValue": "false", "documentation": "仅iOS，传递后会返回：notificationAuthorized，notificationAlertAuthorized，notificationBadgeAuthorized，notificationSoundAuthorized", "name": "includeNotification", "optional": true, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "description": "", "documentation": "业务所需字段，若字段为空时，返回所有字段", "name": "options", "optional": true, "supportInfo": { "androidMinVersion": 10002060, "iosMinVersion": 10002060 }, "type": "string[]" }, { "defaultValue": "false", "documentation": "设置为 true 后screenHeight、screenWidth 在 Android 上返回逻辑像素", "name": "fixScreen", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "若当前为支付宝，则有效值为 \"alipay\"", "documentation": "当前运行的客户端", "name": "app", "optional": false, "supportInfo": { "androidMinVersion": 10001060, "iosMinVersion": 10001060 }, "type": "string" }, { "documentation": "客户端设置的语言", "name": "language", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string" }, { "documentation": "设备像素比", "name": "pixelRatio", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string | number" }, { "documentation": "系统名", "name": "platform", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "string" }, { "exampleValue": "ap", "name": "platformType", "optional": true, "type": "string" }, { "documentation": "屏幕宽度", "name": "screenWidth", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "number" }, { "documentation": "标题栏高度", "name": "titleBarHeight", "optional": false, "supportInfo": { "androidMinVersion": 10001035, "iosMinVersion": 10001035 }, "type": "number" }, { "documentation": "客户端版本号", "name": "version", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string" }, { "documentation": "窗口宽度", "name": "windowWidth", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string | number" }, { "documentation": "用于 Android API 版本", "name": "apiLevel", "optional": true, "type": "number" }, { "documentation": "手机品牌", "name": "brand", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "string" }, { "documentation": "当前电量百分比", "name": "currentBattery", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "string" }, { "documentation": "用户设置字体大小", "name": "fontSizeSetting", "optional": false, "supportInfo": { "androidMinVersion": 10001060, "iosMinVersion": 10001060 }, "type": "number" }, { "documentation": "手机型号", "name": "model", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string" }, { "documentation": "设备性能分级", "name": "performance", "optional": true, "supportInfo": { "androidMinVersion": 10001062 }, "type": "typedefname" }, { "name": "screen", "optional": false, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "typedefname" }, { "documentation": "屏幕高度", "name": "screenHeight", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "number" }, { "documentation": "状态栏高度", "name": "statusBarHeight", "optional": false, "supportInfo": { "androidMinVersion": 10001035, "iosMinVersion": 10001035 }, "type": "number" }, { "documentation": "设备磁盘容量，以 GB 为单位", "name": "storage", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "string" }, { "documentation": "操作系统版本", "name": "system", "optional": false, "supportInfo": { "androidMinVersion": 10001012, "iosMinVersion": 10001012 }, "type": "string" }, { "documentation": "透明状态栏", "name": "transparentTitle", "optional": false, "supportInfo": { "androidMinVersion": 10001060, "iosMinVersion": 10001060 }, "type": "boolean" }, { "documentation": "窗口高度", "name": "windowHeight", "optional": false, "supportInfo": { "androidMinVersion": 9009006, "iosMinVersion": 9009006 }, "type": "string | number" }, { "documentation": "允许支付宝使用相册的开关", "name": "albumAuthorized", "optional": false, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝使用摄像头的开关", "name": "cameraAuthorized", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝使用定位的开关", "name": "locationAuthorized", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝使用麦克风的开关", "name": "microphoneAuthorized", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "定位的系统开关", "name": "locationEnabled", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "Wi-Fi 的系统开关", "name": "wifiEnabled", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "蓝牙的系统开关", "name": "bluetoothEnabled", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝使用蓝牙的开关", "name": "bluetoothAuthorized", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝通知的开关", "name": "notificationAuthorized", "optional": false, "supportInfo": { "androidMinVersion": 10002000, "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝通知带有提醒的开关", "name": "notificationAlertAuthorized", "optional": false, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝通知带有标记的开关", "name": "notificationBadgeAuthorized", "optional": false, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "允许支付宝啊通知带有声音的开关", "name": "notificationSoundAuthorized", "optional": false, "supportInfo": { "iosMinVersion": 10002000 }, "type": "boolean" }, { "documentation": "在竖屏正方向下的安全区域", "name": "safeArea", "optional": false, "supportInfo": { "androidMinVersion": 10002058, "iosMinVersion": 10002058 }, "type": "typedefname" }], "type": "Object" }] } }, { "apiName": "getSystemSetting", "name": "getSystemSetting", "parameters": { "in": [{ "documentation": "", "name": "options", "optional": true, "type": "string[]" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "wifiEnabled", "optional": false, "type": "boolean" }, { "documentation": "", "name": "bluetoothEnabled", "optional": true, "type": "boolean" }, { "documentation": "", "name": "locationEnabled", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getTaobaoAuthCode", "description": "淘宝授权 JSAPI，用于支付宝端内一方 H5、小程序业务获取淘宝授权中心的 authCode", "documentation": "获取淘宝授权码", "name": "getTaobaoAuthCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "授权场景，业务接入淘宝授权时分配", "exampleValue": "authorize_demo", "name": "authorizeScene", "optional": false, "type": "string" }, { "defaultValue": "false", "documentation": "是否仅使用端内 H5 绑定淘宝，默认为 \"false\" 如果为 false：则有安装淘宝 app 优先走唤端授权绑定，未安装淘宝 app 走 H5 链路； 如果为 true：则不管有没有安装淘宝 app，都走端内打开 H5 绑定链路", "exampleValue": "true", "name": "h5Only", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "授权结果码", "exampleValue": "1000", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "授权结果文案描述", "exampleValue": "授权成功", "name": "resultMemo", "optional": false, "type": "string" }, { "documentation": "淘宝授权码\n", "exampleValue": "xxxxxx", "name": "oauthCode", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getTBCode", "name": "getTBCode", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "淘宝授权码", "name": "code", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getTBSessionInfo", "name": "getTBSessionInfo", "parameters": { "in": [{}], "out": [{ "documentation": "淘宝授权会话信息", "name": "data", "optional": false, "type": "Record<string,unknown>" }] } }, { "apiName": "getTinyLocalStorage", "description": "H5请使用 [getAPDataStorage]()", "documentation": "获取应用存储的KV数据", "name": "getTinyLocalStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "key", "optional": false, "type": "string" }, { "name": "type", "optional": false, "type": "\"user\"" }, { "documentation": "近端缓存专用字段，如果是首页请求的，则会将key存储到近端缓存中", "name": "isAppFirstPage", "optional": true, "type": "boolean" }, { "documentation": "如果从上下文中没有获取到appId，则会从参数中取business，当做appId查询数据", "name": "business", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "返回的内容", "name": "data", "optional": true, "type": "string" }, { "name": "success", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getTinyLocalStorageInfo", "documentation": "获取本地键值对存储信息", "name": "getTinyLocalStorageInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "当前 storage 中所有的 key", "name": "keys", "optional": false, "type": "string[]" }, { "documentation": "当前占用的空间大小，单位为 KB", "name": "currentSize", "optional": false, "type": "number" }, { "documentation": "限制的空间大小，单位为 KB", "name": "limitSize", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getTitle", "name": "getTitle", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getTitleAndStatusbarHeight", "description": "- 导航栏包括（标题栏和状态栏）", "documentation": "获取导航栏完整高度", "name": "getTitleAndStatusbarHeight", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "屏幕密度", "name": "density", "optional": false, "supportInfo": { "androidMinVersion": 10001032 }, "type": "number" }, { "documentation": "标题栏高度，单位 px", "name": "titleBarHeight", "optional": false, "type": "number" }, { "documentation": "状态栏高度，单位 px", "name": "statusBarHeight", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getTitleColor", "name": "getTitleColor", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "十进制值", "name": "color", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getUcdpLandingInfo", "name": "getUcdpLandingInfo", "parameters": { "in": [{ "documentation": "", "name": "positionCode", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "sourcePosition", "optional": true, "type": "string" }, { "documentation": "", "name": "landingInfo", "optional": false, "type": "string" }, { "documentation": "", "name": "sourceCreative", "optional": true, "type": "string" }, { "documentation": "", "name": "landingPositionCode", "optional": true, "type": "string" }, { "documentation": "", "name": "sourceCreativeCode", "optional": true, "type": "string" }, { "documentation": "", "name": "sourcePositionCode", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "getUcdpPositions", "description": "同时查询多个UCDP展位的数据，用于数据接入投放的场景\n更多详情：https://yuque.antfin-inc.com/wr08f6/bru64q/fgxn0h", "documentation": "获取UCDP广告位消息", "name": "getUcdpPositions", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "nil", "documentation": "请求UCDP的展位码组，投放后台申请获得", "exampleValue": "[\"spaceCode1,spaceCode2\"]", "name": "positionCodes", "optional": false, "type": "List[]" }, { "defaultValue": "nil", "documentation": "业务扩展字段，透传服务端消费", "exampleValue": "{\"k1\":\"v1\"}", "name": "extInfo", "optional": false, "type": "Map" }], "type": "Object" }], "out": [{ "documentation": "map结构返回投放数据\nkey=positionCode,value=positionInfo", "name": "positionCode", "optional": true, "type": "object" }] } }, { "apiName": "getUserFuCardStatus", "description": "新春五福JSAPI", "documentation": "新春五福JSAPI", "name": "getUserFuCardStatus", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getUserInfo", "description": "- 服务端获取当前用户身份时，请走 RPC Session（前端回传 userId 会引发安全漏洞）", "documentation": "获取当前用户的信息", "name": "getUserInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "用户id，以 \"2088\" 开头", "name": "userId", "optional": false, "type": "string" }, { "documentation": "用户的头像图片 URL", "name": "iconUrl", "optional": false, "type": "string" }, { "documentation": "用户的脱敏登录账号", "name": "loginId", "optional": false, "type": "string" }, { "documentation": "用户的脱敏真实姓名", "name": "userName", "optional": false, "type": "string" }, { "documentation": "用户的脱敏显示账号", "name": "displayName", "optional": false, "type": "string" }, { "documentation": "用户的脱敏别名", "name": "nick", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getVideoInfo", "description": "获取视频文件的信息，包括宽、高、容器类型、帧率、码率、渲染方向等信息", "documentation": "获取视频文件信息", "name": "getVideoInfo", "parameters": { "in": [{ "documentation": "给定的媒体流地址", "name": "src", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "视频没有旋转角度", "exampleValue": "0", "name": "orientation", "optional": false, "type": "object" }, { "documentation": "视频封装格式为flv", "exampleValue": "flv", "name": "type", "optional": false, "type": "string" }, { "documentation": "时长为30000ms", "exampleValue": "30000", "name": "duration", "optional": false, "type": "number" }, { "documentation": "视频大小为60000kb", "exampleValue": "60000", "name": "size", "optional": false, "type": "number" }, { "documentation": "视频高度为720", "exampleValue": "720", "name": "height", "optional": false, "type": "number" }, { "documentation": "视频宽度为1080", "exampleValue": "1080", "name": "width", "optional": false, "type": "number" }, { "documentation": "视频帧率为30", "exampleValue": "30", "name": "fps", "optional": false, "type": "number" }, { "documentation": "视频码率为2000kbps", "exampleValue": "2000", "name": "bitrate", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "getVoiceLoggerExtParams", "name": "getVoiceLoggerExtParams", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getVoucherResult", "description": "惠出境H5场景使用", "documentation": "领取优惠券", "name": "getVoucherResult", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "getWebViewInfo", "name": "getWebViewInfo", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "version", "optional": false, "type": "string" }] } }, { "apiName": "getWebViewStatus", "documentation": "生活tab业务提供给H5页面，用于查询当前WebView是否可见", "name": "getWebViewStatus", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "0：成功；\n非0：失败", "exampleValue": "0", "name": "error", "optional": true, "type": "number" }, { "documentation": "成功时：查询状态成功\n失败：查询失败", "exampleValue": "查询状态成功", "name": "errorMessage", "optional": false, "type": "string" }, { "documentation": "true: 可见\nfalse：不可见", "exampleValue": "true", "name": "visible", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "getWifiBroadcastInfo", "name": "getWifiBroadcastInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "Wifi IP 地址。", "name": "address", "optional": false, "type": "string" }, { "documentation": "Wifi 组播地址。", "name": "broadcastAddr", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "getWifiList", "description": "数据在在 [getWifiList](nativeevent:getWifiList) 事件中返回\n- `iOS` 将跳转到系统的 Wifi 界面\n- `Android` 不会跳转", "documentation": "请求获取 Wifi 列表", "name": "getWifiList", "parameters": { "in": [{ "name": "success", "optional": false, "type": "boolean" }], "out": [{}] } }, { "apiName": "getWindowInfo", "name": "getWindowInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "pixelRatio", "optional": false, "type": "number" }, { "documentation": "", "name": "screen", "optional": false, "type": "object" }, { "documentation": "", "name": "screenHeight", "optional": false, "type": "number" }, { "documentation": "", "name": "screenWidth", "optional": false, "type": "number" }, { "documentation": "", "name": "statusBarHeight", "optional": false, "type": "number" }, { "documentation": "", "name": "titleBarHeight", "optional": false, "type": "number" }, { "documentation": "", "name": "transparentTitle", "optional": false, "type": "boolean" }, { "documentation": "", "name": "windowHeight", "optional": false, "type": "number" }, { "documentation": "", "name": "windowWidth", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "goBackground", "name": "goBackground", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "guideAlivePlugin.pageOut", "name": "guideAlivePlugin.pageOut", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5_titlebar_transstate_change", "name": "h5_titlebar_transstate_change", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "H5APLog", "name": "H5APLog", "parameters": { "in": [{ "documentation": "日志内容，必须是字符串，长度<2000", "name": "content", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "h5MainLink", "name": "h5MainLink", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5Monitor", "name": "h5Monitor", "parameters": { "in": [{ "name": "data", "optional": false, "type": "object" }], "out": [{}] } }, { "apiName": "h5PageAbnormal", "name": "h5PageAbnormal", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageDownloadApk", "name": "h5PageDownloadApk", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageError", "description": "惠出境H5场景", "documentation": "h5页面报错", "name": "h5PageError", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageFinished", "description": "惠出境H5使用场景", "documentation": "h5页面加载完成", "name": "h5PageFinished", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageInterceptScheme", "name": "h5PageInterceptScheme", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageJumpPPDownloadSuccess", "name": "h5PageJumpPPDownloadSuccess", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PagePhysicalBack", "name": "h5PagePhysicalBack", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageQueryPP", "name": "h5PageQueryPP", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageQueryPPCost", "name": "h5PageQueryPPCost", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageScriptReady", "name": "h5PageScriptReady", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageScroll", "name": "h5PageScroll", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageShowClose", "name": "h5PageShowClose", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5PageStarted", "description": "惠出境H5容器场景", "documentation": "h5页面开始加载", "name": "h5PageStarted", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5ScrollEnd", "name": "h5ScrollEnd", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5ScrollStart", "name": "h5ScrollStart", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5ToolbarClose", "name": "h5ToolbarClose", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5ToolbarMenu", "name": "h5ToolbarMenu", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "h5ToolbarReload", "name": "h5ToolbarReload", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "handleLoggingAction", "name": "handleLoggingAction", "parameters": { "in": [{ "name": "actionType", "optional": false, "type": "\"getAntLogInfo\"" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "status", "optional": false, "type": "\"success\"" }, { "name": "data", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "handleUEPEvent", "name": "handleUEPEvent", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hasPermissionGuidePath", "description": "判断是否存在可跳转的系统权限页面", "documentation": "判断是否存在可跳转的系统权限页面", "name": "hasPermissionGuidePath", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "", "name": "authType", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "hasPath", "optional": false, "type": "string" }] } }, { "apiName": "havanaContinueLogin", "name": "havanaContinueLogin", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "haveShortCut", "description": "- 被查询的快捷入口需要保持与 [setShortCut]() 入参一致", "documentation": "查询是否已存在快捷入口", "name": "haveShortCut", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用 appId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "应用名称", "name": "appName", "optional": false, "type": "string" }, { "description": "支持 base64", "documentation": "图标URL", "name": "iconBitmap", "optional": false, "type": "string" }, { "documentation": "扩展参数", "name": "params", "optional": true, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "name": "result", "optional": false, "type": "boolean" }] } }, { "apiName": "hclastLBSinfo", "name": "hclastLBSinfo", "parameters": { "in": [{ "documentation": "", "name": "bizCode", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "curRegion", "optional": false, "type": "string" }, { "documentation": "", "name": "hasLocationPermission", "optional": false, "type": "string" }, { "documentation": "", "name": "locTime", "optional": true, "type": "string" }, { "documentation": "", "name": "province", "optional": true, "type": "string" }, { "documentation": "", "name": "districtAdcode", "optional": true, "type": "string" }, { "documentation": "", "name": "locIsMarketingDistrict", "optional": false, "type": "string" }, { "documentation": "", "name": "choosenCountry", "optional": true, "type": "string" }, { "documentation": "", "name": "provinceCode", "optional": true, "type": "string" }, { "documentation": "", "name": "cityIsMainland", "optional": true, "type": "string" }, { "documentation": "", "name": "districtName", "optional": true, "type": "string" }, { "documentation": "", "name": "countryCode", "optional": true, "type": "string" }, { "documentation": "", "name": "lon", "optional": true, "type": "string" }, { "documentation": "", "name": "country", "optional": true, "type": "string" }, { "documentation": "", "name": "choosenCityIsMainland", "optional": true, "type": "string" }, { "documentation": "", "name": "latitude", "optional": true, "type": "string" }, { "documentation": "", "name": "city", "optional": true, "type": "string" }, { "documentation": "", "name": "overseasCity", "optional": true, "type": "string" }, { "documentation": "", "name": "choosenMarketingDistrict", "optional": false, "type": "string" }, { "documentation": "", "name": "choosenCity", "optional": true, "type": "string" }, { "documentation": "", "name": "choosenCityCode", "optional": true, "type": "string" }, { "documentation": "", "name": "accuracy", "optional": true, "type": "string" }, { "documentation": "", "name": "adCode", "optional": true, "type": "string" }, { "documentation": "", "name": "longitude", "optional": true, "type": "string" }, { "documentation": "", "name": "locationTime", "optional": true, "type": "string" }, { "documentation": "", "name": "isHighAccuracyClose", "optional": false, "type": "string" }, { "documentation": "", "name": "lat", "optional": true, "type": "string" }, { "documentation": "", "name": "cityAdCode", "optional": true, "type": "string" }, { "documentation": "", "name": "choosenCountryCode", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "healthKitRequest", "description": "", "documentation": "获取运动组件相关的接口，支持获取计步数据，权限判断以及上传步数等等功能", "name": "healthKitRequest", "parameters": { "in": [{ "name": "requestType", "optional": false, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "设备计步可用情况", "name": "avaliable", "optional": false, "type": "boolean" }, { "documentation": "时区", "name": "timezoneId", "optional": false, "type": "string" }, { "documentation": "运动开通情况", "name": "activate", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "healthySecurityAlert", "description": "历史存量接口，使用前请咨询", "documentation": "出行卡片类jsapi", "name": "healthySecurityAlert", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "healthySecurityCommonBiz", "description": "历史存量，使用前请咨询", "documentation": "出行卡片相关接口", "name": "healthySecurityCommonBiz", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "healthySecurityPageCreated", "description": "历史存量", "documentation": "出行健康相关jsapi接口", "name": "healthySecurityPageCreated", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "healthySecuritySetCmptVisible", "description": "历史存量接口，使用前请咨询", "documentation": "出行相关jsapi", "name": "healthySecuritySetCmptVisible", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "healthySecurityToast", "description": "历史存量接口，使用前请咨询", "documentation": "出行卡片类jsapi，弹toast", "name": "healthySecurityToast", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideAllKeyboard", "documentation": "隐藏所有键盘", "name": "hideAllKeyboard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideBackButton", "documentation": "隐藏返回按钮", "name": "hideBackButton", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "hideCustomKeyBoard", "name": "hideCustomKeyBoard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideDatePicker", "documentation": "隐藏日期选择", "name": "hideDatePicker", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideFavoriteTips", "name": "hideFavoriteTips", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideFontBar", "name": "hideFontBar", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideKeyboard", "name": "hideKeyboard", "parameters": { "in": [{}], "out": [] } }, { "apiName": "hideLoading", "description": "- 隐藏由 [showLoading]() 唤起的加载界面", "documentation": "隐藏全局加载界面", "name": "hideLoading", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideOptionMenu", "documentation": "隐藏H5右上角选项按钮", "name": "hideOptionMenu", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "hideOptionMenuItem", "description": "- 该 API 现已被禁用，详见 [hideOptionMenuItem接口回收方案](https://yuque.antfin.com/huiyuchen.chy/cb48uu/uwqa48)", "documentation": "隐藏指定菜单栏", "name": "hideOptionMenuItem", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定隐藏菜单项", "name": "name", "optional": false, "type": "enum" }, { "defaultValue": "single", "documentation": "隐藏生效范围", "name": "scope", "optional": false, "type": "enum" }], "type": "Object" }], "out": [{}] } }, { "apiName": "hideShareMenu", "name": "hideShareMenu", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideTitleLoading", "description": "- 隐藏由 [showTitleLoading]() 显示的标题栏加载图标", "documentation": "隐藏标题栏加载图标", "name": "hideTitleLoading", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "hideToast", "documentation": "隐藏弱提示", "name": "hideToast", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "homeAddAppToMyApps", "description": "此接口需要申请。参考[添加首页开放接口接入指南\n](https://yuque.antfin-inc.com/docs/share/0f0a3bdb-614d-4130-9258-9ac0c54315fd?#RNep9)\n\n在满足可添加接口 [homeCanAddAppToMyApps]() 的基础上才能调用此接口，此接口会弹出添加到首页确认面板。\n此接口受疲劳度控制，默认疲劳度为，30天一次，终身6次，用户唤起添加的二次确认面板记录疲劳度。", "documentation": "添加到首页接口", "name": "homeAddAppToMyApps", "parameters": { "in": [{ "name": "appId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "\"false\"" }, { "name": "error", "optional": false, "type": "60001" }, { "name": "errorMessage", "optional": false, "type": "\"应用添加失败\"" }], "type": "Object" }] } }, { "apiName": "homeCanAddAppToMyApps", "description": "使用需要申请。参考[添加首页开放接口接入指南](https://yuque.antfin-inc.com/docs/share/0f0a3bdb-614d-4130-9258-9ac0c54315fd?#BKjoF)", "documentation": "判断是应用是否可以添加到我的应用", "name": "homeCanAddAppToMyApps", "parameters": { "in": [{ "documentation": "将要添加到我的应用的 appId", "name": "appId", "optional": false, "type": "string" }], "out": [{ "documentation": "是否可以添加到我的应用", "name": "canAddAppToMyApps", "optional": false, "type": "boolean" }] } }, { "apiName": "homeIsAppInMyApps", "name": "homeIsAppInMyApps", "parameters": { "in": [{ "name": "appId", "optional": false, "type": "string" }], "out": [{ "name": "isAppInMyApps", "optional": false, "type": "boolean" }] } }, { "apiName": "httpRequest", "documentation": "发起http请求，推荐使用request接口，该接口仅维护状态", "name": "httpRequest", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "目标服务器 URL。", "name": "url", "optional": false, "type": "string" }, { "defaultValue": "{'content-type': 'application/x-www-form-urlencoded'}", "documentation": "设置请求的 HTTP 头对象，该对象里面的 `key` 和 `value` 必须是 `string` 类型。", "name": "headers", "optional": true, "type": "Record<string,string>" }, { "documentation": "请求参数。", "name": "data", "optional": true, "type": "string" }, { "defaultValue": "30000", "documentation": "超时时间，单位 `ms`。", "name": "timeout", "optional": true, "type": "number" }, { "name": "responseType", "optional": true, "type": "\"text\" | \"base64\" | \"json\"" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "响应数据，格式取决于请求时的 `dataType` 参数。", "name": "data", "optional": false, "type": "string" }, { "documentation": "响应码。", "name": "status", "optional": false, "type": "number" }, { "documentation": "响应头。", "name": "headers", "optional": false, "type": "Record<string,string>" }], "type": "Object" }] } }, { "apiName": "imageViewer", "description": "NativeApi调用，API名称为previewImage", "documentation": "图片预览", "name": "imageViewer", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "默认显示第几张", "name": "init", "optional": true, "type": "number" }, { "documentation": "需要预览的图片列表", "name": "images", "optional": false, "type": "object" }, { "documentation": "照片支持长按下载。", "name": "enablesavephoto", "optional": true, "supportInfo": { "androidMinVersion": 10001035, "iosMinVersion": 10001035 }, "type": "boolean" }, { "documentation": "是否在右下角显示下载入口。", "name": "enableShowPhotoDownload", "optional": true, "supportInfo": { "androidMinVersion": 10001035, "iosMinVersion": 10001035 }, "type": "boolean" }, { "documentation": "水印文本", "name": "textWaterMarker", "optional": true, "supportInfo": { "androidMinVersion": 10001082, "iosMinVersion": 10001082 }, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "importFromCardCenter", "name": "importFromCardCenter", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "uploadId", "optional": false, "type": "string" }, { "documentation": "", "name": "action", "optional": false, "type": "string" }, { "documentation": "", "name": "businessParams", "optional": false, "type": "string" }, { "documentation": "", "name": "clientConfig", "optional": true, "type": "string" }, { "documentation": "", "name": "transparent", "optional": false, "type": "string" }, { "documentation": "", "name": "tntInstId", "optional": true, "type": "string" }, { "documentation": "", "name": "albumApFilePath", "optional": true, "type": "string" }, { "documentation": "", "name": "materialType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "ocrResult", "optional": false, "type": "object" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "", "name": "extInfo", "optional": false, "type": "object" }, { "documentation": "", "name": "base64Images", "optional": true, "type": "object" }, { "documentation": "", "name": "algorithmResult", "optional": true, "type": "object" }, { "documentation": "", "name": "apFilePaths", "optional": true, "type": "object" }, { "documentation": "", "name": "detectingDirectionRes", "optional": true, "type": "object" }, { "documentation": "", "name": "funcName", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "inputBlurEvent", "documentation": "端侧键盘输入事件 不对外", "name": "inputBlurEvent", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "rgb(0,0,0)", "documentation": "rgb(0,0,0)", "name": "color", "optional": true, "type": "string" }, { "defaultValue": "static", "name": "position", "optional": true, "type": "string" }, { "defaultValue": "Y", "name": "canReturn", "optional": true, "type": "string" }, { "defaultValue": "140", "name": "maxlength", "optional": true, "type": "number" }, { "defaultValue": "XRiver", "name": "execEngine", "optional": true, "type": "string" }, { "defaultValue": "", "name": "placeholder", "optional": true, "type": "string" }, { "defaultValue": "-1", "name": "cursor", "optional": true, "type": "number" }, { "defaultValue": "true", "name": "canPaste", "optional": true, "type": "boolean" }, { "defaultValue": "text", "name": "type", "optional": true, "type": "string" }, { "defaultValue": "N", "name": "controlled", "optional": true, "type": "string" }, { "name": "offset", "optional": true, "type": "unknown" }, { "defaultValue": "-1", "name": "selectionStart", "optional": true, "type": "number" }, { "defaultValue": "\\\"PingFang SC\\\", \\\"Helvetica Neue\\", "name": "fontFamily", "optional": true, "type": "string" }, { "defaultValue": "17", "name": "fontSize", "optional": true, "type": "number" }, { "defaultValue": "400", "name": "fontWeight", "optional": true, "type": "string" }, { "defaultValue": "1", "name": "kbElId", "optional": true, "type": "number" }, { "defaultValue": "text", "name": "keyboard", "optional": true, "type": "string" }, { "name": "apiCallLink", "optional": true, "type": "string" }, { "defaultValue": "-1", "name": "selectionEnd", "optional": true, "type": "number" }, { "name": "value", "optional": true, "type": "string" }, { "defaultValue": "start", "name": "textAlign", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "inputFocus4Android", "documentation": "数字键盘触发聚焦", "name": "inputFocus4Android", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 坐标值相对于视口\n- 坐标值需要乘以 DPR", "documentation": "需要聚焦的文本框右下角 x 坐标", "name": "coordinateX", "optional": false, "type": "string" }, { "description": "- 坐标值相对于视口\n- 坐标值需要乘以 DPR", "documentation": "需要聚焦的文本框右下角 y 坐标", "name": "coordinateY", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "installApp", "name": "installApp", "parameters": { "in": [{ "documentation": "", "name": "appId", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "installRareNameFont", "documentation": "生僻字字体文件下载与安装", "name": "installRareNameFont", "parameters": { "in": [{ "documentation": "字体文件的URL地址或AFTS地址", "name": "fileId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "生僻字字体名字", "exampleValue": "GB22_test200_0930", "name": "fontName", "optional": false, "type": "string" }, { "documentation": "是否下载并安装成功", "exampleValue": "true/false", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "exampleValue": "60020", "name": "error", "optional": false, "type": "string" }, { "documentation": "错误信息", "exampleValue": "downloadFail", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "iotCheckService", "name": "iotCheckService", "parameters": { "in": [{ "documentation": "该服务的id，由协议服务商定义，协议服务商appId范围内唯一即可，用于单个协议服务商唯一标识一个服务(选填，如果不指定则创建默认服务实例)", "name": "serviceId", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "服务是否存在", "name": "exist", "optional": false, "type": "boolean" }, { "documentation": "业务错误码", "name": "errorCode", "optional": false, "type": "string" }, { "documentation": "业务错误文案", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "iotCreateService", "name": "iotCreateService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "该服务的id，由协议服务商定义，协议服务商appId范围内唯一即可，用于单个协议服务商唯一标识一个服务(选填，如果不指定则创建默认服务实例)", "name": "serviceId", "optional": true, "type": "string" }, { "documentation": "服务名称", "name": "serviceName", "optional": false, "type": "string" }, { "documentation": "服务备注，如果不填，则默认使用协议服务商小程序的名称", "name": "remark", "optional": true, "type": "string" }, { "documentation": "url跳转参数对象，服务创建后用户可点击服务进入协议服务商的小程序(通过形如alipays://platformapi/startapp?appId=xxxxx&key1=value1&key2=value2…)，该字段用于给小程序代入额外业务参数", "name": "urlParams", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "业务错误码", "name": "errorCode", "optional": false, "type": "string" }, { "documentation": "业务错误文案", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "iotSecurity", "documentation": "IoT 加密接口", "name": "iotSecurity", "parameters": { "in": [{ "documentation": "获取 API 版本", "name": "action", "optional": true, "type": "\"version\"" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "版本", "name": "version", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "isAppInMyApps", "name": "isAppInMyApps", "parameters": { "in": [{ "documentation": "", "name": "appId", "optional": true, "type": "string" }], "out": [{ "documentation": "", "name": "isAppInMyApps", "optional": false, "type": "boolean" }] } }, { "apiName": "isAppShowingOnHomeStage", "documentation": "判断指定应用是否正在钱包首页展台显示", "name": "isAppShowingOnHomeStage", "parameters": { "in": [{ "name": "appId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "应用是否是显示推广应用", "name": "isTimeLimitedApp", "optional": false, "type": "boolean" }, { "documentation": "应用是否在首页", "name": "isAppShowingOnHome", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "isCollected", "name": "isCollected", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "name": "resultCode", "optional": false, "type": "string" }, { "name": "resultMsg", "optional": false, "type": "string" }, { "name": "hasKeep", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "isInMultiWindowMode", "documentation": "判断支付宝是否处于android 分屏状态", "name": "isInMultiWindowMode", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "isInstalledApp", "description": "- 在 iOS 9 以上系统必须在支付宝客户端发布前配置 [LSApplicationQueriesSchemes](https://code.alipay.com/wallet/ios-phone-portal-git/blob/master/Portal/Portal-Info.plist#L111) 白名单。iOS15.0以上系统只能配置50个。", "documentation": "检测外部应用是否存在", "name": "isInstalledApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "目标应用的包名(Android)", "name": "packagename", "optional": true, "type": "string" }, { "documentation": "目标应用的 URLScheme(iOS)", "name": "scheme", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "目标应用是否已在用户设备上安装", "name": "installed", "optional": false, "type": "boolean" }] } }, { "apiName": "isLowPowerMode", "name": "isLowPowerMode", "parameters": { "in": [{}], "out": [{ "documentation": "设备是否是低电量模式。", "name": "isLowPowerMode", "optional": false, "type": "boolean" }] } }, { "apiName": "isMediaCreatorTaskRunning", "name": "isMediaCreatorTaskRunning", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "isScreenReaderEnabled", "documentation": "查询读屏应用当前是否开启", "name": "isScreenReaderEnabled", "parameters": { "in": [{}], "out": [{ "documentation": "是否开启无障碍模式", "name": "screenReaderEnabled", "optional": false, "type": "boolean" }] } }, { "apiName": "isShowAutoStartOption", "name": "isShowAutoStartOption", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "isShowPowerWhiteOption", "name": "isShowPowerWhiteOption", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "isSpeechAvailable", "name": "isSpeechAvailable", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "附加扩展字段，用来透传数据。", "name": "extraInfo", "optional": true, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "Record<string,string>" }, { "name": "speechRecognizeBizId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "isSupportShortCut", "description": "- 执行添加删除快捷入口操作请调用 [setShortCut]() / [removeShortCut]()\n- 查询是否已完成添加请调用 [haveShortCut]()", "documentation": "查询系统是否支持添加快捷入口到桌面能力", "name": "isSupportShortCut", "parameters": { "in": [{}], "out": [{ "documentation": "是否支持", "name": "result", "optional": false, "type": "boolean" }] } }, { "apiName": "isSystemRoot", "documentation": "设备是否越狱", "name": "isSystemRoot", "parameters": { "in": [{}], "out": [{ "documentation": "设备是否越狱", "name": "isSystemRoot", "optional": false, "type": "enum" }] } }, { "apiName": "isUseApNavigationBar", "documentation": "框架导航栏，前端感知是否切换到框架提供的导航栏", "name": "isUseApNavigationBar", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "number" }, { "name": "status", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "jsDetectionReport", "documentation": "众测js前端问题上报接口", "name": "jsDetectionReport", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "问题类型", "name": "detect_type", "optional": false, "type": "string" }, { "documentation": "问题发生unix时间", "name": "date", "optional": false, "type": "number" }], "type": "Object" }], "out": [{}] } }, { "apiName": "jumpToAutoStartSettings", "name": "jumpToAutoStartSettings", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "jumpToGreenModeSettings", "name": "jumpToGreenModeSettings", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "jumpToPowerSaveModeSettings", "name": "jumpToPowerSaveModeSettings", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "jumpToPowerWhiteSettings", "name": "jumpToPowerWhiteSettings", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "jumpToSystemSettings", "name": "jumpToSystemSettings", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "intent", "optional": false, "type": "string" }, { "documentation": "", "name": "from", "optional": true, "type": "string" }, { "documentation": "", "name": "tipsDelay", "optional": true, "type": "string" }, { "documentation": "", "name": "tips", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "number" }] } }, { "apiName": "keepAlivePagePerformance", "name": "keepAlivePagePerformance", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "leaveToyMachine", "name": "leaveToyMachine", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "lifeDeleteMessages", "name": "lifeDeleteMessages", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "userId", "optional": true, "type": "string" }, { "documentation": "", "name": "publicId", "optional": true, "type": "string" }, { "documentation": "", "name": "messageIdList", "optional": true, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "lifeEntryHomePage", "name": "lifeEntryHomePage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "", "name": "userId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "lifeQueryMessages", "name": "lifeQueryMessages", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要为当前登录人 userId 否会提示 901 参数错误", "name": "userId", "optional": false, "type": "string" }, { "documentation": "", "name": "pageCount", "optional": false, "type": "number" }, { "documentation": "", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "", "name": "msgTypeList", "optional": false, "type": "string[]" }, { "documentation": "", "name": "traceId", "optional": true, "type": "string" }, { "documentation": "", "name": "requestModel", "optional": true, "type": "number" }, { "documentation": "", "name": "lastMsgTime", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "msgList", "optional": true, "type": "object" }, { "documentation": "", "name": "publicId", "optional": true, "type": "string" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "traceId", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "lifeQueryMessagesByIds", "name": "lifeQueryMessagesByIds", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "", "name": "messageIdList", "optional": false, "type": "string[]" }, { "documentation": "", "name": "userId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "msgList", "optional": false, "type": "object" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "", "name": "publicId", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "lifeQueryUnreadMsgCount", "name": "lifeQueryUnreadMsgCount", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "", "name": "userId", "optional": true, "type": "string" }, { "documentation": "", "name": "msgTypeList", "optional": false, "type": "string[]" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "publicId", "optional": true, "type": "string" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "unreadCount", "optional": true, "type": "object" }], "type": "Object" }] } }, { "apiName": "limitAlert", "documentation": "统一网关限流报错弹窗", "name": "limitAlert", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "顾客太多，客官请稍等", "documentation": "按钮", "name": "title", "optional": false, "type": "string" }, { "defaultValue": "耽误您的时间，我们深表歉意", "documentation": "文案", "name": "message", "optional": false, "type": "string" }, { "defaultValue": "确定", "documentation": "按钮", "name": "button", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "livLiveSubscribe", "description": "native实现调用alipay.content.reading.life.live.subscribe.liveSubscribe接口，实现直播预约功能。预约成功后支持弹出预约海报。", "documentation": "直播预约", "name": "livLiveSubscribe", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "直播ID", "name": "liveId", "optional": false, "type": "string" }, { "documentation": "类型", "name": "type", "optional": false, "type": "string" }, { "documentation": "订阅模版ID", "name": "tempId", "optional": false, "type": "string" }, { "documentation": "是否展示海报", "name": "needPoster", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "livPreloadGuideDialogData", "documentation": "关注回流弹窗 预加载数据jsApi", "name": "livPreloadGuideDialogData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "展位码", "exampleValue": "TAB3_SPACECODE_FOLLOW_DIALOG", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "ACCOUNT_HOME_PAGE（号主页）\nMINI_APP（小程序）\nNATIVE_CONTENT_DETAIL（内容详情页)", "exampleValue": "ACCOUNT_HOME_PAGE", "name": "bizType", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "livShowContentDetail", "name": "livShowContentDetail", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "voiceOpen", "optional": true, "type": "string" }, { "documentation": "", "name": "layoutType", "optional": false, "type": "string" }, { "documentation": "", "name": "needCurrent", "optional": false, "type": "number" }, { "documentation": "", "name": "contentId", "optional": true, "type": "string" }, { "documentation": "", "name": "pageIndex", "optional": true, "type": "number" }, { "documentation": "", "name": "refer", "optional": true, "type": "string" }, { "documentation": "", "name": "chInfo", "optional": true, "type": "string" }, { "documentation": "", "name": "templateData", "optional": true, "type": "object" }, { "documentation": "", "name": "prePageIndex", "optional": true, "type": "number" }, { "documentation": "", "name": "imgIndex", "optional": true, "type": "number" }, { "documentation": "", "name": "lastContentId", "optional": true, "type": "string" }, { "documentation": "", "name": "authorId", "optional": true, "type": "string" }, { "documentation": "", "name": "type", "optional": true, "type": "string" }, { "documentation": "", "name": "commentPanelLevel", "optional": true, "type": "string" }, { "documentation": "", "name": "cardId", "optional": true, "type": "string" }], "type": "Object" }], "out": [] } }, { "apiName": "livShowGuideDialog", "description": "注意⚠️：此jsApi强依赖于livPreloadGuideDialogData获取的数据，如果不调取这个拉取数据，弹窗是弹不出来的", "documentation": "引流回流组件-关注弹窗", "name": "livShowGuideDialog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "展位码", "exampleValue": "TAB3_SPACECODE_FOLLWOW_DIALOG", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "关注的作者的id", "name": "publicId", "optional": false, "type": "string" }, { "documentation": "调用方 AccountHomepage（号主页） MiniApp（小程序） ContentDetail（内容详情页", "exampleValue": "AccountHomepage", "name": "bizType", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "loadCanvasFontFace", "name": "loadCanvasFontFace", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "family", "optional": false, "type": "string" }, { "name": "source", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "loadHoistEmbededWebViewSrc", "name": "loadHoistEmbededWebViewSrc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "element", "optional": false, "type": "string" }, { "documentation": "", "name": "src", "optional": false, "type": "string" }, { "documentation": "", "name": "viewId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "loadPlugin", "name": "loadPlugin", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "plugin", "optional": false, "type": "string" }, { "name": "pluginScene", "optional": true, "type": "void | \"DEBUG\" | \"INSPECT\"" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "url", "optional": false, "type": "string" }, { "name": "version", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "loadSkinRes", "documentation": "获取皮肤数据", "name": "loadSkinRes", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "场景", "name": "scene", "optional": false, "type": "string" }, { "documentation": "位置", "name": "position", "optional": false, "type": "string" }, { "documentation": "用于黑白名单匹配。\n如配置了\n{\"supportCity\": \"北京\"}。\n1.先在meta.json 找supportCity白名单。\n2.若不存在白名单，就supportCityBlackList黑名单。\n3.用“北京”判断是否在黑白名单", "name": "extInfo", "optional": true, "type": "object" }, { "defaultValue": "NO", "documentation": "是否lottie降级。\n如果降级，lottie资源会返回图片资源", "name": "downgrade", "optional": true, "type": "boolean" }, { "documentation": "目前card在使用。\n传入“lottiePath”，返回lottie资源路径", "name": "type", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "资源类型", "name": "resType", "optional": false, "type": "string" }, { "documentation": "资源数据", "name": "resData", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "loadSubPackage", "name": "loadSubPackage", "parameters": { "in": [{ "documentation": "", "name": "packages", "optional": false, "type": "string[]" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "localLog", "documentation": "往支付宝客户端日志中写入单条日志", "name": "localLog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要往客户端日志内写入的日志内容", "name": "message", "optional": false, "type": "string" }, { "defaultValue": "info", "documentation": "日志等级", "name": "level", "optional": true, "type": "enum" }], "type": "Object" }], "out": [{}] } }, { "apiName": "makeBluetoothPair", "documentation": "获取已经配对蓝牙设备接口", "name": "makeBluetoothPair", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 id。", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "pin 码。", "name": "pin", "optional": false, "type": "string" }, { "defaultValue": "20", "documentation": "超时时间，单位（秒）。", "name": "timeout", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "makePhoneCall", "documentation": "拨打电话", "name": "makePhoneCall", "parameters": { "in": [{ "documentation": "电话号码", "name": "number", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "maya_setModalThreshold", "name": "maya_setModalThreshold", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "mcdpFeedback", "documentation": "营销数据埋点并按需上报投放服务端。", "name": "mcdpFeedback", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要上报埋点的组件数据", "name": "moduleItems", "optional": false, "type": "object" }, { "documentation": "上报行为\nAdShow：曝光\nAdClick：点击", "name": "behavior", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否上报成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "必传字段校验失败", "name": "errorMsg", "optional": false, "type": "string" }, { "documentation": "上报失败的Item", "name": "failedList", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "measureText", "name": "measureText", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "fontFamily", "optional": true, "type": "string" }, { "documentation": "", "name": "fontSize", "optional": false, "type": "number" }, { "documentation": "", "name": "fontStyle", "optional": true, "type": "string" }, { "documentation": "", "name": "fontWeight", "optional": true, "type": "string" }, { "documentation": "", "name": "text", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "width", "optional": false, "type": "number" }] } }, { "apiName": "mediaRecord", "name": "mediaRecord", "parameters": { "in": [{ "documentation": "", "name": "maxRecordTime", "optional": false, "type": "number" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "height", "optional": false, "type": "number" }, { "documentation": "", "name": "tempImagePath", "optional": false, "type": "string" }, { "documentation": "", "name": "localId", "optional": false, "type": "string" }, { "documentation": "", "name": "width", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "mobileaixExecuteSolution", "name": "mobileaixExecuteSolution", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "sceneCode", "optional": true, "type": "string" }, { "documentation": "", "name": "inputParams", "optional": true, "type": "object" }, { "documentation": "", "name": "timeout", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "results", "optional": true }, { "documentation": "", "name": "errMessage", "optional": false, "type": "string" }, { "documentation": "", "name": "errCode", "optional": false, "type": "string" }, { "documentation": "", "name": "sceneCode", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "mobileaixNearInfo", "documentation": "调用支付宝端智能获取近场信息", "name": "mobileaixNearInfo", "parameters": { "in": [{ "documentation": "入参", "name": "inputParams", "optional": false, "type": "unknown" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "近场信息结果", "name": "results", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "mobileaixSetString", "name": "mobileaixSetString", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "mobileaixTrigger", "name": "mobileaixTrigger", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "triggerId", "optional": true, "type": "string" }, { "documentation": "", "name": "inputParams", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "results", "optional": false, "type": "object" }, { "documentation": "", "name": "errMessage", "optional": false, "type": "string" }, { "documentation": "", "name": "errCode", "optional": false, "type": "string" }, { "documentation": "", "name": "triggerId", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "mockClickTinyClose", "description": "模拟小程序关闭", "documentation": "模拟小程序关闭", "name": "mockClickTinyClose", "parameters": { "in": [{}], "out": [] } }, { "apiName": "monitorH5Performance", "name": "monitorH5Performance", "parameters": { "in": [{ "name": "data", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "msgboxAppList", "description": "内部业务使用。", "documentation": "服务提醒，查询发送消息的主体信息。", "name": "msgboxAppList", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "30", "name": "count", "optional": false, "type": "number" }, { "name": "sourceId", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "msgboxModifySubscribeStatus", "documentation": "根据模版ID更新模版订阅状态", "name": "msgboxModifySubscribeStatus", "parameters": { "in": [{ "documentation": "{\n \"templateId1\":\"1\",\n \"templateId1\":\"0\"\n}", "name": "serviceCodesInfo", "optional": false, "type": "object" }], "out": [] } }, { "apiName": "msgboxServiceListWithAppId", "name": "msgboxServiceListWithAppId", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用id", "name": "appId", "optional": false, "type": "string" }, { "documentation": "请求条数", "name": "count", "optional": false, "type": "number" }, { "documentation": "来源信息", "name": "sourceId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "[\n{\n\"serviceCode\":\"xxx\"\n},\n{\"serviceCode\":\"xxx2\"}\n]", "name": "serviceList", "optional": false, "type": "object" }] } }, { "apiName": "mtop", "description": "该接口默认提供给H5调用，小程序调用，请使用sendMtop接口。", "documentation": "发起 mtop 调用", "name": "mtop", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "apiName", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "apiVersion", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "needEcodeSign", "optional": true, "type": "boolean" }, { "description": "", "documentation": "", "name": "data", "optional": true, "type": "Record<string, any>" }, { "description": "", "documentation": "", "name": "needWua", "optional": true, "type": "boolean" }, { "description": "", "documentation": "", "name": "isNeedWua", "optional": true, "type": "boolean" }, { "description": "", "documentation": "", "name": "isSec", "optional": true, "type": "number" }, { "description": "", "documentation": "", "name": "usePost", "optional": true, "type": "boolean" }, { "description": "", "documentation": "", "name": "type", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "timeout", "optional": true, "type": "number" }, { "description": "", "documentation": "", "name": "ttid", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "ext_headers", "optional": true, "type": "Record<string, string>" }, { "description": "", "documentation": "", "name": "api", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "v", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "headers", "optional": true, "type": "Record<string, string>" }, { "description": "", "documentation": "", "name": "config", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "api", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "data", "optional": false, "type": "Record<string, any>" }, { "description": "", "documentation": "", "name": "__eagleeye_traceid__", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "v", "optional": false, "type": "string" }, { "name": "error", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "ret", "optional": false, "type": "string[]" }, { "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "multiWorkerPostMessage", "name": "multiWorkerPostMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "message", "optional": false, "type": "Record<string,unknown>" }, { "name": "bizIdentifier", "optional": false, "type": "string" }, { "name": "workerId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "multiWorkerTerminate", "name": "multiWorkerTerminate", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "bizIdentifier", "optional": false, "type": "string" }, { "name": "workerId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "navigateBackFromMiniService", "name": "navigateBackFromMiniService", "parameters": { "in": [{ "name": "data", "optional": false, "type": "any" }], "out": [{}] } }, { "apiName": "navigateBackMiniProgram", "name": "navigateBackMiniProgram", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "appId", "optional": false, "type": "string" }, { "name": "param", "optional": false, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "navigateToAlipayPage", "description": "", "documentation": "navigateToAlipayPage 是用于跳转到支付宝官方业务或运营活动页面的 API。", "name": "navigateToAlipayPage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "要跳转的支付宝官方业务。例如付款码，appCode: 'payCode'", "name": "appCode", "optional": false, "type": "enum" }, { "documentation": "appCode 配套参数，需要和 appCode 搭配使用", "name": "appParams", "optional": true, "type": "Record<string,unknown>" }], "type": "Object" }], "out": [{ "documentation": "跳转成功\n", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "navigateToMiniProgram", "description": "注：针对小程序的跳转", "documentation": "跳转到其他小程序", "name": "navigateToMiniProgram", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "appId", "optional": false, "type": "string" }, { "name": "path", "optional": true, "type": "string" }, { "name": "startParam", "optional": true, "type": "Record<string,string>" }, { "defaultValue": "release", "documentation": "仅在当前小程序为开发版或体验版时此参数有效；如果当前小程序是正式版，则打开的小程序必定是正式版。", "name": "envVersion", "optional": true, "type": "\"develop\" | \"trial\" | \"release\"" }, { "name": "param", "optional": false, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "navigateToMiniService", "name": "navigateToMiniService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "serviceId", "optional": false, "type": "string" }, { "name": "servicePage", "optional": false, "type": "string" }, { "name": "params", "optional": false, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "navigateToOutside", "description": "这个API支付宝不存在！！！", "name": "navigateToOutside", "parameters": { "in": [{ "documentation": "", "name": "url", "optional": false, "type": "string" }], "out": [] } }, { "apiName": "navigateToSetting", "name": "navigateToSetting", "parameters": { "in": [{ "documentation": "仅用于 Android", "name": "option", "optional": true, "type": "\"bluetooth\" | \"wifi\" | \"nfc\" | \"gps\"" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "NBComponent.render", "name": "NBComponent.render", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "element", "optional": false, "type": "string" }, { "name": "data", "optional": false, "type": "Record<string,unknown>" }], "type": "Object" }], "out": [{}] } }, { "apiName": "NBComponent.sendMessage", "name": "NBComponent.sendMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "element", "optional": false, "type": "string" }, { "name": "actionType", "optional": false, "type": "string" }, { "name": "data", "optional": false, "type": "Record<string,unknown>" }], "type": "Object" }], "out": [{}] } }, { "apiName": "NBComponent.setData", "name": "NBComponent.setData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "notifyBLECharacteristicValueChange", "description": "注意：设备的特征值必须支持 notify/indicate 才可以成功调用，具体参照 characteristic 的 properties 属性 另外，必须先启用 notify 才能监听到设备[characteristicValueChange](nativeevent) 事件。", "documentation": "启用低功耗蓝牙设备特征值变化时的 notify 功能", "name": "notifyBLECharacteristicValueChange", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值对应 service 的 UUID", "name": "serviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值的 UUID", "name": "characteristicId", "optional": false, "type": "string" }, { "defaultValue": "00002902-0000-10008000-00805f9b34fb", "documentation": "notify 的 descriptor 的 UUID", "name": "descriptorId", "optional": true, "supportInfo": { "androidMinVersion": 10002020 }, "type": "string" }, { "documentation": "是否启用 notify 或 indicate", "name": "state", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "notifyScroll", "name": "notifyScroll", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ocr", "name": "ocr", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "path", "optional": true, "type": "string" }, { "name": "imageBase64", "optional": true, "type": "string" }, { "name": "side", "optional": true, "type": "\"face\" | \"back\"" }, { "name": "ocrType", "optional": false, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "result", "optional": false, "type": "unknown" }, { "name": "ocrType", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "ocrPassport", "name": "ocrPassport", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ocrTrainTicket", "name": "ocrTrainTicket", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ocrVehiclePlate", "name": "ocrVehiclePlate", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "ocrVin", "name": "ocrVin", "parameters": { "in": [{}], "out": [] } }, { "apiName": "offTitleCloseClick", "name": "offTitleCloseClick", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "onAppPerfEvent", "name": "onAppPerfEvent", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "state", "optional": false, "type": "string" }, { "name": "time", "optional": false, "type": "number" }, { "name": "pagePath", "optional": true, "type": "string" }, { "name": "data", "optional": true, "type": "Record<string, unknown>" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "onCubeAppPerfEvent", "name": "onCubeAppPerfEvent", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "onGetIntlSearchHitWord", "description": "惠出境H5", "documentation": "将关键词提示传递给搜索栏", "name": "onGetIntlSearchHitWord", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "onHomePageDataCompleted", "description": "惠出境H5场景", "documentation": "首页H5加载完成", "name": "onHomePageDataCompleted", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "onShopDetailWebComplete", "description": "国际惠出境使用", "documentation": "打开惠出境详情完成通知", "name": "onShopDetailWebComplete", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "openBLEPeripheral", "documentation": "开启低功耗蓝牙从模式", "name": "openBLEPeripheral", "parameters": { "in": [{ "documentation": "设备名称。", "name": "deviceName", "optional": true, "type": "string" }], "out": [{ "documentation": "成功执行回调。", "name": "isSupportPeripheral", "optional": false, "type": "boolean" }] } }, { "apiName": "openBluetoothAdapter", "description": "生效周期为调用 openBluetoothAdapter 至调用closeBluetoothAdapter 或业务被销毁为止。 在蓝牙适配器模块生效期间，开发者可以正常调用蓝牙相关API，并会收到蓝牙模块相关的 on 事件回调。", "documentation": "初始化蓝牙模块", "name": "openBluetoothAdapter", "parameters": { "in": [{ "documentation": "表示是否在离开当前页面时自动断开蓝牙。", "name": "autoClose", "optional": true, "type": "boolean" }], "out": [{ "documentation": "是否支持 BLE", "name": "isSupportBLE", "optional": false, "type": "boolean" }] } }, { "apiName": "openDocument", "name": "openDocument", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "文件路径，可通过 `downloadFile` 获得。", "name": "filePath", "optional": false, "type": "string" }, { "documentation": "文件类型。\n有效值：\n- `pdf`：PDF 格式。", "name": "fileType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "openEmbeddedMiniProgram", "description": "https://yuque.antfin.com/appxng/open-docs/fti74k?# 《my.openEmbeddedMiniProgram》", "documentation": "打开半屏小程序", "name": "openEmbeddedMiniProgram", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "要打开的小程序 appId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "传递给客户端的额外参数", "name": "param", "optional": true, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "openFloatingWindowPermission", "name": "openFloatingWindowPermission", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "openInBrowser", "documentation": "使用外部原生浏览器上打开 URL", "name": "openInBrowser", "parameters": { "in": [{ "documentation": "打开的URL", "name": "url", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "openLocation", "description": "暂无境外地图数据，在中国内地（不含港澳台）以外的地区可能无法正常调用。\n仅支持高德地图 style 与火星坐标系。", "documentation": "使用支付宝内置地图查看位置", "name": "openLocation", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "缩放比例，范围 3~19。", "name": "scale", "optional": true, "type": "number" }, { "documentation": "“0”：隐藏打车入口；\n“1”：隐藏导航入口；", "name": "hidden", "optional": true, "type": "string" }, { "documentation": "经度", "name": "longitude", "optional": false, "type": "string" }, { "documentation": "纬度", "name": "latitude", "optional": false, "type": "string" }, { "documentation": "位置名称", "name": "name", "optional": false, "type": "string" }, { "documentation": "地址的详细说明。", "name": "address", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "openMessageAuthGuide", "name": "openMessageAuthGuide", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "openOtherApplication", "name": "openOtherApplication", "parameters": { "in": [{ "documentation": "跳转第三方 App 的完整scheme", "name": "url", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "openRoadCard", "description": "惠出境h5容器", "documentation": "打开惠出境店铺的问路卡", "name": "openRoadCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "openSetting", "name": "openSetting", "parameters": { "in": [{}], "out": [{ "name": "authSetting", "optional": false, "type": "object" }] } }, { "apiName": "openSystemSetting", "description": "跳转到手机系统的设置页面，非支付宝设置页面", "documentation": "跳转系统设置页面", "name": "openSystemSetting", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "要跳转的地址", "name": "url", "optional": false, "type": "string" }, { "documentation": "携带的额外参数，仅Android支持", "name": "ext", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "是否跳转成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "operateDownloadTask", "name": "operateDownloadTask", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "downloadTaskId", "optional": false, "type": "number" }, { "name": "operationType", "optional": false, "type": "\"abort\"" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "operateRequestTask", "name": "operateRequestTask", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "requestTaskId", "optional": false, "type": "number" }, { "name": "operationType", "optional": false, "type": "\"abort\"" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "operateUploadTask", "name": "operateUploadTask", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "uploadTaskId", "optional": false, "type": "number" }, { "name": "operationType", "optional": false, "type": "\"abort\"" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "page.bizReady", "name": "page.bizReady", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "pageMonitor", "name": "pageMonitor", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "pauseAudioPlay", "name": "pauseAudioPlay", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "pauseAudioRecord", "name": "pauseAudioRecord", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "pauseBackgroundAudio", "name": "pauseBackgroundAudio", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "number" }, { "name": "describe", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "pauseForegroundAudio", "name": "pauseForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "pauseSportDetect", "description": "暂停运动检测", "documentation": "暂停运动检测", "name": "pauseSportDetect", "parameters": { "in": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "performanceMonitor", "description": "惠出境H5场景", "documentation": "性能监控", "name": "performanceMonitor", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "playBackgroundAudio", "name": "playBackgroundAudio", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "business", "optional": false, "type": "string" }, { "documentation": "该属性设置为true后，忽略该函数其它所有属性，只做播放", "name": "playWithNoParam", "optional": true, "supportInfo": { "androidMinVersion": 10001032, "iosMinVersion": 10001032 }, "type": "boolean" }, { "documentation": "音频源 ，支持url和cloudId", "name": "audioDataUrl", "optional": false, "type": "string" }, { "documentation": "音频描述", "name": "audioName", "optional": true, "type": "string" }, { "documentation": "音频附加描述", "name": "audioDescribe", "optional": true, "type": "string" }, { "documentation": "音频演唱者", "name": "singerName", "optional": true, "type": "string" }, { "documentation": "音频logo地址", "name": "audioLogoURL", "optional": true, "type": "string" }, { "documentation": "封面Url", "name": "coverImgUrl", "optional": true, "type": "string" }, { "documentation": "音频来源程序名称", "name": "appName", "optional": true, "type": "string" }, { "documentation": "音频来源程序标志 logo", "name": "appLogoUrl", "optional": true, "type": "string" }, { "name": "bizExtraParamsJsonObj", "optional": true, "type": "Record<string,string>" }, { "name": "isRecordAudioPlayState", "optional": true, "type": "boolean" }, { "name": "hideRemoteControl", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "number" }, { "name": "describe", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "playForegroundAudio", "name": "playForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "popTo", "description": "- 只允许 popTo 到当前 app 实例内的页面，不允许跨 appId 跳转\n- popTo 时所带的 data 通过 resume 事件接收", "documentation": "回退到指定页面", "name": "popTo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 如果小于 0: 相对于当前页面往前跳对应数值\n- 如果大于 0: 直接跳到当前应用对应绝对索引值页面", "documentation": "目标页面索引", "name": "index", "optional": true, "type": "number" }, { "documentation": "跳转到符合特定URL规则的页面", "name": "urlPattern", "optional": true, "type": "string" }, { "documentation": "回调携带数据，可以通过 [resume](nativeevent:resume) 事件接收", "name": "data", "optional": true, "type": "Record<string,unknown>" }], "type": "Object" }], "out": [{}] } }, { "apiName": "popWindow", "description": "如需接收 data，请参阅 [resume](nativeevent) 事件", "documentation": "关闭当前页面并携带数据", "name": "popWindow", "parameters": { "in": [{ "documentation": "通过目标页面的 resume 事件接收该对象", "name": "data", "optional": true, "type": "Record<string,any>" }], "out": [{}] } }, { "apiName": "postEdgeMining", "name": "postEdgeMining", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "postNotification", "description": "- 一般和 addNotifyListener, removeNotifyListener 一起使用", "documentation": "发布客户端内全局通知消息", "name": "postNotification", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 客户端会自动添加 `NEBULANOTIFY_` 前缀，无需重复添加\n- 通过 [addNotifyListener]() 监听时需要主动添加 `NEBULANOTIFY_` 前缀\n- Android 客户端通过 LocalBroadcastManager 发送广播，可以通过监听 `NEBULANOTIFY_${name}` 在客户端进行监听", "documentation": "通知名称", "name": "name", "optional": false, "type": "string" }, { "description": "- Android 客户端中，通过 postNotification 发送的数据会自动对 value 进行 stringify，请注意兼容格式\n- Android 小于 10.1.0 必须 data 字段不为空 addNotifyListener 才能收到", "name": "data", "optional": false, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "documentation": "是否消息发送成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "preloadCanvasImage", "documentation": "向 canvas 中批量预加载图片，后续渲染时直接使用，而无需等待。", "name": "preloadCanvasImage", "parameters": { "in": [{ "documentation": "需要加载的图片路径集合。", "name": "urls", "optional": false, "type": "string[]" }], "out": [{ "name": "data", "optional": false, "type": "\"\" | #$#" }] } }, { "apiName": "preloadPlugins", "documentation": "预下载插件包", "name": "preloadPlugins", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "wifi, all, 如果不存在该字段，等价于 all", "name": "networkType", "optional": false, "type": "unknown" }, { "documentation": "预加载的插件列表", "name": "plugins", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "preloadWithSrc", "name": "preloadWithSrc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "src", "optional": false, "type": "string" }, { "name": "definition", "optional": true, "type": "number" }, { "name": "extra-info", "optional": true, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "prepareRTCResource", "name": "prepareRTCResource", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "download", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "preRender", "description": "- 在后台开一个隐藏的webview进行页面预渲染，从而加快这个页面的打开速度\n- 该接口需要配合 finishRender/clearRender 使用\n- 每次 preRender 一个页面，这个页面加入到预渲染队列中，一旦被用到，就从队列从消失。也就是说一次预渲染只能使用一次\n- 幂等和时效性：多次使用相同参数调用preRender，相当于保活刷新（更新其时间戳并刷新其页面）", "documentation": "预创建 WebView 渲染", "name": "preRender", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 后续发起 pushWindow 会与此参数比较(JSON序列化)\n- 如果参数为 null，销毁预渲染队列中的一个 WebView\n- 如果参数无效，忽略本次调用", "documentation": "用于 pushWindow 的参数", "name": "windowParams", "optional": false, "type": "Record<string,unknown>" }, { "defaultValue": "first", "description": "- 最多允许preRender N个webview，超限调用时的行为由preRender的kickOut参数控制\n- 上限由钱包开关控制，Key为H5_preRenderMax。默认为3", "documentation": "队列中数据达到上限或者 windowParams=null 时的销毁策略", "name": "kickOut", "optional": true, "type": "enum" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "预渲染队列的url数组", "name": "urls", "optional": false, "type": "string[]" }, { "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "privateSaveImage", "documentation": "接口废弃，使用saveImage", "name": "privateSaveImage", "parameters": { "in": [{}], "out": [] } }, { "apiName": "prompt", "documentation": "弹出一个对话框，让用户在对话框内输入文本", "name": "prompt", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "提示框的标题", "name": "title", "optional": false, "type": "string" }, { "defaultValue": "请输入内容", "documentation": "提示框的显示内容", "name": "message", "optional": true, "type": "string" }, { "defaultValue": "left", "documentation": "提示框的显示内容的对齐方式", "name": "align", "optional": true, "supportInfo": { "androidMinVersion": 10000005, "iosMinVersion": 10000005 }, "type": "enum" }, { "defaultValue": "确定", "name": "okButton", "optional": true, "type": "string" }, { "defaultValue": "取消", "name": "cancelButton", "optional": true, "type": "string" }, { "documentation": "输入框", "name": "placeholder", "optional": true, "type": "string" }, { "documentation": "\"确认\" 按钮颜色，HEX 格式", "name": "confirmColor", "optional": true, "type": "string" }, { "documentation": "\"取消\" 按钮颜色，HEX 格式", "name": "cancelColor", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "ok", "optional": false, "type": "boolean" }, { "name": "inputValue", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "publishNearbyMessage", "documentation": "发布近场Nearby信息。这些信息可以被订阅者获取。", "name": "publishNearbyMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "\t近场信息内容", "name": "content", "optional": false, "type": "Record<string, string>" }, { "defaultValue": "iBeacon", "documentation": "近场信息类型", "name": "type", "optional": false, "type": "string" }, { "defaultValue": "", "documentation": "信息所属空间", "name": "namespace", "optional": false, "type": "string" }, { "documentation": "标记一个业务", "name": "appKey", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "pushH5DataToWasp", "documentation": "蚂蚁众测Native端与前端H5层数据通信的JSAPI", "name": "pushH5DataToWasp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "放置H5前端回传Dom节点等数据信息的URL", "exampleValue": "https://xxx", "name": "h5DomInfoUrl", "optional": true, "type": "string" }, { "defaultValue": "0", "documentation": "时间戳，用于标记当前回传的数据对应的广播消息序列，避免异步通信时乱序", "exampleValue": "1663643891572", "name": "id", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "是否调用成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "pushTaskDataToWasp", "documentation": "写入蚂蚁众测用例数据", "name": "pushTaskDataToWasp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "from", "optional": true, "type": "string" }, { "documentation": "", "name": "projectId", "optional": true, "type": "number" }, { "documentation": "", "name": "caseIndex", "optional": true, "type": "number" }, { "documentation": "", "name": "scheme", "optional": true, "type": "string" }, { "documentation": "", "name": "type", "optional": true, "type": "string" }, { "documentation": "", "name": "projectName", "optional": true, "type": "string" }, { "documentation": "", "name": "data", "optional": true, "type": "Record<string, string>" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "pushWindow", "description": "- 与location.href的区别：类同于PC浏览器的新开标签页，每个window都是一个新的标签页，因此原页面仅仅是被压到后台，状态始终保持，JS也会继续运行。\n- 不允许跨appId打开其他离线应用的虚拟域名页面(可使用 [startApp]() )。", "documentation": "打开一个新的页面。", "name": "pushWindow", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "url", "optional": false, "type": "string" }, { "documentation": "启动参数", "name": "param", "optional": true, "type": "object" }, { "name": "launchParamsTag", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "qdclean.clear", "name": "qdclean.clear", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "qdclean.getScanData", "name": "qdclean.getScanData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "qdclean.start", "name": "qdclean.start", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "queryAllFavorite", "name": "queryAllFavorite", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "", "name": "extraInfo", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "hasKeep", "optional": true, "type": "boolean" }, { "documentation": "", "name": "keepMiniAppInfoResultList", "optional": false }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "queryBadgeInfoBatch", "name": "queryBadgeInfoBatch", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "spaceCodes", "optional": false, "type": "string[]" }, { "documentation": "", "name": "immediately", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "", "name": "YEB_YOUXUAN_BADGE", "optional": false, "type": "object" }] } }, { "apiName": "queryDeviceSportAuthorize", "documentation": "用于查询手机上运动健康，运动传感器的授权状态", "name": "queryDeviceSportAuthorize", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "场景", "name": "scene", "optional": true, "type": "string" }, { "documentation": "数组，查询数据源的集合\n['sensor','sdk']", "name": "authTypes", "optional": false, "type": "unknown" }, { "documentation": "前后端串联追踪traceId", "name": "spmInfo", "optional": true, "type": "string" }, { "documentation": "目标查询数据源", "name": "authType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": true, "type": "boolean" }, { "documentation": "厂商说明", "name": "dataSource", "optional": true, "type": "string" }, { "name": "error", "optional": true, "type": "number" }, { "name": "errorMessage", "optional": true, "type": "string" }, { "documentation": "数组对象，查询输入的数据源数组后的查询结果合集", "name": "authStateInfos", "optional": true, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "queryDisplayRpcLandingParams", "documentation": "h5获取医保native投承一体参数", "name": "queryDisplayRpcLandingParams", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "new0", "optional": false, "type": "unknown" }, { "name": "new1", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "queryEditionInfo", "name": "queryEditionInfo", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "appMode", "optional": false, "type": "string" }, { "documentation": "", "name": "availableAppModes", "optional": false, "type": "string[]" }, { "documentation": "", "name": "attribute", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "queryFloatingWindow", "name": "queryFloatingWindow", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "list", "optional": false, "type": "object" }, { "documentation": "", "name": "error", "optional": true, "type": "number" }, { "documentation": "", "name": "errorMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "queryIsFavorite", "name": "queryIsFavorite", "parameters": { "in": [{ "name": "appId", "optional": true, "type": "string" }], "out": [{ "name": "hasKeep", "optional": false, "type": "boolean" }] } }, { "apiName": "queryLauncherTabShow", "description": "根据当前TabLauncher页面显示的TAB进行查询，查询结果为当前时刻状态值，不同时机调用查询接口返回的结果可能不一致。", "documentation": "查询指定Tab appId应用是否在底部Tab显示", "name": "queryLauncherTabShow", "parameters": { "in": [{ "documentation": "查询的Tab 应用 appId", "name": "appId", "optional": false, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "函数执行成功，无异常", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "被查询的 appId", "name": "appId", "optional": false, "type": "string" }, { "description": "- 如果唤端跳过首页启动导致 Launcher 未加载时，仅会返回查询时刻的预加载结果（后续可能因为客户端配置开关变化导致不准确）", "documentation": "Tab 存在", "name": "show", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "queryLocalStepRecord", "name": "queryLocalStepRecord", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": true, "type": "boolean" }, { "documentation": "", "name": "record", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "queryMetaData", "name": "queryMetaData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "queryMultimediaFileCache", "name": "queryMultimediaFileCache", "parameters": { "in": [{}], "out": [] } }, { "apiName": "querySportAuthState", "name": "querySportAuthState", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "用于新老api切流标记，authSplit 本期切流用authSplit", "exampleValue": "", "name": "apiMode", "optional": true, "type": "string" }, { "documentation": "用于前后埋点串流traceId追踪，可以是一个时间戳", "name": "spmInfo", "optional": true, "type": "string" }, { "documentation": "是否越过疲劳度，强制发起rpc请求", "name": "force", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "更多授权信息的补充数据\n现阶段只针对，apiMode：‘authSplit’，才会返回，也就是只有运动自己能用", "name": "extInfo", "optional": true, "type": "unknown" }] } }, { "apiName": "querySportData", "description": "该接口会触发运动开通授权和步数sdk、传感器的授权。", "documentation": "获取运动步数数据", "name": "querySportData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "查询某一天的步数", "name": "date", "optional": true, "type": "string" }, { "documentation": "查询一段时间的步数的启始时间。（与endDate配套）", "name": "beginDate", "optional": true, "type": "string" }, { "documentation": "查询一段时间的步数的结束时间。（与beginDate配套）", "name": "endDate", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "运动开通状态", "name": "activeness", "optional": false, "type": "boolean" }, { "documentation": "单天步数", "name": "stepInfo", "optional": true, "type": "object" }, { "description": "数组中每项内容格式和stepInfo一致。", "documentation": "多天步数", "name": "stepInfoList", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "querySportDetectData", "description": "查询运动检测数据", "documentation": "查询运动检测数据", "name": "querySportDetectData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "string" }, { "documentation": "查询起始时间戳", "name": "startTime", "optional": false, "type": "number" }, { "documentation": "查询结束时间戳", "name": "endTime", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "string" }, { "documentation": "Array 数组，数据见 sportDataUpdate Event列表", "name": "data", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "queryUserSportAuthorize", "description": "查询用户运动传感器/SDK授权", "documentation": "查询用户运动传感器/SDK授权", "name": "queryUserSportAuthorize", "parameters": { "in": [{ "documentation": "sensor表示系统传感器，sdk表示厂商sdk", "name": "authType", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否开启授权", "name": "isOpen", "optional": false, "type": "boolean" }, { "documentation": "1000 查询成功(开启/关闭)\n2001 查询接口报错\n2002 系统权限未开启\n2003 参数错误\n2004 开关不可用(隐藏开关入口)\n2005 苹果SDK授权结果不准，有值但是建议，UI不展示开关，展现特殊文案", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "结果描述", "name": "resultMessage", "optional": false, "type": "string" }, { "documentation": "厂商名称", "name": "dataSource", "optional": false, "type": "unknown" }, { "documentation": "授权状态的更多详细信息，包括，是否已授权，是否可以打开授权，是否存在疲劳度，是否系统不支持等", "name": "authStateInfos", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "queryVisitHistoryBySourceId", "name": "queryVisitHistoryBySourceId", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "sourceId：uep_h5 uep_scan\napplication", "name": "sourceId", "optional": false, "type": "string" }, { "name": "biz", "optional": false, "type": "string" }, { "documentation": "resultExt callback中原值返回", "name": "resultExt", "optional": true, "type": "unknown" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "resultExt", "optional": false, "type": "unknown" }, { "documentation": "map", "name": "sourceIdResult", "optional": false, "type": "unknown" }, { "documentation": "入参sourceId", "name": "sourceId", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "queryVisitHistorySql", "name": "queryVisitHistorySql", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "sql语句，必传注意性能", "name": "sql", "optional": false, "type": "string" }, { "documentation": "bizid，@布洛", "name": "biz", "optional": false, "type": "string" }, { "documentation": "map\n", "name": "resulExt", "optional": true, "type": "unknown" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "查询的sql", "name": "sql", "optional": false, "type": "string" }, { "documentation": "map", "name": "sqlResult", "optional": false, "type": "unknown" }, { "documentation": "入参返回", "name": "resultExt", "optional": false, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "questionaireJSAPI", "name": "questionaireJSAPI", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "code", "optional": false, "type": "string" }, { "documentation": "", "name": "type", "optional": true, "type": "number" }, { "documentation": "", "name": "extParam", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "code", "optional": true, "type": "string" }, { "documentation": "", "name": "extParam", "optional": true, "type": "object" }, { "documentation": "", "name": "funcName", "optional": true, "type": "string" }, { "documentation": "", "name": "resultCode", "optional": false, "type": "number" }, { "documentation": "", "name": "type", "optional": true, "type": "number" }], "type": "Object" }] } }, { "apiName": "readBLECharacteristicValue", "documentation": "读取低功耗蓝牙特征值内容", "name": "readBLECharacteristicValue", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值对应 service 的 UUID", "name": "serviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值的 UUID", "name": "characteristicId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "设备特征值信息", "name": "characteristic", "optional": false, "type": "typedefname" }] } }, { "apiName": "readNdefMessage", "name": "readNdefMessage", "parameters": { "in": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }], "out": [{ "name": "data", "optional": false, "type": "object" }] } }, { "apiName": "refreshFuCardPage", "description": "新春五福", "documentation": "新春五福", "name": "refreshFuCardPage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "refreshSyncSkey", "documentation": "更新 Sync 消息本地与服务端同步点", "name": "refreshSyncSkey", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "Sync 业务码", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "同步点", "name": "sKey", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "reGeoCode", "name": "reGeoCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务唯一标示。", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "纬度。", "name": "latitude", "optional": false, "type": "number" }, { "documentation": "经度。", "name": "longitude", "optional": false, "type": "number" }, { "defaultValue": "1", "documentation": "逆地理级别。\n- `1` 代表区县级别。\n- `2` 代表街道级别。\n- `3` 代表poi级别。", "name": "regeoLevel", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "国家名称。", "name": "country", "optional": false, "type": "string" }, { "documentation": "国家adcode。", "name": "countryCode", "optional": false, "type": "string" }, { "documentation": "省份名称。", "name": "province", "optional": false, "type": "string" }, { "documentation": "省份adcode。", "name": "provinceAdcode", "optional": false, "type": "string" }, { "documentation": "城市名称。", "name": "city", "optional": false, "type": "string" }, { "documentation": "城市adcode。", "name": "cityAdcode", "optional": false, "type": "string" }, { "documentation": "区县名称。", "name": "district", "optional": false, "type": "string" }, { "documentation": "区县adCode。", "name": "districtAdcode", "optional": false, "type": "string" }, { "documentation": "街道信息。", "name": "streetNumber", "optional": false, "type": "object" }, { "documentation": "poi 列表。", "name": "pois", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "regionPicker", "name": "regionPicker", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "标题。", "name": "title", "optional": true, "type": "string" }, { "documentation": "可为每一列的顶部添加一个自定义的选项。", "name": "customItem", "optional": true, "type": "string" }, { "documentation": "自定义修改城市数据，支持删除、添加和更新城市信息，不会全局生效，仅单次生效", "name": "mergeOptions", "optional": true, "type": "object" }, { "documentation": "表示选中的省市区，默认选中每一列的第一个值。", "name": "selectedItem", "optional": true, "type": "string[]" }, { "documentation": "指定行政区划版本号：\n\n● null、空串：使用老版本（2020Q1）\n\n● UPTODATE：使用最新版\n\n● 2022Q2：使用2022Q2版本\n\n10.3.20开始支持，接入联系百喻", "name": "adVersion", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "选择的省市区名称数组", "name": "data", "optional": false, "type": "string[]" }, { "documentation": "选择的省市区 ID 数组", "name": "code", "optional": false, "type": "string[]" }], "type": "Object" }] } }, { "apiName": "registerBLEScanner", "documentation": "注册蓝牙扫描器", "name": "registerBLEScanner", "parameters": { "in": [{ "documentation": "需要注册的服务id的数组", "name": "serviceIds", "optional": false, "type": "string[]" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "registerSnapshotConfig", "description": "该接口为截屏服务进行注册，必须传参pageId", "documentation": "注册截屏服务", "name": "registerSnapshotConfig", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "页面的ID值", "name": "pageId", "optional": false, "type": "string" }, { "documentation": "小程序的appId", "name": "appId", "optional": true, "type": "string" }, { "documentation": "分享图片的参数", "name": "shareImageParam", "optional": true, "type": "string" }, { "documentation": "分享的地址", "name": "shareUrl", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "registerSSID", "name": "registerSSID", "parameters": { "in": [{ "documentation": "Wifi 设备 SSID。", "name": "SSID", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "registerSync", "description": "- 该接口需要配合 Sync 服务使用\n- 调用该接口后，在退出时必须主动调用 [unregisterSync]() , 否则可能造成 Sync 数据丢失", "documentation": "注册 Sync 消息监听", "name": "registerSync", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要取消监听的 Sync 业务码", "name": "bizType", "optional": false, "type": "string" }, { "defaultValue": "CN", "documentation": "注册区域, 包括(澳门、香港钱包)", "name": "region", "optional": true, "type": "string" }, { "documentation": "页面退出时是否自动反注册", "name": "autoUnregister", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "registerUpdateManager", "documentation": "注册更新状态监听", "name": "registerUpdateManager", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "remoteLog", "name": "remoteLog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "type", "optional": true, "type": "string" }, { "name": "ucId", "optional": true, "type": "string" }, { "name": "bizType", "optional": false, "type": "string" }, { "name": "logLevel", "optional": true, "type": "number" }, { "name": "actionId", "optional": true, "type": "string" }, { "name": "param1", "optional": true, "type": "string" }, { "name": "param2", "optional": true, "type": "string" }, { "name": "param3", "optional": true, "type": "string" }, { "name": "param4", "optional": true, "type": "string | Record<string,any>" }, { "name": "seedId", "optional": false, "type": "string" }, { "name": "spmId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "remoteLogBatch", "name": "remoteLogBatch", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "method", "optional": false, "type": "string" }, { "documentation": "", "name": "param", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removeAPDataStorage", "documentation": "从统一存储删除数据", "name": "removeAPDataStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "common", "documentation": "数据存储维度", "name": "type", "optional": true, "type": "enum" }, { "defaultValue": "NebulaBiz", "documentation": "自定义的业务标识", "name": "business", "optional": true, "type": "string" }, { "documentation": "自定义数据的key", "name": "key", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "删除是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removeAppFromMyApps", "documentation": "从首页宫格移除应用。", "name": "removeAppFromMyApps", "parameters": { "in": [{ "documentation": "从首页宫格移除应用 appId", "name": "appId", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "removed", "optional": false, "type": "boolean" }] } }, { "apiName": "removeBackgroundImage", "name": "removeBackgroundImage", "parameters": { "in": [{}], "out": [{ "documentation": "是否调用完成", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "removeEventCal", "documentation": "移除日历事件", "name": "removeEventCal", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "日历标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "事件发生地点", "name": "location", "optional": true, "type": "string" }, { "documentation": "开始时间", "name": "startDate", "optional": false, "type": "string" }, { "documentation": "结束时间", "name": "endDate", "optional": false, "type": "string" }, { "documentation": "事件内容", "name": "notes", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "sucess", "optional": false, "type": "boolean" }] } }, { "apiName": "removeFollow", "name": "removeFollow", "parameters": { "in": [{ "name": "publicId", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removeFuCard", "description": "新春五福专用", "documentation": "新春五福专用jsapi", "name": "removeFuCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "removeNotifyListener", "description": "移除当前页面内由 [addNotifyListener]() 添加的全局通知监听器", "documentation": "移除客户端内全局通知监听", "name": "removeNotifyListener", "parameters": { "in": [{ "documentation": "通知名称", "name": "name", "optional": false, "type": "string" }], "out": [{ "documentation": "是否成功移除", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removePeripheralService", "name": "removePeripheralService", "parameters": { "in": [{ "documentation": "服务 id。", "name": "serviceId", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "removeRecentUseItem", "name": "removeRecentUseItem", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "appId", "optional": true, "type": "string" }, { "documentation": "", "name": "monitorSource", "optional": true, "type": "string" }, { "documentation": "", "name": "source", "optional": true, "type": "string" }, { "documentation": "", "name": "nbsn", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removeSavedFile", "documentation": "删除保存到本地的文件", "name": "removeSavedFile", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "文件路径。", "name": "apFilePath", "optional": true, "type": "string" }, { "documentation": "文件路径。", "name": "filePath", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "removeSharedData", "description": "- 建议换用更可靠的 removeAPDataStorage", "documentation": "移除共享数据", "name": "removeSharedData", "parameters": { "in": [{ "documentation": "要删除的数据项的 key", "name": "keys", "optional": false, "type": "string[]" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "removeShortCut", "name": "removeShortCut", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用 appId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "应用名称", "name": "appName", "optional": false, "type": "string" }, { "description": "支持 base64", "documentation": "图标URL", "name": "iconBitmap", "optional": false, "type": "string" }, { "documentation": "扩展参数", "name": "params", "optional": true, "type": "Record<string,string>" }], "type": "Object" }], "out": [{}] } }, { "apiName": "removeTabBarItem", "name": "removeTabBarItem", "parameters": { "in": [{ "documentation": "要删除的 item 对应的位置，从 `0` 开始", "name": "index", "optional": false, "type": "number" }], "out": [{ "name": "pagePath", "optional": false, "type": "string" }] } }, { "apiName": "removeTinyLocalStorage", "documentation": "移除应用存储的KV数据", "name": "removeTinyLocalStorage", "parameters": { "in": [{ "name": "key", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "error", "optional": false, "type": "0" }], "type": "Object" }] } }, { "apiName": "replyRoomInvitation", "name": "replyRoomInvitation", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "params", "optional": false, "type": "object" }, { "name": "uid", "optional": false, "type": "string" }, { "name": "replyType", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "reportData", "name": "reportData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "spmDetail", "optional": true, "type": "object" }, { "documentation": "", "name": "ignoreDefaultPageMonitor", "optional": true, "type": "boolean" }, { "documentation": "", "name": "spm", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "reportIotEvent", "name": "reportIotEvent", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "eventId", "optional": false, "type": "string" }, { "name": "data", "optional": false, "type": "Record<string,string>" }], "type": "Object" }], "out": [{}] } }, { "apiName": "reportJST2", "name": "reportJST2", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "request", "description": "", "documentation": "用于发起 HTTPS 网络请求的 API。", "name": "request", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "目标服务器 URL", "name": "url", "optional": false, "type": "string" }, { "documentation": "请求任务ID，仅用于小程序", "name": "requestTaskId", "optional": true, "type": "number" }, { "defaultValue": "GET", "documentation": "默认 GET，目前支持 GET/POST/PUT/DELETE", "name": "method", "optional": true, "type": "string" }, { "documentation": "期望返回的数据格式，默认 JSON，支持 JSON、text、base64、arraybuffer\t", "name": "responseType", "optional": true, "type": "\"json\" | \"text\" | \"base64\" | \"arraybuffer\"" }, { "documentation": "get/delete做url参数拼接\t", "name": "hasAssembleParams", "optional": true, "type": "boolean" }, { "documentation": "请求数据\t", "name": "data", "optional": true, "type": "string | Record<string,string> | ArrayBuffer" }, { "defaultValue": "{'content-type': 'application/json'}", "documentation": "设置 HTTP 请求头对象", "name": "headers", "optional": true, "type": "object" }, { "defaultValue": "false", "description": "iOS默认支持，通过此参数切换到网络库的DTN", "documentation": "是否支持 HTTP2.0 请求", "name": "enableHttp2", "optional": true, "supportInfo": { "androidMinVersion": 10001095, "iosMinVersion": 10001032 }, "type": "boolean" }, { "defaultValue": "30000", "documentation": "超时时间，单位ms\t", "name": "timeout", "optional": true, "type": "number" }, { "defaultValue": "UTF-8", "documentation": "返回数据编码格式", "name": "responseCharset", "optional": true, "type": "string" }, { "defaultValue": "false", "documentation": "是否需要自管理cookie，如果true，则不会再主动填充cookie", "name": "enableCookie", "optional": true, "supportInfo": { "androidMinVersion": 10002033, "iosMinVersion": 10002033 }, "type": "boolean" }, { "defaultValue": "false", "documentation": "是否支持CCDN缓存", "name": "enableCCDNCache", "optional": true, "supportInfo": { "androidMinVersion": 10003010, "iosMinVersion": 10003010 }, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "响应数据，格式取决于请求时的 `dataType` 参数，\n如果 `dataType` 值为 `base64` 时，返回的是符合\n[data URI scheme](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs) 规范的内容字符串。", "name": "data", "optional": false, "type": "string | Record<string,unknown>" }, { "documentation": "响应码。", "name": "status", "optional": false, "type": "number" }, { "documentation": "响应头", "name": "headers", "optional": false, "type": "Record<string,string>" }], "type": "Object" }] } }, { "apiName": "requestDeviceSportAuthorize", "documentation": "请求设备运动健康授权", "name": "requestDeviceSportAuthorize", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "请求的数据源名称\nsdk/sensor", "name": "authType", "optional": false, "type": "string" }, { "documentation": "是否强制越过疲劳度", "name": "force", "optional": true, "type": "boolean" }, { "documentation": "场景", "name": "scene", "optional": true, "type": "string" }, { "documentation": "前后端串流追踪 traceId", "name": "spmInfo", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "授权结果", "name": "authState", "optional": true, "type": "boolean" }, { "documentation": "厂商", "name": "dataSource", "optional": true, "type": "string" }, { "name": "success", "optional": true, "type": "boolean" }, { "name": "error", "optional": true, "type": "number" }, { "name": "errorMessage", "optional": true, "type": "number" }, { "documentation": "更多授权相关信息对象", "name": "extInfo", "optional": true, "type": "unknown" }], "type": "Object" }] } }, { "apiName": "requestPedometerPermission", "name": "requestPedometerPermission", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "requestStepDetectInfo", "documentation": "检测步数是否异常", "name": "requestStepDetectInfo", "parameters": { "in": [{ "documentation": "检测类型\n● simple，简单模式。只返回步可优化项 和 异常状态\n● complete，完整模式，返回详细的检测信息已经推荐文案，检测页面用", "name": "scene", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "步数数据状态", "exampleValue": "normal", "name": "stepState", "optional": false, "type": "string" }, { "documentation": "检测到用户可优化的操作数量", "exampleValue": "0", "name": "optimizeItemCount", "optional": false, "type": "number" }, { "documentation": "传感器检测结果。complete模式下返回", "exampleValue": "", "name": "sensorDetectResult", "optional": true, "type": "object" }, { "documentation": "sdk检测结果。complete模式下返回。只在接入运动sdk的厂商中返回。\n华为、oppo、vivo、三星", "name": "sdkDetectResult", "optional": true, "type": "object" }, { "documentation": "规则验证后的推荐结果。complete模式下返回。即使没有命中任何规则，也会返回兜底文案", "name": "otherDetectResult", "optional": true, "type": "object" }, { "documentation": "业务内部错误码", "name": "resultCode", "optional": true, "type": "number" }, { "documentation": "业务内部错误描述信息", "name": "resultMessage", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "reSelectContacter", "name": "reSelectContacter", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "reSendRedEnvelope", "name": "reSendRedEnvelope", "parameters": { "in": [{ "documentation": "", "name": "params", "optional": false, "type": "object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "recentlyUsedTemplateId", "optional": true, "type": "string" }, { "documentation": "", "name": "resultCode", "optional": true, "type": "string" }, { "documentation": "", "name": "resultDesc", "optional": true, "type": "string" }, { "documentation": "", "name": "resultView", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "responseSyncNotify", "description": "- 本地处理完成收到的消息后，通知通道层本地已经成功处理，无需服务端再重复下发", "documentation": "响应服务端 Sync 消息通知", "name": "responseSyncNotify", "parameters": { "in": [{ "documentation": "收到的完整消息对象", "name": "message", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "restoreOriginUc", "name": "restoreOriginUc", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "restorePullToRefresh", "name": "restorePullToRefresh", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "resumeAudioPlay", "name": "resumeAudioPlay", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "resumeAudioRecord", "name": "resumeAudioRecord", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "resumeSportDetect", "description": "重启运动检测", "documentation": "重启运动检测", "name": "resumeSportDetect", "parameters": { "in": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "number" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "reTplListAndPreview", "name": "reTplListAndPreview", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "riskAnalyze", "documentation": "使用端风控引擎进行风险检测", "name": "riskAnalyze", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "userAction 标识", "name": "uaName", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "properties", "optional": true, "type": "object" }, { "description": "", "documentation": "超时时间，单位ms", "name": "timeout", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "保留字段", "name": "rdsResult", "optional": false, "type": "string" }, { "description": "", "documentation": "风险分析结果", "name": "result", "optional": false, "type": "enum" }, { "description": "", "documentation": "加密的风险分析数据，需要上报到服务端", "name": "sealedData", "optional": false, "type": "string" }, { "description": "", "documentation": "错误码，0表示成功", "name": "status", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "rpc", "documentation": "发起 RPC 请求", "name": "rpc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "rpc 服务名称。", "name": "operationType", "optional": false, "type": "string" }, { "documentation": "请求参数。", "name": "requestData", "optional": false, "type": "unknown[]" }, { "documentation": "请求头。", "name": "headers", "optional": true, "type": "Record<string,string>" }, { "documentation": "网关地址。", "name": "gateway", "optional": true, "type": "string" }, { "defaultValue": "true", "documentation": "是否支持 request gzip 压缩。", "name": "compress", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "rpc 网关被限流时是否禁止自动弹出统一限流弹窗。", "name": "disableLimitView", "optional": true, "type": "boolean" }, { "description": "- **警告**: 尽量不要自定义，否则容易出现服务端有成功返回数据，但客户端已经超时回调报错给前端的情况，容易导致重复发起创建订单之类的严重问题。\n- 默认值: iOS端 wifi 环境 20s，其它环境 30s。Android端 wifi/4g 环境 12s 到 42s 之间。其它环境 32s 到 60s 之间", "documentation": "rpc 超时时间。", "name": "timeout", "optional": true, "supportInfo": { "androidMinVersion": 10000003, "iosMinVersion": 10000003 }, "type": "number" }, { "defaultValue": "false", "description": "- **注意**: 如果设置为true的话，响应数据会多一层嵌套，可用于数据回流上报获取 traceId/entityId 场景，需要开启 MMTP 开关）", "documentation": "获取 rpc 响应头", "name": "getResponse", "optional": true, "supportInfo": { "androidMinVersion": 10000018, "iosMinVersion": 10000018 }, "type": "boolean" }, { "defaultValue": "false", "documentation": "是否为开放 RPC，值为 true 时请求头中会带上当前页面 URL 信息。", "name": "openRpc", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "是否是get方式请求。", "name": "httpGet", "optional": true, "type": "boolean" }, { "defaultValue": "json", "documentation": "请求数据格式类型。", "name": "type", "optional": true, "type": "enum" }, { "defaultValue": "false", "documentation": "是否可重试。", "name": "retryable", "optional": true, "type": "boolean" }, { "documentation": "地区，如澳门等。", "name": "region", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "响应头。", "name": "header", "optional": false, "type": "Record<String, String>" }, { "documentation": "服务端返回数据。", "name": "resData", "optional": false, "type": "Object" }], "type": "Object" }] } }, { "apiName": "rsa", "description": "- 加密与解密过程应分别在客户端与服务端进行，且私钥必须放在服务端（私钥放在客户端易泄露将导致安全问题）", "documentation": "非对称加解密", "name": "rsa", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "使用 RSA 加密还是 RSA 解密。", "name": "action", "optional": false, "type": "enum" }, { "documentation": "需要被加/解密的文本\n- `加密` 为 原始文本。\n- `解密` 为 `Base64` 编码格式文本。", "name": "text", "optional": false, "type": "string" }, { "documentation": "RSA 密钥。\n- `加密` 使用公钥\n- `解密` 使用私钥。", "name": "key", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "经过处理过后得到的文本。\n- `加密` 为 `Base64` 编码文本。\n- `解密` 为 原始文本。", "name": "text", "optional": false, "type": "string" }] } }, { "apiName": "RtsConnect", "name": "RtsConnect", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "rtsType", "optional": false, "type": "string" }, { "documentation": "", "name": "user", "optional": false, "type": "object" }, { "documentation": "", "name": "enableReplay", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "callbackType", "optional": false, "type": "string" }, { "documentation": "", "name": "data", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "RtsCreate", "name": "RtsCreate", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "RtsJoin", "name": "RtsJoin", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "RtsLeave", "name": "RtsLeave", "parameters": { "in": [{ "documentation": "", "name": "rtsType", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "RtsSend", "name": "RtsSend", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "RtsSub", "name": "RtsSub", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "rtsType", "optional": false, "type": "string" }, { "documentation": "", "name": "subTopic", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "callbackType", "optional": false, "type": "string" }, { "documentation": "", "name": "data", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "RtsUnsub", "name": "RtsUnsub", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "rtsType", "optional": false, "type": "string" }, { "documentation": "", "name": "unsubTopic", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "callbackType", "optional": false, "type": "string" }, { "documentation": "", "name": "data", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "runSportDetectInBackground", "description": "后台运行运动检测", "documentation": "后台运行运动检测", "name": "runSportDetectInBackground", "parameters": { "in": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "boolean" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "runSportDetectInForeground", "description": "前台运行运动检测", "documentation": "前台运行运动检测", "name": "runSportDetectInForeground", "parameters": { "in": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误码", "name": "errorMessage", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "runXMediaCoreBiz", "name": "runXMediaCoreBiz", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "processId", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "source", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "apFilePath", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "result", "optional": false, "type": "object" }, { "description": "", "documentation": "", "name": "processId", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "extraData", "optional": true, "type": "object" }, { "description": "", "documentation": "", "name": "errorMessage", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "image", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "error", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "rvToolsFetchResource", "name": "rvToolsFetchResource", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "saveBizServiceResult", "name": "saveBizServiceResult", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "resultStatus", "optional": true, "type": "string" }, { "documentation": "", "name": "result", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "", "name": "savedData", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "saveFile", "documentation": "保存文件到本地", "name": "saveFile", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "文件路径。", "name": "apFilePath", "optional": false, "type": "string" }, { "name": "filePath", "optional": false, "type": "string" }, { "defaultValue": "false", "documentation": "是否将文件保存到外部存储目录", "name": "toDisk", "optional": true, "supportInfo": { "androidMinVersion": 10001085, "iosMinVersion": 10001085 }, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "saveImage", "name": "saveImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "图片地址", "name": "src", "optional": false, "type": "string" }, { "defaultValue": "true", "documentation": "是否显示确认保存的提示", "name": "showActionSheet", "optional": true, "type": "boolean" }, { "documentation": "是否自定义处理保存图片结果", "name": "cusHandleResult", "optional": true, "type": "boolean" }, { "defaultValue": "default", "name": "savePath", "optional": true, "type": "string" }, { "defaultValue": "png", "documentation": "指定保存到手机相册图片的格式", "name": "imageType", "optional": true, "supportInfo": { "iosMinVersion": 10002063 }, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "saveImageToPhotosAlbum", "name": "saveImageToPhotosAlbum", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "要保存的图片链接。", "name": "filePath", "optional": false, "type": "string" }, { "name": "hideToast", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "saveVideoToPhotosAlbum", "name": "saveVideoToPhotosAlbum", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "src", "optional": true, "type": "string" }, { "name": "filePath", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "scan", "name": "scan", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "qr", "name": "type", "optional": false, "type": "\"bar\" | \"lottery\" | \"qr\"" }, { "name": "scanType", "optional": true, "type": "\"qrCode\" | \"barCode\" | \"dmCode\" | \"pdf417Code\" | \"narrowCode\" | \"hmCode\"" }, { "name": "charset", "optional": true, "type": "string" }, { "name": "hideAlbum", "optional": true, "type": "boolean" }, { "defaultValue": "scan", "name": "actionType", "optional": true, "type": "\"scan\" | \"route\" | \"scanAndRoute\" | \"scanAndRpc\"" }, { "documentation": "指定用于”route”操作类型的码值", "name": "qrcode", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "barCode", "optional": false, "type": "string" }] } }, { "apiName": "scanCode", "documentation": "调起客户端扫码界面进行扫码", "name": "scanCode", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "scanType", "optional": false, "type": "string[]" }, { "documentation": "", "name": "onlyFromCamera", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "imageChannel", "optional": false, "type": "string" }, { "documentation": "", "name": "rawData", "optional": false, "type": "string" }, { "documentation": "", "name": "codeType", "optional": false, "type": "string" }, { "documentation": "", "name": "qrCode", "optional": false, "type": "string" }, { "documentation": "", "name": "codeContent", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "searchPoi", "name": "searchPoi", "parameters": { "in": [{}], "out": [] } }, { "apiName": "seekBackgroundAudio", "name": "seekBackgroundAudio", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "0", "name": "position", "optional": false, "type": "number" }, { "name": "business", "optional": false, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "seekForegroundAudio", "name": "seekForegroundAudio", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "audioPlayerID", "optional": false, "type": "string" }, { "documentation": "将媒体流移动到指定位置，单位 s", "name": "position", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "sendFindElement", "documentation": "获取页面控件信息", "name": "sendFindElement", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "sendHCEMessage", "name": "sendHCEMessage", "parameters": { "in": [{ "documentation": "二进制数据。", "name": "data", "optional": false, "type": "ArrayBuffer" }], "out": [{}] } }, { "apiName": "sendLanHttpRequest", "name": "sendLanHttpRequest", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "网址，只支持局域网 IP 地址作为域名，不能是本机地址，只支持 `http` 或 `https`", "name": "url", "optional": false, "type": "string" }, { "defaultValue": "{'content-type': 'application/x-www-form-urlencoded'}", "documentation": "设置请求的 HTTP 头对象，该对象里面的 `key` 和 `value` 必须是 `string` 类型", "name": "headers", "optional": true, "type": "Record<string,unknown>" }, { "defaultValue": "GET", "name": "method", "optional": true, "type": "\"GET\" | \"POST\"" }, { "documentation": "*,传给服务器的数据最终会被转换成 `string` 类型，转换规则如下：\n- 若方法为 `GET`，会将数据转换成 query string，转换规则：encodeURIComponent(key)=encodeURIComponent(value)&encodeURIComponent(key)=encodeURIComponent(value)...\n- 若方法为 `POST` 且 `headers['content-type']` 为 `application/json`，会对数据进行 JSON 序列化。\n- 若方法为 `POST` 且 `headers['content-type']` 为 `application/x-www-form-urlencoded`，会将数据转换成 query string：\nencodeURIComponent(key)=encodeURIComponent(value)&encodeURIComponent(key)=encodeURIComponent(value)...", "name": "data", "optional": true, "type": "unknown" }, { "defaultValue": "30000", "documentation": "超时时间，单位：`毫秒`，为 `0` 则不超时", "name": "timeout", "optional": true, "type": "number" }, { "defaultValue": "JSON", "documentation": "期望返回的数据格式", "name": "dataType", "optional": true, "type": "\"JSON\" | \"text\"" }, { "defaultValue": "false", "documentation": "[**Android Only**] 是否绑定到当前 WiFi，Android 默认不向无法上网的 WiFi 发送网络数据。", "name": "bindToWifi", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "http 响应码", "name": "status", "optional": false, "type": "number" }, { "documentation": "响应头", "name": "headers", "optional": false, "type": "Record<string,unknown>" }, { "documentation": "响应数据，格式取决于请求时的 `dataType` 参数。", "name": "data", "optional": false, "type": "string | Record<string,unknown>" }], "type": "Object" }] } }, { "apiName": "sendMtop", "documentation": "发送Mtop请求", "name": "sendMtop", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "api 名称", "name": "api/apiName", "optional": false, "type": "string" }, { "documentation": "api 版本", "name": "v", "optional": true, "type": "string" }, { "documentation": "是否需要登陆", "name": "needLogin", "optional": true, "type": "boolean" }, { "defaultValue": "AutoLoginAndManualLogin", "name": "sessionOption", "optional": true, "type": "string" }, { "defaultValue": "GET", "documentation": "请求类型", "name": "method", "optional": true, "type": "string" }, { "defaultValue": "originaljson", "documentation": "数据类型", "name": "dataType", "optional": true, "type": "string" }, { "name": "secType", "optional": true, "type": "number" }, { "name": "data", "optional": true, "type": "object" }, { "name": "ext_headers", "optional": true, "type": "object" }, { "name": "ext_querys", "optional": true, "type": "object" }, { "defaultValue": "20000", "name": "timeout", "optional": true, "type": "number" }, { "name": "ttid", "optional": true, "type": "string" }, { "name": "pageUrl", "optional": true, "type": "string" }, { "name": "x-ua", "optional": true, "type": "string" }, { "name": "mpHost", "optional": true, "type": "string" }, { "name": "domain", "optional": true, "type": "string" }, { "name": "accountSite", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "api 名称", "name": "api", "optional": false, "type": "string" }, { "documentation": "数据结果", "name": "data", "optional": false, "type": "object" }, { "documentation": "接口版本", "name": "v", "optional": false, "type": "string" }, { "documentation": "请求状态", "name": "ret", "optional": false, "type": "Array" }], "type": "Object" }] } }, { "apiName": "sendPageAlert", "name": "sendPageAlert", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "sendPageDom", "name": "sendPageDom", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "sendPageIssue", "documentation": "设计巡检接收js数据", "name": "sendPageIssue", "parameters": { "in": [{ "name": "body", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "sendSMS", "description": "当设备不支持短信功能时，会有弹窗提示", "documentation": "发送短信", "name": "sendSMS", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "发送短信的手机号码", "name": "mobile", "optional": false, "type": "string" }, { "documentation": "发送短信的内容", "name": "content", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "操作结果", "name": "status", "optional": false, "type": "enum" }] } }, { "apiName": "sendSocketMessage", "documentation": "发送 socket 信息", "name": "sendSocketMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "socketTaskID", "optional": false, "type": "string" }, { "documentation": "需要发送的内容：普通的文本内容 string 或者经 Base64 编码后的 string。", "name": "data", "optional": false, "type": "string" }, { "defaultValue": "false", "documentation": "注意事项：\n- 如果发送二进制数据，需要将入参数据经 Base64 编码成 string 后赋值 data，同时将此字段设置为 true。\n- 如果是普通的文本内容 string，则不需要设置此字段。", "name": "isBuffer", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "为 true 时按指定前缀拼接新的 appId，与原始 appId 隔离", "name": "fromRemoteDebug", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "sendSyncMessage", "description": "- [registerSync]() 与 [unregisterSync]() 提供了 SYNC 下行消息接受机制\n- 对于 SYNC 上行消息，可以使用该接口来发送", "documentation": "SYNC 上行发送消息", "name": "sendSyncMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "对应 SYNC 的biz", "name": "biz", "optional": false, "type": "string" }, { "description": "在发送 Sync 时，会转换成 JSON 字符串发送", "documentation": "发送的数据", "name": "data", "optional": false, "type": "Record<string,unknown>" }, { "description": "- 如不传，默认传递当前的用户ID", "documentation": "业务可自定义发送的 userId", "name": "currentUserId", "optional": true, "type": "string" }, { "description": "- 如不传，默认传递当前的应用名称", "documentation": "业务可自定义发送的应用名称", "name": "currentAppName", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "发送成功或者失败", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "sendTCPMessage", "name": "sendTCPMessage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "sendUDPMessage", "name": "sendUDPMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "socketId", "optional": false, "type": "string" }, { "name": "address", "optional": false, "type": "string" }, { "name": "port", "optional": false, "type": "number" }, { "name": "length", "optional": false, "type": "number" }, { "name": "offset", "optional": false, "type": "number" }, { "name": "message", "optional": false, "type": "string | ArrayBuffer" }], "type": "Object" }], "out": [{}] } }, { "apiName": "setAPDataStorage", "documentation": "保存字符串值到客户端统一存储", "name": "setAPDataStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "common", "documentation": "数据存储维度", "name": "type", "optional": true, "type": "enum" }, { "defaultValue": "NebulaBiz", "documentation": "自定义的业务标识", "name": "business", "optional": true, "type": "string" }, { "description": "- Android 对于 type=user 是通过 key=`${key}_${MD5(userId+userId+userId)}` 的方式存储的", "documentation": "自定义数据的key", "name": "key", "optional": false, "type": "string" }, { "description": "- 仅支持字符串类型，复杂类型需要自行 JSON.stringify\n- 字符串长度不得超过 200KB", "documentation": "需要存储的值", "name": "value", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setAppxVersion", "name": "setAppxVersion", "parameters": { "in": [{ "documentation": "", "name": "appxVersion", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setBackButton", "name": "setBackButton", "parameters": { "in": [{ "documentation": "HEX", "name": "color", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setBackgroundAudioOption", "name": "setBackgroundAudioOption", "parameters": { "in": [{ "name": "option", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "1" }] } }, { "apiName": "setBackgroundColor", "name": "setBackgroundColor", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "backgroundColor", "optional": true, "type": "string" }, { "name": "backgroundColorTop", "optional": true, "type": "string" }, { "name": "backgroundColorBottom", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setBackgroundImage", "name": "setBackgroundImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "图片对应的链接，支持dataURL/相对路径/离线资源", "name": "imgUrl", "optional": false, "type": "string" }, { "documentation": "图片的背景颜色，用于填补图片透明或空缺的位置", "name": "color", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "是否调用完成", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setBackgroundTextStyle", "name": "setBackgroundTextStyle", "parameters": { "in": [{ "documentation": "下拉背景字体、loading 图的样式", "name": "textStyle", "optional": false, "type": "\"dark\" | \"light\"" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setBackPrevented", "name": "setBackPrevented", "parameters": { "in": [{ "documentation": "是否阻止默认返回行为", "name": "prevented", "optional": false, "type": "boolean" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setBarBottomLineColor", "documentation": "设置导航栏底部边线颜色", "name": "setBarBottomLineColor", "parameters": { "in": [{ "name": "color", "optional": false, "type": "number" }], "out": [{}] } }, { "apiName": "setBizWhiteListStatus", "name": "setBizWhiteListStatus", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setBLEMTU", "documentation": "协商低功耗MTU值", "name": "setBLEMTU", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "设备id", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "mtu值（大于23）", "name": "mtu", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "documentation": "协商后的mtu值", "name": "mtu", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "setCanPullDown", "name": "setCanPullDown", "parameters": { "in": [{ "documentation": "是否支持下拉", "name": "canPullDown", "optional": false, "type": "boolean" }], "out": [{}] } }, { "apiName": "setClipboard", "description": "本接口功能可能涉及隐私问题，请谨慎使用。", "documentation": "设置剪贴板数据。", "name": "setClipboard", "parameters": { "in": [{ "documentation": "剪贴板数据。", "name": "text", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setCustomPopMenu", "name": "setCustomPopMenu", "parameters": { "in": [{ "documentation": "自定义菜单列表", "name": "menus", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setDarkMode", "documentation": "设置钱包深色模式", "name": "setDarkMode", "parameters": { "in": [{ "documentation": "ight , 设置为亮色模式\ndark ,设置为深色模式followSystem ,设置为跟随系统", "name": "darkMode", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setExternalThrough", "name": "setExternalThrough", "parameters": { "in": [{ "documentation": "", "name": "value", "optional": false, "type": "string | #$#" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setForegroundAudioOption", "name": "setForegroundAudioOption", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "audioPlayerID", "optional": false, "type": "string" }, { "name": "option", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "1 | 0" }] } }, { "apiName": "setGestureBack", "description": "- 按照标准规范必须允许侧滑返回，除非特殊场景否则请勿调该接口来禁用", "documentation": "设置手势返回 (iOS)", "name": "setGestureBack", "parameters": { "in": [{ "documentation": "是否可以通过手势返回", "name": "val", "optional": false, "type": "boolean" }], "out": [{}] } }, { "apiName": "setGradeSwitchState", "documentation": "设置App极速模式开关状态", "name": "setGradeSwitchState", "parameters": { "in": [{ "documentation": "0：关闭，1：打开", "name": "switchState", "optional": false, "type": "number" }], "out": [{ "documentation": "true表示设置成功\nfalse表示设置失败", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setH5CustomPopMenuItem", "documentation": "使用中台提供的通用菜单面板，设置自定义菜单项，默认不显示自定义菜单页面部分", "name": "setH5CustomPopMenuItem", "parameters": { "in": [{ "documentation": "自定义菜单名称数组", "name": "menus", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setH5SettingPopMenuItem", "documentation": "框架统一导航栏使用，设置通用菜单项显示或隐藏，默认为框架后台配置项目。参数为可配置的菜单项列表，传入表示显示，不传入隐藏。传入不可配置的菜单项会被忽略。", "name": "setH5SettingPopMenuItem", "parameters": { "in": [{ "documentation": "菜单项mid的数组", "name": "menus", "optional": false, "type": "string[]" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setH5ShareParamsPopMenuItem", "description": "参数为可配置的分享参数，传入则使用业务传入的分享参数，不传则使用默认兜底参数\n", "documentation": "H5统一导航栏分享面版参数传递", "name": "setH5ShareParamsPopMenuItem", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setKeyboardType", "documentation": "native测键盘使用 不对外", "name": "setKeyboardType", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "setKeyboardType", "optional": true, "type": "string" }, { "name": "type", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "setLandscape", "description": "- 如果需要切换到竖屏，请使用 [setPortrait]()", "documentation": "切换到横屏", "name": "setLandscape", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setLocatedCity", "documentation": "用于修改getCities中的默认定位城市名称。", "name": "setLocatedCity", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "当前定位城市的名称。", "name": "locatedCityName", "optional": false, "type": "string" }, { "documentation": "当前定位城市 ID，`chooseCity` 接口的 `onLocatedComplete` 返回。", "name": "locatedCityId", "optional": false, "type": "string" }, { "documentation": "当前定位城市的行政区划代码，不传值时以控件默认拿到的为准。", "name": "locatedCityAdCode", "optional": true, "type": "string" }, { "documentation": "当前定位城市的拼音，不传值时以控件默认拿到的为准。", "name": "locatedCityPinyin", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "修改后的定位城市名称", "name": "locatedCityName", "optional": false, "type": "string" }] } }, { "apiName": "setNavBarTextFieldPlaceHolder", "name": "setNavBarTextFieldPlaceHolder", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setNavBarTextFieldPlaceHolderPlay", "name": "setNavBarTextFieldPlaceHolderPlay", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setNFCTimeout", "name": "setNFCTimeout", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }, { "documentation": "设置超时时间（ms）", "name": "timeout", "optional": false, "type": "number" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setOptionMenu", "description": "- 当自定义后，点击右上角按钮会触发 [optionMenu](nativeevent:optionMenu) 事件\n- 仅进行自定义配置，显示/刷新界面需要调用 [showOptionMenu]() 接口\n- 参数设置中，有几个属性是优先级的：reset > title > icontype > iconfont > icon， 这5个属性只需要有一个即可。\n- 由于苹果的ATS限制，icon URL必须为https链接或base64，http链接会被忽略", "documentation": "自定义H5右上角选项按钮配置", "name": "setOptionMenu", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "是否阻止默认的分享功能", "name": "preventDefault", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "重置到系统默认。当reset=true时，忽略其他参数", "name": "reset", "optional": true, "type": "boolean" }, { "documentation": "在需要设置多个option的情况下，是否保留默认的optionMenu", "name": "override", "optional": true, "type": "boolean" }, { "documentation": "最多只支持新增两个菜单，该数组的长度需要 <= 2", "name": "menus", "optional": true, "type": "object" }, { "name": "bizType", "optional": true, "type": "\"tiny\"" }, { "name": "contentDesc", "optional": true, "type": "string" }, { "name": "color", "optional": true, "type": "string" }, { "description": "- \"-1\" 不显示\n- \"0\" 显示红点\n- \"数字\" 在红点上显示的数字", "documentation": "红点样式", "name": "redDot", "optional": true, "type": "string | '-1' | '0'" }, { "name": "title", "optional": true, "type": "string" }, { "description": "", "documentation": "根据类型加载容器预置图片。只支持单个optionMenu变色。\n", "name": "icontype", "optional": true, "supportInfo": { "androidMinVersion": 9009003, "iosMinVersion": 9009003 }, "type": "enum" }, { "description": "8.3及以前：iOS 40x40（周边不留白）, Android 50x50（四边各透明留白5px）\n8.4及以后：两个平台统一使用40x40（周边不留白）\nBase64 从 9.0 开始支持。使用时，不要写“data:image/png;base64”前缀", "documentation": "按钮图标url / base64", "name": "icon", "optional": true, "type": "string" }, { "description": "支持的类型见下地址，注意不要加上k前缀：\nhttp://alipay-rmsdeploy-image.cn-hangzhou.alipay.aliyun-inc.com/ucpsprod/ios_unicode.html", "documentation": "根据字体类型加载支付宝端内预置图片。", "name": "iconfont", "optional": true, "supportInfo": { "androidMinVersion": 10002020, "iosMinVersion": 10002020 }, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setPortrait", "description": "- 如果需要切换到横屏，请使用 [setLandscape]()", "documentation": "切换到竖屏", "name": "setPortrait", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setPullDownText", "description": "- 页面下拉时会默认显示一个 \"网页由 xxx 提供\" 的安全提示文案，可通过该接口自定义", "documentation": "自定义页面下拉文案", "name": "setPullDownText", "parameters": { "in": [{ "documentation": "自定义下拉文案", "name": "pullDownText", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setRecordSecure", "description": "仅 Android ", "documentation": "设置当前页面禁止截屏、录屏。", "name": "setRecordSecure", "parameters": { "in": [{ "documentation": "设置是否禁止截屏、录屏。默认不禁止，只有当值设置为\"secure\"时，才表示禁止。", "name": "secure", "optional": true, "type": "string" }], "out": [] } }, { "apiName": "setScreenAutolock", "documentation": "保持屏幕常亮", "name": "setScreenAutolock", "parameters": { "in": [{ "name": "actionType", "optional": false, "type": "enum" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setScreenBrightness", "documentation": "设置屏幕亮度", "name": "setScreenBrightness", "parameters": { "in": [{ "documentation": "需要设置的屏幕亮度，取值范围 （0-1）。", "name": "brightness", "optional": false, "type": "number" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setScreenOrientation", "name": "setScreenOrientation", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "必须传递才能生效", "name": "beta", "optional": false, "type": "1" }, { "name": "orientation", "optional": false, "type": "\"landscape\" | \"portrait\"" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setServiceWorkerID", "name": "setServiceWorkerID", "parameters": { "in": [{ "documentation": "ServiceWorker 的 applicationId", "name": "id", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "setSessionData", "description": "- `sessionData`是以每个app为单位的，因此可以实现app内的数据共享, 当app退出之后，数据自动清除\n- 如果需要在app之间共享数据，或者需要做持久化，那么可以使用`sharedData`\n- 数据在不同账户间共享：假如用户账号在其他设备登入导致logout，那么并不会清除数据，这个时候如果这个设备登入另一个账号，是可以看到这个数据的", "documentation": "写入缓存数据（当前应用生命周期内）", "name": "setSessionData", "parameters": { "in": [{ "documentation": "要写入的数据", "name": "data", "optional": false, "type": "Record<string,string>" }], "out": [{}] } }, { "apiName": "setSharedData", "description": "- `getSharedData`，`setSharedData`以及`removeSharedData`可以跨 appId 共享数据\n- 建议换用更可靠的 setAPDataStorage", "documentation": "写入共享数据", "name": "setSharedData", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 每个键值对为一个数据项。value 只支持字符串\n- 由于数据是跨 appId 共享的，因此 key 的选择请以`${appId}.${key}`的格式来避免命名冲突\n- 由于数据是跨用户共享的，在用户登出后，并不会清空数据，假如要做用户维度存储，可以把key设置为`${appId}.${userId}.${key}`", "documentation": "要写入的数据", "name": "data", "optional": false, "type": "Record<string,string>" }, { "description": "- 无论是 true 还是 false 都会持久化存储，区别仅在于用的是支付宝自身实现的文件存储还是使用的系统原生持久化存储(系统存储接口容易被误清除)", "documentation": "是否使用支付宝自身实现的文件存储", "name": "writeToFile", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "setShortCut", "description": "- 移除快捷入口请调用 [removeShortCut]()", "documentation": "添加快捷入口到系统桌面", "name": "setShortCut", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "应用 appId", "name": "appId", "optional": false, "type": "string" }, { "documentation": "应用名称", "name": "appName", "optional": false, "type": "string" }, { "description": "支持 base64", "documentation": "图标URL", "name": "iconBitmap", "optional": false, "type": "string" }, { "documentation": "扩展参数", "name": "params", "optional": true, "type": "Record<string,string>" }, { "defaultValue": "NO", "documentation": "是否显示右上角选项", "name": "showOptionMenu", "optional": true, "type": "\"YES\" | \"NO\"" }, { "defaultValue": "false", "documentation": "是否加速启动", "name": "openDirectly", "optional": true, "supportInfo": { "androidMinVersion": 10001010, "iosMinVersion": 10001010 }, "type": "boolean" }, { "defaultValue": "true", "documentation": "是否需要确认弹框", "name": "needConfirmDialog", "optional": true, "type": "boolean" }, { "defaultValue": "false", "description": "优先级高于 needConfirmDialog，如果为 showDetailDialog=true 则 needConfirmDialog=false", "documentation": "是否需要确认弹框", "name": "showDetailDialog", "optional": true, "type": "boolean" }, { "defaultValue": "true", "documentation": "是否需要完成弱提示", "name": "needTipToasts", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "name": "showDetailDialog", "optional": true, "type": "boolean" }, { "name": "needShowToast", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "setSystemVolume", "name": "setSystemVolume", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "setTabBar", "name": "setTabBar", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "actionType", "optional": false, "type": "\"hideTabBar\" | \"showTabBar\"" }, { "defaultValue": "false", "documentation": "是否需要动画效果，默认为无动画效果。", "name": "animation", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "setTAOptionMenu", "name": "setTAOptionMenu", "parameters": { "in": [{ "name": "icon", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setTBSessionInfo", "name": "setTBSessionInfo", "parameters": { "in": [{ "documentation": "会话信息", "name": "sessionInfo", "optional": false, "type": "Record<string,unknown>" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setTinyLocalStorage", "description": "- H5请使用 [setAPDataStorage]()\n- 用户通过应用中心删除应用时，存储的数据会被清除掉。\n- 如果长时间未使用应用，数据也会被清除掉。", "documentation": "设置KV数据，以appId隔离，如果是插件调用，插件的存储也会隔离。单个应用存储上限为10M", "name": "setTinyLocalStorage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "当前存储的值，最大长度200K", "name": "data", "optional": false, "type": "string" }, { "documentation": "如果从上下文中没有获取到appId，则会从参数中取business，当做appId做隔离使用", "name": "business", "optional": true, "type": "string" }, { "documentation": "存储的key", "name": "key", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "是否存储成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "setTitle", "documentation": "设置标题", "name": "setTitle", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "- 默认会设置为 HTML `<title>` 对应标题\n- Android 自 10.0.20 之后才能够设置 \"空title\"，更低版本可以通过设置 '\\u200b' 绕过", "documentation": "主标题文案", "name": "title", "optional": true, "type": "string" }, { "name": "subtitle", "optional": true, "type": "string" }, { "name": "contentDesc", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "setTitlebarVisible", "name": "setTitlebarVisible", "parameters": { "in": [{ "documentation": "", "name": "isVisible", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "number | boolean" }] } }, { "apiName": "setTitleColor", "name": "setTitleColor", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "color", "optional": true, "type": "number" }, { "name": "frontColor", "optional": true, "type": "number" }, { "name": "reset", "optional": true, "type": "boolean" }, { "name": "resetTransParent", "optional": true, "type": "boolean" }, { "name": "resetTransparent", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setTitleSegControl", "name": "setTitleSegControl", "parameters": { "in": [{}], "out": [] } }, { "apiName": "setToolbarMenu", "description": "- 点击事件通过 toolbarMenuClick 返回", "documentation": "自定义分享面板第二栏的工具栏内容", "name": "setToolbarMenu", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "菜单列表", "name": "menus", "optional": false, "type": "object" }, { "description": "- 当 override=false 时，用户自定义菜单个数必须小于5个", "documentation": "是否覆盖容器自带的菜单列表", "name": "override", "optional": true, "type": "boolean" }, { "description": "- 当 reset=true 时，忽略其他参数", "documentation": "是否重置菜单到系统默认", "name": "reset", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "status", "optional": false, "type": "string" }] } }, { "apiName": "setTransparentTitle", "description": "- 由于动态切换可能导致界面闪动，请尽量使用启动参数 transparentTitle 来启用透明导航栏功能\n- [getSystemInfo]() 可通过 transparentTitle 字段获取当前导航栏透明模式\n- 设置后，iOS 可在回调中立即获取到容器高度但不会触发 resize 事件，Android 需要一定延时才能获取高度，resize 事件也会延迟", "name": "setTransparentTitle", "parameters": { "in": [{ "name": "transparentTitle", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setupSocialComment", "name": "setupSocialComment", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "code", "optional": false, "type": "number" }] } }, { "apiName": "setWebViewTop", "name": "setWebViewTop", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "animated", "optional": true, "type": "boolean" }, { "name": "position", "optional": false, "type": "\"top\" | \"bottom\"" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "setWifiList", "description": "iOS特有接口", "documentation": "设置 WifiList 中 AP 的相关信息", "name": "setWifiList", "parameters": { "in": [{ "documentation": "提供预设的 Wifi 信息列表", "name": "wifiList", "optional": false, "type": "object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "shareInner", "name": "shareInner", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "shareTinyAppMsg", "name": "shareTinyAppMsg", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "title", "optional": false, "type": "string" }, { "name": "desc", "optional": true, "type": "string" }, { "name": "searchTip", "optional": true, "type": "string" }, { "name": "content", "optional": true, "type": "string" }, { "name": "imageUrl", "optional": true, "type": "string" }, { "name": "bgImgUrl", "optional": true, "type": "string" }, { "name": "sharePadType", "optional": true, "type": "string" }, { "name": "page", "optional": false, "type": "string" }, { "name": "isShareFission", "optional": true, "type": "string" }, { "name": "extraParams", "optional": true, "type": "Record<string,string>" }, { "name": "scImgUrl", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "channelName", "optional": false, "type": "string" }, { "name": "shareResult", "optional": false, "type": "false" }, { "name": "error", "optional": false, "type": "10" }, { "name": "errorMessage", "optional": false, "type": "\"分享失败或取消\"" }], "type": "Object" }] } }, { "apiName": "shareToChannel", "name": "shareToChannel", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "", "name": "name", "optional": false, "type": "string" }, { "documentation": "", "name": "param", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "channelName", "optional": false, "type": "string" }, { "documentation": "", "name": "shareResult", "optional": false, "type": "boolean" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "shareToken", "description": "- 该接口需要业务服务端对接码平台，请见 [详细玩法参考](http://gitlab.alibaba-inc.com/alipay-mobile-doc/BeeHive-iOS/blob/master/ShareToken.md)\n- 如要分享可使用 easyShare", "documentation": "弹出吱口令分享弹框（新版弹窗不支持）", "name": "shareToken", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "标题", "name": "title", "optional": false, "type": "string" }, { "documentation": "前缀内容", "name": "preContent", "optional": false, "type": "string" }, { "documentation": "口令文本", "name": "token", "optional": false, "type": "string" }, { "documentation": "后缀内容", "name": "endContent", "optional": false, "type": "string" }, { "documentation": "分享渠道", "name": "shareTokenChannel", "optional": true, "type": "string" }, { "name": "channelId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{}] } }, { "apiName": "shouldShowAddComponent", "name": "shouldShowAddComponent", "parameters": { "in": [{ "documentation": "", "name": "appId", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "iconUrl", "optional": true, "type": "string" }, { "documentation": "", "name": "name", "optional": true, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "shouldShowAutoStartOption", "name": "shouldShowAutoStartOption", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "shouldShowPowerSaveModeOption", "name": "shouldShowPowerSaveModeOption", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showAuthenticDialog", "name": "showAuthenticDialog", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "结果码。", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "结果信息。", "name": "resultMsg", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "showAuthGuide", "description": "- 权限引导弹框受 \"疲劳度\" 等因素控制", "documentation": "权限引导", "name": "showAuthGuide", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "引导的权限标识，用于标识该权限类型(如 地理位置信息)。", "name": "authType", "optional": false, "type": "object" }, { "documentation": "找回车申请", "name": "bizType", "optional": false, "type": "string" }, { "name": "source", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "name": "shown", "optional": false, "type": "boolean" }] } }, { "apiName": "showAuthPage", "name": "showAuthPage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "authType", "optional": true, "type": "string" }, { "documentation": "", "name": "bizType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "desc", "optional": true, "type": "string" }, { "documentation": "", "name": "errorcode", "optional": true, "type": "number" }, { "documentation": "", "name": "status", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "showBackButton", "documentation": "显示标题栏的回退按钮", "name": "showBackButton", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showBackHome", "name": "showBackHome", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showBackToHomepage", "name": "showBackToHomepage", "parameters": { "in": [{ "name": "isHomePage", "optional": false, "type": "boolean" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "showBLEPermissionGuide", "documentation": "显示蓝牙授权向导", "name": "showBLEPermissionGuide", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙授权/开关弹窗标题/内容自定义", "name": "config", "optional": false, "type": "object" }, { "name": "bizType", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "蓝牙授权向导接口调用成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误吗", "name": "error", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "showCommunityIdentityDialog", "description": "新用户入驻和老用户补全资料都可以使用，弹窗内支持选择头像、昵称，随机生成头像昵称", "documentation": "社区用户补充资料引导弹窗", "name": "showCommunityIdentityDialog", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "来源渠道", "name": "chInfo", "optional": false, "type": "string" }, { "documentation": "true需要发布协议 ，默认为false不返回发布协议", "name": "needContentAgreement", "optional": false, "type": "boolean" }, { "documentation": "tab3 | tab2", "name": "source", "optional": false, "type": "string" }, { "documentation": "扩展参数", "name": "extInfo", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "是否成功，失败包括报错和用户关闭弹窗。", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showDomain", "name": "showDomain", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showFavoriteTips", "name": "showFavoriteTips", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showFontBar", "name": "showFontBar", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showFuCard", "description": "五福jsapi", "documentation": "展示福卡，关联AlipayNewYearNebulaPlugin.showFuCard", "name": "showFuCard", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showLifeH5Banner", "name": "showLifeH5Banner", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showLoading", "documentation": "显示全屏加载状态浮层", "name": "showLoading", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "如需设为无文案，需传入一个空格", "documentation": "提示中的文字内容", "name": "text", "optional": true, "type": "string" }, { "defaultValue": "0", "description": "如果在此时间之前调用了 [hideLoading]() 则不会显示。", "documentation": "延迟显示，单位为毫秒（ms）", "name": "delay", "optional": true, "type": "number" }, { "defaultValue": "true", "documentation": "是否在页面关闭后自动隐藏动画", "name": "autoHide", "optional": true, "supportInfo": { "androidMinVersion": 10000015 }, "type": "boolean" }, { "defaultValue": "true", "documentation": "动画是否可被返回键消除", "name": "cancelable", "optional": true, "supportInfo": { "androidMinVersion": 10000018 }, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "showMenu", "name": "showMenu", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showModal", "description": "替换原有的alert", "documentation": "显示模态对话框", "name": "showModal", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "title", "optional": false, "type": "string" }, { "documentation": "", "name": "content", "optional": false, "type": "string" }, { "defaultValue": "true", "documentation": "是否显示取消按钮", "name": "showCancel", "optional": false, "type": "boolean" }, { "defaultValue": "取消", "documentation": "取消按钮的文字，最多 4 个字符", "name": "cancelText", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "confirm", "optional": false, "type": "boolean" }, { "documentation": "editable 为 true 时，用户输入的文本\neditable 为 false 时，不返回该字段", "name": "content", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "showOptionMenu", "description": "- 对于支付宝H5离线包，默认不出现；对于在线页面，默认出现\n- 也可以通过启动参数 showOptionMenu=YES 控制显示\n- 对于小程序请使用 [my.setOptionMenu](miniapi:my.setOptionMenu) 接口", "documentation": "显示H5右上角选项按钮", "name": "showOptionMenu", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showPopMenu", "description": "- 右上角为默认三个点的时候不要调用本接口，右上角为自定义图片或者文字的时候可以调用\n- 一般配合 setOptionMenu/showOptionMenu 接口和 optionMenu 事件使用", "documentation": "右上角自定义显示弹出菜单", "name": "showPopMenu", "parameters": { "in": [{ "name": "menus", "optional": false, "type": "object" }], "out": [{}] } }, { "apiName": "showProgressBar_fallback", "name": "showProgressBar_fallback", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showReminder", "description": "新增/修改待办提醒", "documentation": "待办提醒设置", "name": "showReminder", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "appId", "optional": false, "type": "string" }, { "documentation": "修改时传入已设置的待办数据", "name": "data", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showRemoteDebugMask", "name": "showRemoteDebugMask", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "hide", "optional": true, "type": "boolean" }, { "documentation": "", "name": "text", "optional": true, "type": "string" }, { "documentation": "", "name": "buttonTitle", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showRemoteDebugPanel", "name": "showRemoteDebugPanel", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "status", "optional": true, "type": "string" }, { "documentation": "", "name": "text", "optional": true, "type": "string" }, { "documentation": "", "name": "buttonTitle", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "showTAOptionMenu", "name": "showTAOptionMenu", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "showTitleLoading", "name": "showTitleLoading", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "showUCFailDialog", "description": "- 可以通过 userAgent 判断是否为 UC内核 `navigator.userAgent.indexOf(\"UCBS\") >= 0`", "documentation": "UC初始化异常提醒框", "name": "showUCFailDialog", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "signContract", "name": "signContract", "parameters": { "in": [{ "documentation": "auth url跳转链接", "name": "signStr", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "skipKeepAlive", "documentation": "对当前应用实例关闭保活功能", "name": "skipKeepAlive", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "smartWearSendMsg", "name": "smartWearSendMsg", "parameters": { "in": [{ "documentation": "", "name": "action", "optional": true, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "binded", "optional": false, "type": "boolean" }, { "documentation": "", "name": "notice", "optional": true, "type": "string" }, { "documentation": "", "name": "showTxt", "optional": false, "type": "string" }, { "documentation": "", "name": "pwdType", "optional": false, "type": "string" }, { "documentation": "", "name": "bicNoPwd", "optional": false, "type": "object" }, { "documentation": "", "name": "notice_url", "optional": true, "type": "string" }, { "documentation": "", "name": "displayNoPwd", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "smEncrypt", "description": "目前只支持加密功能\n安全level：high", "documentation": "对输入的数据，使用信封形式进行加解密，由安全SDK保证密钥生成过程的安全性。", "name": "smEncrypt", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "加密公钥", "name": "key", "optional": false, "type": "string" }, { "documentation": "需要加密的文件路径", "name": "filePath", "optional": false, "type": "string" }, { "documentation": "公钥名称", "name": "keyName", "optional": false, "type": "string" }, { "documentation": "公钥版本", "name": "keyVersion", "optional": false, "type": "number" }, { "documentation": "密钥加密算法", "name": "algorithm", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "加密后的文件路径", "name": "filePath", "optional": false, "type": "string" }] } }, { "apiName": "spsafepay.paywithbizreqdata", "name": "spsafepay.paywithbizreqdata", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "biz_type", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "biz_sub_type", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "biz_identity", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "biz_reqdata", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "status", "optional": false, "type": "number" }, { "description": "", "documentation": "", "name": "result", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "memo", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "extendInfo", "optional": true, "type": "object" }, { "description": "", "documentation": "", "name": "callbackurl", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "progress", "optional": true, "type": "number" }, { "description": "", "documentation": "", "name": "callBackUrl", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startApp", "description": "appId与schema只需要二选一即可", "documentation": "跳转到指定微应用", "name": "startApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "指定钱包内应用ID", "name": "appId", "optional": false, "type": "string" }, { "documentation": "客户端应用启动参数(startParam), 由具体业务应用定义", "name": "param", "optional": true, "type": "Record<string,string>" }, { "documentation": "跳转成功后重启当前小程序", "name": "restartCurrentApp", "optional": true, "type": "boolean" }, { "description": "1. presentWithAnimation\n2. noAnimation", "documentation": "跳转过渡动画", "name": "startAnimation", "optional": true, "type": "string" }, { "documentation": "跳转成功后，关闭当前小程序Page", "name": "closeSelfWindow", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，关闭当前小程序", "name": "closeCurrentApp", "optional": true, "type": "boolean" }, { "documentation": "跳转成功后，传递给下个应用的场景参数(sceneParam)", "name": "bizInnerSource", "optional": true, "type": "string" }, { "documentation": "指定钱包内部跳转schema", "name": "scheme", "optional": false, "type": "string" }, { "deprecated": "当前字段已不再生效", "description": "exitSelf", "documentation": "跳转成功后，如果closeCurrentApp为true，则可以另外指定关闭类型", "name": "closeActionType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "跳转成功", "name": "success", "optional": true, "type": "boolean" }] } }, { "apiName": "startAudioRecord", "documentation": "录制语音", "name": "startAudioRecord", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "最大录制时长，单位秒。", "name": "maxRecordTime", "optional": true, "type": "number" }, { "documentation": "最小录制时长，单位秒。", "name": "minRecordTime", "optional": true, "type": "number" }, { "documentation": "业务标识", "name": "business", "optional": true, "type": "string" }, { "defaultValue": "60000", "documentation": "最大录制时长，优先于 maxRecordTime, 单位毫秒", "name": "duration", "optional": true, "type": "number" }, { "documentation": "", "name": "detectDecibel", "optional": true, "type": "boolean" }, { "documentation": "采样率", "name": "sampleRate", "optional": true, "type": "number" }, { "documentation": "码率", "name": "encodeBitRate", "optional": true, "type": "number" }, { "documentation": "声道", "name": "numberOfChannels", "optional": true, "type": "object" }, { "name": "audioSource", "optional": false, "type": "unknown" }, { "defaultValue": "silk", "documentation": "编码格式", "name": "format", "optional": true, "type": "object" }, { "name": "frameSize", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "录音文件路径。", "name": "tempFilePath", "optional": false, "type": "string" }, { "documentation": "录音文件路径。", "name": "identifier", "optional": false, "type": "string" }, { "documentation": "录音时间长度，单位秒。", "name": "duration", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "startBeaconDiscovery", "name": "startBeaconDiscovery", "parameters": { "in": [{ "documentation": "目标 iBeacon 设备广播的 UUIDs。\nuuids[0]、uuids[1] 为目标 iBeacon 的 UUID，可从硬件厂商获取，如果为空，无法搜索到 iBeacon。\niBeacon 需要位置权限。iOS 11 及以后版本的手机，通过手机控制中心的快捷开关打开蓝牙，无法使用 iBeacon，需要在 设置 > 蓝牙 中开启蓝牙，方可使用。", "name": "uuids", "optional": false, "type": "string[]" }], "out": [{}] } }, { "apiName": "startBizService", "name": "startBizService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "name", "optional": false, "type": "string" }, { "name": "param", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "name": "property", "optional": false, "type": "unknown" }] } }, { "apiName": "startBLEAdvertising", "documentation": "开启低功耗蓝牙广播", "name": "startBLEAdvertising", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "服务Id。", "name": "serviceId", "optional": true, "type": "string" }, { "defaultValue": "true", "documentation": "是否广播设备名称。", "name": "includeDeviceName", "optional": true, "type": "boolean" }, { "defaultValue": "false", "documentation": "是否广播 serviceId。", "name": "advertiseServiceId", "optional": true, "type": "boolean" }, { "documentation": "厂商id。", "name": "manufacturerId", "optional": true, "type": "number" }, { "documentation": "厂商信息。", "name": "manufacturerData", "optional": true, "type": "string" }, { "documentation": "广播强度。", "name": "powerLevel", "optional": true, "type": "string" }, { "documentation": "是否可连接。", "name": "connectable", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "startBluetoothDevicesDiscovery", "description": "搜索结果将以onBluetoothDeviceFound 事件的形式返回", "documentation": "开始搜寻附近的蓝牙外围设备。", "name": "startBluetoothDevicesDiscovery", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "includeClassic", "optional": true, "type": "boolean" }, { "documentation": "设备id", "name": "deviceIds", "optional": true, "type": "string[]" }, { "documentation": "设备名", "name": "deviceNames", "optional": true, "type": "string[]" }, { "documentation": "是否允许重复上报同一设备， 如果允许重复上报，则onBluetoothDeviceFound 方法会多次上报同一设备，但是 RSSI 值会有不同。", "name": "allowDuplicatesKey", "optional": true, "supportInfo": { "androidMinVersion": 10000020, "iosMinVersion": 10000020 }, "type": "boolean" }, { "documentation": "上报设备的间隔，默认为0，意思是找到新设备立即上报，否则根据传入的间隔上报。", "name": "interval", "optional": true, "supportInfo": { "androidMinVersion": 10000020, "iosMinVersion": 10000020 }, "type": "number" }, { "documentation": "蓝牙设备主 service 的 uuid 列表。", "name": "services", "optional": false, "type": "string[]" }], "type": "Object" }], "out": [{}] } }, { "apiName": "startContinuousLocation", "name": "startContinuousLocation", "parameters": { "in": [{ "documentation": "业务方标识，要求能够唯一标识使用方的字符串。", "name": "bizType", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startDeviceMotionListening", "documentation": "开始监听设备方向", "name": "startDeviceMotionListening", "parameters": { "in": [{ "documentation": "回调时间隔时间", "name": "interval", "optional": false, "type": "enum" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "成功开启监听", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "具体错误信息", "name": "error", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "startDeviceShakeListener", "name": "startDeviceShakeListener", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "startHCE", "name": "startHCE", "parameters": { "in": [{ "documentation": "需要注册到系统的 AID 列表。", "name": "aid_list", "optional": false, "type": "string[]" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "错误信息。\n有效值：\n- `0` 代表 **调用成功**。\n- `13000` 代表 当前设备不支持 NFC。\n- `13001` 代表 当前设备支持 NFC，但系统NFC开关未开启。\n- `13002` 代表 当前设备支持 NFC，但不支持HCE。\n- `13003` 代表 AID 列表参数格式错误。\n- `13004` 代表 未设置支付宝为默认NFC支付应用。\n- `13005` 代表 返回的指令不合法。\n- `13006` 代表 注册 AID 失败。\n- `13007` 请先调用 `getHCEState`。", "name": "errMsg", "optional": false, "type": "number" }, { "documentation": "错误码。", "name": "errCode", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "startIfaaAuthentication", "description": "开始IFAA生物认证", "documentation": "开始IFAA生物认证", "name": "startIfaaAuthentication", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "requestAuthModes", "optional": false, "type": "string[]" }, { "documentation": "", "name": "challenge", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "code", "optional": false, "type": "string" }, { "documentation": "", "name": "message", "optional": true, "type": "string" }, { "documentation": "", "name": "srcCode", "optional": true, "type": "string" }, { "documentation": "", "name": "token", "optional": true, "type": "string" }, { "documentation": "", "name": "verifyCode", "optional": true, "type": "string" }, { "documentation": "", "name": "verifyId", "optional": true, "type": "string" }, { "documentation": "", "name": "nextIsCasherPament2", "optional": true, "type": "boolean" }, { "documentation": "", "name": "subCode", "optional": true, "type": "string" }, { "documentation": "", "name": "bizResponseData", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "startLocalServiceDiscovery", "name": "startLocalServiceDiscovery", "parameters": { "in": [{ "name": "serviceType", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startMarketApp", "documentation": "应用市场页点击跳转", "name": "startMarketApp", "parameters": { "in": [{}], "out": [] } }, { "apiName": "startMiniService", "name": "startMiniService", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "serviceId", "optional": false, "type": "string" }, { "name": "servicePage", "optional": false, "type": "string" }, { "name": "parentAppId", "optional": false, "type": "string" }, { "name": "sourceId", "optional": false, "type": "string" }, { "name": "params", "optional": false, "type": "object" }], "type": "Object" }], "out": [{}] } }, { "apiName": "startMonitorBackgroundAudio", "description": "- 当且仅当该接口调用后，开始发送 getBackgroundAudioPlayedStateInfo 事件", "documentation": "开始监听背景音频播放事件", "name": "startMonitorBackgroundAudio", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "startMonitorForegroundAudio", "name": "startMonitorForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "startMonitorIotNotify", "name": "startMonitorIotNotify", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "startMonitorIotRawMessage", "name": "startMonitorIotRawMessage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "startMonitorLowPowerWarning", "name": "startMonitorLowPowerWarning", "parameters": { "in": [{ "name": "interval", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "startMonitorMemoryWarning", "description": "开启后，可以监听 [memoryWarning](nativeevent:memoryWarning) 事件获取内存变化，如需停止监听，可以调用 [stopMonitorMemoryWarning]()", "documentation": "开启客户端内存水位监听", "name": "startMonitorMemoryWarning", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startNewContinuousLocation", "name": "startNewContinuousLocation", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务方标识，要求能够唯一标识使用方的字符串。", "name": "bizType", "optional": false, "type": "string" }, { "defaultValue": "false", "documentation": "是否需要速度。", "name": "isNeedSpeed", "optional": true, "type": "boolean" }, { "defaultValue": "2000", "documentation": "持续回调间隔时间(毫秒)。", "name": "callbackInterval", "optional": true, "type": "number" }, { "defaultValue": "0", "documentation": "定位模式", "name": "locationMode", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startNFCDiscovery", "name": "startNFCDiscovery", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "startPermissionPage", "name": "startPermissionPage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "startPlayAudio", "name": "startPlayAudio", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "音频文件路径，只能来源自 `startRecord` 的录音文件路径。", "name": "identifier", "optional": false, "type": "string" }, { "name": "business", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "name": "error", "optional": false, "type": "0" }] } }, { "apiName": "startPullDownRefresh", "name": "startPullDownRefresh", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startScanAPDevice", "name": "startScanAPDevice", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "object" }] } }, { "apiName": "startScreenRecording", "description": "调用jsapi，开启录屏组件，支持端外录屏，暂不支持将视频保存在本地相册\n1. iOS 仅支持 12.0 及以上的系统。\n2. 在iOS系统调用JSAPI，如果系统版本支持就会直接返回success，具体录屏功能是否开启成功，需要通过监听事件：screenRecordingDidStart 来判断\n3. 会通过事件：screenRecordingDataChanged，将录屏的视频流通过图片base64的方式回传给前端 {\"data\":base64}\n4. 如果当前录屏功能停止，会通过事件：screenRecordingDidFinished 进行通知广播", "documentation": "统一录屏组件", "name": "startScreenRecording", "parameters": { "in": [{ "documentation": "仅支持在H5场景下传递，申请需要联系api维护者进行白名单配置", "name": "bizType", "optional": true, "type": "string" }], "out": [{ "documentation": "在iOS系统中，如果系统版本支持，则会直接返回success，具体是否开启成功需要根据事件来判断", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "startShare", "name": "startShare", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizType", "optional": true, "type": "string" }, { "documentation": "", "name": "onlySelectChannel", "optional": true, "type": "string[]" }, { "documentation": "", "name": "sendEvent", "optional": true, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "bizType", "optional": true, "type": "string" }, { "documentation": "", "name": "channelName", "optional": true, "type": "string" }, { "documentation": "", "name": "shareResult", "optional": true, "type": "boolean" }, { "documentation": "", "name": "result", "optional": true, "type": "string" }, { "documentation": "", "name": "message", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "startSpeech", "name": "startSpeech", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "speechRecognizeBizId", "optional": true, "type": "string" }, { "defaultValue": "99", "name": "speechRecognizeType", "optional": true, "type": "number" }, { "name": "inputAudioFormat", "optional": true, "type": "number" }, { "name": "encodeAudio", "optional": true, "type": "boolean" }, { "name": "iOSKey", "optional": true, "type": "string" }, { "name": "extraInfo", "optional": true, "type": "object" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startSportDetect", "description": "开启运动", "documentation": "开启运动", "name": "startSportDetect", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "一次运动的任务标识，start以后，pause/resume/stop 必须传入同一个标识才会有效", "name": "identifier", "optional": false, "type": "string" }, { "documentation": "运动种类，running/cycling/walking", "name": "type", "optional": false, "type": "string" }, { "defaultValue": "60", "documentation": "用户停止运动，开始休息后多长时间会自动停止运动记录", "name": "autoStopDuration", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": true, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "startWifi", "name": "startWifi", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "startXMediaCoreBiz", "name": "startXMediaCoreBiz", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "bizId", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "bizType", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "options", "optional": false, "type": "object" }, { "description": "", "documentation": "", "name": "modelId", "optional": true, "type": "string" }, { "description": "", "documentation": "", "name": "md5", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "result", "optional": true }, { "description": "", "documentation": "", "name": "processId", "optional": false, "type": "string" }, { "description": "", "documentation": "", "name": "extraData", "optional": true, "type": "object" }, { "description": "[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]", "documentation": "", "name": "errorMessage", "optional": true, "type": "string" }, { "description": "[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]", "documentation": "", "name": "image", "optional": true, "type": "string" }, { "description": "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]", "documentation": "", "name": "error", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "stopAudioPlay", "name": "stopAudioPlay", "parameters": { "in": [{}], "out": [{ "name": "error", "optional": false, "type": "0" }] } }, { "apiName": "stopAudioRecord", "name": "stopAudioRecord", "parameters": { "in": [{}], "out": [{ "name": "error", "optional": false, "type": "0" }] } }, { "apiName": "stopBackgroundAudio", "name": "stopBackgroundAudio", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "stopBeaconDiscovery", "name": "stopBeaconDiscovery", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopBLEAdvertising", "name": "stopBLEAdvertising", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopBluetoothDevicesDiscovery", "documentation": "停止蓝牙扫描", "name": "stopBluetoothDevicesDiscovery", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "stopContinuousLocation", "name": "stopContinuousLocation", "parameters": { "in": [{ "documentation": "业务方标识，要求能够唯一标识使用方的字符串。需要和 `startContinuousLocation` 时的保持一致。", "name": "bizType", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "stopDeviceMotionListening", "documentation": "停止设备方向的监听", "name": "stopDeviceMotionListening", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "调用成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "stopDeviceShakeListener", "name": "stopDeviceShakeListener", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "stopForegroundAudio", "name": "stopForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "stopHCE", "name": "stopHCE", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopIndoorLocation", "name": "stopIndoorLocation", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopLocalServiceDiscovery", "name": "stopLocalServiceDiscovery", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "stopMediaCreatorTaskMonitor", "name": "stopMediaCreatorTaskMonitor", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "stopMonitorBackgroundAudio", "description": "- 停止发送 getBackgroundAudioPlayedStateInfo 事件", "documentation": "停止监听背景音频播放事件", "name": "stopMonitorBackgroundAudio", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopMonitorForegroundAudio", "name": "stopMonitorForegroundAudio", "parameters": { "in": [{ "name": "audioPlayerID", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "true" }, { "name": "audioPlayerID", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "stopMonitorIotNotify", "name": "stopMonitorIotNotify", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopMonitorIotRawMessage", "name": "stopMonitorIotRawMessage", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopMonitorMemoryWarning", "description": "关闭后，无法再收到 [memoryWarning](nativeevent:memoryWarning) 事件", "documentation": "关闭客户端内存监听与事件监听", "name": "stopMonitorMemoryWarning", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "stopNewContinuousLocation", "name": "stopNewContinuousLocation", "parameters": { "in": [{ "documentation": "业务方标识，要求能够唯一标识使用方的字符串。需要和 `startContinuousLocation` 时的保持一致。", "name": "bizType", "optional": false, "type": "string" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "stopNFCDiscovery", "name": "stopNFCDiscovery", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "stopScreenRecording", "description": "1. iOS 仅支持 12.0 及以上的系统。", "documentation": "停止统一录屏组件", "name": "stopScreenRecording", "parameters": { "in": [{}], "out": [] } }, { "apiName": "stopSpeech", "name": "stopSpeech", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "\"true\" | true" }] } }, { "apiName": "stopSportDetect", "description": "停止运动检测", "documentation": "停止运动检测", "name": "stopSportDetect", "parameters": { "in": [{ "documentation": "任务标识，如果任务标识不匹配会调用失败", "name": "identifier", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "number" }, { "documentation": "错误原因", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "stopWifi", "documentation": "关闭 Wi-Fi 模块。", "name": "stopWifi", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "stopXMediaCoreBiz", "name": "stopXMediaCoreBiz", "parameters": { "in": [{ "documentation": "", "name": "processId", "optional": false, "type": "string" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "result", "optional": true }, { "description": "", "documentation": "", "name": "processId", "optional": false, "type": "string" }, { "description": "[{},{},{},{},{},{},{},{},{},{},{},{},{},{}]", "documentation": "", "name": "extraData", "optional": true, "type": "object" }, { "description": "[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]", "documentation": "", "name": "errorMessage", "optional": true, "type": "string" }, { "description": "[\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\"]", "documentation": "", "name": "image", "optional": true, "type": "string" }, { "description": "[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]", "documentation": "", "name": "error", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "subscribeMsgbox", "documentation": "订阅服务提醒", "name": "subscribeMsgbox", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "服务码", "name": "serviceCode", "optional": false, "type": "string" }, { "description": "- true：弹订阅框前不显示loading，且失败时不弹toast\n- false（默认值）：弹订阅框前显示loading且失败时候弹toast", "documentation": "是否显示 loading、toast", "name": "silent", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "订阅结果", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "subscribeNearbyMessage", "description": "订阅成功时，会收到：nearbyMessageFound、nearbyMessageLost、nearbyMessageDistanceChanged、nearbyMessageStateChanged事件。", "documentation": "订阅Nearby消息", "name": "subscribeNearbyMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "信息发送类型", "name": "namespaces", "optional": false, "type": "string[]" }, { "documentation": "标记一个业务", "name": "appKey", "optional": false, "type": "string" }, { "defaultValue": "iBeacon", "documentation": "消息广播类型", "name": "type", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "switchTab", "name": "switchTab", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "tag", "optional": false, "type": "string" }, { "name": "recreate", "optional": false, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "syncH5GlobalBlackList", "name": "syncH5GlobalBlackList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "syncUserSportData", "documentation": "同步当前的用户运动健康步数", "name": "syncUserSportData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "Tab3Dynamic", "name": "Tab3Dynamic", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "taobaoAuthorizationLogin", "name": "taobaoAuthorizationLogin", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "testNewApiAdd", "description": "新增测试minidev下发数据", "documentation": "新增测试minidev下发数据", "name": "testNewApiAdd", "parameters": { "in": [{ "name": "new0", "optional": false, "type": "unknown" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "textRiskIdentification", "documentation": "对用户产生的原创内容（UGC）进行风险识别", "name": "textRiskIdentification", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要进行风险识别的文本内容。", "name": "content", "optional": false, "type": "string" }, { "documentation": "识别类型。", "name": "type", "optional": false, "type": "enum" }], "type": "Object" }], "out": [{ "name": "result", "optional": false, "type": "object" }] } }, { "apiName": "textToSpeech", "documentation": "语音合成", "name": "textToSpeech", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "100", "documentation": "音量", "name": "volume", "optional": true, "type": "number" }, { "defaultValue": "0", "documentation": "语速", "name": "speed", "optional": true, "type": "number" }, { "defaultValue": "0", "documentation": "语调", "name": "tone", "optional": true, "type": "number" }, { "documentation": "发声人", "name": "speaker", "optional": false, "type": "number" }, { "documentation": "待合成文本", "name": "text", "optional": false, "type": "string" }, { "name": "align", "optional": true, "supportInfo": { "androidMinVersion": 10002006, "iosMinVersion": 10002006 }, "type": "boolean" }], "type": "Object" }], "out": [{}] } }, { "apiName": "tinyAppConfig", "name": "tinyAppConfig", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "key", "optional": true, "type": "string" }, { "documentation": "", "name": "scopeType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "", "name": "value", "optional": false, "type": "string" }] } }, { "apiName": "tinyDebugConsole", "name": "tinyDebugConsole", "parameters": { "in": [{}], "out": [] } }, { "apiName": "tinyRpc", "description": "只能发送枚举中列出的rpc", "documentation": "发送特定Rpc", "name": "tinyRpc", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "业务类型名称", "name": "type", "optional": false, "type": "enum" }, { "documentation": "RPC 请求的参数", "name": "requestData", "optional": false, "type": "unknown[]" }, { "documentation": "RPC 请求设置的 headers", "name": "headers", "optional": false, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "documentation": "返回数据", "name": "property", "optional": false, "type": "unknown" }] } }, { "apiName": "toast", "description": "- toast虽然会自动关闭，但是也可以通过 hideLoading 来关闭，这种使用方式不常见，但是要防止被 hideLoading 关闭。\n- 安卓需要注意，如果系统通知关闭，则此弹框不会出现", "documentation": "显示一个弱提示，可选择多少秒之后消失", "name": "toast", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "文字内容", "name": "content", "optional": true, "type": "string" }, { "defaultValue": "none", "documentation": "提示类型", "name": "type", "optional": true, "type": "\"none\" | \"success\" | \"fail\" | \"exception\" | \"loading\"" }, { "defaultValue": "3000", "description": "- 安卓10.1.2以下版本中，duration 显示时长实际只支持 2000/3500 两种，小于或等于2000的相当于2000, 大于2000的相当于3500", "documentation": "显示时长，单位为 ms", "name": "duration", "optional": true, "type": "number" }, { "documentation": "延时弹出提示，单位为 ms", "name": "delay", "optional": true, "type": "number" }, { "documentation": "弱提示弹出时的 X 轴偏移", "name": "xOffset", "optional": true, "supportInfo": { "androidMinVersion": 10000015, "iosMinVersion": 10000015 }, "type": "number" }, { "documentation": "弱提示弹出时的 Y 轴偏移", "name": "yOffset", "optional": true, "supportInfo": { "androidMinVersion": 10000015, "iosMinVersion": 10000015 }, "type": "number" }], "type": "Object" }], "out": [{}] } }, { "apiName": "toggleDebugPanel", "name": "toggleDebugPanel", "parameters": { "in": [{}], "out": [] } }, { "apiName": "toggleSoftInput", "name": "toggleSoftInput", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "trackerConfig", "name": "trackerConfig", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "requestType", "optional": false, "type": "string" }, { "documentation": "", "name": "params", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "appId", "optional": false, "type": "string" }, { "documentation": "", "name": "newFlag", "optional": true, "type": "boolean" }, { "documentation": "", "name": "config", "optional": true, "type": "object" }, { "documentation": "", "name": "configVersion", "optional": true, "type": "string" }, { "documentation": "", "name": "env", "optional": true, "type": "string" }, { "documentation": "", "name": "enable", "optional": true, "type": "boolean" }, { "documentation": "", "name": "success", "optional": true, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "tradePay", "documentation": "唤起收银台支付", "name": "tradePay", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "交易号，多个交易号请用英文分号;分隔", "name": "tradeNO", "optional": true, "type": "string" }, { "documentation": "商户ID", "name": "partnerID", "optional": true, "type": "string" }, { "defaultValue": "trade", "documentation": "交易类型", "name": "bizType", "optional": true, "type": "string" }, { "documentation": "交易子类型", "name": "bizSubType", "optional": true, "type": "string" }, { "documentation": "支付额外的参数，格式为JSON字符串", "name": "bizContext", "optional": true, "type": "string" }, { "documentation": "完整的支付参数拼接成的字符串，从服务端获取。", "name": "orderStr", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "resultCode", "optional": false, "type": "enum" }] } }, { "apiName": "tradePayCrossApp", "name": "tradePayCrossApp", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "支付Url", "name": "paymentUrl", "optional": true, "type": "string" }, { "documentation": "支付单号", "name": "tradeNO", "optional": true, "type": "string" }, { "documentation": "订单信息字符串", "name": "orderStr", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "支付结果状态码", "name": "resultCode", "optional": false, "type": "number" }] } }, { "apiName": "transceiveNFC", "documentation": "发送NFC数据", "name": "transceiveNFC", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "Tag 对应的实例 id", "name": "instanceId", "optional": false, "type": "string" }, { "documentation": "需要传递的二进制数据", "name": "data", "optional": false, "type": "ArrayBuffer" }], "type": "Object" }], "out": [{ "documentation": "芯片返回数据", "name": "data", "optional": false, "type": "ArrayBuffer" }] } }, { "apiName": "tryMap3D", "name": "tryMap3D", "parameters": { "in": [{ "documentation": "", "name": "force", "optional": true, "type": "boolean" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "code", "optional": false, "type": "number" }, { "documentation": "", "name": "is3d", "optional": false, "type": "boolean" }, { "documentation": "", "name": "isSupportAnim", "optional": false, "type": "boolean" }, { "documentation": "", "name": "isSupportOversea", "optional": false, "type": "boolean" }, { "documentation": "", "name": "message", "optional": false, "type": "string" }, { "documentation": "", "name": "needStyleV7", "optional": false, "type": "boolean" }, { "documentation": "", "name": "progress", "optional": false, "type": "number" }, { "documentation": "", "name": "sdkName", "optional": false, "type": "string" }, { "documentation": "", "name": "sdkVersion", "optional": false, "type": "string" }, { "documentation": "", "name": "success", "optional": false, "type": "boolean" }], "type": "Object" }] } }, { "apiName": "tyroRequest", "description": "小程序真机调试专用", "documentation": "发起 HTTP 请求", "name": "tyroRequest", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "method", "optional": false, "type": "string" }, { "documentation": "", "name": "url", "optional": false, "type": "string" }, { "documentation": "", "name": "headers", "optional": false, "type": "Record<string, string>" }, { "documentation": "", "name": "requestTaskId", "optional": false, "type": "number" }, { "documentation": "", "name": "timeout", "optional": false, "type": "number" }, { "documentation": "", "name": "blockTimeout", "optional": true, "type": "number" }, { "documentation": "", "name": "data", "optional": true, "type": "string" }, { "documentation": "", "name": "dataType", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "status", "optional": false, "type": "number" }, { "documentation": "", "name": "headers", "optional": false, "type": "Record<string, string>" }, { "documentation": "", "name": "data", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "ucdpFeedback", "name": "ucdpFeedback", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "spaceCode", "optional": false, "type": "string" }, { "documentation": "", "name": "objectId", "optional": false, "type": "string" }, { "documentation": "", "name": "behavior", "optional": false, "type": "string" }], "type": "Object" }], "out": [] } }, { "apiName": "unpublishNearbyMessage", "documentation": "停止发布近场信息", "name": "unpublishNearbyMessage", "parameters": { "in": [{ "documentation": "", "name": "appKey", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "unregisterBLEScanner", "description": "该接口在10.2.58后废弃", "documentation": "停止数字钥匙后台扫描功能", "name": "unregisterBLEScanner", "parameters": { "in": [{ "documentation": "需要停止扫描的服务id", "name": "serviceIds", "optional": false, "type": "string[]" }], "out": [] } }, { "apiName": "unRegisterSnapshotConfig", "description": "取消注册截屏组件服务，pageId必传", "documentation": "取消注册截屏组件服务", "name": "unRegisterSnapshotConfig", "parameters": { "in": [{ "documentation": "页面的ID值", "name": "pageId", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "unregisterSSID", "documentation": "不再信任该 SSID，对于需要 Portal 认证的 Wifi，继续弹出 portal 认证页面。", "name": "unregisterSSID", "parameters": { "in": [{ "documentation": "Wifi 设备 SSID。", "name": "SSID", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "unregisterSync", "description": "- 该接口需要配合 Sync 服务使用", "documentation": "取消 Sync 消息监听", "name": "unregisterSync", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "需要取消监听的 Sync 业务码", "name": "bizType", "optional": false, "type": "string" }, { "defaultValue": "CN", "documentation": "地区", "name": "region", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "unsubscribeNearbyMessage", "documentation": "停止监听近场信息", "name": "unsubscribeNearbyMessage", "parameters": { "in": [{ "documentation": "", "name": "appKey", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "updateAddToHomeComponentFatigue", "description": "appId 从上下文获取", "documentation": "更新component疲劳度，小程序和h5均会调用", "name": "updateAddToHomeComponentFatigue", "parameters": { "in": [{ "documentation": "1：更新曝光疲劳度\n2：更新点击疲劳度", "name": "type", "optional": false, "type": "number" }], "out": [{ "documentation": "true: 更新成功false: 更新失败", "name": "success", "optional": false, "type": "unknown" }] } }, { "apiName": "updateAddToHomeTipsFatigue", "description": "小程序会调用", "documentation": "更新tips组件疲劳度", "name": "updateAddToHomeTipsFatigue", "parameters": { "in": [{ "documentation": "更新疲劳度类型，1是曝光，2是点击", "name": "type", "optional": false, "type": "number" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "是否成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码，success为false时有值", "name": "error", "optional": true, "type": "number" }, { "documentation": "错误码对应的描述文案，success为false时有值", "name": "errorMessage", "optional": true, "type": "number" }], "type": "Object" }] } }, { "apiName": "updateAlipayClient", "name": "updateAlipayClient", "parameters": { "in": [{}], "out": [{ "documentation": "代表是否跳转成功", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "updateBizPermission", "documentation": "权限堡垒，业务授权状态修改，批量修改", "name": "updateBizPermission", "parameters": { "in": [{ "documentation": "要更新的权限信息列表", "name": "bizPermissionRequestInfoList", "optional": false, "type": "string" }], "out": [{ "documentation": "更新是否成功", "name": "success", "optional": false, "type": "boolean" }] } }, { "apiName": "updateCharacteristic", "description": "如果 properties 有 notify 就自动 notifyCharacteristic", "documentation": "更新一个蓝牙外设特征值", "name": "updateCharacteristic", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "服务 id。", "name": "serviceId", "optional": false, "type": "string" }, { "documentation": "特征值 id。", "name": "characteristicId", "optional": false, "type": "string" }, { "documentation": "读写参数。", "name": "value", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "调用成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "错误码", "name": "error", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "updateHomeAppRank", "documentation": "上报首页应用排序", "name": "updateHomeAppRank", "parameters": { "in": [{}], "out": [] } }, { "apiName": "updateLocalUserInfo", "name": "updateLocalUserInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "updateMetaData", "name": "updateMetaData", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "updateMyTabList", "name": "updateMyTabList", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "updateOptionMenu", "name": "updateOptionMenu", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "updateUserAvatar", "description": "对于一方 H5 业务，可直接调用\n对于小程序业务，需要申请权限（离线包挂载该 JSAPI）", "documentation": "上传头像 JSAPI", "name": "updateUserAvatar", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "客户端会校验该字段值的合法性，为空则直接返回错误码 -1", "exampleValue": "xxxxxxxxxxxxx", "name": "avatarData", "optional": true, "type": "string" }, { "documentation": "调用来源字符串标识，可自定义，打印日志及埋点用，标识谁调用上传头像接口", "exampleValue": "MemberCenter", "name": "from", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "结果码", "exampleValue": "1000", "name": "resultCode", "optional": true, "type": "string" }, { "documentation": "结果信息", "exampleValue": "上传成功", "name": "resultMemo", "optional": true, "type": "string" }, { "documentation": "上传成功，该字段对应值为最新头像的 url 地址；上传失败，该字段为空", "exampleValue": "https://xxxxxx\"\t上传成功，该字段对应值为最新头像的 url 地址；上传失败，该字段为空", "name": "avatarUrl", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "uploadFile", "documentation": "上传文件到指定服务器", "name": "uploadFile", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "uploadTaskId", "optional": false, "type": "number" }, { "documentation": "开发者服务器地址。", "name": "url", "optional": false, "type": "string" }, { "documentation": "文件名，即对应的 key，开发者在服务器端通过这个 key 可以获取到文件二进制内容。", "name": "name", "optional": false, "type": "string" }, { "documentation": "文件类型支持图片、视频、音频（image / video / audio）。", "name": "type", "optional": false, "type": "string" }, { "name": "localId", "optional": true, "type": "string" }, { "defaultValue": "false", "documentation": "是否隐藏 loading 图。", "name": "hideLoading", "optional": true, "type": "boolean" }, { "documentation": "HTTP 请求 Header。", "name": "header", "optional": true, "supportInfo": { "androidMinVersion": 10001000, "iosMinVersion": 10001000 }, "type": "Record<string,unknown>" }, { "documentation": "HTTP 请求中其他额外的 form 数据。", "name": "formData", "optional": true, "type": "Record<string,unknown>" }, { "defaultValue": "normal", "documentation": "大文件上传，stream代表大文件上传，默认normal", "name": "transmitType", "optional": false, "supportInfo": { "androidMinVersion": 10002070, "iosMinVersion": 10002070 }, "type": "string" }, { "defaultValue": "6000", "documentation": "上传文件超时时间，默认60秒", "name": "timeout", "optional": false, "supportInfo": { "androidMinVersion": 10002070, "iosMinVersion": 10002070 }, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "服务器返回的数据。", "name": "data", "optional": false, "supportInfo": { "androidMinVersion": 10000000, "iosMinVersion": 10000000 }, "type": "string" }, { "documentation": "HTTP 状态码。", "name": "statusCode", "optional": false, "supportInfo": { "androidMinVersion": 10000000, "iosMinVersion": 10000000 }, "type": "string" }, { "documentation": "服务器返回的 Header。", "name": "header", "optional": false, "supportInfo": { "androidMinVersion": 10000000, "iosMinVersion": 10000000 }, "type": "Record<string,unknown>" }], "type": "Object" }] } }, { "apiName": "uploadFileToAliCloud", "documentation": "上传文件至蚂蚁自建AFTS", "name": "uploadFileToAliCloud", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "文件地址。", "name": "filePath", "optional": false, "type": "string" }, { "documentation": "业务标识。", "name": "bizType", "optional": false, "type": "string" }, { "documentation": "文件类型。", "name": "fileType", "optional": false, "type": "string" }, { "documentation": "请求头。", "name": "headers", "optional": true, "type": "Record<string,unknown>" }, { "documentation": "失败是否要重试。", "name": "needRetry", "optional": true, "type": "boolean" }, { "documentation": "是否是私域资源。\n- true 为私域资源。\n- false 为公域资源，私域资源返回的 fileUrl 默认有效期为一天。", "name": "isPrivate", "optional": false, "type": "boolean" }, { "defaultValue": "false", "documentation": "是否需要隐藏 loading 视图。", "name": "hideLoading", "optional": true, "type": "boolean" }, { "documentation": "上传成功之后是否要删除。", "name": "needDelete", "optional": true, "type": "boolean" }, { "documentation": "跨小程序和 h5 的统一存储 biz，通过 createSharedBiz 进行创建。", "name": "sharedBiz", "optional": true, "type": "boolean" }, { "defaultValue": "60", "documentation": "上传超时时间。默认60秒", "name": "timeout", "optional": false, "supportInfo": { "androidMinVersion": 10002090, "iosMinVersion": 10002090 }, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "文件网络地址。", "name": "fileUrl", "optional": false, "type": "string" }, { "documentation": "是否上传成功", "name": "success", "optional": false, "type": "boolean" }, { "documentation": "上传成功后，存储端返回的fileId", "name": "cloudId", "optional": false, "supportInfo": { "androidMinVersion": 10002090, "iosMinVersion": 10002090 }, "type": "string" }], "type": "Object" }] } }, { "apiName": "uploadImage", "description": "如非必要，请不要用私有资源，例如社交场景带隐私的文件。私有资源不走cdn加速，直接走源站，量大会导致效率低，而且对源站造成风险。\n（即手动带上参数 publicDomain: true）", "documentation": "将图片数据或本地地址上传至APMultimedia", "name": "uploadImage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "上传模式", "name": "dataType", "optional": false, "type": "enum" }, { "documentation": "上传数据", "name": "data", "optional": false, "type": "string" }, { "defaultValue": "NebulaBiz", "documentation": "业务码", "name": "business", "optional": true, "type": "string" }, { "defaultValue": "4", "documentation": "压缩质量", "name": "compress", "optional": true, "type": "enum" }, { "defaultValue": "false", "documentation": "是否上传到公有域，上传到公有域的图片在访问的时候不需要鉴权", "name": "publicDomain", "optional": true, "supportInfo": { "androidMinVersion": 10000008, "iosMinVersion": 10000008 }, "type": "boolean" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "多媒体ID", "name": "multimediaID", "optional": false, "type": "string" }, { "documentation": "上传图片对应的 URL, 仅当 publicDomain=true 时返回", "name": "publicUrl", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "uploadVideo", "description": "- Android平台上传是要区分是小视频还是相册视频，所谓小视频是只用户调用多媒体的拍摄组件拍摄生成的视频，拍摄完成后会返回localid，用户之间将此localid作为参数上传，同时指定videotype为short（不指定情况下默认short）；相册视频是指用其它拍摄组件拍摄后存储在手机系统相册里面视频，通常视频较大，因此在上传的时候需要调用多媒体的视频压缩jsapi传入实际视频路径（非apfilepath），做压缩处理，压缩后会返回压缩后的视频localid，然后用户拿此localid去做上传处理，注意上传相册视频的时候videotype需要设置为album。\n- 历史原因，IOS平台上传的时候是不需要区分videotype，而是直接拿localid上传，只是在换取localid的时候多媒体内部进行了压缩处理。", "documentation": "把短视频/相册视频上传到AFTS", "name": "uploadVideo", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "视频标识，支持 apFilePath / multimediaId", "name": "identifier", "optional": false, "type": "string" }, { "description": "", "documentation": "业务标识", "name": "business", "optional": true, "type": "string" }, { "description": "", "documentation": "需要返回视频地址", "name": "needUrl", "optional": true, "supportInfo": { "androidMinVersion": 10001098, "iosMinVersion": 10001098 }, "type": "boolean" }, { "description": "通过 [progressEvent](nativeevent) 发送事件", "documentation": "需要上传进度", "name": "needProgress", "optional": true, "supportInfo": { "androidMinVersion": 10001099, "iosMinVersion": 10001099 }, "type": "boolean" }, { "defaultValue": "0", "description": "", "documentation": "上传类型", "name": "uploadType", "optional": true, "supportInfo": { "androidMinVersion": 10001099, "iosMinVersion": 10001099 }, "type": "enum" }, { "defaultValue": "120", "description": "", "documentation": "上传超时时间", "name": "timeout4Upload", "optional": true, "supportInfo": { "androidMinVersion": 10001078, "iosMinVersion": 10001078 }, "type": "number" }, { "defaultValue": "short", "description": "", "documentation": "", "name": "videoType", "optional": true, "supportInfo": { "androidMinVersion": 10000003 }, "type": "enum" }, { "description": "", "documentation": "", "name": "extraParams", "optional": true, "supportInfo": { "androidMinVersion": 10001078, "iosMinVersion": 10001078 }, "type": "object" }, { "documentation": "需要返回响应头", "name": "needExtraHeaders", "optional": true, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "boolean" }, { "name": "extraHeaders", "optional": true, "supportInfo": { "androidMinVersion": 10001078, "iosMinVersion": 10001078 }, "type": "Record<string,string>" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "description": "", "documentation": "", "name": "error", "optional": true, "type": "number" }, { "description": "- uploadType为0:上传成功后返回首帧图视频组合id\n- uploadType为1:上传成功后返回视频id\n- uploadType为2:上传成功后返回缩略图id", "documentation": "视频ID", "name": "identifier", "optional": false, "type": "string" }, { "description": "needUrl=true才有返回\n- 若为公有上传，则返回url可长期访问\n- 若为私有上传，则返回url时效为一天。", "documentation": "视频AFTS地址", "name": "videoUrl", "optional": true, "supportInfo": { "androidMinVersion": 10001098, "iosMinVersion": 10001098 }, "type": "string" }, { "description": "", "documentation": "视频封面地址", "name": "videoCoverUrl", "optional": true, "supportInfo": { "androidMinVersion": 10001098, "iosMinVersion": 10001098 }, "type": "string" }, { "description": "needExtraHeaders为true时", "documentation": "响应头", "name": "extraHeaders", "optional": false, "supportInfo": { "androidMinVersion": 10002010, "iosMinVersion": 10002010 }, "type": "Record<string,string>" }], "type": "Object" }] } }, { "apiName": "verifyAndEnable", "name": "verifyAndEnable", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "verifyIdentity", "name": "verifyIdentity", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "标识一次完整的核身流程", "name": "verifyId", "optional": false, "type": "string" }, { "documentation": "核身产品数据", "name": "moduleData", "optional": false, "type": "string" }, { "documentation": "快速核身时 业务场景 ID", "name": "sceneId", "optional": false, "type": "string" }, { "documentation": "快速核身时 产品 ID", "name": "productId", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "核身verifyId", "name": "vid", "optional": false, "type": "string" }, { "documentation": "核身token", "name": "token", "optional": false, "type": "string" }, { "documentation": "业务名", "name": "bizName", "optional": false, "type": "string" }, { "documentation": "核身引擎执行结果", "name": "result", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "vibrate", "documentation": "触发设备震动", "name": "vibrate", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "1" }] } }, { "apiName": "vibrateLong", "documentation": "使手机发生较长时间的振动（400 ms)", "name": "vibrateLong", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "1" }] } }, { "apiName": "vibrateShort", "documentation": "触发设备短时间震动", "name": "vibrateShort", "parameters": { "in": [{}], "out": [{ "name": "success", "optional": false, "type": "1" }] } }, { "apiName": "virtualServiceH5PluginIsv", "documentation": "NFC 虚拟卡服务，目前只支持华为手机。 （Android Only）", "name": "virtualServiceH5PluginIsv", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "调用的方法名。", "name": "method", "optional": false, "type": "string" }, { "documentation": "传递的 json 格式字符串。", "name": "param", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "结果码。", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "结果信息。", "name": "resultMsg", "optional": false, "type": "string" }, { "documentation": "返回内容。", "name": "data", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "voiceBringToFront", "name": "voiceBringToFront", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "voiceGetChargingInfo", "name": "voiceGetChargingInfo", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "voiceGetPermissionStatus", "documentation": "对iOS是个空实现，固定返回status=-1", "name": "voiceGetPermissionStatus", "parameters": { "in": [{ "documentation": "", "name": "key", "optional": false, "type": "string" }], "out": [{ "documentation": "", "name": "status", "optional": false, "type": "number" }] } }, { "apiName": "voiceIsAppLocked", "name": "voiceIsAppLocked", "parameters": { "in": [{}], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "notApplicable", "optional": true, "type": "number" }, { "documentation": "", "name": "status", "optional": false, "type": "number" }], "type": "Object" }] } }, { "apiName": "voiceIsSilentMode", "name": "voiceIsSilentMode", "parameters": { "in": [{}], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "number" }] } }, { "apiName": "voiceSetAppLocked", "name": "voiceSetAppLocked", "parameters": { "in": [{ "documentation": "", "name": "lock", "optional": false, "type": "boolean" }], "out": [{ "documentation": "", "name": "result", "optional": false, "type": "number" }] } }, { "apiName": "watchShake", "description": "默认没有参数时，是摇一摇功能。每次调用 API，在摇一摇手机后触发回调，如需再次监听则需要再次调用这个 API。", "documentation": "摇一摇/加速度传感器/压力传感器/陀螺仪相关功能", "name": "watchShake", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "description": "", "documentation": "值为true时，表示开启加速度传感器监听功能，会不断的收到accelerometerChange事件回调。\n\n", "name": "monitorAccelerometer", "optional": true, "type": "boolean" }, { "description": "", "documentation": "值为true时，表示开启压力传感器监听功能，会不断的收到compassChange事件回调。", "name": "monitorCompass", "optional": true, "type": "boolean" }, { "description": "", "documentation": "值为true时，表示开启陀螺仪传感器监听功能，会不断的收到gyroscopeChange事件回调。", "name": "monitorGyroscope", "optional": true, "type": "boolean" }, { "description": "", "documentation": "传感器采样回调间隔，单位 秒", "name": "interval", "optional": true, "type": "number" }], "type": "Object" }], "out": [{ "documentation": "表示摇一摇有效或传感器监听调用成功", "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "wIdAuth", "description": "w公安部项目，仅支持小程序", "documentation": "提供网络身份认证", "name": "wIdAuth", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "defaultValue": "", "documentation": "机构 ID，业务接入申请时，w分配给机 构的唯一标识 8位", "exampleValue": "90000006", "name": "orgID", "optional": false, "type": "string" }, { "defaultValue": "", "documentation": "应用 ID，业务接入申请时，w分配给网 络应用 APP 的唯一标识 4位", "exampleValue": "0012", "name": "appID", "optional": false, "type": "string" }, { "defaultValue": "", "documentation": "调用方业务序列号 :\t\t \t\t\t\t\t\n由调用方生成的具有唯一性的业务序 列号 32位", "exampleValue": "00520211229094537128225903984632", "name": "bizSeq", "optional": false, "type": "string" }, { "defaultValue": "0", "documentation": "业务类型", "exampleValue": "0", "name": "type", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "响应结果码\n同 网络身份认证App （测试版）SDK接口说明书V2.0.pdf", "exampleValue": "C0000000", "name": "resultCode", "optional": false, "type": "string" }, { "documentation": "响应结果描述\n同 网络身份认证App （测试版）SDK接口说明书V2.0.pdf", "exampleValue": "成功", "name": "resultDesc", "optional": false, "type": "string" }, { "documentation": "resultData 数据结构说明 \n同 网络身份认证App （测试版）SDK接口说明书V2.0.pdf", "exampleValue": "", "name": "resultData", "optional": false, "type": "object" }], "type": "Object" }] } }, { "apiName": "writeBLECharacteristicValue", "documentation": "写蓝牙特征值", "name": "writeBLECharacteristicValue", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "蓝牙设备 ID", "name": "deviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值对应 service 的 UUID", "name": "serviceId", "optional": false, "type": "string" }, { "documentation": "蓝牙特征值的 UUID", "name": "characteristicId", "optional": false, "type": "string" }, { "documentation": "蓝牙设备特征值对应的值，为 16 进制字符串，限制在 20 字节内", "name": "value", "optional": false, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "错误码", "name": "errorCode", "optional": false, "type": "string" }, { "documentation": "错误信息", "name": "errorMessage", "optional": false, "type": "string" }], "type": "Object" }] } }, { "apiName": "writeBluetoothSocketValue", "name": "writeBluetoothSocketValue", "parameters": { "in": [{}], "out": [{}] } }, { "apiName": "writeNdefMessage", "name": "writeNdefMessage", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "name": "instanceId", "optional": false, "type": "string" }, { "name": "records", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "name": "success", "optional": false, "type": "true" }] } }, { "apiName": "xNNGraphInit", "name": "xNNGraphInit", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "图描述的json 字符串", "name": "graph", "optional": false, "type": "string" }, { "documentation": "扩展字段", "name": "options", "optional": false, "type": "Record<string, unknown>" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "当前事务处理id", "name": "id", "optional": false, "type": "string" }, { "name": "error", "optional": false, "type": "0" }], "type": "Object" }] } }, { "apiName": "xNNGraphRequestCameraPermission", "name": "xNNGraphRequestCameraPermission", "parameters": { "in": [{}], "out": [] } }, { "apiName": "xNNGraphSetOptions", "name": "xNNGraphSetOptions", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "当前事务处理id", "name": "id", "optional": false, "type": "string" }, { "name": "type", "optional": false, "type": "\"param\"" }, { "documentation": "需要设置的节点名", "name": "node", "optional": false, "type": "string" }, { "name": "options", "optional": false, "type": "object" }], "type": "Object" }], "out": [{ "name": "error", "optional": false, "type": "0" }] } }, { "apiName": "xNNGraphUninit", "name": "xNNGraphUninit", "parameters": { "in": [{ "documentation": "当前事务处理id", "name": "id", "optional": false, "type": "string" }], "out": [{}] } }, { "apiName": "zimIdentity", "name": "zimIdentity", "parameters": { "in": [{ "documentation": "入参，Object 类型。", "parameters": [{ "documentation": "", "name": "action", "optional": true, "type": "string" }, { "documentation": "", "name": "verifyType", "optional": true, "type": "string" }, { "documentation": "", "name": "verifyId", "optional": true, "type": "string" }], "type": "Object" }], "out": [{ "documentation": "出参，Object 类型。", "parameters": [{ "documentation": "", "name": "actionResult", "optional": true, "type": "string | #$#" }, { "documentation": "", "name": "extInfo", "optional": true, "type": "object" }, { "documentation": "", "name": "code", "optional": true, "type": "string" }, { "documentation": "", "name": "verifyCode", "optional": true, "type": "string" }, { "documentation": "", "name": "action", "optional": true, "type": "string" }, { "documentation": "", "name": "reason", "optional": true, "type": "string" }], "type": "Object" }] } }, { "apiName": "zodiacAwardStr", "description": "新春五福", "documentation": "新春五福", "name": "zodiacAwardStr", "parameters": { "in": [{}], "out": [{}] } }];
exports.NativeAPI = NativeAPI;


/***/ }),

/***/ "../shared/lib/index.js":
/*!******************************!*\
  !*** ../shared/lib/index.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./meta */ "../shared/lib/meta/index.js"), exports);
__exportStar(__webpack_require__(/*! ./command */ "../shared/lib/command/index.js"), exports);
__exportStar(__webpack_require__(/*! ./notification */ "../shared/lib/notification/index.js"), exports);
__exportStar(__webpack_require__(/*! ./config */ "../shared/lib/config/index.js"), exports);
__exportStar(__webpack_require__(/*! ./constants */ "../shared/lib/constants.js"), exports);
__exportStar(__webpack_require__(/*! ./jsonFile */ "../shared/lib/jsonFile.js"), exports);
__exportStar(__webpack_require__(/*! ./types */ "../shared/lib/types.js"), exports);
__exportStar(__webpack_require__(/*! ./url */ "../shared/lib/url.js"), exports);


/***/ }),

/***/ "../shared/lib/jsapi/generate.js":
/*!***************************************!*\
  !*** ../shared/lib/jsapi/generate.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getApiRuntimeData = exports.provideHover4NativeApi = exports.provideHover4Miniapi = exports.generateJSSnippets = exports.getAPIDocumentation = exports.getAPIInsertText = void 0;
const vscode_languageserver_1 = __webpack_require__(/*! vscode-languageserver */ "../shared/node_modules/vscode-languageserver/lib/node/main.js");
const i18n_1 = __webpack_require__(/*! ./i18n */ "../shared/lib/jsapi/i18n.js");
const undici_1 = __importDefault(__webpack_require__(/*! undici */ "../../node_modules/undici/index.js"));
function removeNewLine(str) {
    return str.replace(/(\r\n|\n|\r)/gm, '<br />');
}
function appendSupportInfo(api) {
    let result = '';
    const supportInfo = api.supportInfo;
    if (supportInfo && Object.keys(supportInfo).length > 0) {
        const getInfo = (client) => {
            const supportNumber = supportInfo[client];
            const patchV = supportNumber % 1000;
            const minorV = Math.floor(supportNumber / 1000) % 1000;
            const majorV = Math.floor(supportNumber / 1000000) % 1000;
            return supportNumber ? `${majorV}.${minorV}.${patchV}+` : '暂无';
        };
        result = `### ${(0, i18n_1.get)('clientVer')}
    \n
| appx | android | ios | IDE |
| -- | -- | -- | -- |
| ${getInfo('lib1MinVersion')}/${getInfo('lib2MinVersion')} | ${getInfo('androidMinVersion')} | ${getInfo('iosMinVersion')} | ${getInfo('ideMinVersion')} |
`;
    }
    return result;
}
const builtinSnippets = {
    'my.getPhoneNumber': {
        snippets: [
            {
                label: 'getPhoneNumber({success, fail})',
                content: 'getPhoneNumber({\n  success: (result) => {\n    $1\n  },\n  fail: () => {\n    $2\n  }\n});',
            },
        ],
    },
    'my.tradePay': {
        snippets: [
            {
                label: 'tradePay({orderStr, tradeNO, success, fail})',
                content: "tradePay({\n  orderStr: '${1}',\n  tradeNO: '${2}',\n  success: (result) => {\n    $3\n  },\n  fail: () => {\n    $4\n  }\n});",
            },
        ],
    },
    'my.getAuthCode': {
        apiName: 'my.getAuthCode',
        snippets: [
            {
                label: 'getAuthCode({scopes, success, fail})',
                content: 'getAuthCode({\n  scopes: [$1],\n  success: (result) => {\n    $2\n  },\n  fail: () => {\n    $3\n  }\n});',
            },
        ],
    },
    'my.request': {
        snippets: [
            {
                label: 'request({url, method, data, success, fail})',
                content: "request({\n  url: '${1}',\n  method: '${2}',\n  data: {$3},\n  success: (result) => {\n    $4\n  },\n  fail: () => {\n    $5\n  }\n});",
            },
        ],
    },
    'my.setNavigationBar': {
        snippets: [
            {
                label: 'setNavigationBar({title})',
                content: "setNavigationBar({\n  title: '${1}'\n});",
            },
        ],
    },
    'my.alert': {
        snippets: [
            {
                label: 'alert({title})',
                content: "alert({\n  title: '${1}'\n});",
            },
        ],
    },
    'my.showLoading': {
        snippets: [
            {
                label: 'showLoading({content, delay})',
                content: "showLoading({\n  content: '${1}',\n  delay: ${2:0}\n});",
            },
        ],
    },
    'my.showToast': {
        snippets: [
            {
                label: 'showToast({content})',
                content: "showToast({\n  content: '${1}'\n});",
            },
            {
                label: 'showToast({content, duration})',
                content: "showToast({\n  content: '${1}',\n  duration: ${2:2000}\n});",
            },
        ],
    },
    'my.multiLevelSelect': {
        snippets: [
            {
                label: 'multiLevelSelect({title, list, success})',
                content: 'multiLevelSelect({\n  title: \'多级联选择器\',\n  list: [{\n    name: \'杭州市\',\n    subList: [{\n      name: "西湖区",\n      subList: [{\n        name: "古翠街道"\n      }, {\n        name: "文新街道"\n      }]\n    }]\n  }],\n  success: (result) => {\n    ${1}\n  }\n});',
            },
        ],
    },
};
function getAPIInsertText(apiName, api, paramFilter) {
    let label = apiName;
    if (!api.parameters) {
        return {
            label,
            snippetString: `${apiName}();`,
        };
    }
    const paramsString = [];
    let paramsDefaultValue = '';
    const cbString = '';
    let index = 1;
    const SnippetString = [];
    if (api.parameters.in && api.parameters.in.length > 0) {
        label = `${apiName}(`;
        const labelParams = [];
        api.parameters.in.forEach((inParam) => {
            if (!inParam.type) {
                inParam.type = '';
            }
            // 一级入参也有非必填的
            // 一级入参不可跳跃式必填，比如(非必填，必填，非必填，必填)，此种情况会出问题，当前无此类型数据
            if (paramFilter) {
                if (!paramFilter(inParam)) {
                    // 自定义组装snippet时，参数过滤逻辑由外部控制
                    return;
                }
            }
            switch (inParam.type.toLowerCase()) {
                case 'object': {
                    const paramList = [];
                    if (inParam.parameters && inParam.parameters.length > 0) {
                        inParam.parameters.forEach((param) => {
                            if (paramFilter) {
                                if (!paramFilter(param)) {
                                    // 自定义组装snippet时，参数过滤逻辑由外部控制
                                    return;
                                }
                            }
                            paramList.push(param.name);
                            if (!param.type) {
                                param.type = '';
                            }
                            switch (param.type.toLocaleLowerCase()) {
                                case 'string':
                                    // paramsDefaultValue = param.defaultValue ? `'${param.defaultValue}'` : `'$${index++}'`;
                                    paramsDefaultValue = `'$\{${index++}${param.defaultValue ? ':' + param.defaultValue : ''}}'`;
                                    break;
                                case 'boolean':
                                    paramsDefaultValue = `$\{${index++}:${param.defaultValue ? param.defaultValue : 'false'}}`;
                                    break;
                                case 'number':
                                    // paramsDefaultValue = param.defaultValue ? `${param.defaultValue}` : `$${index++}`;
                                    // number defaultValue 不存在时应该显示0
                                    paramsDefaultValue = `$\{${index++}:${param.defaultValue ? param.defaultValue : '0'}}`;
                                    break;
                                case 'function':
                                    if (param.name === 'success' &&
                                        api.parameters.out &&
                                        api.parameters.out.length > 0) {
                                        paramsDefaultValue = `(result) => {\n    $${index++}\n  }`;
                                    }
                                    else {
                                        paramsDefaultValue = `() => {\n    $${index++}\n  }`;
                                    }
                                    break;
                                default:
                                    if (param.type.toLocaleLowerCase().endsWith('[]')) {
                                        paramsDefaultValue = `[$${index++}]`;
                                    }
                                    else {
                                        paramsDefaultValue = `{$${index++}}`;
                                    }
                                    break;
                            }
                            paramsString.push(`${param.name}: ${paramsDefaultValue}`);
                        });
                        if (paramsString.length === 0 && !cbString) {
                            if (api.parameters.in.length !== 1) {
                                SnippetString.push('{}');
                            }
                        }
                        else if (paramsString.length > 0 && cbString) {
                            SnippetString.push(`{\n  ${paramsString.join(',\n  ')},\n  ${cbString}\n}`);
                        }
                        else {
                            SnippetString.push(`{\n  ${paramsString.join(',\n  ')}${cbString}\n}`);
                        }
                    }
                    labelParams.push(paramList.length > 0 ? `{${paramList.join(', ')}}` : '');
                    break;
                }
                case 'function':
                    labelParams.push(`function(){...}`);
                    SnippetString.push(`function(result) {\n  $${index++}\n}`);
                    break;
                case 'string':
                    labelParams.push(`''`);
                    SnippetString.push(`'$${index++}'`);
                    break;
                case 'number':
                    labelParams.push(`number`);
                    SnippetString.push(`$${index++}:${inParam.defaultValue || '0'}`);
                    break;
                case 'boolean':
                    labelParams.push(`boolean`);
                    SnippetString.push(`$${index++}:${inParam.defaultValue || 'false'}`);
                    break;
                default:
                    if (inParam.type.endsWith('[]')) {
                        labelParams.push(`[]`);
                        SnippetString.push(`[]`);
                    }
                    else {
                        labelParams.push(``);
                        SnippetString.push(`$${index++}`);
                    }
                    break;
            }
        });
        label = label + labelParams.join(', ') + ')';
    }
    return {
        label,
        snippetString: `${apiName}(${SnippetString.join(',\n  ')});`,
    };
}
exports.getAPIInsertText = getAPIInsertText;
function getAPIDocumentation(apiName, api) {
    const markdownStr = [];
    const documentation = (0, i18n_1.switchText)(api.documentation, api.enDocumentation);
    if (true) {
        const url = (0, i18n_1.switchText)(api.docUrl, api.enDocUrl);
        if (url) {
            markdownStr.push(`${api.name}`);
            markdownStr.push(`[${(0, i18n_1.get)('openInBrowser')}](${url})`);
        }
    }
    const inMarkdown = [];
    let inParamIsFunction = false;
    // 摘要
    if (documentation) {
        markdownStr.push(`### ${(0, i18n_1.get)('summary')}`);
        markdownStr.push(documentation);
        if (api.description) {
            markdownStr.push('\n');
            markdownStr.push(api.description + '\n');
        }
    }
    // 入参和类型
    if (api.parameters.in && api.parameters.in.length > 0) {
        api.parameters.in.forEach((inParam) => {
            var _a, _b;
            if (!inParam.type) {
                inParam.type = '';
            }
            if (inParam.type.toLowerCase() === 'object' ||
                inParam.type.toLowerCase() === 'function') {
                if (inParam.type.toLowerCase() === 'function') {
                    inParamIsFunction = true;
                }
                if (inParam.parameters && inParam.parameters.length > 0) {
                    inParam.documentation = (0, i18n_1.switchText)((_a = inParam.documentation) !== null && _a !== void 0 ? _a : '', (_b = inParam.enDocumentation) !== null && _b !== void 0 ? _b : '').trim();
                    inMarkdown.push(`${inParam.name ? inParam.name + '  ' : ''}${inParam.documentation ? inParam.documentation + '\n\n' : ''}

|${(0, i18n_1.get)('name')}|${(0, i18n_1.get)('type')}|${(0, i18n_1.get)('required')}|${(0, i18n_1.get)('description')}|
|--|--|--|--|
${inParam.parameters
                        .map((para) => {
                        return `|${para.name}|${para.type}|${!para.optional ? (0, i18n_1.get)('yes') : (0, i18n_1.get)('no')}|${removeNewLine((0, i18n_1.switchText)(para.documentation, para.enDocumentation))}|`;
                    })
                        .join('\n')}
`);
                }
            }
            else {
                if (inParam.documentation) {
                    inMarkdown.push(`${inParam.name ? inParam.name + '  ' : ''} ${inParam.type} ${(0, i18n_1.get)('type')}\n\n${inParam.documentation}`);
                }
            }
        });
        if (inMarkdown.length > 0) {
            markdownStr.push(`### ${(0, i18n_1.get)('parameters')}

`, ...inMarkdown);
        }
    }
    const outMarkdown = [];
    // 返回和出参
    if (api.parameters.out && api.parameters.out.length > 0) {
        // 出参和类型
        api.parameters.out.forEach((outParam) => {
            // 空对象
            if (Object.keys(outParam).length === 0) {
                return;
            }
            if (outParam.documentation || outParam.enDocumentation) {
                outMarkdown.push(`${(0, i18n_1.switchText)(outParam.documentation, outParam.enDocumentation)}\n`);
            }
            outMarkdown.push(`${outParam.type || ''} ${(0, i18n_1.get)('name') + (0, i18n_1.get)('attributesList')}\n`);
            let tableText = `|${(0, i18n_1.get)('name')}|${(0, i18n_1.get)('type')}|${(0, i18n_1.get)('description')}|\n| -- | -- | -- |\n`;
            if (outParam.parameters && outParam.parameters.length > 0) {
                tableText += outParam.parameters
                    .map((parameter) => {
                    return `|${parameter.name}|${parameter.type}|${removeNewLine((0, i18n_1.switchText)(parameter.documentation, parameter.enDocumentation)) || (0, i18n_1.get)('N/A')}|`;
                })
                    .join('\n');
            }
            else {
                tableText += `|${outParam.name}|${outParam.type}|${removeNewLine((0, i18n_1.switchText)(outParam.documentation, outParam.enDocumentation)) || (0, i18n_1.get)('N/A')}|\n`;
            }
            outMarkdown.push(tableText);
        });
        if (outMarkdown.length > 0) {
            // 同步，返回值
            if (api.mode === 'SYNC') {
                markdownStr.push(`### ${(0, i18n_1.get)('returns')}`);
            }
            // 异步，回调
            else if (api.mode === 'ASYNC') {
                if (inParamIsFunction) {
                    markdownStr.push(`### ${(0, i18n_1.get)('callback')}`);
                }
                else {
                    markdownStr.push(`### success ${(0, i18n_1.get)('callback')}`);
                }
            }
            // 结果，既非同步又非异步，直接拼个标题
            else {
                markdownStr.push(`### ${(0, i18n_1.get)('result')}`);
            }
            markdownStr.push(...outMarkdown);
        }
    }
    // TODO：补充耗时错误率
    // 1. 版本兼容性
    const supportInfo = appendSupportInfo(api);
    if (supportInfo) {
        markdownStr.push(supportInfo);
    }
    let _mardownStr = markdownStr.join('\n\n');
    if (false) {}
    return _mardownStr;
}
exports.getAPIDocumentation = getAPIDocumentation;
function generateJSSnippets(jsApis) {
    const configs = [];
    // ap ==> [ {}, {} ]
    const newScopeConfig = new Map();
    // ap ==> {  canIUse => {}, xx ==> {} }
    const newScopedMaps = new Map();
    const updateScopeData = (scopeName, apiName, completionConfig, ifAppendConfigs) => {
        // 更新 newScopeConfig
        const scopeDataArray = newScopeConfig.get(scopeName) || [];
        scopeDataArray.push(completionConfig);
        newScopeConfig.set(scopeName, scopeDataArray);
        // newScopedMaps
        if (!newScopedMaps.has(scopeName)) {
            newScopedMaps.set(scopeName, new Map());
        }
        const currentMap = newScopedMaps.get(scopeName);
        currentMap.set(apiName, completionConfig); // currentMap不可能为空值
        // ap上的api才会执行这个
        if (ifAppendConfigs) {
            configs.push(completionConfig);
        }
    };
    jsApis.forEach((api) => {
        var _a;
        // jsapi必须是my.开头的才提供
        if (!api.name.startsWith('my.') || !api.name) {
            return;
        }
        // 几种类型： my.xx / my.ap.xx / my.dd.xxx
        // 确认scopeName和apiName
        const scopes = api.name.split('.');
        const apiName = scopes.pop() || '';
        const documentation = {
            kind: vscode_languageserver_1.MarkupKind.Markdown,
            value: getAPIDocumentation(apiName, api),
        };
        let scopeName;
        let ifAppendConfigs = false;
        // my.xx
        if (scopes.length === 1) {
            scopeName = 'ap';
            ifAppendConfigs = true;
            // my.ap.xxx
        }
        else if (scopes.length === 2 && scopes[1]) {
            scopeName = scopes[1];
        }
        else {
            return;
        }
        const currentLabel = [];
        const snippets = (_a = builtinSnippets[api.name]) === null || _a === void 0 ? void 0 : _a.snippets;
        if (snippets && snippets.length > 0) {
            snippets.forEach((snippet) => {
                if (!snippet.content || !snippet.label) {
                    return;
                }
                const label = snippet.label || apiName || '';
                currentLabel.push(label);
                const completionItem = {
                    insertText: snippet.content,
                    insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                    sortText: snippet.label,
                    documentation,
                    label,
                    kind: vscode_languageserver_1.CompletionItemKind.Snippet,
                };
                updateScopeData(scopeName, apiName, completionItem, ifAppendConfigs);
            });
            // 根据optional的标记，生成一个推荐用法
        }
        {
            // 根据文档接口生成的补全
            const { label, snippetString } = getAPIInsertText(apiName, api, (param) => {
                return param.optional !== true;
            });
            currentLabel.push(label);
            const completionItem = {
                insertText: snippetString,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                documentation,
                label,
                sortText: label,
                kind: vscode_languageserver_1.CompletionItemKind.Snippet,
            };
            updateScopeData(scopeName, apiName, completionItem, ifAppendConfigs);
        }
        // 根据所有参数，生成一个完整的
        const { label, snippetString } = getAPIInsertText(apiName, api /* 不配置过滤参数 */);
        // 如果和上述生成有重复，就不用继续了
        if (currentLabel.indexOf(label) < 0) {
            const fullParamCompletionItem = {
                insertText: snippetString,
                insertTextFormat: vscode_languageserver_1.InsertTextFormat.Snippet,
                documentation,
                label,
                sortText: label,
                kind: vscode_languageserver_1.CompletionItemKind.Snippet,
            };
            updateScopeData(scopeName, apiName, fullParamCompletionItem, ifAppendConfigs);
        }
    });
    return {
        configs,
        completionScopes: newScopeConfig,
        completionScopeMaps: newScopedMaps,
    };
}
exports.generateJSSnippets = generateJSSnippets;
function provideHover4Miniapi(word, completionScopeMaps) {
    const wordSplit = word.split('.');
    let apiName = '';
    let scopeName = '';
    switch (wordSplit.length) {
        case 0:
        case 1:
            break;
        case 2:
            apiName = wordSplit.pop();
            scopeName = 'ap';
            break;
        default:
            apiName = wordSplit.pop();
            wordSplit.shift();
            scopeName = wordSplit.join('.');
            break;
    }
    if (!scopeName || !apiName) {
        return;
    }
    const completionsMap = completionScopeMaps.get(scopeName);
    if (!completionsMap) {
        return;
    }
    const completionItem = completionsMap.get(apiName);
    if (completionItem && completionItem.documentation) {
        return {
            contents: completionItem.documentation,
        };
    }
}
exports.provideHover4Miniapi = provideHover4Miniapi;
function provideHover4NativeApi(NativeApiMeta, apiName) {
    const targetName = apiName.replace(/'|"/g, '');
    try {
        const api = NativeApiMeta.find((meta) => [meta.apiName, meta.name].includes(targetName));
        return {
            contents: getAPIDocumentation(targetName, Object.assign(Object.assign({}, api), { 
                // 手动对齐
                // native api 一定是异步
                mode: 'ASYNC', 
                // 文档取 minidev 链接
                docUrl: `https://minidev.antgroup-inc.cn/c/api/nativeapi/index?method=${targetName}`, enDocUrl: `https://minidev.antgroup-inc.cn/c/api/nativeapi/index?method=${targetName}` })),
        };
    }
    catch (error) {
        console.error('❌ || provideHover4NativeApi error', error);
    }
}
exports.provideHover4NativeApi = provideHover4NativeApi;
const getNativeapiRuntimeDataUrl = (apiName) => 'https://dataservice-api.alipay.com/dataserving/api/queryData/ds1849463769f0001919nativeapigroupbytest?apiName=' +
    apiName;
function getNativeApiRuntimeData(apiName) {
    return __awaiter(this, void 0, void 0, function* () {
        const requestUrl = getNativeapiRuntimeDataUrl(apiName);
        const result = yield undici_1.default.request(requestUrl);
        return result.body.json();
    });
}
/**
 * 获取 api 运行时的调用数据
 * 暂时只支持 native api
 * 源数据：afxadm.adm_c_innovation_jsapi_runtime_data_dt
 */
function getApiRuntimeData(apiName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const res = yield getNativeApiRuntimeData(apiName);
            const { data, success } = res;
            if (success) {
                const avgRuntimeData = data.items
                    .map((item) => {
                    const result = {};
                    Object.keys(item).forEach((key) => {
                        result[key] = +item[key].value;
                    });
                    return Object.assign(Object.assign({}, result), { 
                        // 计算错误率
                        errorPercent: parseFloat((result.api_fail_count / result.api_count).toFixed(4)) });
                })
                    // 累计并求平均
                    .reduce((last, current, currentIndex, arr) => {
                    const result = {
                        errorPercent: current.errorPercent + Number(last.errorPercent || 0),
                        api_p98_time: current.api_p98_time + Number(last.api_p98_time || 0),
                        api_p95_time: current.api_p95_time + Number(last.api_p95_time || 0),
                        avg_time: current.avg_time + Number(last.avg_time || 0),
                        api_p99_time: current.api_p99_time + Number(last.api_p99_time || 0),
                    };
                    if (currentIndex === arr.length - 1) {
                        Object.assign(result, {
                            errorPercent: ((result.errorPercent / arr.length) * 100).toFixed(2),
                            api_p98_time: Math.floor(result.api_p98_time / arr.length),
                            api_p95_time: Math.floor(result.api_p95_time / arr.length),
                            avg_time: Math.floor(result.avg_time / arr.length),
                            api_p99_time: Math.floor(result.api_p99_time / arr.length),
                        });
                    }
                    return result;
                }, {});
                return {
                    contents: `
${apiName}

#### 线上大盘调用数据

错误率：${avgRuntimeData.errorPercent}% \n
P98 调用耗时：${avgRuntimeData.api_p98_time}ms
`,
                };
            }
        }
        catch (error) {
            console.error('❌ || getApiRuntimeData error', error);
        }
    });
}
exports.getApiRuntimeData = getApiRuntimeData;


/***/ }),

/***/ "../shared/lib/jsapi/i18n.js":
/*!***********************************!*\
  !*** ../shared/lib/jsapi/i18n.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.format = exports.localize = exports.switchText = exports.get = void 0;
const supportedLngs = ['en', 'zh-cn'];
const lng = getLng();
const configs = {
    en: {
        summary: 'Summary',
        name: 'Attribute',
        type: 'Type',
        required: 'Required',
        description: 'Description',
        yes: 'Yes',
        no: 'No',
        parameters: 'Parameters',
        returns: 'Return',
        callback: 'Callback',
        result: 'Result',
        attributesList: ', attributes follows:',
        'N/A': 'N/A',
        openInBrowser: 'Open Online Docs',
        clientVer: 'Alipay APP compatibility ',
        'extension.sitemap.isIndexed': 'This page will be indexed due to rule [{0}] in sitemap.json',
        'create.input.tips': 'Please right click on the file tree',
        'create.template.empty': 'No templates available',
        'create.miniService.unavailable': "Current workspace's service is unavailable, you can try to refresh",
        'fileTree.placeholder.createDirectory': 'Create mini program files: axml/{0}/{1}/json',
        'fileTree.placeholder.createDirectory.info': ', add a `/` at the end of the path to create a folder',
        'fileTree.placeholder.createDirectory.new': 'Please input the path',
        'fileTree.valid.nonEmpty': 'The directory name entered cannot be empty',
        'fileTree.valid.brokenTarget': 'Target path became invalid, please retry.',
        'fileTree.valid.destExists': 'File or folder in the path address already exists',
        'fileTree.valid.mustInProject': 'Path not inside your project root directory',
        'fileTree.valid.template': 'Template files are broken: ',
        'fileTree.info.createInfo': 'Will create files: {0}, add a `/` at the end of the path to create a folder',
        'service.appInfo.generatingPage': 'Generating Page...',
        'completion.detail.my': 'MiniProgram API',
        'extension.configuration.askAutoGeneratePage': 'Enable "Automatically create the corresponding code file when a new page is added in app.json"? (You can modify it in settings)',
    },
    'zh-cn': {
        summary: '摘要',
        name: '属性',
        type: '类型',
        required: '必填',
        description: '描述',
        yes: '是',
        no: '否',
        parameters: '入参',
        returns: '返回值',
        callback: '回调函数',
        result: '结果',
        attributesList: '，属性如下：',
        'N/A': '无',
        openInBrowser: '打开在线文档',
        clientVer: '支付宝版本兼容性',
        'extension.sitemap.isIndexed': '根据 sitemap.json 中的规则[{0}], 该页面将会被索引',
        'create.input.tips': '请在需要新建的地方右键选择',
        'create.template.empty': '没有可用的模板',
        'create.miniService.unavailable': '当前文件夹的语言服务暂时不可用，请刷新重试',
        'fileTree.placeholder.createDirectory': '创建小程序文件：axml/{0}/{1}/json',
        'fileTree.placeholder.createDirectory.info': '，输入以 / 结尾的路径会创建一个文件夹',
        'fileTree.placeholder.createDirectory.new': '请输入路径',
        'fileTree.valid.nonEmpty': '输入目录名不能为空',
        'fileTree.valid.brokenTarget': '创建目标路径已被更改且不可用，请重试',
        'fileTree.valid.destExists': '该路径地址的文件或文件夹已存在',
        'fileTree.valid.mustInProject': '该路径不在插件根目录或小程序根目录内',
        'fileTree.valid.template': '模板文件已损坏',
        'fileTree.info.createInfo': '将会创建这些文件 {0}，输入以 / 结尾的路径会创建一个文件夹',
        'service.appInfo.generatingPage': '生成 Page 中...',
        'completion.detail.my': '小程序 API',
        'extension.configuration.askAutoGeneratePage': '需要开启『在 app.json 中新增小程序页面后自动创建对应代码文件』吗？(可在设置中修改)',
    },
};
function getLng() {
    let lng = '';
    if (process.env.VOL_NLS_CONFIG) {
        lng = process.env.VOL_NLS_CONFIG || 'en';
    }
    else if (process.env.VSCODE_NLS_CONFIG) {
        let nls;
        try {
            nls = JSON.parse(process.env.VSCODE_NLS_CONFIG);
        }
        catch (e) {
            nls = {};
        }
        lng = nls.locale || '';
    }
    if (lng) {
        lng = lng.toLowerCase();
        if (supportedLngs.indexOf(lng) < 0) {
            lng = supportedLngs[0];
        }
        return lng;
    }
    else {
        return 'en';
    }
}
function get(id, dm) {
    return configs[lng][id] || dm || id;
}
exports.get = get;
function switchText(zhText, enText) {
    if (lng !== 'zh' && enText) {
        return enText;
    }
    return zhText || '';
}
exports.switchText = switchText;
function localize(key, defaultMessage, ...args) {
    const m = get(key, defaultMessage || '');
    return format(m, args);
}
exports.localize = localize;
function format(message, args) {
    let result;
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            const index = rest[0];
            const arg = args[index];
            let replacement = match;
            if (typeof arg === 'string') {
                replacement = arg;
            }
            else if (typeof arg === 'number' ||
                typeof arg === 'boolean' ||
                arg === void 0 ||
                arg === null) {
                replacement = String(arg);
            }
            return replacement;
        });
    }
    return result;
}
exports.format = format;


/***/ }),

/***/ "../shared/lib/jsonFile.js":
/*!*********************************!*\
  !*** ../shared/lib/jsonFile.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.JSONFileOnlineSchemasMapping = exports.JSONFileDocs = exports.EJsonType = exports.AppxJsonFile = void 0;
var AppxJsonFile;
(function (AppxJsonFile) {
    AppxJsonFile.MiniProjectJson = 'mini.project.json';
    AppxJsonFile.AppJson = 'app.json';
    AppxJsonFile.ComponentJson = 'component.json';
    AppxJsonFile.PageJson = 'page.json';
    AppxJsonFile.PluginJson = 'plugin.json';
    AppxJsonFile.PreloadJson = 'preload.json';
})(AppxJsonFile = exports.AppxJsonFile || (exports.AppxJsonFile = {}));
var EJsonType;
(function (EJsonType) {
    EJsonType["AppJson"] = "app.json";
    EJsonType["PageJson"] = "page.json";
    EJsonType["ComponentJson"] = "component.json";
    EJsonType["PluginJson"] = "plugin.json";
    EJsonType["PreloadJson"] = "preload.json";
    EJsonType["MiniProjectJsonV1"] = "mini.project.json";
    EJsonType["MiniProjectJsonV2"] = "mini.project.v2.json";
    EJsonType["MiniProjectJsonV1Public"] = "mini.project.public.json";
    EJsonType["MiniProjectJsonV2Public"] = "mini.project.v2.public.json";
})(EJsonType = exports.EJsonType || (exports.EJsonType = {}));
exports.JSONFileDocs = {
    [EJsonType.AppJson]: 'https://opendocs.alipay.com/mini/framework/app-json',
    [EJsonType.PageJson]: 'https://opendocs.alipay.com/mini/framework/page-json',
    [EJsonType.ComponentJson]: 'https://opendocs.alipay.com/mini/framework/component_configuration',
    [EJsonType.MiniProjectJsonV1]: 'https://opendocs.alipay.com/mini/framework/project',
    [EJsonType.MiniProjectJsonV2]: 'https://opendocs.alipay.com/mini/03dbc3',
    [EJsonType.PluginJson]: 'https://opendocs.alipay.com/mini/plugin/plugin-development',
    [EJsonType.PreloadJson]: 'https://opendocs.alipay.com/mini/02sd57',
};
exports.JSONFileOnlineSchemasMapping = {
    [EJsonType.AppJson]: `app.schema.json`,
    [EJsonType.PageJson]: `page.schema.json`,
    [EJsonType.ComponentJson]: `component.schema.json`,
    [EJsonType.MiniProjectJsonV1]: `mini-project.schema.json`,
    [EJsonType.MiniProjectJsonV1Public]: `mini-project.public.schema.json`,
    [EJsonType.MiniProjectJsonV2]: `mini-project.v2.schema.json`,
    [EJsonType.MiniProjectJsonV2Public]: `mini-project.v2.public.schema.json`,
    [EJsonType.PluginJson]: `plugin.schema.json`,
    [EJsonType.PreloadJson]: `preload.schema.json`,
};


/***/ }),

/***/ "../shared/lib/meta/axml-meta.js":
/*!***************************************!*\
  !*** ../shared/lib/meta/axml-meta.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/meta/index.js":
/*!***********************************!*\
  !*** ../shared/lib/meta/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./axml-meta */ "../shared/lib/meta/axml-meta.js"), exports);


/***/ }),

/***/ "../shared/lib/node/index.js":
/*!***********************************!*\
  !*** ../shared/lib/node/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkIsInsideUserSync = exports.checkIsInsideUser = void 0;
var isInsideUser_1 = __webpack_require__(/*! ./isInsideUser */ "../shared/lib/node/isInsideUser.js");
Object.defineProperty(exports, "checkIsInsideUser", ({ enumerable: true, get: function () { return isInsideUser_1.checkIsInsideUser; } }));
Object.defineProperty(exports, "checkIsInsideUserSync", ({ enumerable: true, get: function () { return isInsideUser_1.checkIsInsideUserSync; } }));


/***/ }),

/***/ "../shared/lib/node/installer/index.js":
/*!*********************************************!*\
  !*** ../shared/lib/node/installer/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getValidResource = exports.getValidResourceSync = exports.resourceExistsSync = exports.resourceExists = exports.getJSONResourceSync = exports.getJSONResource = exports.getResourceLocalPath = exports.MiniResources = exports.ResourceName = void 0;
const path_1 = __importDefault(__webpack_require__(/*! path */ "path"));
const promises_1 = __importDefault(__webpack_require__(/*! fs/promises */ "fs/promises"));
const fs_1 = __importDefault(__webpack_require__(/*! fs */ "fs"));
var ResourceName;
(function (ResourceName) {
    ResourceName["MiniResources"] = "mini-resources";
    ResourceName["Schemas"] = "schemas";
})(ResourceName = exports.ResourceName || (exports.ResourceName = {}));
var MiniResources;
(function (MiniResources) {
    MiniResources["ElementsJSON"] = "elements.json";
    MiniResources["CanIUseJSON"] = "canIUse.json";
    MiniResources["MiniAPIJSON"] = "mini-api.json";
    MiniResources["NativeAPIJSON"] = "native-api.json";
})(MiniResources = exports.MiniResources || (exports.MiniResources = {}));
function getResourceLocalPath(storagePath, resourceName, fileName) {
    return path_1.default.join(storagePath, resourceName, fileName);
}
exports.getResourceLocalPath = getResourceLocalPath;
function getJSONResource(storagePath, resourceName, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        const content = yield promises_1.default.readFile(getResourceLocalPath(storagePath, resourceName, fileName));
        return JSON.parse(content.toString());
    });
}
exports.getJSONResource = getJSONResource;
function getJSONResourceSync(storagePath, resourceName, fileName) {
    const content = fs_1.default.readFileSync(getResourceLocalPath(storagePath, resourceName, fileName));
    return JSON.parse(content.toString());
}
exports.getJSONResourceSync = getJSONResourceSync;
function resourceExists(storagePath, resourceName, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield promises_1.default.access(getResourceLocalPath(storagePath, resourceName, fileName));
            return true;
        }
        catch (_a) {
            return false;
        }
    });
}
exports.resourceExists = resourceExists;
function resourceExistsSync(storagePath, resourceName, fileName) {
    try {
        fs_1.default.accessSync(getResourceLocalPath(storagePath, resourceName, fileName));
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.resourceExistsSync = resourceExistsSync;
function getValidResourceSync(storagePath, resourceName, fileName) {
    if (resourceExistsSync(storagePath, resourceName, fileName)) {
        let data;
        try {
            data = getJSONResourceSync(storagePath, resourceName, fileName);
            return data;
        }
        catch (_a) {
            // nop
            return undefined;
        }
    }
    return undefined;
}
exports.getValidResourceSync = getValidResourceSync;
function getValidResource(storagePath, resourceName, fileName) {
    return __awaiter(this, void 0, void 0, function* () {
        if (yield resourceExists(storagePath, resourceName, fileName)) {
            let data;
            try {
                data = yield getJSONResource(storagePath, resourceName, fileName);
                return data;
            }
            catch (_a) {
                // nop
                return undefined;
            }
        }
        return undefined;
    });
}
exports.getValidResource = getValidResource;


/***/ }),

/***/ "../shared/lib/node/isInsideUser.js":
/*!******************************************!*\
  !*** ../shared/lib/node/isInsideUser.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkIsInsideUserSync = exports.checkIsInsideUser = void 0;
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
const util_1 = __webpack_require__(/*! util */ "util");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const uemClient = ['AliLangClient', 'AntUEMClient'].map((v) => v.toLowerCase());
const grepKeyword = 'Client';
/**
 * 判断当前用户是否是 阿里巴巴 用户
 * 判断依据：是否安装和运行了阿里郎
 */
function checkIsInsideUser() {
    return __awaiter(this, void 0, void 0, function* () {
        if (process.env.FORCE_NO_INNER_USER) {
            return false;
        }
        return isRunning(uemClient);
    });
}
exports.checkIsInsideUser = checkIsInsideUser;
function checkIsInsideUserSync() {
    if (process.env.FORCE_NO_INNER_USER) {
        return false;
    }
    return isRunningSync(uemClient);
}
exports.checkIsInsideUserSync = checkIsInsideUserSync;
function getCmd() {
    const platform = process.platform;
    let cmd = '';
    switch (platform) {
        case 'win32':
            cmd = 'tasklist';
            break;
        case 'darwin':
            cmd = `ps -ax | grep ${grepKeyword}`;
            break;
        case 'linux':
            cmd = 'ps -A | grep ${grepKeyword}';
            break;
        default:
            break;
    }
    return cmd;
}
const processStdout = (queries, _stdout) => {
    const platform = process.platform;
    const stdout = _stdout.toLowerCase();
    try {
        if (platform !== 'win32') {
            // Unix 平台上把 grep 去掉
            const lines = stdout.split('\n');
            for (const l of lines) {
                if (l.includes('grep ')) {
                    continue;
                }
                if (queries.some((v) => l.includes(v))) {
                    return true;
                }
            }
            return false;
        }
        return queries.some((v) => stdout.includes(v));
    }
    catch (e) {
        console.error(e);
        return false;
    }
};
function isRunning(query) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const cmd = getCmd();
            const { stdout } = yield execAsync(cmd);
            return processStdout(query, stdout);
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error(e);
            return false;
        }
    });
}
function isRunningSync(query) {
    try {
        const cmd = getCmd();
        const stdout = (0, child_process_1.execSync)(cmd).toString();
        return processStdout(query, stdout);
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.error(e);
        return false;
    }
}


/***/ }),

/***/ "../shared/lib/node/isVol.js":
/*!***********************************!*\
  !*** ../shared/lib/node/isVol.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isVol = void 0;
const isVol = () => {
    return Boolean(process.env.VOL_APP_PATH);
};
exports.isVol = isVol;


/***/ }),

/***/ "../shared/lib/node/yuyanConfig/index.js":
/*!***********************************************!*\
  !*** ../shared/lib/node/yuyanConfig/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// yuyan-config
// https://code.alipay.com/yuyan/yuyan-config-data
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NetworkType = exports.EnvEnum = exports.fetchPriorityCache = exports.getCache = exports.fetchData = exports.get = exports.getConfigDataUrl = void 0;
const utils_1 = __webpack_require__(/*! ./utils */ "../shared/lib/node/yuyanConfig/utils.js");
const types_1 = __webpack_require__(/*! ./types */ "../shared/lib/node/yuyanConfig/types.js");
Object.defineProperty(exports, "EnvEnum", ({ enumerable: true, get: function () { return types_1.EnvEnum; } }));
Object.defineProperty(exports, "NetworkType", ({ enumerable: true, get: function () { return types_1.NetworkType; } }));
const localStorage_1 = __webpack_require__(/*! ./localStorage */ "../shared/lib/node/yuyanConfig/localStorage.js");
// 主站
const MAIN_SITE_DOMAIN = {
    [types_1.NetworkType.OFFICE]: {
        dev: 'renderofficedev.alipay.com',
        local: 'renderofficedev.alipay.com',
        test: 'renderofficetest.alipay.com',
        stable: 'renderofficestable.alipay.com',
        pre: 'renderofficepre.alipay.com',
        prod: 'renderoffice.alipay.com',
    },
    [types_1.NetworkType.INTERNET]: {
        dev: 'renderdev.alipay.com',
        local: 'renderdev.alipay.com',
        test: 'rendertest.alipay.com',
        stable: 'renderstable.alipay.com',
        pre: 'renderpre.alipay.com',
        prod: 'render.alipay.com',
    },
};
const scope = 'p/yuyan';
/**
 * 获取h5data 2.0 url
 * @param {string} snippetPath bmw snippet path
 * @param {string} env EnvEnum
 */
const getConfigDataUrl = (path, env, options) => {
    var _a;
    const language = options.language || 'zh_CN';
    const networkType = options.networkType || types_1.NetworkType.INTERNET;
    const domain = (_a = MAIN_SITE_DOMAIN[networkType]) === null || _a === void 0 ? void 0 : _a[env];
    const protocol = 'https:';
    if (!domain)
        throw new Error(` ${networkType} is not supported`);
    return `${protocol}//${domain}/${scope}/${path}/${language}.json`;
};
exports.getConfigDataUrl = getConfigDataUrl;
const initEnv = (env) => env || types_1.EnvEnum.dev;
const initConfig = (path, option = {}) => __awaiter(void 0, void 0, void 0, function* () {
    const o = {
        autoCache: false,
        fetchFirst: false,
        timestamp: false,
    };
    const env = initEnv(option.env);
    return Object.assign(Object.assign(Object.assign({}, o), option), { path,
        env, url: (0, exports.getConfigDataUrl)(path, env, option) });
});
/**
 * 发起http请求
 * @param {string} url fetch url
 * @param {string} env h5data env
 * @param showEnvUrl
 */
const fetchRemoteData = (url, env, showEnvUrl = true) => {
    return (0, utils_1.request)(url).then((res) => {
        // 数组不能忘里面添加额外信息;
        if (Array.isArray(res)) {
            return res;
        }
        if (showEnvUrl) {
            return Object.assign({ __url: url, __env: env }, res);
        }
        else {
            return res;
        }
    });
};
/**
 * 根据path, appName获取h5data v2的json内容
 * @param {string} path basement中需要请求的区块的schema的path
 * @param {object} option option
 * @param {string} option.env 指定请求哪个环境下的数据, 若不指定, 自动根据当前的url判断
 * @param {boolean} option.autoCache 开启缓存
 * @param {boolean} option.fetchFirst 强制使用 fetch 方法请求
 * @param {boolean} option.timestamp 请求携带时间戳，绕过http缓存
 */
const get = (path, o) => __awaiter(void 0, void 0, void 0, function* () {
    let option = o;
    if (!option) {
        option = {};
    }
    const { url, env, autoCache, timestamp } = yield initConfig(path, option);
    // 浏览器环境下才做缓存
    const useCache = autoCache && localStorage_1.localStorage;
    const fetchURL = timestamp ? `${url}?t=${+new Date()}` : url; // 添加 timestamp 强制绕过304缓存
    const { showEnvUrl = true } = option;
    return fetchRemoteData(fetchURL, env, showEnvUrl).then((res) => {
        if (useCache) {
            localStorage_1.localStorage.setItem((0, utils_1.getCacheKey)(env, path), JSON.stringify(res));
        }
        return res;
    });
});
exports.get = get;
exports.fetchData = exports.get;
// 单纯得获取缓存, 没有就返回 null;
const getCache = (path, option) => __awaiter(void 0, void 0, void 0, function* () {
    const { env } = yield initConfig(path, option);
    const data = localStorage_1.localStorage.getItem((0, utils_1.getCacheKey)(env, path));
    if (data) {
        // 从缓存中读取数据, 格式化成 json 并返回; 第二个参数标记是否为缓存;
        return JSON.parse(data);
    }
    return null;
});
exports.getCache = getCache;
/**
 * fetch data 优先使用缓存版本, 若有缓存直接返回缓存, 无缓存请求后记录缓存
 * @param {string} path basement中需要请求的区块的schema的path
 * @param {object} option option
 * @param {string} option.env 指定请求哪个环境下的数据, 若不指定, 自动根据当前的url判断
 */
const fetchPriorityCache = (path, option) => __awaiter(void 0, void 0, void 0, function* () {
    const { env } = yield initConfig(path, option);
    const cacheRetStr = localStorage_1.localStorage && localStorage_1.localStorage.getItem((0, utils_1.getCacheKey)(env, path));
    const cacheRet = cacheRetStr && (0, utils_1.safeParseJSON)(cacheRetStr);
    if (cacheRet) {
        // 打标
        cacheRet.__useCache = true;
        return Promise.resolve(cacheRet);
    }
    option.autoCache = true;
    return (0, exports.fetchData)(path, option);
});
exports.fetchPriorityCache = fetchPriorityCache;


/***/ }),

/***/ "../shared/lib/node/yuyanConfig/localStorage.js":
/*!******************************************************!*\
  !*** ../shared/lib/node/yuyanConfig/localStorage.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.localStorage = exports.LocalStorage = void 0;
class LocalStorage {
    constructor() {
        this.data = {};
        this.getItem = (key) => (this.data[key] !== undefined ? this.data[key] : null);
        this.setItem = (key, val) => {
            this.data[key] = val + '';
        };
        this.removeItem = (key) => {
            delete this.data[key];
        };
        this.clear = () => {
            Object.keys(this.data).map((key) => delete this.data[key]);
        };
        this.toString = () => {
            return '[object Storage]';
        };
        this.key = (idx) => Object.keys(this.data)[idx] || null;
    }
    get length() {
        return Object.keys(this.data).length;
    }
    // for backwards compatibility
    get __STORE__() {
        return this.data;
    }
}
exports.LocalStorage = LocalStorage;
exports.localStorage = new LocalStorage();


/***/ }),

/***/ "../shared/lib/node/yuyanConfig/types.js":
/*!***********************************************!*\
  !*** ../shared/lib/node/yuyanConfig/types.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Platform = exports.NetworkType = exports.EnvEnum = void 0;
var EnvEnum;
(function (EnvEnum) {
    EnvEnum["dev"] = "dev";
    EnvEnum["test"] = "test";
    EnvEnum["pre"] = "pre";
    EnvEnum["prod"] = "prod";
    EnvEnum["local"] = "local";
    EnvEnum["stable"] = "stable";
})(EnvEnum = exports.EnvEnum || (exports.EnvEnum = {}));
var NetworkType;
(function (NetworkType) {
    NetworkType["OFFICE"] = "OFFICE";
    NetworkType["INTERNET"] = "INTERNET";
})(NetworkType = exports.NetworkType || (exports.NetworkType = {}));
var Platform;
(function (Platform) {
    Platform["WEB"] = "web";
})(Platform = exports.Platform || (exports.Platform = {}));


/***/ }),

/***/ "../shared/lib/node/yuyanConfig/utils.js":
/*!***********************************************!*\
  !*** ../shared/lib/node/yuyanConfig/utils.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.request = exports.getPlatform = exports.safeParseJSON = exports.getCacheKey = void 0;
const undici_1 = __importDefault(__webpack_require__(/*! undici */ "../../node_modules/undici/index.js"));
const types_1 = __webpack_require__(/*! ./types */ "../shared/lib/node/yuyanConfig/types.js");
/**
 * 获取缓存key
 * @param {string} env EnvEnum
 * @param {string} path snippet path
 */
const getCacheKey = (env, path) => `h5data-cache-${env}-${path}`;
exports.getCacheKey = getCacheKey;
/**
 *  安全的解析json, 非法格式返回空
 * @param {string} str json string
 * @param {throwError} boolean 解析错误的时候是否抛错, 默认不抛
 * @return {object|null} 若非法则返回空
 */
const safeParseJSON = (str) => {
    let jsonObject;
    try {
        jsonObject = str && JSON.parse(str);
    }
    catch (err) {
        jsonObject = null;
    }
    return jsonObject;
};
exports.safeParseJSON = safeParseJSON;
const getPlatform = () => {
    return types_1.Platform.WEB;
};
exports.getPlatform = getPlatform;
const request = (url) => {
    return undici_1.default
        .request(url)
        .then((fetchRes) => fetchRes.body.json())
        .catch((err) => {
        // node环境下, render404导致的302会后会直接请求404页面, 导致返回的是200, 但内容是404html, 所以要特殊处理
        if (/Unexpected token </.test(err && err.message)) {
            return Promise.reject('data not found');
        }
        // 在浏览器内, 请求404导致render返回的http code 为302, res header里面没有跨域头导致请求跨域被浏览器拦截, 所以跨域请求一律当404处理
        if (err &&
            // firefox
            (err.message === 'NetworkError when attempting to fetch resource.' ||
                // safari
                err.message === 'Type error' ||
                // chrome
                err.message === 'Failed to fetch')) {
            console.log(`有可能请求链接错误导致render返回 http code 为 302 让请求跳转至404页面
该 response header 无跨域头导致浏览器跨域, 请检查请求链接`);
        }
        return Promise.reject(err);
    });
};
exports.request = request;


/***/ }),

/***/ "../shared/lib/notification/client.js":
/*!********************************************!*\
  !*** ../shared/lib/notification/client.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/notification/index.js":
/*!*******************************************!*\
  !*** ../shared/lib/notification/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./client */ "../shared/lib/notification/client.js"), exports);
__exportStar(__webpack_require__(/*! ./server */ "../shared/lib/notification/server.js"), exports);
__exportStar(__webpack_require__(/*! ./lsp */ "../shared/lib/notification/lsp.js"), exports);


/***/ }),

/***/ "../shared/lib/notification/lsp.js":
/*!*****************************************!*\
  !*** ../shared/lib/notification/lsp.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/notification/server.js":
/*!********************************************!*\
  !*** ../shared/lib/notification/server.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/types.js":
/*!******************************!*\
  !*** ../shared/lib/types.js ***!
  \******************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../shared/lib/url.js":
/*!****************************!*\
  !*** ../shared/lib/url.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.appendUTM = void 0;
function appendUTM(url) {
    const u = new URL(url);
    u.searchParams.append('utm_source', 'minicode');
    return u.toString();
}
exports.appendUTM = appendUTM;


/***/ }),

/***/ "../shared/lib/utils/json.js":
/*!***********************************!*\
  !*** ../shared/lib/utils/json.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseJson = void 0;
const strip_json_comments_1 = __importDefault(__webpack_require__(/*! strip-json-comments */ "../../node_modules/strip-json-comments/index.js"));
function parseJson(content) {
    return JSON.parse((0, strip_json_comments_1.default)(content));
}
exports.parseJson = parseJson;


/***/ }),

/***/ "../shared/lib/utils/nodeRequire.js":
/*!******************************************!*\
  !*** ../shared/lib/utils/nodeRequire.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nodeResolve = void 0;
const nodeVer = typeof process !== 'undefined' && ((_a = process.versions) === null || _a === void 0 ? void 0 : _a.node);
const nodeRequire = nodeVer
    ?  true
        ? require
        : 0
    : undefined;
const nodeResolve = (moduleName, options) => nodeRequire.resolve(moduleName, options);
exports.nodeResolve = nodeResolve;


/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/api.js":
/*!***************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../shared/node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "../shared/node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../shared/node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "../shared/node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "../shared/node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "../shared/node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!************************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "../shared/node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "../shared/node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let knownCanceledRequests = new Set();
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
                const tokenKey = String(cancelId);
                const cancellationToken = requestTokens[tokenKey];
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} arguments`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js":
/*!******************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _b;
        return (_b = this._head) === null || _b === void 0 ? void 0 : _b.value;
    }
    get last() {
        var _b;
        return (_b = this._tail) === null || _b === void 0 ? void 0 : _b.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "../shared/node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "../shared/node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!********************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "../shared/node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!***************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js":
/*!**************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "../shared/node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(/*! ../common/api */ "../shared/node_modules/vscode-jsonrpc/lib/common/api.js");
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
__exportStar(__webpack_require__(/*! ../common/api */ "../shared/node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*************************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(/*! ../common/ral */ "../shared/node_modules/vscode-jsonrpc/lib/common/ral.js");
const util_1 = __webpack_require__(/*! util */ "util");
const disposable_1 = __webpack_require__(/*! ../common/disposable */ "../shared/node_modules/vscode-jsonrpc/lib/common/disposable.js");
const messageBuffer_1 = __webpack_require__(/*! ../common/messageBuffer */ "../shared/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-jsonrpc/node.js":
/*!*****************************************************!*\
  !*** ../shared/node_modules/vscode-jsonrpc/node.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Proposed = exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(/*! vscode-jsonrpc */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! vscode-languageserver-types */ "../shared/node_modules/vscode-languageserver-types/lib/esm/main.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.js"), exports);
var connection_1 = __webpack_require__(/*! ./connection */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/connection.js");
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
const diag = __webpack_require__(/*! ./proposed.diagnostic */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js");
var Proposed;
(function (Proposed) {
    Proposed.DiagnosticServerCancellationData = diag.DiagnosticServerCancellationData;
    Proposed.DocumentDiagnosticReportKind = diag.DocumentDiagnosticReportKind;
    Proposed.DocumentDiagnosticRequest = diag.DocumentDiagnosticRequest;
    Proposed.WorkspaceDiagnosticRequest = diag.WorkspaceDiagnosticRequest;
    Proposed.DiagnosticRefreshRequest = diag.DiagnosticRefreshRequest;
})(Proposed = exports.Proposed || (exports.Proposed = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js");
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js");
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js":
/*!***********************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * @since 3.17.0 - proposed state
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind["full"] = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind["unChanged"] = "unChanged";
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
//# sourceMappingURL=proposed.diagnostic.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!**************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!*************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
const Is = __webpack_require__(/*! ./utils/is */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js");
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js");
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js");
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js");
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js");
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js");
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js");
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js");
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js");
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js");
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(/*! ./protocol.semanticTokens */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js");
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(/*! ./protocol.showDocument */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js");
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(/*! ./protocol.linkedEditingRange */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js");
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(/*! ./protocol.fileOperations */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js");
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(/*! ./protocol.moniker */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js");
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js":
/*!*******************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js":
/*!********************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!*********************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "../shared/node_modules/vscode-jsonrpc/lib/node/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js":
/*!*************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!***************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js":
/*!*****************************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!******************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ "../shared/node_modules/vscode-jsonrpc/node.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/node */ "../shared/node_modules/vscode-jsonrpc/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "../shared/node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-protocol/node.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-protocol/node.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemLabelDetails": () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "SemanticTokenModifiers": () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   "SemanticTokenTypes": () => (/* binding */ SemanticTokenTypes),
/* harmony export */   "SemanticTokens": () => (/* binding */ SemanticTokens),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.parameters) || candidate.parameters === undefined) &&
            (Is.string(candidate.qualifier) || candidate.qualifier === undefined) && (Is.string(candidate.type) || candidate.type === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/api.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/api.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.SemanticTokensBuilder = void 0;
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "../shared/node_modules/vscode-languageserver/lib/common/semanticTokens.js");
Object.defineProperty(exports, "SemanticTokensBuilder", ({ enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } }));
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/ */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! ./server */ "../shared/node_modules/vscode-languageserver/lib/common/server.js"), exports);
const proposed_diagnostic_1 = __webpack_require__(/*! ./proposed.diagnostic */ "../shared/node_modules/vscode-languageserver/lib/common/proposed.diagnostic.js");
var ProposedFeatures;
(function (ProposedFeatures) {
    ProposedFeatures.all = {
        __brand: 'features',
        languages: proposed_diagnostic_1.DiagnosticFeature
    };
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/callHierarchy.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/callHierarchy.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const CallHierarchyFeature = (Base) => {
    return class extends Base {
        get callHierarchy() {
            return {
                onPrepare: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
                    });
                },
                onIncomingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onOutgoingCalls: (handler) => {
                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/configuration.js":
/*!********************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/configuration.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "../shared/node_modules/vscode-languageserver/lib/common/utils/is.js");
const ConfigurationFeature = (Base) => {
    return class extends Base {
        getConfiguration(arg) {
            if (!arg) {
                return this._getConfiguration({});
            }
            else if (Is.string(arg)) {
                return this._getConfiguration({ section: arg });
            }
            else {
                return this._getConfiguration(arg);
            }
        }
        _getConfiguration(arg) {
            let params = {
                items: Array.isArray(arg) ? arg : [arg]
            };
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
                return Array.isArray(arg) ? result : result[0];
            });
        }
    };
};
exports.ConfigurationFeature = ConfigurationFeature;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/fileOperations.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/fileOperations.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileOperationsFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const FileOperationsFeature = (Base) => {
    return class extends Base {
        onDidCreateFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidRenameFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onDidDeleteFiles(handler) {
            this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
                handler(params);
            });
        }
        onWillCreateFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillRenameFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
        onWillDeleteFiles(handler) {
            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
                return handler(params, cancel);
            });
        }
    };
};
exports.FileOperationsFeature = FileOperationsFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js":
/*!*************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const LinkedEditingRangeFeature = (Base) => {
    return class extends Base {
        onLinkedEditingRange(handler) {
            this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);
            });
        }
    };
};
exports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/moniker.js":
/*!**************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/moniker.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const MonikerFeature = (Base) => {
    return class extends Base {
        get moniker() {
            return {
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
            };
        }
    };
};
exports.MonikerFeature = MonikerFeature;
//# sourceMappingURL=moniker.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/progress.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/progress.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "../shared/node_modules/vscode-languageserver/lib/common/utils/uuid.js");
class WorkDoneProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
    }
    begin(title, percentage, message, cancellable) {
        let param = {
            kind: 'begin',
            title,
            percentage,
            message,
            cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    report(arg0, arg1) {
        let param = {
            kind: 'report'
        };
        if (typeof arg0 === 'number') {
            param.percentage = arg0;
            if (arg1 !== undefined) {
                param.message = arg1;
            }
        }
        else {
            param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
    }
    done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });
    }
}
WorkDoneProgressReporterImpl.Instances = new Map();
class WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {
    constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
        super.done();
    }
    cancel() {
        this._source.cancel();
    }
}
class NullProgressReporter {
    constructor() {
    }
    begin() {
    }
    report() {
    }
    done() {
    }
}
class NullProgressServerReporter extends NullProgressReporter {
    constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
    }
    get token() {
        return this._source.token;
    }
    done() {
        this._source.dispose();
    }
    cancel() {
        this._source.cancel();
    }
}
function attachWorkDone(connection, params) {
    if (params === undefined || params.workDoneToken === undefined) {
        return new NullProgressReporter();
    }
    const token = params.workDoneToken;
    delete params.workDoneToken;
    return new WorkDoneProgressReporterImpl(connection, token);
}
exports.attachWorkDone = attachWorkDone;
const ProgressFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._progressSupported = false;
        }
        initialize(capabilities) {
            var _a;
            super.initialize(capabilities);
            if (((_a = capabilities === null || capabilities === void 0 ? void 0 : capabilities.window) === null || _a === void 0 ? void 0 : _a.workDoneProgress) === true) {
                this._progressSupported = true;
                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                        progress.cancel();
                    }
                });
            }
        }
        attachWorkDoneProgress(token) {
            if (token === undefined) {
                return new NullProgressReporter();
            }
            else {
                return new WorkDoneProgressReporterImpl(this.connection, token);
            }
        }
        createWorkDoneProgress() {
            if (this._progressSupported) {
                const token = uuid_1.generateUuid();
                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
                    return result;
                });
            }
            else {
                return Promise.resolve(new NullProgressServerReporter());
            }
        }
    };
};
exports.ProgressFeature = ProgressFeature;
var ResultProgress;
(function (ResultProgress) {
    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();
})(ResultProgress || (ResultProgress = {}));
class ResultProgressReporterImpl {
    constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
    }
    report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
    }
}
function attachPartialResult(connection, params) {
    if (params === undefined || params.partialResultToken === undefined) {
        return undefined;
    }
    const token = params.partialResultToken;
    delete params.partialResultToken;
    return new ResultProgressReporterImpl(connection, token);
}
exports.attachPartialResult = attachPartialResult;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/proposed.diagnostic.js":
/*!**************************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/proposed.diagnostic.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const DiagnosticFeature = (Base) => {
    return class extends Base {
        get diagnostics() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRefreshRequest.type);
                },
                on: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.partialResult, params));
                    });
                },
                onWorkspace: (handler) => {
                    this.connection.onRequest(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.partialResult, params));
                    });
                }
            };
        }
    };
};
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=proposed.diagnostic.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/semanticTokens.js":
/*!*********************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/semanticTokens.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const SemanticTokensFeature = (Base) => {
    return class extends Base {
        get semanticTokens() {
            return {
                refresh: () => {
                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
                },
                on: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onDelta: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                },
                onRange: (handler) => {
                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
                    this.connection.onRequest(type, (params, cancel) => {
                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
                    });
                }
            };
        }
    };
};
exports.SemanticTokensFeature = SemanticTokensFeature;
class SemanticTokensDiff {
    constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
    }
    computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
            startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
            let originalEndIndex = originalLength - 1;
            let modifiedEndIndex = modifiedLength - 1;
            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
                originalEndIndex--;
                modifiedEndIndex--;
            }
            // if one moved behind the start index move them forward again
            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
                originalEndIndex++;
                modifiedEndIndex++;
            }
            const deleteCount = originalEndIndex - startIndex + 1;
            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
            // If we moved behind the start index we could have missed a simple delete.
            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
                return [
                    { start: startIndex, deleteCount: deleteCount - 1 }
                ];
            }
            else {
                return [
                    { start: startIndex, deleteCount, data: newData }
                ];
            }
        }
        else if (startIndex < modifiedLength) {
            return [
                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
            ];
        }
        else if (startIndex < originalLength) {
            return [
                { start: startIndex, deleteCount: originalLength - startIndex }
            ];
        }
        else {
            // The two arrays are the same.
            return [];
        }
    }
}
exports.SemanticTokensDiff = SemanticTokensDiff;
class SemanticTokensBuilder {
    constructor() {
        this._prevData = undefined;
        this.initialize();
    }
    initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
    }
    push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
            pushLine -= this._prevLine;
            if (pushLine === 0) {
                pushChar -= this._prevChar;
            }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
    }
    get id() {
        return this._id.toString();
    }
    previousResult(id) {
        if (this.id === id) {
            this._prevData = this._data;
        }
        this.initialize();
    }
    build() {
        this._prevData = undefined;
        return {
            resultId: this.id,
            data: this._data
        };
    }
    canBuildEdits() {
        return this._prevData !== undefined;
    }
    buildEdits() {
        if (this._prevData !== undefined) {
            return {
                resultId: this.id,
                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()
            };
        }
        else {
            return this.build();
        }
    }
}
exports.SemanticTokensBuilder = SemanticTokensBuilder;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/server.js":
/*!*************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/server.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.combineFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = exports.TextDocuments = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "../shared/node_modules/vscode-languageserver/lib/common/utils/is.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "../shared/node_modules/vscode-languageserver/lib/common/utils/uuid.js");
const progress_1 = __webpack_require__(/*! ./progress */ "../shared/node_modules/vscode-languageserver/lib/common/progress.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "../shared/node_modules/vscode-languageserver/lib/common/configuration.js");
const workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ "../shared/node_modules/vscode-languageserver/lib/common/workspaceFolders.js");
const callHierarchy_1 = __webpack_require__(/*! ./callHierarchy */ "../shared/node_modules/vscode-languageserver/lib/common/callHierarchy.js");
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "../shared/node_modules/vscode-languageserver/lib/common/semanticTokens.js");
const showDocument_1 = __webpack_require__(/*! ./showDocument */ "../shared/node_modules/vscode-languageserver/lib/common/showDocument.js");
const fileOperations_1 = __webpack_require__(/*! ./fileOperations */ "../shared/node_modules/vscode-languageserver/lib/common/fileOperations.js");
const linkedEditingRange_1 = __webpack_require__(/*! ./linkedEditingRange */ "../shared/node_modules/vscode-languageserver/lib/common/linkedEditingRange.js");
const moniker_1 = __webpack_require__(/*! ./moniker */ "../shared/node_modules/vscode-languageserver/lib/common/moniker.js");
function null2Undefined(value) {
    if (value === null) {
        return undefined;
    }
    return value;
}
/**
 * A manager for simple text documents
 */
class TextDocuments {
    /**
     * Create a new text document manager.
     */
    constructor(configuration) {
        this._documents = Object.create(null);
        this._configuration = configuration;
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened or the content changes.
     */
    get onDidChangeContent() {
        return this._onDidChangeContent.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been opened.
     */
    get onDidOpen() {
        return this._onDidOpen.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * will be saved.
     */
    get onWillSave() {
        return this._onWillSave.event;
    }
    /**
     * Sets a handler that will be called if a participant wants to provide
     * edits during a text document save.
     */
    onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been saved.
     */
    get onDidSave() {
        return this._onDidSave.event;
    }
    /**
     * An event that fires when a text document managed by this manager
     * has been closed.
     */
    get onDidClose() {
        return this._onDidClose.event;
    }
    /**
     * Returns the document for the given URI. Returns undefined if
     * the document is not managed by this instance.
     *
     * @param uri The text document's URI to retrieve.
     * @return the text document or `undefined`.
     */
    get(uri) {
        return this._documents[uri];
    }
    /**
     * Returns all text documents managed by this instance.
     *
     * @return all text documents.
     */
    all() {
        return Object.keys(this._documents).map(key => this._documents[key]);
    }
    /**
     * Returns the URIs of all text documents managed by this instance.
     *
     * @return the URI's of all text documents.
     */
    keys() {
        return Object.keys(this._documents);
    }
    /**
     * Listens for `low level` notification on the given connection to
     * update the text documents managed by this instance.
     *
     * Please note that the connection only provides handlers not an event model. Therefore
     * listening on a connection will overwrite the following handlers on a connection:
     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,
     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.
     *
     * Use the corresponding events on the TextDocuments instance instead.
     *
     * @param connection The connection to listen on.
     */
    listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Full;
        connection.onDidOpenTextDocument((event) => {
            let td = event.textDocument;
            let document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
            this._documents[td.uri] = document;
            let toFire = Object.freeze({ document });
            this._onDidOpen.fire(toFire);
            this._onDidChangeContent.fire(toFire);
        });
        connection.onDidChangeTextDocument((event) => {
            let td = event.textDocument;
            let changes = event.contentChanges;
            if (changes.length === 0) {
                return;
            }
            let document = this._documents[td.uri];
            const { version } = td;
            if (version === null || version === undefined) {
                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
            }
            document = this._configuration.update(document, changes, version);
            this._documents[td.uri] = document;
            this._onDidChangeContent.fire(Object.freeze({ document }));
        });
        connection.onDidCloseTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                delete this._documents[event.textDocument.uri];
                this._onDidClose.fire(Object.freeze({ document }));
            }
        });
        connection.onWillSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onWillSave.fire(Object.freeze({ document, reason: event.reason }));
            }
        });
        connection.onWillSaveTextDocumentWaitUntil((event, token) => {
            let document = this._documents[event.textDocument.uri];
            if (document && this._willSaveWaitUntil) {
                return this._willSaveWaitUntil(Object.freeze({ document, reason: event.reason }), token);
            }
            else {
                return [];
            }
        });
        connection.onDidSaveTextDocument((event) => {
            let document = this._documents[event.textDocument.uri];
            if (document) {
                this._onDidSave.fire(Object.freeze({ document }));
            }
        });
    }
}
exports.TextDocuments = TextDocuments;
/**
 * Helps tracking error message. Equal occurrences of the same
 * message are only stored once. This class is for example
 * useful if text documents are validated in a loop and equal
 * error message should be folded into one.
 */
class ErrorMessageTracker {
    constructor() {
        this._messages = Object.create(null);
    }
    /**
     * Add a message to the tracker.
     *
     * @param message The message to add.
     */
    add(message) {
        let count = this._messages[message];
        if (!count) {
            count = 0;
        }
        count++;
        this._messages[message] = count;
    }
    /**
     * Send all tracked messages to the connection's window.
     *
     * @param connection The connection established between client and server.
     */
    sendErrors(connection) {
        Object.keys(this._messages).forEach(message => {
            connection.window.showErrorMessage(message);
        });
    }
}
exports.ErrorMessageTracker = ErrorMessageTracker;
class RemoteConsoleImpl {
    constructor() {
    }
    rawAttach(connection) {
        this._rawConnection = connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    fillServerCapabilities(_capabilities) {
    }
    initialize(_capabilities) {
    }
    error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
    }
    warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
    }
    info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
    }
    log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
    }
    send(type, message) {
        if (this._rawConnection) {
            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message });
        }
    }
}
class _RemoteWindowImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
    showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
    }
}
const RemoteWindowImpl = showDocument_1.ShowDocumentFeature(progress_1.ProgressFeature(_RemoteWindowImpl));
var BulkRegistration;
(function (BulkRegistration) {
    /**
     * Creates a new bulk registration.
     * @return an empty bulk registration.
     */
    function create() {
        return new BulkRegistrationImpl();
    }
    BulkRegistration.create = create;
})(BulkRegistration = exports.BulkRegistration || (exports.BulkRegistration = {}));
class BulkRegistrationImpl {
    constructor() {
        this._registrations = [];
        this._registered = new Set();
    }
    add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
            throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
            id: id,
            method: method,
            registerOptions: registerOptions || {}
        });
        this._registered.add(method);
    }
    asRegistrationParams() {
        return {
            registrations: this._registrations
        };
    }
}
var BulkUnregistration;
(function (BulkUnregistration) {
    function create() {
        return new BulkUnregistrationImpl(undefined, []);
    }
    BulkUnregistration.create = create;
})(BulkUnregistration = exports.BulkUnregistration || (exports.BulkUnregistration = {}));
class BulkUnregistrationImpl {
    constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = new Map();
        unregistrations.forEach(unregistration => {
            this._unregistrations.set(unregistration.method, unregistration);
        });
    }
    get isAttached() {
        return !!this._connection;
    }
    attach(connection) {
        this._connection = connection;
    }
    add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
    }
    dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
            unregistrations.push(unregistration);
        }
        let params = {
            unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this._connection.console.info(`Bulk unregistration failed.`);
        });
    }
    disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
            return false;
        }
        let params = {
            unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
            this._unregistrations.delete(method);
        }, (_error) => {
            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
    }
}
class RemoteClientImpl {
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
            return this.registerMany(typeOrRegistrations);
        }
        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        }
        else {
            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
    }
    registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
            unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            unregistration.add({ id: id, method: method });
            return unregistration;
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
            registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
            return vscode_languageserver_protocol_1.Disposable.create(() => {
                this.unregisterSingle(id, method);
            });
        }, (_error) => {
            this.connection.console.info(`Registering request handler for ${method} failed.`);
            return Promise.reject(_error);
        });
    }
    unregisterSingle(id, method) {
        let params = {
            unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(undefined, (_error) => {
            this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
    }
    registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));
        }, (_error) => {
            this.connection.console.info(`Bulk registration failed.`);
            return Promise.reject(_error);
        });
    }
}
class _RemoteWorkspaceImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
            return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
    }
}
const RemoteWorkspaceImpl = fileOperations_1.FileOperationsFeature(workspaceFolders_1.WorkspaceFoldersFeature(configuration_1.ConfigurationFeature(_RemoteWorkspaceImpl)));
class TracerImpl {
    constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    set trace(value) {
        this._trace = value;
    }
    log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
            return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
            message: message,
            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined
        });
    }
}
class TelemetryImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data);
    }
}
class _LanguagesImpl {
    constructor() {
    }
    attach(connection) {
        this._connection = connection;
    }
    get connection() {
        if (!this._connection) {
            throw new Error('Remote is not attached to a connection yet.');
        }
        return this._connection;
    }
    initialize(_capabilities) {
    }
    fillServerCapabilities(_capabilities) {
    }
    attachWorkDoneProgress(params) {
        return progress_1.attachWorkDone(this.connection, params);
    }
    attachPartialResultProgress(_type, params) {
        return progress_1.attachPartialResult(this.connection, params);
    }
}
exports._LanguagesImpl = _LanguagesImpl;
const LanguagesImpl = moniker_1.MonikerFeature(linkedEditingRange_1.LinkedEditingRangeFeature(semanticTokens_1.SemanticTokensFeature(callHierarchy_1.CallHierarchyFeature(_LanguagesImpl))));
function combineConsoleFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineConsoleFeatures = combineConsoleFeatures;
function combineTelemetryFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTelemetryFeatures = combineTelemetryFeatures;
function combineTracerFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineTracerFeatures = combineTracerFeatures;
function combineClientFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineClientFeatures = combineClientFeatures;
function combineWindowFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWindowFeatures = combineWindowFeatures;
function combineWorkspaceFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineWorkspaceFeatures = combineWorkspaceFeatures;
function combineLanguagesFeatures(one, two) {
    return function (Base) {
        return two(one(Base));
    };
}
exports.combineLanguagesFeatures = combineLanguagesFeatures;
function combineFeatures(one, two) {
    function combine(one, two, func) {
        if (one && two) {
            return func(one, two);
        }
        else if (one) {
            return one;
        }
        else {
            return two;
        }
    }
    let result = {
        __brand: 'features',
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures)
    };
    return result;
}
exports.combineFeatures = combineFeatures;
function createConnection(connectionFactory, watchDog, factories) {
    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());
    const connection = connectionFactory(logger);
    logger.rawAttach(connection);
    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());
    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());
    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());
    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());
    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());
    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());
    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages];
    function asPromise(value) {
        if (value instanceof Promise) {
            return value;
        }
        else if (Is.thenable(value)) {
            return new Promise((resolve, reject) => {
                value.then((resolved) => resolve(resolved), (error) => reject(error));
            });
        }
        else {
            return Promise.resolve(value);
        }
    }
    let shutdownHandler = undefined;
    let initializeHandler = undefined;
    let exitHandler = undefined;
    let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
            const method = Is.string(type) ? type : type.method;
            if (arguments.length === 1) {
                connection.sendNotification(method);
            }
            else {
                connection.sendNotification(method, param);
            }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => initializeHandler = handler,
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => shutdownHandler = handler,
        onExit: (handler) => exitHandler = handler,
        get console() { return logger; },
        get telemetry() { return telemetry; },
        get tracer() { return tracer; },
        get client() { return client; },
        get window() { return remoteWindow; },
        get workspace() { return workspace; },
        get languages() { return languages; },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: undefined,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
            return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), progress_1.attachPartialResult(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
            return handler(params, cancel, progress_1.attachWorkDone(connection, params), undefined);
        }),
        dispose: () => connection.dispose()
    };
    for (let remote of allRemotes) {
        remote.attach(protocolConnection);
    }
    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
            remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, progress_1.attachWorkDone(connection, params), undefined);
            return asPromise(result).then((value) => {
                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
                    return value;
                }
                let result = value;
                if (!result) {
                    result = { capabilities: {} };
                }
                let capabilities = result.capabilities;
                if (!capabilities) {
                    capabilities = {};
                    result.capabilities = capabilities;
                }
                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {
                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
                }
                for (let remote of allRemotes) {
                    remote.fillServerCapabilities(capabilities);
                }
                return result;
            });
        }
        else {
            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
            for (let remote of allRemotes) {
                remote.fillServerCapabilities(result.capabilities);
            }
            return result;
        }
    });
    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        }
        else {
            return undefined;
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
            if (exitHandler) {
                exitHandler();
            }
        }
        finally {
            if (watchDog.shutdownReceived) {
                watchDog.exit(0);
            }
            else {
                watchDog.exit(1);
            }
        }
    });
    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
    });
    return protocolConnection;
}
exports.createConnection = createConnection;
//# sourceMappingURL=server.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/showDocument.js":
/*!*******************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/showDocument.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const ShowDocumentFeature = (Base) => {
    return class extends Base {
        showDocument(params) {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
    };
};
exports.ShowDocumentFeature = ShowDocumentFeature;
//# sourceMappingURL=showDocument.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/utils/is.js":
/*!***************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/utils/is.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/utils/uuid.js":
/*!*****************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/utils/uuid.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/common/workspaceFolders.js":
/*!***********************************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/common/workspaceFolders.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "../shared/node_modules/vscode-languageserver-protocol/lib/node/main.js");
const WorkspaceFoldersFeature = (Base) => {
    return class extends Base {
        constructor() {
            super();
            this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
            super.initialize(capabilities);
            let workspaceCapabilities = capabilities.workspace;
            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
                    this._onDidChangeWorkspaceFolders.fire(params.event);
                });
            }
        }
        fillServerCapabilities(capabilities) {
            var _a, _b;
            super.fillServerCapabilities(capabilities);
            const changeNotifications = (_b = (_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.workspaceFolders) === null || _b === void 0 ? void 0 : _b.changeNotifications;
            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';
        }
        getWorkspaceFolders() {
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
            if (!this._onDidChangeWorkspaceFolders) {
                throw new Error('Client doesn\'t support sending workspace folder change events.');
            }
            if (!this._notificationIsAutoRegistered && !this._unregistration) {
                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
            }
            return this._onDidChangeWorkspaceFolders.event;
        }
    };
};
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/node/files.js":
/*!**********************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/node/files.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;
const url = __webpack_require__(/*! url */ "url");
const path = __webpack_require__(/*! path */ "path");
const fs = __webpack_require__(/*! fs */ "fs");
const child_process_1 = __webpack_require__(/*! child_process */ "child_process");
/**
 * @deprecated Use the `vscode-uri` npm module which provides a more
 * complete implementation of handling VS Code URIs.
 */
function uriToFilePath(uri) {
    let parsed = url.parse(uri);
    if (parsed.protocol !== 'file:' || !parsed.path) {
        return undefined;
    }
    let segments = parsed.path.split('/');
    for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
    }
    if (process.platform === 'win32' && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        // Do we have a drive letter and we started with a / which is the
        // case if the first segement is empty (see split above)
        if (first.length === 0 && second.length > 1 && second[1] === ':') {
            // Remove first slash
            segments.shift();
        }
    }
    return path.normalize(segments.join('/'));
}
exports.uriToFilePath = uriToFilePath;
function isWindows() {
    return process.platform === 'win32';
}
function resolve(moduleName, nodePath, cwd, tracer) {
    const nodePathKey = 'NODE_PATH';
    const app = [
        'var p = process;',
        'p.on(\'message\',function(m){',
        'if(m.c===\'e\'){',
        'p.exit(0);',
        '}',
        'else if(m.c===\'rs\'){',
        'try{',
        'var r=require.resolve(m.a);',
        'p.send({c:\'r\',s:true,r:r});',
        '}',
        'catch(err){',
        'p.send({c:\'r\',s:false});',
        '}',
        '}',
        '});'
    ].join('');
    return new Promise((resolve, reject) => {
        let env = process.env;
        let newEnv = Object.create(null);
        Object.keys(env).forEach(key => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {
            if (newEnv[nodePathKey]) {
                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
            }
            else {
                newEnv[nodePathKey] = nodePath;
            }
            if (tracer) {
                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
            }
        }
        newEnv['ELECTRON_RUN_AS_NODE'] = '1';
        try {
            let cp = child_process_1.fork('', [], {
                cwd: cwd,
                env: newEnv,
                execArgv: ['-e', app]
            });
            if (cp.pid === void 0) {
                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
                return;
            }
            cp.on('error', (error) => {
                reject(error);
            });
            cp.on('message', (message) => {
                if (message.c === 'r') {
                    cp.send({ c: 'e' });
                    if (message.s) {
                        resolve(message.r);
                    }
                    else {
                        reject(new Error(`Failed to resolve module: ${moduleName}`));
                    }
                }
            });
            let message = {
                c: 'rs',
                a: moduleName
            };
            cp.send(message);
        }
        catch (error) {
            reject(error);
        }
    });
}
exports.resolve = resolve;
/**
 * Resolve the global npm package path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalNodePath(tracer) {
    let npmCommand = 'npm';
    const env = Object.create(null);
    Object.keys(process.env).forEach(key => env[key] = process.env[key]);
    env['NO_UPDATE_NOTIFIER'] = 'true';
    const options = {
        encoding: 'utf8',
        env
    };
    if (isWindows()) {
        npmCommand = 'npm.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let stdout = child_process_1.spawnSync(npmCommand, ['config', 'get', 'prefix'], options).stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'npm config get prefix' didn't return a value.`);
            }
            return undefined;
        }
        let prefix = stdout.trim();
        if (tracer) {
            tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
            if (isWindows()) {
                return path.join(prefix, 'node_modules');
            }
            else {
                return path.join(prefix, 'lib', 'node_modules');
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalNodePath = resolveGlobalNodePath;
/*
 * Resolve the global yarn pakage path.
 * @deprecated Since this depends on the used package manager and their version the best is that servers
 * implement this themselves since they know best what kind of package managers to support.
 * @param tracer the tracer to use
 */
function resolveGlobalYarnPath(tracer) {
    let yarnCommand = 'yarn';
    let options = {
        encoding: 'utf8'
    };
    if (isWindows()) {
        yarnCommand = 'yarn.cmd';
        options.shell = true;
    }
    let handler = () => { };
    try {
        process.on('SIGPIPE', handler);
        let results = child_process_1.spawnSync(yarnCommand, ['global', 'dir', '--json'], options);
        let stdout = results.stdout;
        if (!stdout) {
            if (tracer) {
                tracer(`'yarn global dir' didn't return a value.`);
                if (results.stderr) {
                    tracer(results.stderr);
                }
            }
            return undefined;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
            try {
                let yarn = JSON.parse(line);
                if (yarn.type === 'log') {
                    return path.join(yarn.data, 'node_modules');
                }
            }
            catch (e) {
                // Do nothing. Ignore the line
            }
        }
        return undefined;
    }
    catch (err) {
        return undefined;
    }
    finally {
        process.removeListener('SIGPIPE', handler);
    }
}
exports.resolveGlobalYarnPath = resolveGlobalYarnPath;
var FileSystem;
(function (FileSystem) {
    let _isCaseSensitive = undefined;
    function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
            return _isCaseSensitive;
        }
        if (process.platform === 'win32') {
            _isCaseSensitive = false;
        }
        else {
            // convert current file name to upper case / lower case and check if file exists
            // (guards against cases when name is already all uppercase or lowercase)
            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
    }
    FileSystem.isCaseSensitive = isCaseSensitive;
    function isParent(parent, child) {
        if (isCaseSensitive()) {
            return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        }
        else {
            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
    }
    FileSystem.isParent = isParent;
})(FileSystem = exports.FileSystem || (exports.FileSystem = {}));
function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
    if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
            nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
            if (FileSystem.isParent(nodePath, value)) {
                return value;
            }
            else {
                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
            }
        }).then(undefined, (_error) => {
            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
    }
    else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
    }
}
exports.resolveModulePath = resolveModulePath;
//# sourceMappingURL=files.js.map

/***/ }),

/***/ "../shared/node_modules/vscode-languageserver/lib/node/main.js":
/*!*********************************************************************!*\
  !*** ../shared/node_modules/vscode-languageserver/lib/node/main.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConnection = exports.Files = void 0;
const Is = __webpack_require__(/*! ../common/utils/is */ "../shared/node_modules/vscode-languageserver/lib/common/utils/is.js");
const server_1 = __webpack_require__(/*! ../common/server */ "../shared/node_modules/vscode-languageserver/lib/common/server.js");
const fm = __webpack_require__(/*! ./files */ "../shared/node_modules/vscode-languageserver/lib/node/files.js");
const node_1 = __webpack_require__(/*! vscode-languageserver-protocol/node */ "../shared/node_modules/vscode-languageserver-protocol/node.js");
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/node */ "../shared/node_modules/vscode-languageserver-protocol/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "../shared/node_modules/vscode-languageserver/lib/common/api.js"), exports);
var Files;
(function (Files) {
    Files.uriToFilePath = fm.uriToFilePath;
    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;
    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
    Files.resolve = fm.resolve;
    Files.resolveModulePath = fm.resolveModulePath;
})(Files = exports.Files || (exports.Files = {}));
let _protocolConnection;
function endProtocolConnection() {
    if (_protocolConnection === undefined) {
        return;
    }
    try {
        _protocolConnection.end();
    }
    catch (_err) {
        // Ignore. The client process could have already
        // did and we can't send an end into the connection.
    }
}
let _shutdownReceived = false;
let exitTimer = undefined;
function setupExitTimer() {
    const argName = '--clientProcessId';
    function runTimer(value) {
        try {
            let processId = parseInt(value);
            if (!isNaN(processId)) {
                exitTimer = setInterval(() => {
                    try {
                        process.kill(processId, 0);
                    }
                    catch (ex) {
                        // Parent process doesn't exist anymore. Exit the server.
                        endProtocolConnection();
                        process.exit(_shutdownReceived ? 0 : 1);
                    }
                }, 3000);
            }
        }
        catch (e) {
            // Ignore errors;
        }
    }
    for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
            runTimer(process.argv[i + 1]);
            return;
        }
        else {
            let args = arg.split('=');
            if (args[0] === argName) {
                runTimer(args[1]);
            }
        }
    }
}
setupExitTimer();
const watchDog = {
    initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === undefined) {
            // We received a parent process id. Set up a timer to periodically check
            // if the parent is still alive.
            setInterval(() => {
                try {
                    process.kill(processId, 0);
                }
                catch (ex) {
                    // Parent process doesn't exist anymore. Exit the server.
                    process.exit(_shutdownReceived ? 0 : 1);
                }
            }, 3000);
        }
    },
    get shutdownReceived() {
        return _shutdownReceived;
    },
    set shutdownReceived(value) {
        _shutdownReceived = value;
    },
    exit: (code) => {
        endProtocolConnection();
        process.exit(code);
    }
};
function createConnection(arg1, arg2, arg3, arg4) {
    let factories;
    let input;
    let output;
    let options;
    if (arg1 !== void 0 && arg1.__brand === 'features') {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
    }
    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
    }
    else {
        input = arg1;
        output = arg2;
        options = arg3;
    }
    return _createConnection(input, output, options, factories);
}
exports.createConnection = createConnection;
function _createConnection(input, output, options, factories) {
    if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
            let arg = argv[i];
            if (arg === '--node-ipc') {
                input = new node_1.IPCMessageReader(process);
                output = new node_1.IPCMessageWriter(process);
                break;
            }
            else if (arg === '--stdio') {
                input = process.stdin;
                output = process.stdout;
                break;
            }
            else if (arg === '--socket') {
                port = parseInt(argv[i + 1]);
                break;
            }
            else if (arg === '--pipe') {
                pipeName = argv[i + 1];
                break;
            }
            else {
                var args = arg.split('=');
                if (args[0] === '--socket') {
                    port = parseInt(args[1]);
                    break;
                }
                else if (args[0] === '--pipe') {
                    pipeName = args[1];
                    break;
                }
            }
        }
        if (port) {
            let transport = node_1.createServerSocketTransport(port);
            input = transport[0];
            output = transport[1];
        }
        else if (pipeName) {
            let transport = node_1.createServerPipeTransport(pipeName);
            input = transport[0];
            output = transport[1];
        }
    }
    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \'--node-ipc\', \'--stdio\' or \'--socket={number}\'';
    if (!input) {
        throw new Error('Connection input stream is not set. ' + commandLineMessage);
    }
    if (!output) {
        throw new Error('Connection output stream is not set. ' + commandLineMessage);
    }
    // Backwards compatibility
    if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on('end', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on('close', () => {
            endProtocolConnection();
            process.exit(_shutdownReceived ? 0 : 1);
        });
    }
    const connectionFactory = (logger) => {
        const result = node_1.createProtocolConnection(input, output, logger, options);
        return result;
    };
    return server_1.createConnection(connectionFactory, watchDog, factories);
}
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/@alipay/mac-address/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@alipay/mac-address/lib/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const address = __importStar(__webpack_require__(/*! address */ "./node_modules/address/lib/address.js"));
const os_1 = __webpack_require__(/*! os */ "os");
const macRegex = /(?:[a-z0-9]{1,2}[:-]){5}[a-z0-9]{1,2}/i;
const zeroRegex = /(?:[0]{1,2}[:-]){5}[0]{1,2}/;
const invalidMacAddresses = new Set([
    '00:00:00:00:00:00',
    'ff:ff:ff:ff:ff:ff',
    'ac:de:48:00:11:22',
    '00:50:56:c0:00:01',
    '02:00:4c:4f:4f:50'
]);
/******* copy get mac start *******/
/**
 * Get the first proper MAC address
 * @param iface If provided, restrict MAC address fetching to this interface
 */
function getMAC(iface) {
    const list = os_1.networkInterfaces();
    if (iface) {
        const parts = list[iface];
        if (!parts) {
            throw new Error(`interface ${iface} was not found`);
        }
        for (const part of parts) {
            const _mac = part.mac.toLowerCase();
            if (!invalidMacAddresses.has(_mac)) {
                return part.mac;
            }
        }
        throw new Error(`interface ${iface} had no valid mac addresses`);
    }
    else {
        for (const key of Object.keys(list)) {
            const parts = list[key];
            for (const part of parts) {
                const _mac = part.mac.toLowerCase();
                if (!invalidMacAddresses.has(_mac)) {
                    return part.mac;
                }
            }
        }
    }
    throw new Error('failed to get the MAC address');
}
/** Check if the input is a valid MAC address */
function isMAC(macAddress) {
    return macRegex.test(macAddress);
}
/******* copy get mac end *******/
let cachedMacAddress = null;
function getMacAddress() {
    return new Promise((resolve, reject) => {
        if (cachedMacAddress) {
            resolve(cachedMacAddress);
            return;
        }
        try {
            const macAddr = getMAC();
            if (macAddr) {
                cachedMacAddress = macAddr;
                resolve(macAddr);
            }
            else {
                address.mac((err, addr) => {
                    if (err || !addr) {
                        reject(err);
                    }
                    else {
                        resolve(addr);
                    }
                });
            }
        }
        catch (error) {
            address.mac((err, addr) => {
                if (err || !addr) {
                    reject(err);
                }
                else {
                    resolve(addr);
                }
            });
        }
    });
}
exports.getMacAddress = getMacAddress;


/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/global/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/global/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./plugin */ "./node_modules/@alipay/mini-api-types/lib/global/plugin.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/global/plugin.js":
/*!******************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/global/plugin.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=plugin.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Global = exports.API = void 0;
var public_1 = __webpack_require__(/*! ./public */ "./node_modules/@alipay/mini-api-types/lib/public/index.js");
Object.defineProperty(exports, "API", ({ enumerable: true, get: function () { return public_1.API; } }));
exports.Global = __importStar(__webpack_require__(/*! ./global */ "./node_modules/@alipay/mini-api-types/lib/global/index.js"));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/apis/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/apis/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./apis */ "./node_modules/@alipay/mini-api-types/lib/public/apis/index.js"), exports);
__exportStar(__webpack_require__(/*! ./type */ "./node_modules/@alipay/mini-api-types/lib/public/type/index.js"), exports);
__exportStar(__webpack_require__(/*! ./validate */ "./node_modules/@alipay/mini-api-types/lib/public/validate.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/bridge.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/bridge.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=bridge.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./bridge */ "./node_modules/@alipay/mini-api-types/lib/public/type/bridge.js"), exports);
__exportStar(__webpack_require__(/*! ./lib */ "./node_modules/@alipay/mini-api-types/lib/public/type/lib.js"), exports);
__exportStar(__webpack_require__(/*! ./meta */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/index.js"), exports);
__exportStar(__webpack_require__(/*! ./registry */ "./node_modules/@alipay/mini-api-types/lib/public/type/registry.js"), exports);
__exportStar(__webpack_require__(/*! ./state */ "./node_modules/@alipay/mini-api-types/lib/public/type/state.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/lib.js":
/*!********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/lib.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=lib.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/api.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/api.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.API = void 0;
var API;
(function (API) {
    // 应用
    // 基础能力
    API["arrayBufferToBase64"] = "arrayBufferToBase64";
    API["base64ToArrayBuffer"] = "base64ToArrayBuffer";
    //   版本管理
    API["getRunScene"] = "getRunScene";
    API["getUpdateManager"] = "getUpdateManager";
    API["ap$updateAlipayClient"] = "ap.updateAlipayClient";
    API["SDKVersion"] = "SDKVersion";
    API["isIDE"] = "isIDE";
    //   应用信息
    API["getLaunchOptionsSync"] = "getLaunchOptionsSync";
    API["getEnterOptionsSync"] = "getEnterOptionsSync";
    API["getAppIdSync"] = "getAppIdSync";
    //   生命周期
    API["onAppShow"] = "onAppShow";
    API["offAppShow"] = "offAppShow";
    API["onAppHide"] = "onAppHide";
    API["offAppHide"] = "offAppHide";
    API["exit"] = "exit";
    API["onPageNotFound"] = "onPageNotFound";
    API["offPageNotFound"] = "offPageNotFound";
    //   异常监控
    API["onUnhandledRejection"] = "onUnhandledRejection";
    API["offUnhandledRejection"] = "offUnhandledRejection";
    API["onError"] = "onError";
    API["offError"] = "offError";
    API["onComponentError"] = "onComponentError";
    API["offComponentError"] = "offComponentError";
    //   埋点上报
    API["reportAnalytics"] = "reportAnalytics";
    API["reportCustomEvent"] = "reportCustomEvent";
    API["reportCustomError"] = "reportCustomError";
    API["getChinfoChain"] = "getChinfoChain";
    API["appendChinfoChain"] = "appendChinfoChain";
    API["reportBizReady"] = "reportBizReady";
    // 导航路由
    //   应用内页面跳转
    API["navigateBack"] = "navigateBack";
    API["navigateTo"] = "navigateTo";
    API["reLaunch"] = "reLaunch";
    API["redirectTo"] = "redirectTo";
    API["switchTab"] = "switchTab";
    // 视图界面
    //   节点操作
    API["createAnimation"] = "createAnimation";
    API["createSelectorQuery"] = "createSelectorQuery";
    API["createIntersectionObserver"] = "createIntersectionObserver";
    //   字体
    API["loadFontFace"] = "loadFontFace";
    //   滚动
    API["pageScrollTo"] = "pageScrollTo";
    //   下拉刷新
    API["stopPullDownRefresh"] = "stopPullDownRefresh";
    API["setCanPullDown"] = "setCanPullDown";
    API["startPullDownRefresh"] = "startPullDownRefresh";
    API["setViewTop"] = "setViewTop";
    //   窗口背景
    API["setBackgroundColor"] = "setBackgroundColor";
    API["setBackgroundTextStyle"] = "setBackgroundTextStyle";
    /**
     * @deprecated
     */
    API["setWebViewTop"] = "setWebViewTop";
    /**
     * @deprecated
     */
    API["setBackgroundImage"] = "setBackgroundImage";
    /**
     * @deprecated
     */
    API["removeBackgroundImage"] = "removeBackgroundImage";
    //   TabBar
    API["addTabBarItem"] = "addTabBarItem";
    API["removeTabBarItem"] = "removeTabBarItem";
    API["hideTabBar"] = "hideTabBar";
    API["showTabBar"] = "showTabBar";
    API["setTabBarItem"] = "setTabBarItem";
    API["setTabBarStyle"] = "setTabBarStyle";
    API["hideTabBarRedDot"] = "hideTabBarRedDot";
    API["showTabBarRedDot"] = "showTabBarRedDot";
    API["removeTabBarBadge"] = "removeTabBarBadge";
    API["setTabBarBadge"] = "setTabBarBadge";
    //   导航栏
    //     标题
    API["setTransparentTitle"] = "setTransparentTitle";
    API["setNavigationBar"] = "setNavigationBar";
    API["getTitleColor"] = "getTitleColor";
    API["onTitleCloseClick"] = "onTitleCloseClick";
    API["offTitleCloseClick"] = "offTitleCloseClick";
    API["onTitleMoreClick"] = "onTitleMoreClick";
    API["offTitleMoreClick"] = "offTitleMoreClick";
    API["showNavigationBarLoading"] = "showNavigationBarLoading";
    API["hideNavigationBarLoading"] = "hideNavigationBarLoading";
    API["hideDebugVersion"] = "hideDebugVersion";
    //     按钮
    API["setBackButton"] = "setBackButton";
    API["showBackToHomepage"] = "showBackToHomepage";
    API["hideBackHome"] = "hideBackHome";
    API["setCustomPopMenu"] = "setCustomPopMenu";
    API["hideAddToDesktopMenu"] = "hideAddToDesktopMenu";
    API["hideAllAddToDesktopMenu"] = "hideAllAddToDesktopMenu";
    API["setOptionMenu"] = "setOptionMenu";
    API["getMenuButtonBoundingClientRect"] = "getMenuButtonBoundingClientRect";
    //   小程序设置
    API["openSetting"] = "openSetting";
    API["ap$openSetting"] = "ap.openSetting";
    API["getSetting"] = "getSetting";
    API["ap$getSetting"] = "ap.getSetting";
    //   交互反馈
    API["alert"] = "alert";
    API["confirm"] = "confirm";
    API["prompt"] = "prompt";
    API["showLoading"] = "showLoading";
    API["hideLoading"] = "hideLoading";
    API["showToast"] = "showToast";
    API["hideToast"] = "hideToast";
    //   键盘
    API["hideKeyboard"] = "hideKeyboard";
    API["getSelectedTextRange"] = "getSelectedTextRange";
    //   多选项
    API["showActionSheet"] = "showActionSheet";
    API["multiLevelSelect"] = "multiLevelSelect";
    API["optionsSelect"] = "optionsSelect";
    API["datePicker"] = "datePicker";
    // 组件
    //   画布(2D)
    API["createCanvasContext"] = "createCanvasContext";
    API["canvasToTempFilePath"] = "canvasToTempFilePath";
    API["preloadCanvasImage"] = "preloadCanvasImage";
    // 统一放到多媒体吧。。
    API["createLottieContext"] = "createLottieContext";
    API["createWebViewContext"] = "createWebViewContext";
    API["createRtcRoomContext"] = "createRtcRoomContext";
    // 设备
    // mdns
    API["onLocalServiceResolveFail"] = "onLocalServiceResolveFail";
    API["onLocalServiceLost"] = "onLocalServiceLost";
    API["onLocalServiceFound"] = "onLocalServiceFound";
    API["onLocalServiceDiscoveryStop"] = "onLocalServiceDiscoveryStop";
    API["offLocalServiceResolveFail"] = "offLocalServiceResolveFail";
    API["offLocalServiceLost"] = "offLocalServiceLost";
    API["offLocalServiceFound"] = "offLocalServiceFound";
    API["offLocalServiceDiscoveryStop"] = "offLocalServiceDiscoveryStop";
    API["stopLocalServiceDiscovery"] = "stopLocalServiceDiscovery";
    API["startLocalServiceDiscovery"] = "startLocalServiceDiscovery";
    //   服务端时间
    API["getServerTime"] = "getServerTime";
    //   标识符
    API["getDeviceID"] = "getDeviceID";
    API["getDeviceInfo"] = "getDeviceInfo";
    //   系统信息
    API["env"] = "env";
    API["getSystemInfo"] = "getSystemInfo";
    API["getSystemInfoSync"] = "getSystemInfoSync";
    //   联系人
    API["chooseContact"] = "chooseContact";
    API["choosePhoneContact"] = "choosePhoneContact";
    API["chooseAlipayContact"] = "chooseAlipayContact";
    API["addPhoneContact"] = "addPhoneContact";
    //   运动传感器
    API["onGyroscopeChange"] = "onGyroscopeChange";
    API["offGyroscopeChange"] = "offGyroscopeChange";
    API["onAccelerometerChange"] = "onAccelerometerChange";
    API["offAccelerometerChange"] = "offAccelerometerChange";
    API["onCompassChange"] = "onCompassChange";
    API["offCompassChange"] = "offCompassChange";
    API["onDeviceMotionChange"] = "onDeviceMotionChange";
    API["offDeviceMotionChange"] = "offDeviceMotionChange";
    //   振动
    API["vibrate"] = "vibrate";
    API["watchShake"] = "watchShake";
    API["vibrateLong"] = "vibrateLong";
    API["vibrateShort"] = "vibrateShort";
    //   屏幕
    //     亮度
    API["getScreenBrightness"] = "getScreenBrightness";
    API["setScreenBrightness"] = "setScreenBrightness";
    API["setKeepScreenOn"] = "setKeepScreenOn";
    //     截屏
    API["onUserCaptureScreen"] = "onUserCaptureScreen";
    API["offUserCaptureScreen"] = "offUserCaptureScreen";
    //     朝向
    API["setScreenOrientation"] = "setScreenOrientation";
    API["getScreenOrientation"] = "getScreenOrientation";
    //   剪贴板
    API["setClipboard"] = "setClipboard";
    API["getClipboard"] = "getClipboard";
    //   电话短信
    API["makePhoneCall"] = "makePhoneCall";
    API["sendSMS"] = "sendSMS";
    //   日历
    API["addEventCal"] = "addEventCal";
    API["addEventCalendar"] = "addEventCalendar";
    //   电源
    API["getBatteryInfo"] = "getBatteryInfo";
    API["getBatteryInfoSync"] = "getBatteryInfoSync";
    API["onLowPowerWarning"] = "onLowPowerWarning";
    API["offLowPowerWarning"] = "offLowPowerWarning";
    API["isLowPowerMode"] = "isLowPowerMode";
    //   内存
    API["onMemoryWarning"] = "onMemoryWarning";
    API["offMemoryWarning"] = "offMemoryWarning";
    //   网络状态
    API["getCarrierName"] = "getCarrierName";
    API["getNetworkType"] = "getNetworkType";
    API["onNetworkStatusChange"] = "onNetworkStatusChange";
    API["offNetworkStatusChange"] = "offNetworkStatusChange";
    //   WiFi 连接
    API["startWifi"] = "startWifi";
    API["stopWifi"] = "stopWifi";
    API["connectWifi"] = "connectWifi";
    API["getWifiList"] = "getWifiList";
    API["setWifiList"] = "setWifiList";
    API["getConnectedWifi"] = "getConnectedWifi";
    API["onGetWifiList"] = "onGetWifiList";
    API["offGetWifiList"] = "offGetWifiList";
    API["onWifiConnected"] = "onWifiConnected";
    API["offWifiConnected"] = "offWifiConnected";
    API["getWifiBroadcastInfo"] = "getWifiBroadcastInfo";
    API["registerSSID"] = "registerSSID";
    API["unregisterSSID"] = "unregisterSSID";
    //   NFC
    //      交通卡
    API["showAuthenticDialog"] = "showAuthenticDialog";
    API["seNFCServiceIsv"] = "seNFCServiceIsv";
    //     模拟卡
    API["getHCEState"] = "getHCEState";
    API["startHCE"] = "startHCE";
    API["stopHCE"] = "stopHCE";
    API["onHCEMessage"] = "onHCEMessage";
    API["offHCEMessage"] = "offHCEMessage";
    API["sendHCEMessage"] = "sendHCEMessage";
    //       设备安全
    API["rsa"] = "rsa";
    API["isSystemRoot"] = "isSystemRoot";
    //   蓝牙
    //      传统蓝牙
    API["openBluetoothAdapter"] = "openBluetoothAdapter";
    API["closeBluetoothAdapter"] = "closeBluetoothAdapter";
    API["getBluetoothAdapterState"] = "getBluetoothAdapterState";
    API["startBluetoothDevicesDiscovery"] = "startBluetoothDevicesDiscovery";
    API["stopBluetoothDevicesDiscovery"] = "stopBluetoothDevicesDiscovery";
    API["getBluetoothDevices"] = "getBluetoothDevices";
    API["getConnectedBluetoothDevices"] = "getConnectedBluetoothDevices";
    API["onBluetoothAdapterStateChange"] = "onBluetoothAdapterStateChange";
    API["offBluetoothAdapterStateChange"] = "offBluetoothAdapterStateChange";
    API["onBluetoothDeviceFound"] = "onBluetoothDeviceFound";
    API["offBluetoothDeviceFound"] = "offBluetoothDeviceFound";
    //       低功耗蓝牙
    API["connectBLEDevice"] = "connectBLEDevice";
    API["disconnectBLEDevice"] = "disconnectBLEDevice";
    API["getBLEDeviceServices"] = "getBLEDeviceServices";
    API["getBLEDeviceCharacteristics"] = "getBLEDeviceCharacteristics";
    API["notifyBLECharacteristicValueChange"] = "notifyBLECharacteristicValueChange";
    API["onBLECharacteristicValueChange"] = "onBLECharacteristicValueChange";
    API["offBLECharacteristicValueChange"] = "offBLECharacteristicValueChange";
    API["onBLEConnectionStateChanged"] = "onBLEConnectionStateChanged";
    API["offBLEConnectionStateChanged"] = "offBLEConnectionStateChanged";
    API["writeBLECharacteristicValue"] = "writeBLECharacteristicValue";
    API["readBLECharacteristicValue"] = "readBLECharacteristicValue";
    API["cancelBluetoothPair"] = "cancelBluetoothPair";
    API["getBluetoothPairs"] = "getBluetoothPairs";
    //      蓝牙从模式
    API["openBLEPeripheral"] = "openBLEPeripheral";
    API["closeBLEPeripheral"] = "closeBLEPeripheral";
    API["addPeripheralService"] = "addPeripheralService";
    API["removePeripheralService"] = "removePeripheralService";
    API["updateCharacteristic"] = "updateCharacteristic";
    API["startBLEAdvertising"] = "startBLEAdvertising";
    API["stopBLEAdvertising"] = "stopBLEAdvertising";
    API["onDeviceConnected"] = "onDeviceConnected";
    API["offDeviceConnected"] = "offDeviceConnected";
    API["onDeviceDisconnected"] = "onDeviceDisconnected";
    API["offDeviceDisconnected"] = "offDeviceDisconnected";
    API["onCharacteristicRead"] = "onCharacteristicRead";
    API["offCharacteristicRead"] = "offCharacteristicRead";
    API["onCharacteristicWrite"] = "onCharacteristicWrite";
    API["offCharacteristicWrite"] = "offCharacteristicWrite";
    API["onCharacteristicDidSubscribe"] = "onCharacteristicDidSubscribe";
    API["offCharacteristicDidSubscribe"] = "offCharacteristicDidSubscribe";
    API["onCharacteristicDidUnsubscribe"] = "onCharacteristicDidUnsubscribe";
    API["offCharacteristicDidUnsubscribe"] = "offCharacteristicDidUnsubscribe";
    //      iBeacon
    API["startBeaconDiscovery"] = "startBeaconDiscovery";
    API["stopBeaconDiscovery"] = "stopBeaconDiscovery";
    API["getBeacons"] = "getBeacons";
    API["onBeaconUpdate"] = "onBeaconUpdate";
    API["offBeaconUpdate"] = "offBeaconUpdate";
    API["onBeaconServiceChange"] = "onBeaconServiceChange";
    API["offBeaconServiceChange"] = "offBeaconServiceChange";
    // 位置
    //    用户操作定位
    API["chooseLocation"] = "chooseLocation";
    API["chooseCity"] = "chooseCity";
    API["onLocatedComplete"] = "onLocatedComplete";
    API["offLocatedComplete"] = "offLocatedComplete";
    API["openLocation"] = "openLocation";
    API["regionPicker"] = "regionPicker";
    //    接口操作定位
    API["getLocation"] = "getLocation";
    API["reGeoCode"] = "reGeoCode";
    API["geoCode"] = "geoCode";
    API["setLocatedCity"] = "setLocatedCity";
    //    持续定位
    API["onContinuousLocation"] = "onContinuousLocation";
    API["offContinuousLocation"] = "offContinuousLocation";
    API["startContinuousLocation"] = "startContinuousLocation";
    API["stopContinuousLocation"] = "stopContinuousLocation";
    //  网络请求
    //    Http 请求
    API["request"] = "request";
    API["httpRequest"] = "httpRequest";
    //    网关请求
    API["rpc"] = "rpc";
    API["sendMtop"] = "sendMtop";
    API["openRpc"] = "openRpc";
    //    Socket 请求
    API["connectSocket"] = "connectSocket";
    API["sendSocketMessage"] = "sendSocketMessage";
    API["closeSocket"] = "closeSocket";
    API["onSocketOpen"] = "onSocketOpen";
    API["offSocketOpen"] = "offSocketOpen";
    API["onSocketMessage"] = "onSocketMessage";
    API["offSocketMessage"] = "offSocketMessage";
    API["onSocketError"] = "onSocketError";
    API["offSocketError"] = "offSocketError";
    API["onSocketClose"] = "onSocketClose";
    API["offSocketClose"] = "offSocketClose";
    //    TCP/UDP
    API["createTCPSocket"] = "createTCPSocket";
    API["createUDPSocket"] = "createUDPSocket";
    //    上传下载
    API["uploadFile"] = "uploadFile";
    API["uploadFileToAliCloud"] = "uploadFileToAliCloud";
    API["downloadFile"] = "downloadFile";
    // 文件与存储
    //    键值对缓存
    API["setStorage"] = "setStorage";
    API["getStorage"] = "getStorage";
    API["removeStorage"] = "removeStorage";
    API["clearStorage"] = "clearStorage";
    API["getStorageInfo"] = "getStorageInfo";
    API["setStorageSync"] = "setStorageSync";
    API["getStorageSync"] = "getStorageSync";
    API["removeStorageSync"] = "removeStorageSync";
    API["clearStorageSync"] = "clearStorageSync";
    API["getStorageInfoSync"] = "getStorageInfoSync";
    //    文件存储
    API["chooseFileFromDisk"] = "chooseFileFromDisk";
    API["saveFile"] = "saveFile";
    API["removeSavedFile"] = "removeSavedFile";
    API["openDocument"] = "openDocument";
    API["getSavedFileList"] = "getSavedFileList";
    API["getSavedFileInfo"] = "getSavedFileInfo";
    API["getFileInfo"] = "getFileInfo";
    //    文件系统
    API["getFileSystemManager"] = "getFileSystemManager";
    // 性能计算
    API["createXnnManager"] = "createXnnManager";
    API["createWorker"] = "createWorker";
    // 多媒体
    //   音频
    //     中断事件
    API["onAudioInterruptionBegin"] = "onAudioInterruptionBegin";
    API["onAudioInterruptionEnd"] = "onAudioInterruptionEnd";
    API["offAudioInterruptionBegin"] = "offAudioInterruptionBegin";
    API["offAudioInterruptionEnd"] = "offAudioInterruptionEnd";
    //     后台播放(旧)
    API["playBackgroundAudio"] = "playBackgroundAudio";
    API["pauseBackgroundAudio"] = "pauseBackgroundAudio";
    API["stopBackgroundAudio"] = "stopBackgroundAudio";
    API["seekBackgroundAudio"] = "seekBackgroundAudio";
    API["getBackgroundAudioPlayerState"] = "getBackgroundAudioPlayerState";
    API["onBackgroundAudioPlay"] = "onBackgroundAudioPlay";
    API["offBackgroundAudioPlay"] = "offBackgroundAudioPlay";
    API["onBackgroundAudioPause"] = "onBackgroundAudioPause";
    API["offBackgroundAudioPause"] = "offBackgroundAudioPause";
    API["onBackgroundAudioStop"] = "onBackgroundAudioStop";
    API["offBackgroundAudioStop"] = "offBackgroundAudioStop";
    //     后台播放管理器(新)
    API["getBackgroundAudioManager"] = "getBackgroundAudioManager";
    //     播放(旧)
    API["createAudioContext"] = "createAudioContext";
    //     播放(新)
    API["createInnerAudioContext"] = "createInnerAudioContext";
    //   实时音视频
    API["createLivePlayerContext"] = "createLivePlayerContext";
    API["createLivePusherContext"] = "createLivePusherContext";
    //   语音
    //     录音(旧)
    API["startRecord"] = "startRecord";
    API["stopRecord"] = "stopRecord";
    API["cancelRecord"] = "cancelRecord";
    //     录音管理器(新)
    API["getRecorderManager"] = "getRecorderManager";
    API["getAvailableAudioSources"] = "getAvailableAudioSources";
    //     播放语音
    API["playVoice"] = "playVoice";
    API["pauseVoice"] = "pauseVoice";
    API["resumeVoice"] = "resumeVoice";
    API["stopVoice"] = "stopVoice";
    //     TTS
    API["textToSpeech"] = "textToSpeech";
    //     语音识别
    API["isSpeechRecognizeAvailable"] = "isSpeechRecognizeAvailable";
    API["startSpeechRecognize"] = "startSpeechRecognize";
    API["stopSpeechRecognize"] = "stopSpeechRecognize";
    API["onSpeechRecognizeResult"] = "onSpeechRecognizeResult";
    API["offSpeechRecognizeResult"] = "offSpeechRecognizeResult";
    API["onSpeechRecognizeError"] = "onSpeechRecognizeError";
    API["offSpeechRecognizeError"] = "offSpeechRecognizeError";
    //   增强现实(AR)
    API["createARContext"] = "createARContext";
    API["ARScan"] = "ARScan";
    API["ap$ARScan"] = "ap.ARScan";
    //   图片
    API["chooseImage"] = "chooseImage";
    API["saveImageToPhotosAlbum"] = "saveImageToPhotosAlbum";
    API["previewImage"] = "previewImage";
    API["saveImage"] = "saveImage";
    API["getImageInfo"] = "getImageInfo";
    API["compressImage"] = "compressImage";
    API["generateImageFromCode"] = "generateImageFromCode";
    //   视频
    API["saveVideoToPhotosAlbum"] = "saveVideoToPhotosAlbum";
    API["chooseVideo"] = "chooseVideo";
    API["createVideoContext"] = "createVideoContext";
    //   地图
    API["createMapContext"] = "createMapContext";
    API["calculateRoute"] = "calculateRoute";
    //   相机
    API["ap$xnnOcr"] = "ap.xnnOcr";
    API["scan"] = "scan";
    API["ocr"] = "ocr";
    API["ap$ocr"] = "ap.ocr";
    API["createCameraContext"] = "createCameraContext";
    API["createAICameraContext"] = "createAICameraContext";
    // 留存
    //    分享
    API["hideShareMenu"] = "hideShareMenu";
    API["showSharePanel"] = "showSharePanel";
    //    收藏 (inside 没有)
    API["isFavorite"] = "isFavorite";
    API["addToFavorite"] = "addToFavorite";
    API["removeFromFavorite"] = "removeFromFavorite";
    API["onFavorite"] = "onFavorite";
    API["offFavorite"] = "offFavorite";
    API["onInternalFavorite"] = "onInternalFavorite";
    API["offInternalFavorite"] = "offInternalFavorite";
    API["isCollected"] = "isCollected";
    API["canFavorite"] = "canFavorite";
    API["hideFavoriteMenu"] = "hideFavoriteMenu";
    API["hideAllFavoriteMenu"] = "hideAllFavoriteMenu";
    // 性能
    //   首屏快照
    API["enableSnapshot"] = "enableSnapshot";
    API["reportSnapshot"] = "reportSnapshot";
    API["saveSnapshot"] = "saveSnapshot";
    // 开放接口
    //      用户信息
    API["getAuthCode"] = "getAuthCode";
    API["ap$getAuthCode"] = "ap.getAuthCode";
    API["authorize"] = "authorize";
    API["ap$authorize"] = "ap.authorize";
    API["getAuthUserInfo"] = "getAuthUserInfo";
    API["ap$getAuthUserInfo"] = "ap.getAuthUserInfo";
    API["getUserInfo"] = "getUserInfo";
    API["ap$getUserInfo"] = "ap.getUserInfo";
    API["getOpenUserInfo"] = "getOpenUserInfo";
    API["getOpenUserData"] = "getOpenUserData";
    API["getPhoneNumber"] = "getPhoneNumber";
    API["getIDNumber"] = "getIDNumber";
    API["getVisitToken"] = "getVisitToken";
    //      设备授权
    API["showAuthGuide"] = "showAuthGuide";
    API["getAuthStatus"] = "getAuthStatus";
    //   插件
    API["loadPlugin"] = "loadPlugin";
    API["getParentAppId"] = "getParentAppId";
    API["getParentAppIdSync"] = "getParentAppIdSync";
    //   模板小程序
    API["getExtConfig"] = "getExtConfig";
    API["getExtConfigSync"] = "getExtConfigSync";
    //    小服务
    API["navigateToMiniService"] = "navigateToMiniService";
    API["startMiniService"] = "startMiniService";
    API["navigateBackFromMiniService"] = "navigateBackFromMiniService";
    API["navigateToMiniProgram"] = "navigateToMiniProgram";
    API["navigateBackMiniProgram"] = "navigateBackMiniProgram";
    //    H5
    API["ap$navigateToAlipayPage"] = "ap.navigateToAlipayPage";
    //   应用跳转
    API["openOtherApplication"] = "openOtherApplication";
    API["ap$openOtherApplication"] = "ap.openOtherApplication";
    // 智能硬件(IoT)
    //    消息
    API["onIotRawMessage"] = "onIotRawMessage";
    API["offIotRawMessage"] = "offIotRawMessage";
    API["onIotNotify"] = "onIotNotify";
    API["offIotNotify"] = "offIotNotify";
    //   请求
    API["sendLanHttpRequest"] = "sendLanHttpRequest";
    //   服务
    API["iotCreateService"] = "iotCreateService";
    API["ap$iotCreateService"] = "ap.iotCreateService";
    API["iotCheckService"] = "iotCheckService";
    API["ap$iotCheckService"] = "ap.iotCheckService";
    //  业务能力
    //    运动
    API["getRunData"] = "getRunData";
    //    内容安全
    API["textRiskIdentification"] = "textRiskIdentification";
    API["ap$textRiskIdentification"] = "ap.textRiskIdentification";
    API["ap$imgRisk"] = "ap.imgRisk";
    API["ap$imgRiskCallback"] = "ap.imgRiskCallback";
    //    淘宝
    API["openTaobao"] = "openTaobao";
    API["ap$openTaobao"] = "ap.openTaobao";
    API["getTBCode"] = "getTBCode";
    API["setTBSessionInfo"] = "setTBSessionInfo";
    API["getTBSessionInfo"] = "getTBSessionInfo";
    //   支付及资金
    API["tradePay"] = "tradePay";
    API["ap$tradePay"] = "ap.tradePay";
    API["paySignCenter"] = "paySignCenter";
    API["ap$paySignCenter"] = "ap.paySignCenter";
    // getConfigService = 'getConfigService', // my. & my.ap. & configService.getConfig I mean only Alipay
    //   云客服
    API["openCustomerService"] = "openCustomerService";
    API["ap$openCustomerService"] = "ap.openCustomerService";
    //   聊天会话
    API["ap$openChatWindow"] = "ap.openChatWindow";
    API["openChatWindow"] = "openChatWindow";
    //   券详情
    API["navigateToCouponDetail"] = "navigateToCouponDetail";
    API["ap$navigateToCouponDetail"] = "ap.navigateToCouponDetail";
    //   车主服务
    API["openCarService"] = "openCarService";
    API["ap$openCarService"] = "ap.openCarService";
    //   财富
    API["ap$navigateToFinance"] = "ap.navigateToFinance";
    // 生活号
    API["ap$cancelFollowLifestyle"] = "ap.cancelFollowLifestyle";
    API["ap$isFollowLifestyle"] = "ap.isFollowLifestyle";
    //    卡包
    API["openVoucherList"] = "openVoucherList";
    API["ap$openVoucherList"] = "ap.openVoucherList";
    API["openTicketList"] = "openTicketList";
    API["ap$openTicketList"] = "ap.openTicketList";
    API["openVoucherDetail"] = "openVoucherDetail";
    API["ap$openVoucherDetail"] = "ap.openVoucherDetail";
    API["openTicketDetail"] = "openTicketDetail";
    API["ap$openTicketDetail"] = "ap.openTicketDetail";
    API["openMerchantVoucherList"] = "openMerchantVoucherList";
    API["ap$openMerchantVoucherList"] = "ap.openMerchantVoucherList";
    API["openMerchantTicketList"] = "openMerchantTicketList";
    API["ap$openMerchantTicketList"] = "ap.openMerchantTicketList";
    API["openKBVoucherDetail"] = "openKBVoucherDetail";
    API["ap$openKBVoucherDetail"] = "ap.openKBVoucherDetail";
    //   商户会员卡
    API["addCardAuth"] = "addCardAuth";
    API["ap$addCardAuth"] = "ap.addCardAuth";
    API["openCardList"] = "openCardList";
    API["ap$openCardList"] = "ap.openCardList";
    API["openCardDetail"] = "openCardDetail";
    API["ap$openCardDetail"] = "ap.openCardDetail";
    API["openMerchantCardList"] = "openMerchantCardList";
    API["ap$openMerchantCardList"] = "ap.openMerchantCardList";
    //     营销反作弊
    API["createRDSContext"] = "createRDSContext";
    API["ap$preventCheat"] = "ap.preventCheat";
    //     先享后付保障
    API["ap$nsf"] = "ap.nsf";
    //       核身
    API["startAPVerify"] = "startAPVerify";
    API["ap$startAPVerify"] = "ap.startAPVerify";
    API["ap$getVerifyEnvData"] = "ap.getVerifyEnvData";
    API["ap$startVerifyIdentity"] = "ap.startVerifyIdentity";
    API["ap$faceVerify"] = "ap.faceVerify";
    API["ap$zimIdentity"] = "ap.zimIdentity";
    //    发票
    API["chooseInvoiceTitle"] = "chooseInvoiceTitle";
    API["ap$chooseInvoiceTitle"] = "ap.chooseInvoiceTitle";
    //    收货地址
    // 支付宝多端可以
    API["chooseAddress"] = "chooseAddress";
    API["ap$chooseAddress"] = "ap.chooseAddress";
    API["getAddress"] = "getAddress";
    API["ap$getAddress"] = "ap.getAddress";
    //    芝麻信用 (inside 还没，可以有)
    API["zmCreditBorrow"] = "zmCreditBorrow";
    API["ap$zmCreditBorrow"] = "ap.zmCreditBorrow";
    API["zmRentTransition"] = "zmRentTransition";
    API["ap$zmRentTransition"] = "ap.zmRentTransition";
    API["zmFreeDeposit"] = "zmFreeDeposit";
    API["ap$zmFreeDeposit"] = "ap.zmFreeDeposit";
    API["startZMCreditRent"] = "startZMCreditRent";
    API["ap$startZMCreditRent"] = "ap.startZMCreditRent";
    API["startZMVerify"] = "startZMVerify";
    API["ap$startZMVerify"] = "ap.startZMVerify";
    // generateImageFromCode = "generateImageFromCode",
    // ap$subscribeMsgbox = 'ap.subscribeMsgbox',
    // ap$getAdTrackClues = 'ap.getAdTrackClues',
    // donateInBrowser = "donateInBrowser",
})(API = exports.API || (exports.API = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/client.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/client.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/flag.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/flag.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Flag = void 0;
var Flag;
(function (Flag) {
    var Navigation;
    (function (Navigation) {
        Navigation["AlipayPageAppCode"] = "Navigation$AlipayPageAppCode";
    })(Navigation = Flag.Navigation || (Flag.Navigation = {}));
    var Bluetooth;
    (function (Bluetooth) {
        Bluetooth["ChangeState"] = "Bluetooth$ChangeState";
        Bluetooth["DiscoveryFeature"] = "Bluetooth$DiscoveryFeature";
    })(Bluetooth = Flag.Bluetooth || (Flag.Bluetooth = {}));
    var Device;
    (function (Device) {
        Device["SystemInfo140"] = "Device$SystemInfo140";
        Device["SystemInfoAuthorized"] = "Device$SystemInfoAuthorized";
        Device["AddPhoneContact"] = "Device$AddPhoneContact";
        Device["GetDeviceIDType"] = "GetDeviceIDType";
        Device["EnvClientName"] = "Env.clientName";
        Device["EnvClientVersion"] = "Env.clientVersion";
        Device["EnvLanguage"] = "Env.language";
        Device["EnvPlatform"] = "Env.platform";
    })(Device = Flag.Device || (Flag.Device = {}));
    var UI;
    (function (UI) {
        UI["InteractiveButtonColor"] = "UI$InteractiveButtonColor";
        UI["ShowActionSheetBadges"] = "UI$ShowActionSheetBadges";
        UI["DatePickerFormatyyyyMM"] = "DatePickerFormatyyyy-MM";
        UI["DatePickerFormatyyyy"] = "DatePickerFormatyyyy";
    })(UI = Flag.UI || (Flag.UI = {}));
    var Scroll;
    (function (Scroll) {
        Scroll["PageScrollToSelector"] = "PageScrollToSelector";
        Scroll["PageScrollToDuration"] = "PageScrollToDuration";
    })(Scroll = Flag.Scroll || (Flag.Scroll = {}));
    var Internal;
    (function (Internal) {
        Internal["Zero"] = "Internal$Zero";
    })(Internal = Flag.Internal || (Flag.Internal = {}));
    var Request;
    (function (Request) {
        Request["RequestMethodPut"] = "RequestMethodPut";
        Request["RequestMethodDelete"] = "RequestMethodDelete";
        Request["RequestDataArrayBuffer"] = "RequestDataArrayBuffer";
        Request["RequestDataTypeArrayBuffer"] = "RequestDataTypeArrayBuffer";
        Request["UploadFileUploadTaskAbort"] = "UploadFileUploadTaskAbort";
        Request["UploadFileUploadTaskonProgressUpdate"] = "UploadFileUploadTaskonProgressUpdate";
        Request["UploadFileToAliCloudNeedRetry"] = "UploadFileToAliCloudNeedRetry";
        Request["UploadFileToAliCloudIsPrivate"] = "UploadFileToAliCloudIsPrivate";
        Request["UploadFileToAliCloudHideLoading"] = "UploadFileToAliCloudHideLoading";
        Request["UploadFileToAliCloudNeedDelete"] = "UploadFileToAliCloudNeedDelete";
        Request["UploadFileToAliCloudSharedBiz"] = "UploadFileToAliCloudSharedBiz";
    })(Request = Flag.Request || (Flag.Request = {}));
    var FileSystem;
    (function (FileSystem) {
        FileSystem["GetSavedFileList"] = "FileSystemGetSavedFileList";
        FileSystem["GetSavedFileListSync"] = "FileSystemGetSavedFileListSync";
    })(FileSystem = Flag.FileSystem || (Flag.FileSystem = {}));
    var Location;
    (function (Location) {
        Location["ChooseCityLongitude"] = "ChooseCityLongitude";
        Location["ChooseCityLatitude"] = "ChooseCityLatitude";
    })(Location = Flag.Location || (Flag.Location = {}));
    var Audio;
    (function (Audio) {
        Audio["BackgroundAudioManagerIsRecordAudioPlayState"] = "BackgroundAudioManagerIsRecordAudioPlayState";
        Audio["InnerAudioContextIsRecordAudioPlayState"] = "InnerAudioContextIsRecordAudioPlayState";
        Audio["InnerAudioContextSupportBackgroundPlay"] = "InnerAudioContext.supportBackgroundPlay";
    })(Audio = Flag.Audio || (Flag.Audio = {}));
    var RecorderManager;
    (function (RecorderManager) {
        RecorderManager["RecorderManagerStartFormat"] = "RecorderManager.start.format";
        RecorderManager["RecorderManagerStartFrameSize"] = "RecorderManager.start.frameSize";
        RecorderManager["RecorderManagerOnFrameRecordedFrameBuffer"] = "RecorderManager.onFrameRecorded.frameBuffer";
        RecorderManager["RecorderManagerOnFrameRecordedIsLastFrame"] = "RecorderManager.onFrameRecorded.isLastFrame";
    })(RecorderManager = Flag.RecorderManager || (Flag.RecorderManager = {}));
    var Map;
    (function (Map) {
        Map["GetMapInfo"] = "Map$GetMapInfo";
        Map["MapContextCalculateDistance"] = "MapContext.calculateDistance";
        Map["MapContextChangeMarkers"] = "MapContext.changeMarkers";
        Map["MapContextClearRoute"] = "MapContext.clearRoute";
        Map["MapContextGestureEnable"] = "MapContext.gestureEnable";
        Map["MapContextGetCenterLocation"] = "MapContext.getCenterLocation";
        Map["MapContextGetMapProperties"] = "MapContext.getMapProperties";
        Map["MapContextGetRegion"] = "MapContext.getRegion";
        Map["MapContextMoveToLocation"] = "MapContext.moveToLocation";
        Map["MapContextShowRoute"] = "MapContext.showRoute";
        Map["MapContextShowsCompass"] = "MapContext.showsCompass";
        Map["MapContextShowsScale"] = "MapContext.showsScale";
        Map["MapContextSmoothMoveMarker"] = "MapContext.smoothMoveMarker";
        Map["MapContextSmoothMovePolyline"] = "MapContext.smoothMovePolyline";
        Map["MapContextTranslateMarker"] = "MapContext.translateMarker";
        Map["MapContextUpdateComponents"] = "MapContext.updateComponents";
        Map["MapContextMarkerLevel"] = "MapContext.markerLevel";
        Map["MapContextMarkerStyle"] = "MapContext.marker.style";
        Map["MapContextMarkerLabel"] = "MapContext.marker.label";
        Map["MapContextPolylineIconPath"] = "MapContext.polyline.iconPath";
        Map["MapContextPolylineIconWidth"] = "MapContext.polyline.iconWidth";
        Map["MapContextPropertySdkName"] = "MapContext.property.sdkName";
        Map["MapContextPropertySdkVersion"] = "MapContext.property.sdkVersion";
        Map["MapContextPropertyIsSupportOversea"] = "MapContext.property.isSupportOversea";
        Map["MapContextPropertyNeedStyleV7"] = "MapContext.marker.needStyleV7";
        Map["MapContextShowRouteSearchType"] = "MapContext.showRoute.searchType";
        Map["MapContextShowRouteThroughPoints"] = "MapContext.showRoute.throughPoints";
        Map["MapContextShowRouteZIndex"] = "MapContext.showRoute.zIndex";
        Map["MapContextMarkerAnimationType"] = "MapContext.marker.animation.type";
    })(Map = Flag.Map || (Flag.Map = {}));
    var AR;
    (function (AR) {
        AR["SetFaceTrackingNodeOptionFacePoints"] = "setFaceTrackingNode.option.facePoints";
        AR["SetFaceTrackingNodeOptionFaceFrame"] = "setFaceTrackingNode.option.faceFrame";
    })(AR = Flag.AR || (Flag.AR = {}));
    var Media;
    (function (Media) {
        Media["IsSpeechRecognizeAvailableExtraInfo"] = "isSpeechRecognizeAvailableExtraInfo.extraInfo";
        Media["StartSpeechRecognizeEncodeAudio"] = "startSpeechRecognize.encodeAudio";
        Media["StartSpeechRecognizeExtraInfo"] = "startSpeechRecognize.extraInfo";
        Media["StartSpeechRecognizeExtraInfoEnableDBCallback"] = "startSpeechRecognize.extraInfo.enableDBCallback";
        Media["OnSpeechRecognizeResultTempAudioPath"] = "onSpeechRecognizeResult.tempAudioPath";
    })(Media = Flag.Media || (Flag.Media = {}));
    var Video;
    (function (Video) {
        Video["ChooseVideoResponseTempFilePath"] = "chooseVideo.response.tempFilePath";
    })(Video = Flag.Video || (Flag.Video = {}));
    var Image;
    (function (Image) {
        Image["SaveImageShowActionSheet"] = "saveImage.showActionSheet";
        Image["PreviewImageEnablesavephoto"] = "previewImage.enablesavephoto";
        Image["PreviewImageEnableShowPhotoDownload"] = "previewImage.enableShowPhotoDownload";
    })(Image = Flag.Image || (Flag.Image = {}));
    var Favorite;
    (function (Favorite) {
        Favorite["AddToFavoriteBizType"] = "addToFavorite.bizType";
        Favorite["AddToFavoriteExtraInfo"] = "addToFavorite.extraInfo";
        Favorite["RemoveFromFavoriteBizType"] = "removeFromFavorite.bizType";
        Favorite["RemoveFromFavoriteExtraInfo"] = "removeFromFavorite.extraInfo";
    })(Favorite = Flag.Favorite || (Flag.Favorite = {}));
    var Performance;
    (function (Performance) {
        Performance["EnableSnapshotDisableDynamicPluginCheck"] = "enableSnapshot.disableDynamicPluginCheck";
    })(Performance = Flag.Performance || (Flag.Performance = {}));
})(Flag = exports.Flag || (exports.Flag = {}));
//# sourceMappingURL=flag.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

// 定一个分类
// instance#method
// instance 是有类型的 默认是 My 默认都在 My 下，也有可以 MyAP 下
// CanvasContext 的 method 就是 CanvasContext 下
// 这样 createCanvasContext 就单纯定义成一个 Sync 方法/ Fn 方法就好了
// 所有方法都是 全局注册的 成员方法
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIType = void 0;
// my.ap.xxx 的类型 TODO，还没想好
// 还是得全局 Type 注册表
// 默认给固化成 request/response 还是不太好？
// 函数作为一等公民
// 1. 单纯 Type 导出哪些
// 2. APIExport，是定义一个函数的入参出餐，只要是 API 即可
// 3. TypeExport 是定义非 POJO 字面量之外的类型，可以包含 method, property 等，但是除开字面量以外，必须强制引用全局的 TypeExport 或者 APIExport
/**
 * export interface TypeExport<S> {
 *   [Type.CanvasContext]: {
 *     draw: ScopedAPIRef<ScopedAPI.CanvasContext.draw> // 单纯 ...args/ret
 *     fontSize: string;
 *   }
 * }
 *
 * // 以下是否要统一？
 * export interface ScopedAPIExport {
 *   [ScopedAPI.CanvasContext.draw]: {
 *     args: [];
 *     response: {};
 *   }
 * }
 *
 * export interface APIExport<S> {
 *   [API.navigateTo]: {
 *     request: {};
 *     response: {};
 *   }
 * }
 */
__exportStar(__webpack_require__(/*! ./api */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/api.js"), exports);
__exportStar(__webpack_require__(/*! ./client */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/client.js"), exports);
__exportStar(__webpack_require__(/*! ./flag */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/flag.js"), exports);
__exportStar(__webpack_require__(/*! ./sdk */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/sdk.js"), exports);
__exportStar(__webpack_require__(/*! ./type */ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/type.js"), exports);
var APIType;
(function (APIType) {
    APIType["Sync"] = "sync";
    APIType["Fn"] = "fn";
    APIType["Event"] = "event";
    APIType["Property"] = "property";
    APIType["Alias"] = "alias";
    APIType["Async"] = "async";
})(APIType = exports.APIType || (exports.APIType = {}));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/sdk.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/sdk.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=sdk.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/meta/type.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/meta/type.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
var Type;
(function (Type) {
    var Open;
    (function (Open) {
        Open["NSFBizContext"] = "NSFBizContext";
    })(Open = Type.Open || (Type.Open = {}));
    var Interactive;
    (function (Interactive) {
        Interactive["PromptOk"] = "PromptOk";
        Interactive["PromptCancel"] = "PromptCancel";
        Interactive["CancelButtonColor"] = "CancelButtonColor";
        Interactive["ConfirmButtonColor"] = "ConfirmButtonColor";
    })(Interactive = Type.Interactive || (Type.Interactive = {}));
    var App;
    (function (App) {
        App["Rejection"] = "Rejection";
        App["ReferrerInfo"] = "ReferrerInfo";
        App["ReportAnalyticsData"] = "ReportAnalyticsData";
        App["RequirePlugin"] = "requirePlugin";
    })(App = Type.App || (Type.App = {}));
    var Navigation;
    (function (Navigation) {
        Navigation["AlipayPageOptionAppCode"] = "AlipayPageOptionAppCode";
        Navigation["AlipayPageOptionPath"] = "AlipayPageOptionPath";
    })(Navigation = Type.Navigation || (Type.Navigation = {}));
    var Bluetooth;
    (function (Bluetooth) {
        Bluetooth["BLECharacteristic"] = "BLECharacteristic";
        Bluetooth["BLEProperties"] = "BLEProperties";
        Bluetooth["BlueBoothCommonError"] = "BlueBoothCommonError";
        Bluetooth["EBlueBoothErrorCodeCommon"] = "EBlueBoothErrorCodeCommon";
    })(Bluetooth = Type.Bluetooth || (Type.Bluetooth = {}));
    var Shared;
    (function (Shared) {
        Shared["Callback"] = "Callback";
    })(Shared = Type.Shared || (Type.Shared = {}));
    var Worker;
    (function (Worker) {
        Worker["Instance"] = "Worker.Instance";
        Worker["onMessage"] = "Worker.onMessage";
        Worker["MessageCallback"] = "Worker.MessageCallback";
        Worker["postMessage"] = "Worker.postMessage";
        Worker["terminate"] = "Worker.terminate";
    })(Worker = Type.Worker || (Type.Worker = {}));
    var CanvasContext;
    (function (CanvasContext) {
        CanvasContext["Context"] = "CanvasContext";
        CanvasContext["addColorStop"] = "CanvasContext.addColorStop";
        CanvasContext["arc"] = "CanvasContext.arc";
        CanvasContext["beginPath"] = "CanvasContext.beginPath";
        CanvasContext["bezierCurveTo"] = "CanvasContext.bezierCurveTo";
        CanvasContext["clearRect"] = "CanvasContext.clearRect";
        CanvasContext["clip"] = "CanvasContext.clip";
        CanvasContext["closePath"] = "CanvasContext.closePath";
        CanvasContext["createCircularGradient"] = "CanvasContext.createCircularGradient";
        CanvasContext["createLinearGradient"] = "CanvasContext.createLinearGradient";
        CanvasContext["fill"] = "CanvasContext.fill";
        CanvasContext["fillRect"] = "CanvasContext.fillRect";
        CanvasContext["fillText"] = "CanvasContext.fillText";
        CanvasContext["getImageData"] = "CanvasContext.getImageData";
        CanvasContext["lineTo"] = "CanvasContext.lineTo";
        CanvasContext["measureText"] = "CanvasContext.measureText";
        CanvasContext["moveTo"] = "CanvasContext.moveTo";
        CanvasContext["putImageData"] = "CanvasContext.putImageData";
        CanvasContext["quadraticCurveTo"] = "CanvasContext.quadraticCurveTo";
        CanvasContext["rect"] = "CanvasContext.rect";
        CanvasContext["restore"] = "CanvasContext.restore";
        CanvasContext["rotate"] = "CanvasContext.rotate";
        CanvasContext["save"] = "CanvasContext.save";
        CanvasContext["scale"] = "CanvasContext.scale";
        CanvasContext["setFillStyle"] = "CanvasContext.setFillStyle";
        CanvasContext["setFontSize"] = "CanvasContext.setFontSize";
        CanvasContext["setGlobalAlpha"] = "CanvasContext.setGlobalAlpha";
        CanvasContext["setLineCap"] = "CanvasContext.setLineCap";
        CanvasContext["setLineDash"] = "CanvasContext.setLineDash";
        CanvasContext["setLineJoin"] = "CanvasContext.setLineJoin";
        CanvasContext["setLineWidth"] = "CanvasContext.setLineWidth";
        CanvasContext["setMiterLimit"] = "CanvasContext.setMiterLimit";
        CanvasContext["setShadow"] = "CanvasContext.setShadow";
        CanvasContext["setStrokeStyle"] = "CanvasContext.setStrokeStyle";
        CanvasContext["setTextAlign"] = "CanvasContext.setTextAlign";
        CanvasContext["setTextBaseline"] = "CanvasContext.setTextBaseline";
        CanvasContext["setTransform"] = "CanvasContext.setTransform";
        CanvasContext["stroke"] = "CanvasContext.stroke";
        CanvasContext["strokeRect"] = "CanvasContext.strokeRect";
        CanvasContext["toDataURL"] = "CanvasContext.toDataURL";
        CanvasContext["toTempFilePath"] = "CanvasContext.toTempFilePath";
        CanvasContext["transform"] = "CanvasContext.transform";
        CanvasContext["translate"] = "CanvasContext.translate";
        CanvasContext["Draw"] = "CanvasContext.draw";
        CanvasContext["DrawImage"] = "CanvasContext.drawImage";
    })(CanvasContext = Type.CanvasContext || (Type.CanvasContext = {}));
    var Version;
    (function (Version) {
    })(Version = Type.Version || (Type.Version = {}));
    var UpdateManager;
    (function (UpdateManager) {
        UpdateManager["Manager"] = "UpdateManager$Manager";
        UpdateManager["ApplyUpdate"] = "UpdateManager$ApplyUpdate";
        UpdateManager["OnCheckForUpdate"] = "UpdateManager$OnCheckForUpdate";
        UpdateManager["OnCheckForUpdateCallback"] = "UpdateManager$OnCheckForUpdateCallback";
        UpdateManager["OnUpdateReady"] = "UpdateManager$OnUpdateReady";
        UpdateManager["OnUpdateFailed"] = "UpdateManager$OnUpdateFailed";
    })(UpdateManager = Type.UpdateManager || (Type.UpdateManager = {}));
    var SystemInfo;
    (function (SystemInfo) {
        SystemInfo["Env"] = "SystemInfo$Env";
        SystemInfo["Info"] = "SystemInfo$Info";
        SystemInfo["InfoBasic"] = "SystemInfo$InfoBasic";
        SystemInfo["Info140"] = "SystemInfo$Info140";
        SystemInfo["InfoAuthorized"] = "SystemInfo$InfoAuthorized";
        SystemInfo["SafeArea"] = "SystemInfo$SafeArea";
    })(SystemInfo = Type.SystemInfo || (Type.SystemInfo = {}));
    var Storage;
    (function (Storage) {
        Storage["StorageInfo"] = "Storage$StorageInfo";
    })(Storage = Type.Storage || (Type.Storage = {}));
    var UI;
    (function (UI) {
    })(UI = Type.UI || (Type.UI = {}));
    var Dom;
    (function (Dom) {
        Dom["SelectorQuery"] = "SelectorQuery";
        Dom["SelectorQuerySelect"] = "SelectorQuery.select";
        Dom["SelectorQuerySelectAll"] = "SelectorQuery.selectAll";
        Dom["SelectorQueryBoundingClientRect"] = "SelectorQuery.boundingClientRect";
        Dom["SelectorQueryScrollOffset"] = "SelectorQuery.scrollOffset";
        Dom["SelectorQueryExec"] = "SelectorQuery.exec";
        Dom["SelectorQuerySelectViewport"] = "SelectorQuery.selectViewport";
        Dom["IntersectionObserver"] = "IntersectionObserver";
        Dom["IntersectionObserverDisconnect"] = "IntersectionObserver.disconnect";
        Dom["IntersectionObserverObserve"] = "IntersectionObserver.observe";
        Dom["IntersectionObserverRelativeTo"] = "IntersectionObserver.relativeTo";
        Dom["IntersectionObserverRelativeToViewport"] = "IntersectionObserver.relativeToViewport";
        Dom["AnimationContext"] = "AnimationContext";
        Dom["AnimationContextStep"] = "AnimationContext.step";
        Dom["AnimationContextExport"] = "AnimationContext.export";
        Dom["AnimationContextOpacity"] = "AnimationContext.opacity";
        Dom["AnimationContextBackgroundColor"] = "AnimationContext.backgroundColor";
        Dom["AnimationContextWidth"] = "AnimationContext.width";
        Dom["AnimationContextHeight"] = "AnimationContext.height";
        Dom["AnimationContextTop"] = "AnimationContext.top";
        Dom["AnimationContextLeft"] = "AnimationContext.left";
        Dom["AnimationContextBottom"] = "AnimationContext.bottom";
        Dom["AnimationContextRight"] = "AnimationContext.right";
        Dom["AnimationContextRotate"] = "AnimationContext.rotate";
        Dom["AnimationContextRotateX"] = "AnimationContext.rotateX";
        Dom["AnimationContextRotateY"] = "AnimationContext.rotateY";
        Dom["AnimationContextRotateZ"] = "AnimationContext.rotateZ";
        Dom["AnimationContextRotate3d"] = "AnimationContext.rotate3d";
        Dom["AnimationContextScale"] = "AnimationContext.scale";
        Dom["AnimationContextScaleX"] = "AnimationContext.scaleX";
        Dom["AnimationContextScaleY"] = "AnimationContext.scaleY";
        Dom["AnimationContextScaleZ"] = "AnimationContext.scaleZ";
        Dom["AnimationContextScale3d"] = "AnimationContext.scale3d";
        Dom["AnimationContextTranslate"] = "AnimationContext.translate";
        Dom["AnimationContextTranslateX"] = "AnimationContext.translateX";
        Dom["AnimationContextTranslateY"] = "AnimationContext.translateY";
        Dom["AnimationContextTranslateZ"] = "AnimationContext.translateZ";
        Dom["AnimationContextTranslate3d"] = "AnimationContext.translate3d";
        Dom["AnimationContextSkew"] = "AnimationContext.skew";
        Dom["AnimationContextSkewX"] = "AnimationContext.skewX";
        Dom["AnimationContextSkewY"] = "AnimationContext.skewY";
        Dom["AnimationContextMatrix"] = "AnimationContext.matrix";
        Dom["AnimationContextMatrix3d"] = "AnimationContext.matrix3d";
    })(Dom = Type.Dom || (Type.Dom = {}));
    var FileSystem;
    (function (FileSystem) {
        FileSystem["Mkdir"] = "FileSystemManager.mkdir";
        FileSystem["MkdirSync"] = "FileSystemManager.mkdirSync";
        FileSystem["AppendFile"] = "FileSystemManager.appendFile";
        FileSystem["AppendFileSync"] = "FileSystemManager.appendFileSync";
        FileSystem["CopyFile"] = "FileSystemManager.copyFile";
        FileSystem["CopyFileSync"] = "FileSystemManager.copyFileSync";
        FileSystem["Readdir"] = "FileSystemManager.readdir";
        FileSystem["ReaddirSync"] = "FileSystemManager.readdirSync";
        FileSystem["RemoveSavedFile"] = "FileSystemManager.removeSavedFile";
        FileSystem["RemoveSavedFileSync"] = "FileSystemManager.removeSavedFileSync";
        FileSystem["Rename"] = "FileSystemManager.rename";
        FileSystem["RenameSync"] = "FileSystemManager.renameSync";
        FileSystem["Stat"] = "FileSystemManager.stat";
        FileSystem["StatSync"] = "FileSystemManager.statSync";
        FileSystem["Unlink"] = "FileSystemManager.unlink";
        FileSystem["UnlinkSync"] = "FileSystemManager.unlinkSync";
        FileSystem["Unzip"] = "FileSystemManager.unzip";
        FileSystem["WriteFile"] = "FileSystemManager.writeFile";
        FileSystem["WriteFileSync"] = "FileSystemManager.writeFileSync";
        FileSystem["GetFileInfo"] = "FileSystemManager.getFileInfo";
        FileSystem["GetFileInfoSync"] = "FileSystemManager.getFileInfoSync";
        FileSystem["ReadFile"] = "FileSystemManager.readFile";
        FileSystem["ReadFileSync"] = "FileSystemManager.readFileSync";
        FileSystem["GetSavedFileList"] = "FileSystemManager.getSavedFileList";
        FileSystem["GetSavedFileListSync"] = "FileSystemManager.getSavedFileListSync";
        FileSystem["SaveFile"] = "FileSystemManager.saveFile";
        FileSystem["SaveFileSync"] = "FileSystemManager.saveFileSync";
        FileSystem["Access"] = "FileSystemManager.access";
        FileSystem["AccessSync"] = "FileSystemManager.accessSync";
        FileSystem["Rmdir"] = "FileSystemManager.rmdir";
        FileSystem["RmdirSync"] = "FileSystemManager.rmdirSync";
    })(FileSystem = Type.FileSystem || (Type.FileSystem = {}));
    var Audio;
    (function (Audio) {
        Audio["BackgroundAudioManager"] = "BackgroundAudioManager";
        Audio["BackgroundAudioManagerPlay"] = "BackgroundAudioManager.play";
        Audio["BackgroundAudioManagerPause"] = "BackgroundAudioManager.pause";
        Audio["BackgroundAudioManagerStop"] = "BackgroundAudioManager.stop";
        Audio["BackgroundAudioManagerSeek"] = "BackgroundAudioManager.seek";
        Audio["BackgroundAudioManagerOnCanplay"] = "BackgroundAudioManager.onCanplay";
        Audio["BackgroundAudioManagerOnWaiting"] = "BackgroundAudioManager.onWaiting";
        Audio["BackgroundAudioManagerOnError"] = "BackgroundAudioManager.onError";
        Audio["BackgroundAudioManagerOnPlay"] = "BackgroundAudioManager.onPlay";
        Audio["BackgroundAudioManagerOnPause"] = "BackgroundAudioManager.onPause";
        Audio["BackgroundAudioManagerOnSeeking"] = "BackgroundAudioManager.onSeeking";
        Audio["BackgroundAudioManagerOnSeeked"] = "BackgroundAudioManager.onSeeked";
        Audio["BackgroundAudioManagerOnEnded"] = "BackgroundAudioManager.onEnded";
        Audio["BackgroundAudioManagerOnStop"] = "BackgroundAudioManager.onStop";
        Audio["BackgroundAudioManagerOnTimeUpdate"] = "BackgroundAudioManager.onTimeUpdate";
        Audio["BackgroundAudioManagerOnNext"] = "BackgroundAudioManager.onNext";
        Audio["BackgroundAudioManagerOnPrev"] = "BackgroundAudioManager.onPrev";
        Audio["AudioContext"] = "AudioContext";
        Audio["AudioContextSetSrc"] = "AudioContext.setSrc";
        Audio["AudioContextPlay"] = "AudioContext.play";
        Audio["AudioContextPause"] = "AudioContext.pause";
        Audio["AudioContextSeek"] = "AudioContext.seek";
        Audio["InnerAudioContext"] = "InnerAudioContext";
        Audio["InnerAudioContextPlay"] = "InnerAudioContext.play";
        Audio["InnerAudioContextPause"] = "InnerAudioContext.pause";
        Audio["InnerAudioContextStop"] = "InnerAudioContext.stop";
        Audio["InnerAudioContextSeek"] = "InnerAudioContext.seek";
        Audio["InnerAudioContextDestory"] = "InnerAudioContext.destory";
        Audio["InnerAudioContextOnCanplay"] = "InnerAudioContext.onCanplay";
        Audio["InnerAudioContextOnPlay"] = "InnerAudioContext.onPlay";
        Audio["InnerAudioContextOnPause"] = "InnerAudioContext.onPause";
        Audio["InnerAudioContextOnStop"] = "InnerAudioContext.onStop";
        Audio["InnerAudioContextOnEnded"] = "InnerAudioContext.onEnded";
        Audio["InnerAudioContextOnTimeUpdate"] = "InnerAudioContext.onTimeUpdate";
        Audio["InnerAudioContextOnError"] = "InnerAudioContext.onError";
        Audio["InnerAudioContextOnWaiting"] = "InnerAudioContext.onWaiting";
        Audio["InnerAudioContextOnSeeking"] = "InnerAudioContext.onSeeking";
        Audio["InnerAudioContextOnSeeked"] = "InnerAudioContext.onSeeked";
        Audio["InnerAudioContextOffCanplay"] = "InnerAudioContext.offCanplay";
        Audio["InnerAudioContextOffPlay"] = "InnerAudioContext.offPlay";
        Audio["InnerAudioContextOffPause"] = "InnerAudioContext.offPause";
        Audio["InnerAudioContextOffStop"] = "InnerAudioContext.offStop";
        Audio["InnerAudioContextOffEnded"] = "InnerAudioContext.offEnded";
        Audio["InnerAudioContextOffTimeUpdate"] = "InnerAudioContext.offTimeUpdate";
        Audio["InnerAudioContextOffError"] = "InnerAudioContext.offError";
        Audio["InnerAudioContextOffWaiting"] = "InnerAudioContext.offWaiting";
        Audio["InnerAudioContextOffSeeking"] = "InnerAudioContext.offSeeking";
        Audio["InnerAudioContextOffSeeked"] = "InnerAudioContext.offSeeked";
    })(Audio = Type.Audio || (Type.Audio = {}));
    var RecorderManager;
    (function (RecorderManager) {
        RecorderManager["RecorderManager"] = "RecorderManager";
        RecorderManager["RecorderManagerStart"] = "RecorderManager.start";
        RecorderManager["RecorderManagerStop"] = "RecorderManager.stop";
        RecorderManager["RecorderManagerPause"] = "RecorderManager.pause";
        RecorderManager["RecorderManagerResume"] = "RecorderManager.resume";
        RecorderManager["RecorderManagerOnError"] = "RecorderManager.onError";
        RecorderManager["RecorderManagerOnDecibelChange"] = "RecorderManager.onDecibelChange";
        RecorderManager["RecorderManagerOnStart"] = "RecorderManager.onStart";
        RecorderManager["RecorderManagerOnStop"] = "RecorderManager.onStop";
        RecorderManager["RecorderManagerOnPause"] = "RecorderManager.onPause";
        RecorderManager["RecorderManagerOnResume"] = "RecorderManager.onResume";
        RecorderManager["RecorderManagerOffError"] = "RecorderManager.offError";
        RecorderManager["RecorderManagerOffDecibelChange"] = "RecorderManager.offDecibelChange";
        RecorderManager["RecorderManagerOffStart"] = "RecorderManager.offStart";
        RecorderManager["RecorderManagerOffStop"] = "RecorderManager.offStop";
        RecorderManager["RecorderManagerOffPause"] = "RecorderManager.offPause";
        RecorderManager["RecorderManagerOffResume"] = "RecorderManager.offResume";
        RecorderManager["RecorderManagerOnFrameRecorded"] = "RecorderManager.onFrameRecorded";
        RecorderManager["RecorderManagerOffFrameRecorded"] = "RecorderManager.offFrameRecorded";
    })(RecorderManager = Type.RecorderManager || (Type.RecorderManager = {}));
    var Live;
    (function (Live) {
        Live["LivePusherContext"] = "LivePusherContext";
        Live["LivePusherContextStart"] = "LivePusherContext.start";
        Live["LivePusherContextPause"] = "LivePusherContext.pause";
        Live["LivePusherContextResume"] = "LivePusherContext.resume";
        Live["LivePusherContextStop"] = "LivePusherContext.stop";
        Live["LivePusherContextSwitchCamera"] = "LivePusherContext.switchCamera";
        Live["LivePusherContextToggleTorch"] = "LivePusherContext.toggleTorch";
        Live["LivePlayerContext"] = "LivePlayerContext";
        Live["LivePlayerContextPlay"] = "LivePlayerContext.play";
        Live["LivePlayerContextPause"] = "LivePlayerContext.pause";
        Live["LivePlayerContextResume"] = "LivePlayerContext.resume";
        Live["LivePlayerContextStop"] = "LivePlayerContext.stop";
        Live["LivePlayerContextMute"] = "LivePlayerContext.mute";
        Live["LivePlayerContextRequestFullScreen"] = "LivePlayerContext.requestFullScreen";
        Live["LivePlayerContextShowFloatingWindow"] = "LivePlayerContext.showFloatingWindow";
    })(Live = Type.Live || (Type.Live = {}));
    var Map;
    (function (Map) {
        Map["MapContext"] = "MapContext";
        Map["MapContextCalculateDistance"] = "MapContext.calculateDistance";
        Map["MapContextChangeMarkers"] = "MapContext.changeMarkers";
        Map["MapContextClearRoute"] = "MapContext.clearRoute";
        Map["MapContextGestureEnable"] = "MapContext.gestureEnable";
        Map["MapContextGetCenterLocation"] = "MapContext.getCenterLocation";
        Map["MapContextGetMapProperties"] = "MapContext.getMapProperties";
        Map["MapContextGetRegion"] = "MapContext.getRegion";
        Map["MapContextMoveToLocation"] = "MapContext.moveToLocation";
        Map["MapContextShowRoute"] = "MapContext.showRoute";
        Map["MapContextShowsCompass"] = "MapContext.showsCompass";
        Map["MapContextShowsScale"] = "MapContext.showsScale";
        Map["MapContextSmoothMoveMarker"] = "MapContext.smoothMoveMarker";
        Map["MapContextSmoothMovePolyline"] = "MapContext.smoothMovePolyline";
        Map["MapContextTranslateMarker"] = "MapContext.translateMarker";
        Map["MapContextUpdateComponents"] = "MapContext.updateComponents";
    })(Map = Type.Map || (Type.Map = {}));
    var AR;
    (function (AR) {
        AR["ARContext"] = "ARContext";
        AR["ARContextGetCameraPosition"] = "ARContext.getCameraPosition";
        AR["ARContextSwitchCameraPosition"] = "ARContext.switchCameraPosition";
        AR["ARContextRotateScene"] = "ARContext.rotateScene";
        AR["ARContextTranslateScene"] = "ARContext.translateScene";
        AR["ARContextScaleScene"] = "ARContext.scaleScene";
        AR["ARContextTransformCoordinate"] = "ARContext.transformCoordinate";
        AR["ARContextHitTest"] = "ARContext.hitTest";
        AR["ARContextIsNodeVisible"] = "ARContext.isNodeVisible";
        AR["ARContextSetNodeVisible"] = "ARContext.setNodeVisible";
        AR["ARContextGetNodePosition"] = "ARContext.getNodePosition";
        AR["ARContextGetNodeRotation"] = "ARContext.getNodeRotation";
        AR["ARContextGetNodeScale"] = "ARContext.getNodeScale";
        AR["ARContextSetNodePosition"] = "ARContext.setNodePosition";
        AR["ARContextTranslateNode"] = "ARContext.translateNode";
        AR["ARContextRotateNode"] = "ARContext.rotateNode";
        AR["ARContextScaleNode"] = "ARContext.scaleNode";
        AR["ARContextSetNodeBillboard"] = "ARContext.setNodeBillboard";
        AR["ARContextSetNodeStatic"] = "ARContext.setNodeStatic";
        AR["ARContextSetLightAmbientColor"] = "ARContext.setLightAmbientColor";
        AR["ARContextSetLightColor"] = "ARContext.setLightColor";
        AR["ARContextSetLightRange"] = "ARContext.setLightRange";
        AR["ARContextSetLightInnerAngle"] = "ARContext.setLightInnerAngle";
        AR["ARContextSetLightOuterAngle"] = "ARContext.setLightOuterAngle";
        AR["ARContextSetNodeTexture"] = "ARContext.setNodeTexture";
        AR["ARContextRemoveTextureCache"] = "ARContext.removeTextureCache";
        AR["ARContextModulateAlpha"] = "ARContext.modulateAlpha";
        AR["ARContextModulateColor"] = "ARContext.modulateColor";
        AR["ARContextStartEnvironmentTexturing"] = "ARContext.startEnvironmentTexturing";
        AR["ARContextStopEnvironmentTexturing"] = "ARContext.stopEnvironmentTexturing";
        AR["ARContextPlayAnimation"] = "ARContext.playAnimation";
        AR["ARContextPauseAnimation"] = "ARContext.pauseAnimation";
        AR["ARContextResumeAnimation"] = "ARContext.resumeAnimation";
        AR["ARContextStopAnimation"] = "ARContext.stopAnimation";
        AR["ARContextCreateAnimation"] = "ARContext.createAnimation";
        AR["ARContextCreateAnimationClip"] = "ARContext.createAnimationClip";
        AR["ARContextSetAnimationAdditiveBlending"] = "ARContext.setAnimationAdditiveBlending";
        AR["ARContextClearAnimationAdditiveBlending"] = "ARContext.clearAnimationAdditiveBlending";
        AR["ARContextCrossFadeAnimation"] = "ARContext.crossFadeAnimation";
        AR["ARContextLoadAnimation"] = "ARContext.loadAnimation";
        AR["ARContextEmitParticle"] = "ARContext.emitParticle";
        AR["ARContextGetTrackMode"] = "ARContext.getTrackMode";
        AR["ARContextResetScene"] = "ARContext.resetScene";
        AR["ARContextGetFaceTrackingStatus"] = "ARContext.getFaceTrackingStatus";
        AR["ARContextStartFaceTracking"] = "ARContext.startFaceTracking";
        AR["ARContextSetFaceTrackingNode"] = "ARContext.setFaceTrackingNode";
        AR["ARContextGetFaceInfo"] = "ARContext.getFaceInfo";
        AR["ARContextStopFaceTracking"] = "ARContext.stopFaceTracking";
        AR["ARContextGetSmileDetectingStatus"] = "ARContext.getSmileDetectingStatus";
        AR["ARContextStartSmileDetecting"] = "ARContext.startSmileDetecting";
        AR["ARContextGetSmileDetectingScore"] = "ARContext.getSmileDetectingScore";
        AR["ARContextStopSmileDetecting"] = "ARContext.stopSmileDetecting";
        AR["ARContextGetGestureDetectingStatus"] = "ARContext.getGestureDetectingStatus";
        AR["ARContextStartGestureDetecting"] = "ARContext.startGestureDetecting";
        AR["ARContextStopGestureDetecting"] = "ARContext.stopGestureDetecting";
        AR["ARContextGetGestureDetectingResult"] = "ARContext.getGestureDetectingResult";
        AR["ARContextGetGestureDetectingScore"] = "ARContext.getGestureDetectingScore";
        /** 姿势识别 */
        AR["ARPoseOnPoseResult"] = "AR.onPoseResult";
        AR["ARPoseConfig"] = "AR.pose.config";
        AR["ARPoseStatus"] = "AR.pose.status";
        AR["ARPoseStart"] = "AR.pose.start";
        AR["ARPoseStop"] = "AR.pose.stop";
        AR["ARPoseScore"] = "AR.pose.score";
        AR["ARContextGetPoseDetectingStatus"] = "ARContext.getPoseDetectingStatus";
        AR["ARContextStartPoseDetecting"] = "ARContext.startPoseDetecting";
        AR["ARContextGetPoseDetectingScore"] = "ARContext.getPoseDetectingScore";
        AR["ARContextStopPoseDetecting"] = "ARContext.stopPoseDetecting";
    })(AR = Type.AR || (Type.AR = {}));
    var RtcRoom;
    (function (RtcRoom) {
        RtcRoom["RtcRoomContext"] = "RtcRoomContext";
        RtcRoom["RtcRoomContextStart"] = "RtcRoomContext.start";
        RtcRoom["RtcRoomContextStop"] = "RtcRoomContext.stop";
        RtcRoom["RtcRoomContextMute"] = "RtcRoomContext.mute";
        RtcRoom["RtcRoomContextSwitchCamera"] = "RtcRoomContext.switchCamera";
        RtcRoom["RtcRoomContextEnableCamera"] = "RtcRoomContext.enableCamera";
        RtcRoom["RtcRoomContextAudioMode"] = "RtcRoomContext.audioMode";
        RtcRoom["RtcRoomContextSendMessage"] = "RtcRoomContext.sendMessage";
        RtcRoom["RtcRoomContextSnapshot"] = "RtcRoomContext.snapshot";
        RtcRoom["RtcRoomContextShowPreView"] = "RtcRoomContext.showPreView";
        RtcRoom["RtcRoomContextStartScreenCapture"] = "RtcRoomContext.startScreenCapture";
        RtcRoom["RtcRoomContextStopScreenCapture"] = "RtcRoomContext.stopScreenCapture";
    })(RtcRoom = Type.RtcRoom || (Type.RtcRoom = {}));
    var Video;
    (function (Video) {
        Video["VideoContext"] = "VideoContext";
        Video["VideoContextPlay"] = "VideoContext.play";
        Video["VideoContextPause"] = "VideoContext.pause";
        Video["VideoContextStop"] = "VideoContext.stop";
        Video["VideoContextSeek"] = "VideoContext.seek";
        Video["VideoContextRequestFullScreen"] = "VideoContext.requestFullScreen";
        Video["VideoContextExitFullScreen"] = "VideoContext.exitFullScreen";
        Video["VideoContextShowStatusBar"] = "VideoContext.showStatusBar";
        Video["VideoContextHideStatusBar"] = "VideoContext.hideStatusBar";
        Video["VideoContextMute"] = "VideoContext.mute";
        Video["VideoContextPlaybackRate"] = "VideoContext.playbackRate";
        Video["VideoContextShowFloatingWindow"] = "VideoContext.showFloatingWindow";
    })(Video = Type.Video || (Type.Video = {}));
    var Camera;
    (function (Camera) {
        Camera["CameraContext"] = "CameraContext";
        Camera["CameraContextOnCameraFrame"] = "CameraContext.onCameraFrame";
        Camera["CameraContextOnCameraFrameCameraFrameListener"] = "CameraFrameListener";
        Camera["CameraContextOnCameraFrameCameraFrameListenerStart"] = "CameraFrameListener.start";
        Camera["CameraContextOnCameraFrameCameraFrameListenerStop"] = "CameraFrameListener.stop";
        Camera["CameraContextStartRecord"] = "CameraContext.startRecord";
        Camera["CameraContextStopRecord"] = "CameraContext.stopRecord";
        Camera["CameraContextTakePhoto"] = "CameraContext.takePhoto";
        Camera["AICameraContext"] = "AICameraContext";
        Camera["AICameraContextTakePhoto"] = "AICameraContext.takePhoto";
        Camera["AICameraContextStartRecord"] = "AICameraContext.startRecord";
        Camera["AICameraContextStopRecord"] = "AICameraContext.stopRecord";
        Camera["AICameraContextStartAudioRecognize"] = "AICameraContext.startAudioRecognize";
        Camera["AICameraContextStopAudioRecognize"] = "AICameraContext.stopAudioRecognize";
        Camera["AICameraContextStartVideoRecognize"] = "AICameraContext.startVideoRecognize";
        Camera["AICameraContextStopVideoRecognize"] = "AICameraContext.stopVideoRecognize";
        Camera["AICameraContextHasHeadset"] = "AICameraContext.hasHeadset";
    })(Camera = Type.Camera || (Type.Camera = {}));
    var Lottie;
    (function (Lottie) {
        Lottie["LottieContext"] = "LottieContext";
        Lottie["LottieContextPlay"] = "LottieContext.play";
        Lottie["LottieContextStop"] = "LottieContext.stop";
        Lottie["LottieContextPause"] = "LottieContext.pause";
        Lottie["LottieContextSetSpeed"] = "LottieContext.setSpeed";
        Lottie["LottieContextGoToAndStop"] = "LottieContext.goToAndStop";
        Lottie["LottieContextGoToAndPlay"] = "LottieContext.goToAndPlay";
        Lottie["LottieContextPlayFromMinToMaxProgress"] = "LottieContext.playFromMinToMaxProgress";
        Lottie["LottieContextPlayFromMinToMaxFrame"] = "LottieContext.playFromMinToMaxFrame";
        Lottie["LottieContextDowngradeToPlaceholder"] = "LottieContext.downgradeToPlaceholder";
    })(Lottie = Type.Lottie || (Type.Lottie = {}));
    var WebView;
    (function (WebView) {
        WebView["WebViewContext"] = "WebViewContext";
        WebView["WebViewContextPostMessage"] = "WebViewContext.postMessage";
    })(WebView = Type.WebView || (Type.WebView = {}));
    var RDS;
    (function (RDS) {
        RDS["RDSContext"] = "RDSContext";
        RDS["RDSContextEnableDetect"] = "RDSContext.enableDetect";
        RDS["RDSContextGetRDSData"] = "RDSContext.getRDSData";
    })(RDS = Type.RDS || (Type.RDS = {}));
})(Type = exports.Type || (exports.Type = {}));
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/registry.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/registry.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/type/state.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/type/state.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-api-types/lib/public/validate.js":
/*!********************************************************************!*\
  !*** ./node_modules/@alipay/mini-api-types/lib/public/validate.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// const my = {} as Bridge.Instance;
// const r1 = my.navigateTo({
//   url: '321',
//   success(a) {},
//   fail(e) {}
// });
// const r2 = my.navigateTo({
//   url: '123'
// }, () => {});
// const r3 = my.navigateTo(() => {});
// const r4 = my.navigateTo({
//   url: '123'
// });
//# sourceMappingURL=validate.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-build-shared-io/lib/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fs = void 0;
var fs = __importStar(__webpack_require__(/*! fs-extra */ "./node_modules/fs-extra/lib/index.js"));
exports.fs = fs;
__exportStar(__webpack_require__(/*! ./load-json */ "./node_modules/@alipay/mini-program-build-shared-io/lib/load-json.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-build-shared-io/lib/load-json.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-build-shared-io/lib/load-json.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadJSONSync = exports.loadJSON = void 0;
var fs = __importStar(__webpack_require__(/*! fs-extra */ "./node_modules/fs-extra/lib/index.js"));
/**
 * Load a json object
 * @param filePath
 */
function loadJSON(filePath, loose, fallbackValue) {
    if (loose === void 0) { loose = true; }
    if (fallbackValue === void 0) { fallbackValue = {}; }
    return __awaiter(this, void 0, void 0, function () {
        var isExist, content, e_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fs.pathExists(filePath)];
                case 1:
                    isExist = _a.sent();
                    if (!isExist) return [3 /*break*/, 6];
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, fs.readFile(filePath, { encoding: 'utf-8' })];
                case 3:
                    content = _a.sent();
                    return [2 /*return*/, JSON.parse(content)];
                case 4:
                    e_1 = _a.sent();
                    if (loose) {
                        console.error("Failed to load json: ".concat(filePath));
                        console.error(e_1);
                        return [2 /*return*/, fallbackValue];
                    }
                    throw new Error("Failed to load: ".concat(filePath));
                case 5: return [3 /*break*/, 7];
                case 6:
                    if (loose) {
                        return [2 /*return*/, fallbackValue];
                    }
                    throw new Error("Non-existed path: ".concat(filePath));
                case 7: return [2 /*return*/];
            }
        });
    });
}
exports.loadJSON = loadJSON;
/**
 * Load a json object sync
 * @param filePath
 */
function loadJSONSync(filePath, loose, fallbackValue) {
    if (loose === void 0) { loose = true; }
    if (fallbackValue === void 0) { fallbackValue = {}; }
    var isExist = fs.pathExistsSync(filePath);
    if (isExist) {
        try {
            var content = fs.readFileSync(filePath, { encoding: 'utf-8' });
            return JSON.parse(content);
        }
        catch (e) {
            if (loose) {
                console.error("Failed to load json: ".concat(filePath));
                console.error(e);
                return fallbackValue;
            }
            throw new Error("Failed to load: ".concat(filePath));
        }
    }
    else {
        if (loose) {
            return fallbackValue;
        }
        throw new Error("Non-existed path: ".concat(filePath));
    }
}
exports.loadJSONSync = loadJSONSync;
//# sourceMappingURL=load-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/entity/mini-project-json.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/entity/mini-project-json.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniProjectJson = void 0;
__webpack_require__(/*! reflect-metadata */ "./node_modules/reflect-metadata/Reflect.js");
var mini_program_types_1 = __webpack_require__(/*! @alipay/mini-program-types */ "./node_modules/@alipay/mini-program-types/lib/index.js");
var lodash_get_1 = __importDefault(__webpack_require__(/*! lodash.get */ "./node_modules/lodash.get/index.js"));
var lodash_set_1 = __importDefault(__webpack_require__(/*! lodash.set */ "./node_modules/lodash.set/index.js"));
var twoWayMappingV2MetadataKey = Symbol('twoWayMappingV2');
function setMetaData(metaKey, metaValue) {
    return function mapKeyDecorator(target, propertyKey) {
        return Reflect.defineMetadata(metaKey, metaValue || propertyKey.toString(), target.constructor, propertyKey);
    };
}
// v2 key 双向绑定
function mapV2(metaValue) {
    return setMetaData(twoWayMappingV2MetadataKey, metaValue);
}
// 获取 v2 双向绑定 key
function getMappingKeyV2(target, propertyKey) {
    return Reflect.getMetadata(twoWayMappingV2MetadataKey, target, propertyKey);
}
function getBuildTargetForConfig(_a) {
    var compileOptions = _a.compileOptions;
    if (compileOptions === null || compileOptions === void 0 ? void 0 : compileOptions.downgradeToLegacyWeb) {
        return;
    }
    if (!(compileOptions === null || compileOptions === void 0 ? void 0 : compileOptions.buildTarget) || (compileOptions === null || compileOptions === void 0 ? void 0 : compileOptions.buildTarget) === 'web') {
        return true;
    }
}
function getEnableParallelLoaderForConfig(_a) {
    var developOptions = _a.developOptions;
    if (developOptions === null || developOptions === void 0 ? void 0 : developOptions.disableParallel) {
        return false;
    }
}
function getEnableParallelLoaderForV2(v2Config, config) {
    if (config.enableParallelLoader === false) {
        (0, lodash_set_1.default)(v2Config, 'developOptions.disableParallel', true);
    }
}
var MiniProjectJson = /** @class */ (function () {
    function MiniProjectJson() {
    }
    Object.defineProperty(MiniProjectJson.prototype, "format", {
        get: function () {
            return this._rawConfig.format || 1;
        },
        enumerable: false,
        configurable: true
    });
    // v1 直来直往
    MiniProjectJson.fromV1 = function (config) {
        // 如果version 不对就不加载了
        if (config.format && config.format !== 1) {
            return {};
        }
        return JSON.parse(JSON.stringify(config));
    };
    MiniProjectJson.fromV2 = function (config) {
        var specConfig = {
            format: 2,
        };
        for (var _i = 0, _a = MiniProjectJson.getKeys(); _i < _a.length; _i++) {
            var key = _a[_i];
            var mappedKeyOrFn = getMappingKeyV2(MiniProjectJson, key);
            if (!mappedKeyOrFn) {
                continue;
            }
            var val = void 0;
            if (typeof mappedKeyOrFn === 'string') {
                val = (0, lodash_get_1.default)(config, mappedKeyOrFn);
            }
            else if (mappedKeyOrFn.fromV2 && typeof mappedKeyOrFn.fromV2 === 'function') {
                val = mappedKeyOrFn.fromV2(config);
            }
            if (val !== undefined) {
                specConfig[key] = val;
            }
        }
        return specConfig;
    };
    // v1 直来直往
    MiniProjectJson.toV1 = function (config) {
        if (config.format === 2) {
            throw new Error('cannot transform to mini.project.json format 1');
        }
        return JSON.parse(JSON.stringify(config));
    };
    MiniProjectJson.toV2 = function (config) {
        var v2Config = {
            format: 2,
        };
        var allowKeys = MiniProjectJson.getKeys();
        for (var _i = 0, allowKeys_1 = allowKeys; _i < allowKeys_1.length; _i++) {
            var key = allowKeys_1[_i];
            var mappedKeyOrFn = getMappingKeyV2(MiniProjectJson, key);
            if (!mappedKeyOrFn) {
                if (config[key] !== undefined) {
                    (0, lodash_set_1.default)(v2Config, ['unsupportedConfig', key], config[key]);
                }
                continue;
            }
            if (typeof mappedKeyOrFn === 'string') {
                if (config[key] !== undefined) {
                    (0, lodash_set_1.default)(v2Config, mappedKeyOrFn, config[key]);
                }
            }
            else if (mappedKeyOrFn.setToV2 && typeof mappedKeyOrFn.setToV2 === 'function') {
                mappedKeyOrFn.setToV2(v2Config, config);
            }
        }
        // 还要在处理一下 getKeys 中未申明的用户配置
        var specialKeys = ['format', 'node_modules_es6_whitelist'];
        for (var key in config) {
            if (allowKeys.includes(key) || specialKeys.includes(key)) {
                continue;
            }
            if (Object.prototype.hasOwnProperty.call(config, key)) {
                (0, lodash_set_1.default)(v2Config, ['unsupportedConfig', key], config[key]);
            }
        }
        return v2Config;
    };
    MiniProjectJson.fromFileContent = function (config) {
        return config.format === 2 ? MiniProjectJson.fromV2(config) : MiniProjectJson.fromV1(config);
    };
    MiniProjectJson.toFileContent = function (config) {
        return config.format === 2 ? MiniProjectJson.toV2(config) : MiniProjectJson.toV1(config);
    };
    MiniProjectJson.getKeys = function () {
        return [
            // 'format',
            'enableAppxNg',
            'enableEnhancedBuild',
            'enableHMR',
            'component2',
            'axmlStrictCheck',
            'nonLoadingIndicator',
            'enableParallelLoader',
            'enableDistFileMinify',
            'enableNodeModuleBabelTransform',
            'uniBuild',
            'miniprogramRoot',
            'pluginRoot',
            'componentRoot',
            'compileType',
            'compileSPMDataset',
            'scripts',
            'include',
            'exclude',
            'enableCube',
            'enableUnibuildAndAppxngComplexBundle',
            'debugOptions',
            'experimental',
            'node_modules_es6_whitelist',
            'compatible',
            'cloud',
            'serverlessRoot',
            'compileOptionsLess',
            'compileOptionsTypescript',
            'developOptionsDisableSourcemap',
            'webViewOptions',
            'unsupportedConfig',
        ];
    };
    __decorate([
        mapV2({
            fromV2: getBuildTargetForConfig,
        }),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "enableAppxNg", void 0);
    __decorate([
        mapV2({
            fromV2: getBuildTargetForConfig,
        }),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "uniBuild", void 0);
    __decorate([
        mapV2({
            fromV2: getBuildTargetForConfig,
        }),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "enableUnibuildAndAppxngComplexBundle", void 0);
    __decorate([
        mapV2('developOptions.hotReload'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "enableHMR", void 0);
    __decorate([
        mapV2('compileOptions.component2'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "component2", void 0);
    __decorate([
        mapV2('compileOptions.nonLoadingIndicator'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "nonLoadingIndicator", void 0);
    __decorate([
        mapV2({
            fromV2: getEnableParallelLoaderForConfig,
            setToV2: getEnableParallelLoaderForV2,
        }),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "enableParallelLoader", void 0);
    __decorate([
        mapV2('compileOptions.enableNodeModuleBabelTransform'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "enableNodeModuleBabelTransform", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", String)
    ], MiniProjectJson.prototype, "miniprogramRoot", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", String)
    ], MiniProjectJson.prototype, "pluginRoot", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", String)
    ], MiniProjectJson.prototype, "componentRoot", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", String)
    ], MiniProjectJson.prototype, "compileType", void 0);
    __decorate([
        mapV2('compileOptions.compileSPMDataset'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "compileSPMDataset", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "scripts", void 0);
    __decorate([
        mapV2('assetsInclude'),
        __metadata("design:type", Array)
    ], MiniProjectJson.prototype, "include", void 0);
    __decorate([
        mapV2('uploadExclude'),
        __metadata("design:type", Array)
    ], MiniProjectJson.prototype, "exclude", void 0);
    __decorate([
        mapV2('pluginResolution'),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "debugOptions", void 0);
    __decorate([
        mapV2({
            fromV2: function (v2Config) {
                var _a, _b;
                return ((_a = v2Config.compileOptions) === null || _a === void 0 ? void 0 : _a.nodeModulesES6Whitelist) || ((_b = v2Config.compileOptions) === null || _b === void 0 ? void 0 : _b.node_modules_es6_whitelist);
            },
            setToV2: function (v2Config, config) {
                var nodeModulesES6Whitelist = config.node_modules_es6_whitelist;
                if (config.node_modules_es6_whitelist) {
                    (0, lodash_set_1.default)(v2Config, 'compileOptions.nodeModulesES6Whitelist', nodeModulesES6Whitelist);
                }
            },
        }),
        __metadata("design:type", Array)
    ], MiniProjectJson.prototype, "node_modules_es6_whitelist", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "cloud", void 0);
    __decorate([
        mapV2({
            fromV2: function (v2Config) {
                return v2Config.serverlessRoot;
            },
            setToV2: function (v2Config, config) {
                if (config.serverlessRoot) {
                    v2Config.serverlessRoot = config.serverlessRoot;
                }
                else if (config.cloud) {
                    v2Config.serverlessRoot = 'server';
                }
            },
        }),
        __metadata("design:type", String)
    ], MiniProjectJson.prototype, "serverlessRoot", void 0);
    __decorate([
        mapV2('compileOptions.less'),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "compileOptionsLess", void 0);
    __decorate([
        mapV2('compileOptions.typescript'),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "compileOptionsTypescript", void 0);
    __decorate([
        mapV2('developOptions.disableSourcemap'),
        __metadata("design:type", Boolean)
    ], MiniProjectJson.prototype, "developOptionsDisableSourcemap", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "webViewOptions", void 0);
    __decorate([
        mapV2(),
        __metadata("design:type", Object)
    ], MiniProjectJson.prototype, "unsupportedConfig", void 0);
    return MiniProjectJson;
}());
exports.MiniProjectJson = MiniProjectJson;
//# sourceMappingURL=mini-project-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/fabrication.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/fabrication.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveDebugPlugins = exports.isUsingPlugins = exports.getAllPlugins = exports.getFirstPage = exports.isTabBarEnabledViaTabBarJson = exports.isTabBarEnabled = void 0;
/**
 * 根据 app.json 内容判断是否开启 tabBar
 *
 * @param appJson app.json 内容
 * @param firstPage 首页路径
 */
function isTabBarEnabled(appJson, firstPage) {
    if (!appJson.tabBar || !appJson.tabBar.items || !firstPage) {
        return false;
    }
    // eslint-disable-next-line
    return appJson.tabBar.items.filter(function (item) { return item.pagePath === firstPage; }).length > 0;
}
exports.isTabBarEnabled = isTabBarEnabled;
/**
 * 根据 tabBar.json 内容判断是否开启 tabBar
 *
 * @param tabBarJson tabBar.json 内容
 * @param firstPage 首页路径
 */
function isTabBarEnabledViaTabBarJson(tabBarJson, firstPage) {
    if (!Array.isArray(tabBarJson === null || tabBarJson === void 0 ? void 0 : tabBarJson.items) || !firstPage) {
        return false;
    }
    return Boolean(tabBarJson.items.find(function (item) { return item.tag === firstPage; }));
}
exports.isTabBarEnabledViaTabBarJson = isTabBarEnabledViaTabBarJson;
/**
 * 获取小程序首页
 *
 * @param appJson app.json 内容
 * @param appConfigJson 产物 appConfig.json 内容
 */
function getFirstPage(appJson, appConfigJson) {
    if (appConfigJson === null || appConfigJson === void 0 ? void 0 : appConfigJson.entryPagePath) {
        return appConfigJson.entryPagePath;
    }
    var pages = appJson.pages || [];
    return pages[0];
}
exports.getFirstPage = getFirstPage;
/**
 * 获取小程序引用的所有静态插件
 *
 * @param appJson app.json 内容
 * @param appId 小程序 appId
 */
function getAllPlugins(appJson, appId) {
    var dedup = new Set();
    var allPluginsConfig = [];
    // 根据 appid (provider) 去重
    var append = function (plugin) {
        var before = dedup.size;
        if (plugin.provider === '{{currentPluginId}}' && appId) {
            plugin.provider = appId; // 特殊值替换为选中的 pluginId
        }
        dedup.add(plugin.provider);
        if (dedup.size > before) {
            allPluginsConfig.push(plugin);
        }
    };
    // eslint-disable-next-line
    var getPlugins = function (config) {
        if (config === void 0) { config = {}; }
        var plugins = config.plugins || {};
        return Object.keys(plugins).map(function (k) { return plugins[k]; });
    };
    getPlugins(appJson).forEach(append); // 主包引用的插件
    if (appJson.subPackages) {
        for (var _i = 0, _a = appJson.subPackages; _i < _a.length; _i++) {
            var sub = _a[_i];
            getPlugins(sub).forEach(append); // 各个分包引用的插件
        }
    }
    return allPluginsConfig;
}
exports.getAllPlugins = getAllPlugins;
/**
 * 小程序是否引用了插件
 *
 * @param appJson app.json 内容
 */
function isUsingPlugins(appJson) {
    return !!(appJson === null || appJson === void 0 ? void 0 : appJson.useDynamicPlugins) || !!(appJson === null || appJson === void 0 ? void 0 : appJson.plugins);
}
exports.isUsingPlugins = isUsingPlugins;
/*
 * 解析联调插件:
 * - 把联调插件从 debugPlugins 中读出来后和 pluginList 合并
 * - 合并时只取 pluginList 中存在插件的联调配置
 * - DEBUG 版本的插件版本号为 dev:a.b.c.d，INSPECT 版本的插件版本号为 inspect:a.b.c.d
 */
function resolveDebugPlugins(debugPlugins, pluginList) {
    debugPlugins = debugPlugins || {};
    pluginList = pluginList || [];
    var debugPluginList = [];
    for (var _i = 0, pluginList_1 = pluginList; _i < pluginList_1.length; _i++) {
        var plugin = pluginList_1[_i];
        var debugPlugin = debugPlugins[plugin.pluginId];
        if (debugPlugin) {
            // 有联调配置时使用联调版本
            var version = debugPlugin.version;
            if (version.startsWith('dev:') || version.startsWith('inspect:')) {
                // 加入联调插件信息
                debugPluginList.push({ pluginId: plugin.pluginId, version: version, lazy: plugin.lazy });
            }
            else {
                throw new Error("Debug config for plugin ".concat(plugin.pluginId, " invalid: ")
                    + "version `".concat(version, "` is not valid, should start with `dev:` or `inspect:`"));
            }
        }
        else {
            // 没有联调配置使用原版
            debugPluginList.push(plugin);
        }
    }
    return debugPluginList;
}
exports.resolveDebugPlugins = resolveDebugPlugins;
//# sourceMappingURL=fabrication.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MiniProjectJson = exports.transformV1ToV2 = void 0;
__exportStar(__webpack_require__(/*! ./fabrication */ "./node_modules/@alipay/mini-program-config-loader/lib/fabrication.js"), exports);
__exportStar(__webpack_require__(/*! ./load-mini-project-json */ "./node_modules/@alipay/mini-program-config-loader/lib/load-mini-project-json.js"), exports);
__exportStar(__webpack_require__(/*! ./load-app-json */ "./node_modules/@alipay/mini-program-config-loader/lib/load-app-json.js"), exports);
__exportStar(__webpack_require__(/*! ./load-package-json */ "./node_modules/@alipay/mini-program-config-loader/lib/load-package-json.js"), exports);
__exportStar(__webpack_require__(/*! ./load-plugin-json */ "./node_modules/@alipay/mini-program-config-loader/lib/load-plugin-json.js"), exports);
__exportStar(__webpack_require__(/*! ./load-preload-json */ "./node_modules/@alipay/mini-program-config-loader/lib/load-preload-json.js"), exports);
var transform_mini_project_json_1 = __webpack_require__(/*! ./utils/transform-mini-project-json */ "./node_modules/@alipay/mini-program-config-loader/lib/utils/transform-mini-project-json.js");
Object.defineProperty(exports, "transformV1ToV2", ({ enumerable: true, get: function () { return transform_mini_project_json_1.transformV1ToV2; } }));
var mini_project_json_1 = __webpack_require__(/*! ./entity/mini-project-json */ "./node_modules/@alipay/mini-program-config-loader/lib/entity/mini-project-json.js");
Object.defineProperty(exports, "MiniProjectJson", ({ enumerable: true, get: function () { return mini_project_json_1.MiniProjectJson; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/load-app-json.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/load-app-json.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadAppJSONSync = exports.loadAppJSON = exports.getAppJsonPath = void 0;
var path = __importStar(__webpack_require__(/*! path */ "path"));
var mini_program_build_shared_io_1 = __webpack_require__(/*! @alipay/mini-program-build-shared-io */ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js");
function getAppJsonPath(miniprogramRoot) {
    return path.join(miniprogramRoot, 'app.json');
}
exports.getAppJsonPath = getAppJsonPath;
function loadAppJSON(miniprogramRoot) {
    return __awaiter(this, void 0, void 0, function () {
        var appPath, appConfig, extPath, extConfig, _i, _a, k;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!miniprogramRoot) {
                        return [2 /*return*/, {}];
                    }
                    appPath = getAppJsonPath(miniprogramRoot);
                    return [4 /*yield*/, (0, mini_program_build_shared_io_1.loadJSON)(appPath)];
                case 1:
                    appConfig = _b.sent();
                    extPath = path.join(miniprogramRoot, 'ext.json');
                    return [4 /*yield*/, (0, mini_program_build_shared_io_1.loadJSON)(extPath)];
                case 2:
                    extConfig = _b.sent();
                    if (!extConfig.extEnable) {
                        extConfig = {};
                    }
                    for (_i = 0, _a = Object.keys(extConfig); _i < _a.length; _i++) {
                        k = _a[_i];
                        if (!k.match(/ext[A-Z\d]/)) {
                            appConfig[k] = extConfig[k];
                        }
                    }
                    return [2 /*return*/, appConfig];
            }
        });
    });
}
exports.loadAppJSON = loadAppJSON;
function loadAppJSONSync(miniprogramRoot) {
    if (!miniprogramRoot) {
        return {};
    }
    var appPath = getAppJsonPath(miniprogramRoot);
    var appConfig = (0, mini_program_build_shared_io_1.loadJSONSync)(appPath);
    // TODO Get types of `ext.json`.
    var extPath = path.join(miniprogramRoot, 'ext.json');
    var extConfig = (0, mini_program_build_shared_io_1.loadJSONSync)(extPath);
    if (!extConfig.extEnable) {
        extConfig = {};
    }
    for (var _i = 0, _a = Object.keys(extConfig); _i < _a.length; _i++) {
        var k = _a[_i];
        if (!k.match(/ext[A-Z\d]/)) {
            appConfig[k] = extConfig[k];
        }
    }
    return appConfig;
}
exports.loadAppJSONSync = loadAppJSONSync;
//# sourceMappingURL=load-app-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/load-mini-project-json.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/load-mini-project-json.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * A module to resolve `mini.project.json`.
 * Modified from `minicode-compile`.
 */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadMiniProjectJsonSync = exports.loadMiniProjectJson = exports.loadRawMiniProjectJsonSync = exports.loadRawMiniProjectJson = exports.getMiniProjectJsonPath = void 0;
var path = __importStar(__webpack_require__(/*! path */ "path"));
var mini_program_types_1 = __webpack_require__(/*! @alipay/mini-program-types */ "./node_modules/@alipay/mini-program-types/lib/index.js");
var mini_program_build_shared_io_1 = __webpack_require__(/*! @alipay/mini-program-build-shared-io */ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js");
var transform_mini_project_json_1 = __webpack_require__(/*! ./utils/transform-mini-project-json */ "./node_modules/@alipay/mini-program-config-loader/lib/utils/transform-mini-project-json.js");
function getMiniProjectJsonPath(projectRoot) {
    return path.join(projectRoot, mini_program_types_1.MINI_PROJECT_CONFIG_FILE);
}
exports.getMiniProjectJsonPath = getMiniProjectJsonPath;
function transformAndLoadMiniProjectJsonSync(projectRoot) {
    var miniProjectConfigPath = getMiniProjectJsonPath(projectRoot);
    if (mini_program_build_shared_io_1.fs.existsSync(miniProjectConfigPath)) {
        return (0, transform_mini_project_json_1.transformMiniProjectJson)((0, mini_program_build_shared_io_1.loadJSONSync)(miniProjectConfigPath));
    }
    return {};
}
function transformAndLoadMiniProjectJson(projectRoot) {
    return __awaiter(this, void 0, void 0, function () {
        var miniProjectConfigPath, config;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    miniProjectConfigPath = getMiniProjectJsonPath(projectRoot);
                    if (!mini_program_build_shared_io_1.fs.existsSync(miniProjectConfigPath)) return [3 /*break*/, 2];
                    return [4 /*yield*/, (0, mini_program_build_shared_io_1.loadJSON)(miniProjectConfigPath)];
                case 1:
                    config = _a.sent();
                    return [2 /*return*/, (0, transform_mini_project_json_1.transformMiniProjectJson)(config)];
                case 2: return [2 /*return*/, {}];
            }
        });
    });
}
/**
 * Load original json content of `mini.project.json`.
 */
function loadRawMiniProjectJson(projectRoot) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, transformAndLoadMiniProjectJson(projectRoot)];
        });
    });
}
exports.loadRawMiniProjectJson = loadRawMiniProjectJson;
/**
 * Load original json content of `mini.project.json`.
 */
function loadRawMiniProjectJsonSync(projectRoot) {
    return transformAndLoadMiniProjectJsonSync(projectRoot);
}
exports.loadRawMiniProjectJsonSync = loadRawMiniProjectJsonSync;
/**
 * Load `mini.project.json` with some business logic, e.g. make `miniprogramRoot` absolute.
 */
function loadMiniProjectJson(projectRoot) {
    return __awaiter(this, void 0, void 0, function () {
        var miniProjectConfigRaw;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!projectRoot) {
                        return [2 /*return*/, {
                                _raw: {},
                                _wasEmpty: true,
                            }];
                    }
                    return [4 /*yield*/, transformAndLoadMiniProjectJson(projectRoot)];
                case 1:
                    miniProjectConfigRaw = _a.sent();
                    return [2 /*return*/, parseMiniProjectJson(projectRoot, miniProjectConfigRaw)];
            }
        });
    });
}
exports.loadMiniProjectJson = loadMiniProjectJson;
/**
 * Load `mini.project.json` with some business logic, e.g. make `miniprogramRoot` absolute.
 */
function loadMiniProjectJsonSync(projectRoot) {
    if (!projectRoot) {
        return {
            _raw: {},
            _wasEmpty: true,
        };
    }
    var miniProjectConfigRaw = transformAndLoadMiniProjectJsonSync(projectRoot);
    return parseMiniProjectJson(projectRoot, miniProjectConfigRaw);
}
exports.loadMiniProjectJsonSync = loadMiniProjectJsonSync;
function parseMiniProjectJson(projectRoot, miniProjectConfigRaw) {
    var resolvePath = function (key) {
        var val = miniProjectConfigRaw[key];
        var resolved = path.join(projectRoot, val);
        if (path.isAbsolute(val)) {
            throw new Error("Parse ".concat(mini_program_types_1.MINI_PROJECT_CONFIG_FILE, " failed: ").concat(key, " can only be relative path"));
        }
        if (path.relative(projectRoot, resolved).startsWith('..')) {
            throw new Error("Parse ".concat(mini_program_types_1.MINI_PROJECT_CONFIG_FILE, " failed: ").concat(key, " cannot point to a path outside workspace root"));
        }
        return resolved;
    };
    var projectConfig = __assign({}, miniProjectConfigRaw);
    // resolve 路径类配置
    if (projectConfig.miniprogramRoot) {
        projectConfig.miniprogramRoot = resolvePath('miniprogramRoot');
    }
    else {
        var serverPath = path.join(projectRoot, 'server');
        if (mini_program_build_shared_io_1.fs.pathExistsSync(serverPath)) {
            // 云服务/Serverless 项目，尝试 client 目录
            // TODO: 这个逻辑真的需要吗...
            var clientPath = path.join(projectRoot, 'client');
            if (mini_program_build_shared_io_1.fs.pathExistsSync(path.join(clientPath, 'app.json'))) {
                // client 目录存在且有 app.json，认为它是小程序目录
                projectConfig.miniprogramRoot = clientPath;
            }
            else {
                projectConfig.miniprogramRoot = projectRoot;
            }
        }
        else {
            // 默认使用项目根目录
            projectConfig.miniprogramRoot = projectRoot;
        }
    }
    if (projectConfig.pluginRoot) {
        projectConfig.pluginRoot = resolvePath('pluginRoot');
    }
    if (projectConfig.componentRoot) {
        projectConfig.componentRoot = resolvePath('componentRoot');
    }
    return __assign({ _raw: miniProjectConfigRaw, _wasEmpty: Object.keys(miniProjectConfigRaw).length < 1 }, projectConfig);
}
//# sourceMappingURL=load-mini-project-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/load-package-json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/load-package-json.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPkgSync = exports.loadPkg = void 0;
/**
 * Module dependencies
 */
var path_1 = __webpack_require__(/*! path */ "path");
var mini_program_build_shared_io_1 = __webpack_require__(/*! @alipay/mini-program-build-shared-io */ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js");
/**
 * Expose a utility to resolve package.json (ASYNC)
 *
 * @param cwd current working directory
 */
function loadPkg(cwd) {
    return (0, mini_program_build_shared_io_1.loadJSON)((0, path_1.join)(cwd, 'package.json'));
}
exports.loadPkg = loadPkg;
/**
 * Expose a utility to resolve package.json (SYNC)
 *
 * @param cwd current working directory
 */
function loadPkgSync(cwd) {
    return (0, mini_program_build_shared_io_1.loadJSONSync)((0, path_1.join)(cwd, 'package.json'));
}
exports.loadPkgSync = loadPkgSync;
//# sourceMappingURL=load-package-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/load-plugin-json.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/load-plugin-json.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPluginJsonSync = exports.loadPluginJson = exports.getPluginJsonPath = void 0;
var path = __importStar(__webpack_require__(/*! path */ "path"));
var mini_program_build_shared_io_1 = __webpack_require__(/*! @alipay/mini-program-build-shared-io */ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js");
function getPluginJsonPath(pluginRoot) {
    return path.join(pluginRoot, 'plugin.json');
}
exports.getPluginJsonPath = getPluginJsonPath;
function loadPluginJson(pluginRoot) {
    return __awaiter(this, void 0, void 0, function () {
        var pluginJsonPath;
        return __generator(this, function (_a) {
            if (!pluginRoot) {
                return [2 /*return*/, {}];
            }
            pluginJsonPath = getPluginJsonPath(pluginRoot);
            return [2 /*return*/, (0, mini_program_build_shared_io_1.loadJSON)(pluginJsonPath)];
        });
    });
}
exports.loadPluginJson = loadPluginJson;
function loadPluginJsonSync(pluginRoot) {
    if (!pluginRoot) {
        return {};
    }
    var pluginJsonPath = getPluginJsonPath(pluginRoot);
    return (0, mini_program_build_shared_io_1.loadJSONSync)(pluginJsonPath);
}
exports.loadPluginJsonSync = loadPluginJsonSync;
//# sourceMappingURL=load-plugin-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/load-preload-json.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/load-preload-json.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadPreloadJsonSync = exports.loadPreloadJson = exports.getPreloadJsonPath = void 0;
var path = __importStar(__webpack_require__(/*! path */ "path"));
var mini_program_build_shared_io_1 = __webpack_require__(/*! @alipay/mini-program-build-shared-io */ "./node_modules/@alipay/mini-program-build-shared-io/lib/index.js");
function getPreloadJsonPath(miniprogramRoot) {
    return path.join(miniprogramRoot, 'preload.json');
}
exports.getPreloadJsonPath = getPreloadJsonPath;
function loadPreloadJson(miniprogramRoot) {
    return __awaiter(this, void 0, void 0, function () {
        var appPath;
        return __generator(this, function (_a) {
            if (!miniprogramRoot) {
                return [2 /*return*/, []];
            }
            appPath = getPreloadJsonPath(miniprogramRoot);
            return [2 /*return*/, (0, mini_program_build_shared_io_1.loadJSON)(appPath, true, [])];
        });
    });
}
exports.loadPreloadJson = loadPreloadJson;
function loadPreloadJsonSync(miniprogramRoot) {
    if (!miniprogramRoot) {
        return [];
    }
    var appPath = getPreloadJsonPath(miniprogramRoot);
    return (0, mini_program_build_shared_io_1.loadJSONSync)(appPath, true, []);
}
exports.loadPreloadJsonSync = loadPreloadJsonSync;
//# sourceMappingURL=load-preload-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-config-loader/lib/utils/transform-mini-project-json.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-config-loader/lib/utils/transform-mini-project-json.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.transformV1ToV2 = exports.transformMiniProjectJson = void 0;
var mini_project_json_1 = __webpack_require__(/*! ../entity/mini-project-json */ "./node_modules/@alipay/mini-program-config-loader/lib/entity/mini-project-json.js");
/**
 *
 * 把新版本的配置文件、转换为旧版本的配置文件
 *
 * @param _config 原始的配置文件
 * @returns IMiniProjectJsonSpec mini.project.json 规范
 */
function transformMiniProjectJson(_config) {
    var _a;
    var format = (_a = _config.format) !== null && _a !== void 0 ? _a : 1;
    switch (format) {
        case 2: {
            return mini_project_json_1.MiniProjectJson.fromV2(_config);
        }
        case 1: {
            return mini_project_json_1.MiniProjectJson.fromV1(_config);
        }
        default: {
            throw new Error("don't support mini.project.json format ".concat(format, ", please upgrade ide"));
        }
    }
}
exports.transformMiniProjectJson = transformMiniProjectJson;
function transformV1ToV2(config) {
    var realConfig = mini_project_json_1.MiniProjectJson.fromV1(config);
    return mini_project_json_1.MiniProjectJson.toV2(realConfig);
}
exports.transformV1ToV2 = transformV1ToV2;
//# sourceMappingURL=transform-mini-project-json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/api/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/api/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiTypes = void 0;
var ApiTypes = __importStar(__webpack_require__(/*! @alipay/mini-api-types */ "./node_modules/@alipay/mini-api-types/lib/index.js"));
exports.ApiTypes = ApiTypes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/app/app_js.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/app/app_js.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=app_js.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/app/app_json.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/app/app_json.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=app_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/app/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/app/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./app_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/app/app_json.js"), exports);
__exportStar(__webpack_require__(/*! ./app_js */ "./node_modules/@alipay/mini-program-runtime-types/lib/app/app_js.js"), exports);
__exportStar(__webpack_require__(/*! ./plugin_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/app/plugin_json.js"), exports);
__exportStar(__webpack_require__(/*! ./preload_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/app/preload_json.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/app/plugin_json.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/app/plugin_json.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=plugin_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/app/preload_json.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/app/preload_json.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=preload_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/component/component_js.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/component/component_js.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// # sourceMappingURL=index_js.d.ts.map
//# sourceMappingURL=component_js.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/component/component_json.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/component/component_json.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=component_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/component/index.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/component/index.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./component_js */ "./node_modules/@alipay/mini-program-runtime-types/lib/component/component_js.js"), exports);
__exportStar(__webpack_require__(/*! ./component_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/component/component_json.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./app */ "./node_modules/@alipay/mini-program-runtime-types/lib/app/index.js"), exports);
__exportStar(__webpack_require__(/*! ./page */ "./node_modules/@alipay/mini-program-runtime-types/lib/page/index.js"), exports);
__exportStar(__webpack_require__(/*! ./component */ "./node_modules/@alipay/mini-program-runtime-types/lib/component/index.js"), exports);
__exportStar(__webpack_require__(/*! ./shared */ "./node_modules/@alipay/mini-program-runtime-types/lib/shared/index.js"), exports);
__exportStar(__webpack_require__(/*! ./api */ "./node_modules/@alipay/mini-program-runtime-types/lib/api/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/page/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/page/index.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./page_js */ "./node_modules/@alipay/mini-program-runtime-types/lib/page/page_js.js"), exports);
__exportStar(__webpack_require__(/*! ./page_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/page/page_json.js"), exports);
__exportStar(__webpack_require__(/*! ./web-view_json */ "./node_modules/@alipay/mini-program-runtime-types/lib/page/web-view_json.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/page/page_js.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/page/page_js.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=page_js.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/page/page_json.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/page/page_json.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=page_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/page/web-view_json.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/page/web-view_json.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=web-view_json.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-runtime-types/lib/shared/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-runtime-types/lib/shared/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/context.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/context.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/events.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/events.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EAppxCompilationEvent = void 0;
var EAppxCompilationEvent;
(function (EAppxCompilationEvent) {
    EAppxCompilationEvent["done"] = "done";
    EAppxCompilationEvent["failed"] = "failed";
    EAppxCompilationEvent["invalid"] = "invalid";
})(EAppxCompilationEvent = exports.EAppxCompilationEvent || (exports.EAppxCompilationEvent = {}));
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./context */ "./node_modules/@alipay/mini-program-types/lib/build/context.js"), exports);
__exportStar(__webpack_require__(/*! ./events */ "./node_modules/@alipay/mini-program-types/lib/build/events.js"), exports);
__exportStar(__webpack_require__(/*! ./project */ "./node_modules/@alipay/mini-program-types/lib/build/project.js"), exports);
__exportStar(__webpack_require__(/*! ./plugin */ "./node_modules/@alipay/mini-program-types/lib/build/plugin.js"), exports);
__exportStar(__webpack_require__(/*! ./vanilla-build */ "./node_modules/@alipay/mini-program-types/lib/build/vanilla-build.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/plugin.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/plugin.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=plugin.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/project.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/project.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EAppxElementAtomType = exports.EAppxPluginType = exports.EAppxElementType = void 0;
var EAppxElementType;
(function (EAppxElementType) {
    EAppxElementType["App"] = "App";
    EAppxElementType["Page"] = "Page";
    EAppxElementType["Component"] = "Component";
})(EAppxElementType = exports.EAppxElementType || (exports.EAppxElementType = {}));
var EAppxPluginType;
(function (EAppxPluginType) {
    EAppxPluginType["Plugin"] = "Plugin";
})(EAppxPluginType = exports.EAppxPluginType || (exports.EAppxPluginType = {}));
var EAppxElementAtomType;
(function (EAppxElementAtomType) {
    EAppxElementAtomType["axml"] = "axml";
    EAppxElementAtomType["script"] = "script";
    EAppxElementAtomType["style"] = "style";
    EAppxElementAtomType["config"] = "config";
})(EAppxElementAtomType = exports.EAppxElementAtomType || (exports.EAppxElementAtomType = {}));
//# sourceMappingURL=project.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/build/vanilla-build.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/build/vanilla-build.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=vanilla-build.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/client/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/client/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// COMMENT HERE SINCE ENUM IS HARD TO USE.
//
// {
// alipay = 'alipay',
// dingtalk = 'dingtalk',
// taobao = 'taobao',
// uc = 'uc',
// quark = 'quark',
// alibabaHealth = 'alibabaHealth',
// cainiao = 'cainiao',
// }
// /**
//  * BundleId
//  */
// export const EClientBundleId: Record<EClientType, string> = {
//   [EClientType.alipay]: 'com.alipay.wallet.test',
//   [EClientType.dingtalk]: 'N/A',
//   [EClientType.taobao]: 'N/A',
//   [EClientType.uc]: 'com.uc.app',
//   [EClientType.quark]: 'com.quark.browser',
//   [EClientType.alibabaHealth]: 'com.alibaba.health',
//   [EClientType.cainiao]: 'com.cainiao.cs.app',
// };
// export type IsAlipay<T extends EClientType> = T extends EClientType.alipay ? true : false;
// export type IsDingtalk<T extends EClientType> = T extends EClientType.dingtalk ? true : false;
// export type GetBundleId<T extends EClientType> = typeof EClientBundleId[T];
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/cloud-build/index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/cloud-build/index.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./package */ "./node_modules/@alipay/mini-program-types/lib/cloud-build/package.js"), exports);
__exportStar(__webpack_require__(/*! ./options */ "./node_modules/@alipay/mini-program-types/lib/cloud-build/options.js"), exports);
__exportStar(__webpack_require__(/*! ./types */ "./node_modules/@alipay/mini-program-types/lib/cloud-build/types.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/cloud-build/options.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/cloud-build/options.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EPackageType = void 0;
/**
 * 包类型
 */
var EPackageType;
(function (EPackageType) {
    EPackageType["Debug"] = "DEBUG";
    EPackageType["Inspect"] = "INSPECT";
})(EPackageType = exports.EPackageType || (exports.EPackageType = {}));
//# sourceMappingURL=options.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/cloud-build/package.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/cloud-build/package.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=package.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/cloud-build/types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/cloud-build/types.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECloudBuildStatus = exports.ECloudBuildMode = void 0;
/**
 * 云构建任务的模式
 */
var ECloudBuildMode;
(function (ECloudBuildMode) {
    ECloudBuildMode["Build"] = "build";
    ECloudBuildMode["BuildPush"] = "buildpush";
    ECloudBuildMode["Push"] = "push";
})(ECloudBuildMode = exports.ECloudBuildMode || (exports.ECloudBuildMode = {}));
/**
 * 云构建任务的状态
 */
var ECloudBuildStatus;
(function (ECloudBuildStatus) {
    ECloudBuildStatus["Building"] = "BUILDING";
    ECloudBuildStatus["Pushing"] = "PUSHING";
    ECloudBuildStatus["Complete"] = "COMPLETE";
    ECloudBuildStatus["PushComplete"] = "PUSHCOMPLETE";
    ECloudBuildStatus["BuildCancel"] = "BUILDCANCEL";
    ECloudBuildStatus["PushCancel"] = "PUSHCANCEL";
})(ECloudBuildStatus = exports.ECloudBuildStatus || (exports.ECloudBuildStatus = {}));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/config.js":
/*!***************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/config.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MINI_PROJECT_CONFIG_FILE = exports.ECompileType = void 0;
var ECompileType;
(function (ECompileType) {
    ECompileType["MiniProgram"] = "mini";
    ECompileType["Plugin"] = "plugin";
    /**
     * @private
     */
    ECompileType["Component"] = "component";
})(ECompileType = exports.ECompileType || (exports.ECompileType = {}));
exports.MINI_PROJECT_CONFIG_FILE = 'mini.project.json';
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/fallback-build/index.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/fallback-build/index.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./build */ "./node_modules/@alipay/mini-program-types/lib/build/index.js"), exports);
__exportStar(__webpack_require__(/*! ./cloud-build */ "./node_modules/@alipay/mini-program-types/lib/cloud-build/index.js"), exports);
__exportStar(__webpack_require__(/*! ./runtime */ "./node_modules/@alipay/mini-program-types/lib/runtime/index.js"), exports);
__exportStar(__webpack_require__(/*! ./client */ "./node_modules/@alipay/mini-program-types/lib/client/index.js"), exports);
__exportStar(__webpack_require__(/*! ./config */ "./node_modules/@alipay/mini-program-types/lib/config.js"), exports);
__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/@alipay/mini-program-types/lib/logger/index.js"), exports);
__exportStar(__webpack_require__(/*! ./shared */ "./node_modules/@alipay/mini-program-types/lib/shared/index.js"), exports);
__exportStar(__webpack_require__(/*! ./river */ "./node_modules/@alipay/mini-program-types/lib/river/index.js"), exports);
__exportStar(__webpack_require__(/*! ./fallback-build */ "./node_modules/@alipay/mini-program-types/lib/fallback-build/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/logger/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/logger/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./logger */ "./node_modules/@alipay/mini-program-types/lib/logger/logger.js"), exports);
__exportStar(__webpack_require__(/*! ./key-logger */ "./node_modules/@alipay/mini-program-types/lib/logger/key-logger.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/logger/key-logger.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/logger/key-logger.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=key-logger.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/logger/logger.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/logger/logger.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ELoggerLevel = void 0;
var ELoggerLevel;
(function (ELoggerLevel) {
    ELoggerLevel[ELoggerLevel["silent"] = 0] = "silent";
    ELoggerLevel[ELoggerLevel["error"] = 1] = "error";
    ELoggerLevel[ELoggerLevel["warn"] = 2] = "warn";
    ELoggerLevel[ELoggerLevel["info"] = 3] = "info";
    ELoggerLevel[ELoggerLevel["debug"] = 4] = "debug";
})(ELoggerLevel = exports.ELoggerLevel || (exports.ELoggerLevel = {}));
//# sourceMappingURL=logger.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/river/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/river/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/runtime/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/runtime/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! @alipay/mini-program-runtime-types */ "./node_modules/@alipay/mini-program-runtime-types/lib/index.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@alipay/mini-program-types/lib/shared/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@alipay/mini-program-types/lib/shared/index.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/address/lib/address.js":
/*!*********************************************!*\
  !*** ./node_modules/address/lib/address.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var os = __webpack_require__(/*! os */ "os");
var fs = __webpack_require__(/*! fs */ "fs");
var child = __webpack_require__(/*! child_process */ "child_process");

var DEFAULT_RESOLV_FILE = '/etc/resolv.conf';

function getInterfaceName() {
  var val = 'eth';
  var platform = os.platform();
  if (platform === 'darwin') {
    val = 'en';
  } else if (platform === 'win32') {
    val = null;
  }
  return val;
}

function getIfconfigCMD() {
  if (os.platform() === 'win32') {
    return 'ipconfig/all';
  }
  return '/sbin/ifconfig';
}

// typeof os.networkInterfaces family is a number (v18.0.0)
// types: 'IPv4' | 'IPv6' => 4 | 6
// @see https://github.com/nodejs/node/issues/42861
function matchName(actualFamily, expectedFamily) {
  if (expectedFamily === 'IPv4') {
    return actualFamily === 'IPv4' || actualFamily === 4;
  }
  if (expectedFamily === 'IPv6') {
    return actualFamily === 'IPv6' || actualFamily === 6;
  }
  return actualFamily === expectedFamily;
}

/**
 * Get all addresses.
 *
 * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
 * @param {Function(err, addr)} callback
 *  - {Object} addr {
 *    - {String} ip
 *    - {String} ipv6
 *    - {String} mac
 *  }
 */
function address(interfaceName, callback) {
  if (typeof interfaceName === 'function') {
    callback = interfaceName;
    interfaceName = null;
  }

  var addr = {
    ip: address.ip(interfaceName),
    ipv6: address.ipv6(interfaceName),
    mac: null
  };
  address.mac(interfaceName, function (err, mac) {
    if (mac) {
      addr.mac = mac;
    }
    callback(err, addr);
  });
}

address.interface = function (family, name) {
  var interfaces = os.networkInterfaces();
  var noName = !name;
  name = name || getInterfaceName();
  family = family || 'IPv4';
  for (var i = -1; i < 8; i++) {
    var interfaceName = name + (i >= 0 ? i : ''); // support 'lo' and 'lo0'
    var items = interfaces[interfaceName];
    if (items) {
      for (var j = 0; j < items.length; j++) {
        var item = items[j];
        if (matchName(item.family, family)) {
          return item;
        }
      }
    }
  }

  if (noName) {
    // filter all loopback or local addresses
    for (var k in interfaces) {
      var items = interfaces[k];
      for (var i = 0; i < items.length; i++) {
        var item = items[i];
        // all 127 addresses are local and should be ignored
        if (matchName(item.family, family) && !item.address.startsWith('127.')) {
          return item;
        }
      }
    }
  }
  return;
};

/**
 * Get current machine IPv4
 *
 * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
 * @return {String} IP address
 */
address.ip = function (interfaceName) {
  var item = address.interface('IPv4', interfaceName);
  return item && item.address;
};

/**
 * Get current machine IPv6
 *
 * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
 * @return {String} IP address
 */
address.ipv6 = function (interfaceName) {
  var item = address.interface('IPv6', interfaceName);
  return item && item.address;
};

// osx start line 'en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500'
// linux start line 'eth0      Link encap:Ethernet  HWaddr 00:16:3E:00:0A:29  '
var MAC_OSX_START_LINE = /^(\w+)\:\s+flags=/;
var MAC_LINUX_START_LINE = /^(\w+)\s{2,}link encap:\w+/i;

// ether 78:ca:39:b0:e6:7d
// HWaddr 00:16:3E:00:0A:29
var MAC_RE = address.MAC_RE = /(?:ether|HWaddr)\s+((?:[a-z0-9]{2}\:){5}[a-z0-9]{2})/i;

// osx: inet 192.168.2.104 netmask 0xffffff00 broadcast 192.168.2.255
// linux: inet addr:10.125.5.202  Bcast:10.125.15.255  Mask:255.255.240.0
var MAC_IP_RE = address.MAC_IP_RE = /inet\s(?:addr\:)?(\d+\.\d+\.\d+\.\d+)/;

function getMAC(content, interfaceName, matchIP) {
  var lines = content.split('\n');
  for (var i = 0; i < lines.length; i++) {
    var line = lines[i].trimRight();
    var m = MAC_OSX_START_LINE.exec(line) || MAC_LINUX_START_LINE.exec(line);
    if (!m) {
      continue;
    }

    // check interface name
    var name = m[1];
    if (name.indexOf(interfaceName) !== 0) {
      continue;
    }

    var ip = null;
    var mac = null;
    var match = MAC_RE.exec(line);
    if (match) {
      mac = match[1];
    }

    i++;
    while (true) {
      line = lines[i];
      if (!line || MAC_OSX_START_LINE.exec(line) || MAC_LINUX_START_LINE.exec(line)) {
        i--;
        break; // hit next interface, handle next interface
      }
      if (!mac) {
        match = MAC_RE.exec(line);
        if (match) {
          mac = match[1];
        }
      }

      if (!ip) {
        match = MAC_IP_RE.exec(line);
        if (match) {
          ip = match[1];
        }
      }

      i++;
    }

    if (ip === matchIP) {
      return mac;
    }
  }
}

/**
 * Get current machine MAC address
 *
 * @param {String} [interfaceName] interface name, default is 'eth' on linux, 'en' on mac os.
 * @param {Function(err, address)} callback
 */
address.mac = function (interfaceName, callback) {
  if (typeof interfaceName === 'function') {
    callback = interfaceName;
    interfaceName = null;
  }
  interfaceName = interfaceName || getInterfaceName();
  var item = address.interface('IPv4', interfaceName);
  if (!item) {
    return callback();
  }

  // https://github.com/nodejs/node/issues/13581
  // bug in node 7.x and <= 8.4.0
  if (!process.env.CI && (item.mac === 'ff:00:00:00:00:00' || item.mac === '00:00:00:00:00:00')) {
    // wrong address, ignore it
    item.mac = '';
  }

  if (item.mac) {
    return callback(null, item.mac);
  }

  child.exec(getIfconfigCMD(), {timeout: 5000}, function (err, stdout, stderr) {
    if (err || !stdout) {
      return callback(err);
    }

    var mac = getMAC(stdout || '', interfaceName, item.address);
    callback(null, mac);
  });
};

// nameserver 172.24.102.254
var DNS_SERVER_RE = /^nameserver\s+(\d+\.\d+\.\d+\.\d+)$/i;

/**
 * Get DNS servers.
 *
 * @param {String} [filepath] resolv config file path. default is '/etc/resolv.conf'.
 * @param {Function(err, servers)} callback
 */
address.dns = function (filepath, callback) {
  if (typeof filepath === 'function') {
    callback = filepath;
    filepath = null;
  }
  filepath = filepath || DEFAULT_RESOLV_FILE;
  fs.readFile(filepath, 'utf8', function (err, content) {
    if (err) {
      return callback(err);
    }
    var servers = [];
    content = content || '';
    var lines = content.split('\n');
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i].trim();
      var m = DNS_SERVER_RE.exec(line);
      if (m) {
        servers.push(m[1]);
      }
    }

    callback(null, servers);
  });
};

module.exports = address;


/***/ }),

/***/ "./node_modules/at-least-node/index.js":
/*!*********************************************!*\
  !*** ./node_modules/at-least-node/index.js ***!
  \*********************************************/
/***/ ((module) => {

module.exports = r => {
  const n = process.versions.node.split('.').map(x => parseInt(x, 10))
  r = r.split('.').map(x => parseInt(x, 10))
  return n[0] > r[0] || (n[0] === r[0] && (n[1] > r[1] || (n[1] === r[1] && n[2] >= r[2])))
}


/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(/*! concat-map */ "./node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "./node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/copy-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/copy-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdirsSync = (__webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js").mkdirsSync)
const utimesMillisSync = (__webpack_require__(/*! ../util/utimes */ "./node_modules/fs-extra/lib/util/utimes.js").utimesMillisSync)
const stat = __webpack_require__(/*! ../util/stat */ "./node_modules/fs-extra/lib/util/stat.js")

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy')
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  return handleFilterAndCopy(destStat, src, dest, opts)
}

function handleFilterAndCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirsSync(destParent)
  return startCopy(destStat, src, dest, opts)
}

function startCopy (destStat, src, dest, opts) {
  if (opts.filter && !opts.filter(src, dest)) return
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  fs.copyFileSync(src, dest)
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)
  return setDestMode(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)
  return setDestTimestamps(src, dest)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200)
}

function setDestMode (dest, srcMode) {
  return fs.chmodSync(dest, srcMode)
}

function setDestTimestamps (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs.statSync(src)
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
  if (destStat && !destStat.isDirectory()) {
    throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
  }
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcMode, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return setDestMode(dest, srcMode)
}

function copyDir (src, dest, opts) {
  fs.readdirSync(src).forEach(item => copyDirItem(item, src, dest, opts))
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy')
  return startCopy(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (!destStat) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

module.exports = copySync


/***/ }),

/***/ "./node_modules/fs-extra/lib/copy-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  copySync: __webpack_require__(/*! ./copy-sync */ "./node_modules/fs-extra/lib/copy-sync/copy-sync.js")
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/copy.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/copy.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdirs = (__webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js").mkdirs)
const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)
const utimesMillis = (__webpack_require__(/*! ../util/utimes */ "./node_modules/fs-extra/lib/util/utimes.js").utimesMillis)
const stat = __webpack_require__(/*! ../util/stat */ "./node_modules/fs-extra/lib/util/stat.js")

function copy (src, dest, opts, cb) {
  if (typeof opts === 'function' && !cb) {
    cb = opts
    opts = {}
  } else if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  cb = cb || function () {}
  opts = opts || {}

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;\n
    see https://github.com/jprichardson/node-fs-extra/issues/269`)
  }

  stat.checkPaths(src, dest, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'copy', err => {
      if (err) return cb(err)
      if (opts.filter) return handleFilter(checkParentDir, destStat, src, dest, opts, cb)
      return checkParentDir(destStat, src, dest, opts, cb)
    })
  })
}

function checkParentDir (destStat, src, dest, opts, cb) {
  const destParent = path.dirname(dest)
  pathExists(destParent, (err, dirExists) => {
    if (err) return cb(err)
    if (dirExists) return startCopy(destStat, src, dest, opts, cb)
    mkdirs(destParent, err => {
      if (err) return cb(err)
      return startCopy(destStat, src, dest, opts, cb)
    })
  })
}

function handleFilter (onInclude, destStat, src, dest, opts, cb) {
  Promise.resolve(opts.filter(src, dest)).then(include => {
    if (include) return onInclude(destStat, src, dest, opts, cb)
    return cb()
  }, error => cb(error))
}

function startCopy (destStat, src, dest, opts, cb) {
  if (opts.filter) return handleFilter(getStats, destStat, src, dest, opts, cb)
  return getStats(destStat, src, dest, opts, cb)
}

function getStats (destStat, src, dest, opts, cb) {
  const stat = opts.dereference ? fs.stat : fs.lstat
  stat(src, (err, srcStat) => {
    if (err) return cb(err)

    if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isFile() ||
             srcStat.isCharacterDevice() ||
             srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts, cb)
    else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts, cb)
  })
}

function onFile (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return copyFile(srcStat, src, dest, opts, cb)
  return mayCopyFile(srcStat, src, dest, opts, cb)
}

function mayCopyFile (srcStat, src, dest, opts, cb) {
  if (opts.overwrite) {
    fs.unlink(dest, err => {
      if (err) return cb(err)
      return copyFile(srcStat, src, dest, opts, cb)
    })
  } else if (opts.errorOnExist) {
    return cb(new Error(`'${dest}' already exists`))
  } else return cb()
}

function copyFile (srcStat, src, dest, opts, cb) {
  fs.copyFile(src, dest, err => {
    if (err) return cb(err)
    if (opts.preserveTimestamps) return handleTimestampsAndMode(srcStat.mode, src, dest, cb)
    return setDestMode(dest, srcStat.mode, cb)
  })
}

function handleTimestampsAndMode (srcMode, src, dest, cb) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) {
    return makeFileWritable(dest, srcMode, err => {
      if (err) return cb(err)
      return setDestTimestampsAndMode(srcMode, src, dest, cb)
    })
  }
  return setDestTimestampsAndMode(srcMode, src, dest, cb)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode, cb) {
  return setDestMode(dest, srcMode | 0o200, cb)
}

function setDestTimestampsAndMode (srcMode, src, dest, cb) {
  setDestTimestamps(src, dest, err => {
    if (err) return cb(err)
    return setDestMode(dest, srcMode, cb)
  })
}

function setDestMode (dest, srcMode, cb) {
  return fs.chmod(dest, srcMode, cb)
}

function setDestTimestamps (src, dest, cb) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  fs.stat(src, (err, updatedSrcStat) => {
    if (err) return cb(err)
    return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb)
  })
}

function onDir (srcStat, destStat, src, dest, opts, cb) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts, cb)
  if (destStat && !destStat.isDirectory()) {
    return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))
  }
  return copyDir(src, dest, opts, cb)
}

function mkDirAndCopy (srcMode, src, dest, opts, cb) {
  fs.mkdir(dest, err => {
    if (err) return cb(err)
    copyDir(src, dest, opts, err => {
      if (err) return cb(err)
      return setDestMode(dest, srcMode, cb)
    })
  })
}

function copyDir (src, dest, opts, cb) {
  fs.readdir(src, (err, items) => {
    if (err) return cb(err)
    return copyDirItems(items, src, dest, opts, cb)
  })
}

function copyDirItems (items, src, dest, opts, cb) {
  const item = items.pop()
  if (!item) return cb()
  return copyDirItem(items, item, src, dest, opts, cb)
}

function copyDirItem (items, item, src, dest, opts, cb) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  stat.checkPaths(srcItem, destItem, 'copy', (err, stats) => {
    if (err) return cb(err)
    const { destStat } = stats
    startCopy(destStat, srcItem, destItem, opts, err => {
      if (err) return cb(err)
      return copyDirItems(items, src, dest, opts, cb)
    })
  })
}

function onLink (destStat, src, dest, opts, cb) {
  fs.readlink(src, (err, resolvedSrc) => {
    if (err) return cb(err)
    if (opts.dereference) {
      resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
    }

    if (!destStat) {
      return fs.symlink(resolvedSrc, dest, cb)
    } else {
      fs.readlink(dest, (err, resolvedDest) => {
        if (err) {
          // dest exists and is a regular file or directory,
          // Windows may throw UNKNOWN error. If dest already exists,
          // fs throws error anyway, so no need to guard against it here.
          if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest, cb)
          return cb(err)
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest)
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`))
        }

        // do not copy if src is a subdir of dest since unlinking
        // dest in this case would result in removing src contents
        // and therefore a broken symlink would be created.
        if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`))
        }
        return copyLink(resolvedSrc, dest, cb)
      })
    }
  })
}

function copyLink (resolvedSrc, dest, cb) {
  fs.unlink(dest, err => {
    if (err) return cb(err)
    return fs.symlink(resolvedSrc, dest, cb)
  })
}

module.exports = copy


/***/ }),

/***/ "./node_modules/fs-extra/lib/copy/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/copy/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
module.exports = {
  copy: u(__webpack_require__(/*! ./copy */ "./node_modules/fs-extra/lib/copy/copy.js"))
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/empty/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/empty/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js")
const remove = __webpack_require__(/*! ../remove */ "./node_modules/fs-extra/lib/remove/index.js")

const emptyDir = u(function emptyDir (dir, callback) {
  callback = callback || function () {}
  fs.readdir(dir, (err, items) => {
    if (err) return mkdir.mkdirs(dir, callback)

    items = items.map(item => path.join(dir, item))

    deleteItem()

    function deleteItem () {
      const item = items.pop()
      if (!item) return callback()
      remove.remove(item, err => {
        if (err) return callback(err)
        deleteItem()
      })
    }
  })
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/file.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/file.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const mkdir = __webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js")

function createFile (file, callback) {
  function makeFile () {
    fs.writeFile(file, '', err => {
      if (err) return callback(err)
      callback()
    })
  }

  fs.stat(file, (err, stats) => { // eslint-disable-line handle-callback-err
    if (!err && stats.isFile()) return callback()
    const dir = path.dirname(file)
    fs.stat(dir, (err, stats) => {
      if (err) {
        // if the directory doesn't exist, make it
        if (err.code === 'ENOENT') {
          return mkdir.mkdirs(dir, err => {
            if (err) return callback(err)
            makeFile()
          })
        }
        return callback(err)
      }

      if (stats.isDirectory()) makeFile()
      else {
        // parent is not a directory
        // This is just to cause an internal ENOTDIR error to be thrown
        fs.readdir(dir, err => {
          if (err) return callback(err)
        })
      }
    })
  })
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch {}
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  try {
    if (!fs.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs.readdirSync(dir)
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)
    else throw err
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const file = __webpack_require__(/*! ./file */ "./node_modules/fs-extra/lib/ensure/file.js")
const link = __webpack_require__(/*! ./link */ "./node_modules/fs-extra/lib/ensure/link.js")
const symlink = __webpack_require__(/*! ./symlink */ "./node_modules/fs-extra/lib/ensure/symlink.js")

module.exports = {
  // file
  createFile: file.createFile,
  createFileSync: file.createFileSync,
  ensureFile: file.createFile,
  ensureFileSync: file.createFileSync,
  // link
  createLink: link.createLink,
  createLinkSync: link.createLinkSync,
  ensureLink: link.createLink,
  ensureLinkSync: link.createLinkSync,
  // symlink
  createSymlink: symlink.createSymlink,
  createSymlinkSync: symlink.createSymlinkSync,
  ensureSymlink: symlink.createSymlink,
  ensureSymlinkSync: symlink.createSymlinkSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/link.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/link.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const mkdir = __webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function createLink (srcpath, dstpath, callback) {
  function makeLink (srcpath, dstpath) {
    fs.link(srcpath, dstpath, err => {
      if (err) return callback(err)
      callback(null)
    })
  }

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureLink')
        return callback(err)
      }

      const dir = path.dirname(dstpath)
      pathExists(dir, (err, dirExists) => {
        if (err) return callback(err)
        if (dirExists) return makeLink(srcpath, dstpath)
        mkdir.mkdirs(dir, err => {
          if (err) return callback(err)
          makeLink(srcpath, dstpath)
        })
      })
    })
  })
}

function createLinkSync (srcpath, dstpath) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  try {
    fs.lstatSync(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-paths.js":
/*!***********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-paths.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

function symlinkPaths (srcpath, dstpath, callback) {
  if (path.isAbsolute(srcpath)) {
    return fs.lstat(srcpath, (err) => {
      if (err) {
        err.message = err.message.replace('lstat', 'ensureSymlink')
        return callback(err)
      }
      return callback(null, {
        toCwd: srcpath,
        toDst: srcpath
      })
    })
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    return pathExists(relativeToDst, (err, exists) => {
      if (err) return callback(err)
      if (exists) {
        return callback(null, {
          toCwd: relativeToDst,
          toDst: srcpath
        })
      } else {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace('lstat', 'ensureSymlink')
            return callback(err)
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: path.relative(dstdir, srcpath)
          })
        })
      }
    })
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  let exists
  if (path.isAbsolute(srcpath)) {
    exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  } else {
    const dstdir = path.dirname(dstpath)
    const relativeToDst = path.join(dstdir, srcpath)
    exists = fs.existsSync(relativeToDst)
    if (exists) {
      return {
        toCwd: relativeToDst,
        toDst: srcpath
      }
    } else {
      exists = fs.existsSync(srcpath)
      if (!exists) throw new Error('relative srcpath does not exist')
      return {
        toCwd: srcpath,
        toDst: path.relative(dstdir, srcpath)
      }
    }
  }
}

module.exports = {
  symlinkPaths,
  symlinkPathsSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink-type.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink-type.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")

function symlinkType (srcpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type
  if (type) return callback(null, type)
  fs.lstat(srcpath, (err, stats) => {
    if (err) return callback(null, 'file')
    type = (stats && stats.isDirectory()) ? 'dir' : 'file'
    callback(null, type)
  })
}

function symlinkTypeSync (srcpath, type) {
  let stats

  if (type) return type
  try {
    stats = fs.lstatSync(srcpath)
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType,
  symlinkTypeSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/ensure/symlink.js":
/*!*****************************************************!*\
  !*** ./node_modules/fs-extra/lib/ensure/symlink.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const path = __webpack_require__(/*! path */ "path")
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const _mkdirs = __webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js")
const mkdirs = _mkdirs.mkdirs
const mkdirsSync = _mkdirs.mkdirsSync

const _symlinkPaths = __webpack_require__(/*! ./symlink-paths */ "./node_modules/fs-extra/lib/ensure/symlink-paths.js")
const symlinkPaths = _symlinkPaths.symlinkPaths
const symlinkPathsSync = _symlinkPaths.symlinkPathsSync

const _symlinkType = __webpack_require__(/*! ./symlink-type */ "./node_modules/fs-extra/lib/ensure/symlink-type.js")
const symlinkType = _symlinkType.symlinkType
const symlinkTypeSync = _symlinkType.symlinkTypeSync

const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function createSymlink (srcpath, dstpath, type, callback) {
  callback = (typeof type === 'function') ? type : callback
  type = (typeof type === 'function') ? false : type

  pathExists(dstpath, (err, destinationExists) => {
    if (err) return callback(err)
    if (destinationExists) return callback(null)
    symlinkPaths(srcpath, dstpath, (err, relative) => {
      if (err) return callback(err)
      srcpath = relative.toDst
      symlinkType(relative.toCwd, type, (err, type) => {
        if (err) return callback(err)
        const dir = path.dirname(dstpath)
        pathExists(dir, (err, dirExists) => {
          if (err) return callback(err)
          if (dirExists) return fs.symlink(srcpath, dstpath, type, callback)
          mkdirs(dir, err => {
            if (err) return callback(err)
            fs.symlink(srcpath, dstpath, type, callback)
          })
        })
      })
    })
  })
}

function createSymlinkSync (srcpath, dstpath, type) {
  const destinationExists = fs.existsSync(dstpath)
  if (destinationExists) return undefined

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/fs/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fs-extra/lib/fs/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'lchmod',
  'lchown',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rmdir',
  'stat',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.opendir was added in Node.js v12.12.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export all keys:
Object.keys(fs).forEach(key => {
  if (key === 'promises') {
    // fs.promises is a getter property that triggers ExperimentalWarning
    // Don't re-export it here, the getter is defined in "lib/index.js"
    return
  }
  exports[key] = fs[key]
})

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read(), fs.write(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

// fs.writev only available in Node v12.9.0+
if (typeof fs.writev === 'function') {
  // Function signature is
  // s.writev(fd, buffers[, position], callback)
  // We need to handle the optional arg, so we use ...args
  exports.writev = function (fd, buffers, ...args) {
    if (typeof args[args.length - 1] === 'function') {
      return fs.writev(fd, buffers, ...args)
    }

    return new Promise((resolve, reject) => {
      fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
        if (err) return reject(err)
        resolve({ bytesWritten, buffers })
      })
    })
  }
}

// fs.realpath.native only available in Node v9.2+
if (typeof fs.realpath.native === 'function') {
  exports.realpath.native = u(fs.realpath.native)
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/fs-extra/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  // Export promiseified graceful-fs:
  ...__webpack_require__(/*! ./fs */ "./node_modules/fs-extra/lib/fs/index.js"),
  // Export extra methods:
  ...__webpack_require__(/*! ./copy-sync */ "./node_modules/fs-extra/lib/copy-sync/index.js"),
  ...__webpack_require__(/*! ./copy */ "./node_modules/fs-extra/lib/copy/index.js"),
  ...__webpack_require__(/*! ./empty */ "./node_modules/fs-extra/lib/empty/index.js"),
  ...__webpack_require__(/*! ./ensure */ "./node_modules/fs-extra/lib/ensure/index.js"),
  ...__webpack_require__(/*! ./json */ "./node_modules/fs-extra/lib/json/index.js"),
  ...__webpack_require__(/*! ./mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js"),
  ...__webpack_require__(/*! ./move-sync */ "./node_modules/fs-extra/lib/move-sync/index.js"),
  ...__webpack_require__(/*! ./move */ "./node_modules/fs-extra/lib/move/index.js"),
  ...__webpack_require__(/*! ./output */ "./node_modules/fs-extra/lib/output/index.js"),
  ...__webpack_require__(/*! ./path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js"),
  ...__webpack_require__(/*! ./remove */ "./node_modules/fs-extra/lib/remove/index.js")
}

// Export fs.promises as a getter property so that we don't trigger
// ExperimentalWarning before fs.promises is actually accessed.
const fs = __webpack_require__(/*! fs */ "fs")
if (Object.getOwnPropertyDescriptor(fs, 'promises')) {
  Object.defineProperty(module.exports, "promises", ({
    get () { return fs.promises }
  }))
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/json/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromPromise)
const jsonFile = __webpack_require__(/*! ./jsonfile */ "./node_modules/fs-extra/lib/json/jsonfile.js")

jsonFile.outputJson = u(__webpack_require__(/*! ./output-json */ "./node_modules/fs-extra/lib/json/output-json.js"))
jsonFile.outputJsonSync = __webpack_require__(/*! ./output-json-sync */ "./node_modules/fs-extra/lib/json/output-json-sync.js")
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),

/***/ "./node_modules/fs-extra/lib/json/jsonfile.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/jsonfile.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonFile = __webpack_require__(/*! jsonfile */ "./node_modules/jsonfile/index.js")

module.exports = {
  // jsonfile exports
  readJson: jsonFile.readFile,
  readJsonSync: jsonFile.readFileSync,
  writeJson: jsonFile.writeFile,
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json-sync.js":
/*!************************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json-sync.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(/*! jsonfile/utils */ "./node_modules/jsonfile/utils.js")
const { outputFileSync } = __webpack_require__(/*! ../output */ "./node_modules/fs-extra/lib/output/index.js")

function outputJsonSync (file, data, options) {
  const str = stringify(data, options)

  outputFileSync(file, str, options)
}

module.exports = outputJsonSync


/***/ }),

/***/ "./node_modules/fs-extra/lib/json/output-json.js":
/*!*******************************************************!*\
  !*** ./node_modules/fs-extra/lib/json/output-json.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(/*! jsonfile/utils */ "./node_modules/jsonfile/utils.js")
const { outputFile } = __webpack_require__(/*! ../output */ "./node_modules/fs-extra/lib/output/index.js")

async function outputJson (file, data, options = {}) {
  const str = stringify(data, options)

  await outputFile(file, str, options)
}

module.exports = outputJson


/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromPromise)
const { makeDir: _makeDir, makeDirSync } = __webpack_require__(/*! ./make-dir */ "./node_modules/fs-extra/lib/mkdirs/make-dir.js")
const makeDir = u(_makeDir)

module.exports = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/mkdirs/make-dir.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/mkdirs/make-dir.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Adapted from https://github.com/sindresorhus/make-dir
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

const fs = __webpack_require__(/*! ../fs */ "./node_modules/fs-extra/lib/fs/index.js")
const path = __webpack_require__(/*! path */ "path")
const atLeastNode = __webpack_require__(/*! at-least-node */ "./node_modules/at-least-node/index.js")

const useNativeRecursiveOption = atLeastNode('10.12.0')

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
const checkPath = pth => {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''))

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`)
      error.code = 'EINVAL'
      throw error
    }
  }
}

const processOptions = options => {
  const defaults = { mode: 0o777 }
  if (typeof options === 'number') options = { mode: options }
  return { ...defaults, ...options }
}

const permissionError = pth => {
  // This replicates the exception of `fs.mkdir` with native the
  // `recusive` option when run on an invalid drive under Windows.
  const error = new Error(`operation not permitted, mkdir '${pth}'`)
  error.code = 'EPERM'
  error.errno = -4048
  error.path = pth
  error.syscall = 'mkdir'
  return error
}

module.exports.makeDir = async (input, options) => {
  checkPath(input)
  options = processOptions(options)

  if (useNativeRecursiveOption) {
    const pth = path.resolve(input)

    return fs.mkdir(pth, {
      mode: options.mode,
      recursive: true
    })
  }

  const make = async pth => {
    try {
      await fs.mkdir(pth, options.mode)
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error
      }

      if (error.code === 'ENOENT') {
        if (path.dirname(pth) === pth) {
          throw permissionError(pth)
        }

        if (error.message.includes('null bytes')) {
          throw error
        }

        await make(path.dirname(pth))
        return make(pth)
      }

      try {
        const stats = await fs.stat(pth)
        if (!stats.isDirectory()) {
          // This error is never exposed to the user
          // it is caught below, and the original error is thrown
          throw new Error('The path is not a directory')
        }
      } catch {
        throw error
      }
    }
  }

  return make(path.resolve(input))
}

module.exports.makeDirSync = (input, options) => {
  checkPath(input)
  options = processOptions(options)

  if (useNativeRecursiveOption) {
    const pth = path.resolve(input)

    return fs.mkdirSync(pth, {
      mode: options.mode,
      recursive: true
    })
  }

  const make = pth => {
    try {
      fs.mkdirSync(pth, options.mode)
    } catch (error) {
      if (error.code === 'EPERM') {
        throw error
      }

      if (error.code === 'ENOENT') {
        if (path.dirname(pth) === pth) {
          throw permissionError(pth)
        }

        if (error.message.includes('null bytes')) {
          throw error
        }

        make(path.dirname(pth))
        return make(pth)
      }

      try {
        if (!fs.statSync(pth).isDirectory()) {
          // This error is never exposed to the user
          // it is caught below, and the original error is thrown
          throw new Error('The path is not a directory')
        }
      } catch {
        throw error
      }
    }
  }

  return make(path.resolve(input))
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/index.js":
/*!******************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/index.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  moveSync: __webpack_require__(/*! ./move-sync */ "./node_modules/fs-extra/lib/move-sync/move-sync.js")
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/move-sync/move-sync.js":
/*!**********************************************************!*\
  !*** ./node_modules/fs-extra/lib/move-sync/move-sync.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const copySync = (__webpack_require__(/*! ../copy-sync */ "./node_modules/fs-extra/lib/copy-sync/index.js").copySync)
const removeSync = (__webpack_require__(/*! ../remove */ "./node_modules/fs-extra/lib/remove/index.js").removeSync)
const mkdirpSync = (__webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js").mkdirpSync)
const stat = __webpack_require__(/*! ../util/stat */ "./node_modules/fs-extra/lib/util/stat.js")

function moveSync (src, dest, opts) {
  opts = opts || {}
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat } = stat.checkPathsSync(src, dest, 'move')
  stat.checkParentPathsSync(src, srcStat, dest, 'move')
  mkdirpSync(path.dirname(dest))
  return doRename(src, dest, overwrite)
}

function doRename (src, dest, overwrite) {
  if (overwrite) {
    removeSync(dest)
    return rename(src, dest, overwrite)
  }
  if (fs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    fs.renameSync(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copySync(src, dest, opts)
  return removeSync(src)
}

module.exports = moveSync


/***/ }),

/***/ "./node_modules/fs-extra/lib/move/index.js":
/*!*************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
module.exports = {
  move: u(__webpack_require__(/*! ./move */ "./node_modules/fs-extra/lib/move/move.js"))
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/move/move.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/move/move.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const copy = (__webpack_require__(/*! ../copy */ "./node_modules/fs-extra/lib/copy/index.js").copy)
const remove = (__webpack_require__(/*! ../remove */ "./node_modules/fs-extra/lib/remove/index.js").remove)
const mkdirp = (__webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js").mkdirp)
const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)
const stat = __webpack_require__(/*! ../util/stat */ "./node_modules/fs-extra/lib/util/stat.js")

function move (src, dest, opts, cb) {
  if (typeof opts === 'function') {
    cb = opts
    opts = {}
  }

  const overwrite = opts.overwrite || opts.clobber || false

  stat.checkPaths(src, dest, 'move', (err, stats) => {
    if (err) return cb(err)
    const { srcStat } = stats
    stat.checkParentPaths(src, srcStat, dest, 'move', err => {
      if (err) return cb(err)
      mkdirp(path.dirname(dest), err => {
        if (err) return cb(err)
        return doRename(src, dest, overwrite, cb)
      })
    })
  })
}

function doRename (src, dest, overwrite, cb) {
  if (overwrite) {
    return remove(dest, err => {
      if (err) return cb(err)
      return rename(src, dest, overwrite, cb)
    })
  }
  pathExists(dest, (err, destExists) => {
    if (err) return cb(err)
    if (destExists) return cb(new Error('dest already exists.'))
    return rename(src, dest, overwrite, cb)
  })
}

function rename (src, dest, overwrite, cb) {
  fs.rename(src, dest, err => {
    if (!err) return cb()
    if (err.code !== 'EXDEV') return cb(err)
    return moveAcrossDevice(src, dest, overwrite, cb)
  })
}

function moveAcrossDevice (src, dest, overwrite, cb) {
  const opts = {
    overwrite,
    errorOnExist: true
  }
  copy(src, dest, opts, err => {
    if (err) return cb(err)
    return remove(src, cb)
  })
}

module.exports = move


/***/ }),

/***/ "./node_modules/fs-extra/lib/output/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/output/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const mkdir = __webpack_require__(/*! ../mkdirs */ "./node_modules/fs-extra/lib/mkdirs/index.js")
const pathExists = (__webpack_require__(/*! ../path-exists */ "./node_modules/fs-extra/lib/path-exists/index.js").pathExists)

function outputFile (file, data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding
    encoding = 'utf8'
  }

  const dir = path.dirname(file)
  pathExists(dir, (err, itDoes) => {
    if (err) return callback(err)
    if (itDoes) return fs.writeFile(file, data, encoding, callback)

    mkdir.mkdirs(dir, err => {
      if (err) return callback(err)

      fs.writeFile(file, data, encoding, callback)
    })
  })
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (fs.existsSync(dir)) {
    return fs.writeFileSync(file, ...args)
  }
  mkdir.mkdirsSync(dir)
  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/path-exists/index.js":
/*!********************************************************!*\
  !*** ./node_modules/fs-extra/lib/path-exists/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromPromise)
const fs = __webpack_require__(/*! ../fs */ "./node_modules/fs-extra/lib/fs/index.js")

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/index.js":
/*!***************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/index.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(/*! universalify */ "./node_modules/universalify/index.js").fromCallback)
const rimraf = __webpack_require__(/*! ./rimraf */ "./node_modules/fs-extra/lib/remove/rimraf.js")

module.exports = {
  remove: u(rimraf),
  removeSync: rimraf.sync
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/remove/rimraf.js":
/*!****************************************************!*\
  !*** ./node_modules/fs-extra/lib/remove/rimraf.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
const path = __webpack_require__(/*! path */ "path")
const assert = __webpack_require__(/*! assert */ "assert")

const isWindows = (process.platform === 'win32')

function defaults (options) {
  const methods = [
    'unlink',
    'chmod',
    'stat',
    'lstat',
    'rmdir',
    'readdir'
  ]
  methods.forEach(m => {
    options[m] = options[m] || fs[m]
    m = m + 'Sync'
    options[m] = options[m] || fs[m]
  })

  options.maxBusyTries = options.maxBusyTries || 3
}

function rimraf (p, options, cb) {
  let busyTries = 0

  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert.strictEqual(typeof cb, 'function', 'rimraf: callback function required')
  assert(options, 'rimraf: invalid options argument provided')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  defaults(options)

  rimraf_(p, options, function CB (er) {
    if (er) {
      if ((er.code === 'EBUSY' || er.code === 'ENOTEMPTY' || er.code === 'EPERM') &&
          busyTries < options.maxBusyTries) {
        busyTries++
        const time = busyTries * 100
        // try again, with the same exact callback as this one.
        return setTimeout(() => rimraf_(p, options, CB), time)
      }

      // already gone
      if (er.code === 'ENOENT') er = null
    }

    cb(er)
  })
}

// Two possible strategies.
// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR
// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR
//
// Both result in an extra syscall when you guess wrong.  However, there
// are likely far more normal files in the world than directories.  This
// is based on the assumption that a the average number of files per
// directory is >= 1.
//
// If anyone ever complains about this, then I guess the strategy could
// be made configurable somehow.  But until then, YAGNI.
function rimraf_ (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // sunos lets the root user unlink directories, which is... weird.
  // so we have to lstat here and make sure it's not a dir.
  options.lstat(p, (er, st) => {
    if (er && er.code === 'ENOENT') {
      return cb(null)
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er && er.code === 'EPERM' && isWindows) {
      return fixWinEPERM(p, options, er, cb)
    }

    if (st && st.isDirectory()) {
      return rmdir(p, options, er, cb)
    }

    options.unlink(p, er => {
      if (er) {
        if (er.code === 'ENOENT') {
          return cb(null)
        }
        if (er.code === 'EPERM') {
          return (isWindows)
            ? fixWinEPERM(p, options, er, cb)
            : rmdir(p, options, er, cb)
        }
        if (er.code === 'EISDIR') {
          return rmdir(p, options, er, cb)
        }
      }
      return cb(er)
    })
  })
}

function fixWinEPERM (p, options, er, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.chmod(p, 0o666, er2 => {
    if (er2) {
      cb(er2.code === 'ENOENT' ? null : er)
    } else {
      options.stat(p, (er3, stats) => {
        if (er3) {
          cb(er3.code === 'ENOENT' ? null : er)
        } else if (stats.isDirectory()) {
          rmdir(p, options, er, cb)
        } else {
          options.unlink(p, cb)
        }
      })
    }
  })
}

function fixWinEPERMSync (p, options, er) {
  let stats

  assert(p)
  assert(options)

  try {
    options.chmodSync(p, 0o666)
  } catch (er2) {
    if (er2.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  try {
    stats = options.statSync(p)
  } catch (er3) {
    if (er3.code === 'ENOENT') {
      return
    } else {
      throw er
    }
  }

  if (stats.isDirectory()) {
    rmdirSync(p, options, er)
  } else {
    options.unlinkSync(p)
  }
}

function rmdir (p, options, originalEr, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)
  // if we guessed wrong, and it's not a directory, then
  // raise the original error.
  options.rmdir(p, er => {
    if (er && (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM')) {
      rmkids(p, options, cb)
    } else if (er && er.code === 'ENOTDIR') {
      cb(originalEr)
    } else {
      cb(er)
    }
  })
}

function rmkids (p, options, cb) {
  assert(p)
  assert(options)
  assert(typeof cb === 'function')

  options.readdir(p, (er, files) => {
    if (er) return cb(er)

    let n = files.length
    let errState

    if (n === 0) return options.rmdir(p, cb)

    files.forEach(f => {
      rimraf(path.join(p, f), options, er => {
        if (errState) {
          return
        }
        if (er) return cb(errState = er)
        if (--n === 0) {
          options.rmdir(p, cb)
        }
      })
    })
  })
}

// this looks simpler, and is strictly *faster*, but will
// tie up the JavaScript thread and fail on excessively
// deep directory trees.
function rimrafSync (p, options) {
  let st

  options = options || {}
  defaults(options)

  assert(p, 'rimraf: missing path')
  assert.strictEqual(typeof p, 'string', 'rimraf: path should be a string')
  assert(options, 'rimraf: missing options')
  assert.strictEqual(typeof options, 'object', 'rimraf: options should be object')

  try {
    st = options.lstatSync(p)
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    }

    // Windows can EPERM on stat.  Life is suffering.
    if (er.code === 'EPERM' && isWindows) {
      fixWinEPERMSync(p, options, er)
    }
  }

  try {
    // sunos lets the root user unlink directories, which is... weird.
    if (st && st.isDirectory()) {
      rmdirSync(p, options, null)
    } else {
      options.unlinkSync(p)
    }
  } catch (er) {
    if (er.code === 'ENOENT') {
      return
    } else if (er.code === 'EPERM') {
      return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)
    } else if (er.code !== 'EISDIR') {
      throw er
    }
    rmdirSync(p, options, er)
  }
}

function rmdirSync (p, options, originalEr) {
  assert(p)
  assert(options)

  try {
    options.rmdirSync(p)
  } catch (er) {
    if (er.code === 'ENOTDIR') {
      throw originalEr
    } else if (er.code === 'ENOTEMPTY' || er.code === 'EEXIST' || er.code === 'EPERM') {
      rmkidsSync(p, options)
    } else if (er.code !== 'ENOENT') {
      throw er
    }
  }
}

function rmkidsSync (p, options) {
  assert(p)
  assert(options)
  options.readdirSync(p).forEach(f => rimrafSync(path.join(p, f), options))

  if (isWindows) {
    // We only end up here once we got ENOTEMPTY at least once, and
    // at this point, we are guaranteed to have removed all the kids.
    // So, we know that it won't be ENOENT or ENOTDIR or anything else.
    // try really hard to delete stuff on windows, because it has a
    // PROFOUNDLY annoying habit of not closing handles promptly when
    // files are deleted, resulting in spurious ENOTEMPTY errors.
    const startTime = Date.now()
    do {
      try {
        const ret = options.rmdirSync(p, options)
        return ret
      } catch {}
    } while (Date.now() - startTime < 500) // give up after 500ms
  } else {
    const ret = options.rmdirSync(p, options)
    return ret
  }
}

module.exports = rimraf
rimraf.sync = rimrafSync


/***/ }),

/***/ "./node_modules/fs-extra/lib/util/stat.js":
/*!************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/stat.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! ../fs */ "./node_modules/fs-extra/lib/fs/index.js")
const path = __webpack_require__(/*! path */ "path")
const util = __webpack_require__(/*! util */ "util")
const atLeastNode = __webpack_require__(/*! at-least-node */ "./node_modules/at-least-node/index.js")

const nodeSupportsBigInt = atLeastNode('10.5.0')
const stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file)
const statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file)

function getStats (src, dest) {
  return Promise.all([
    stat(src),
    stat(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest) {
  let destStat
  const srcStat = statSync(src)
  try {
    destStat = statSync(dest)
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

function checkPaths (src, dest, funcName, cb) {
  util.callbackify(getStats)(src, dest, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat } = stats
    if (destStat && areIdentical(srcStat, destStat)) {
      return cb(new Error('Source and destination must not be the same.'))
    }
    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return cb(null, { srcStat, destStat })
  })
}

function checkPathsSync (src, dest, funcName) {
  const { srcStat, destStat } = getStatsSync(src, dest)
  if (destStat && areIdentical(srcStat, destStat)) {
    throw new Error('Source and destination must not be the same.')
  }
  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
  const callback = (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    }
    if (areIdentical(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    }
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  }
  if (nodeSupportsBigInt) fs.stat(destParent, { bigint: true }, callback)
  else fs.stat(destParent, callback)
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    destStat = statSync(destParent)
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical (srcStat, destStat) {
  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
    if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
      // definitive answer
      return true
    }
    // Use additional heuristics if we can't use 'bigint'.
    // Different 'ino' could be represented the same if they are >= Number.MAX_SAFE_INTEGER
    // See issue 657
    if (destStat.size === srcStat.size &&
        destStat.mode === srcStat.mode &&
        destStat.nlink === srcStat.nlink &&
        destStat.atimeMs === srcStat.atimeMs &&
        destStat.mtimeMs === srcStat.mtimeMs &&
        destStat.ctimeMs === srcStat.ctimeMs &&
        destStat.birthtimeMs === srcStat.birthtimeMs) {
      // heuristic answer
      return true
    }
  }
  return false
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

module.exports = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir
}


/***/ }),

/***/ "./node_modules/fs-extra/lib/util/utimes.js":
/*!**************************************************!*\
  !*** ./node_modules/fs-extra/lib/util/utimes.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")

function utimesMillis (path, atime, mtime, callback) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  fs.open(path, 'r+', (err, fd) => {
    if (err) return callback(err)
    fs.futimes(fd, atime, mtime, futimesErr => {
      fs.close(fd, closeErr => {
        if (callback) callback(futimesErr || closeErr)
      })
    })
  })
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  utimesMillis,
  utimesMillisSync
}


/***/ }),

/***/ "./node_modules/graceful-fs/clone.js":
/*!*******************************************!*\
  !*** ./node_modules/graceful-fs/clone.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),

/***/ "./node_modules/graceful-fs/graceful-fs.js":
/*!*************************************************!*\
  !*** ./node_modules/graceful-fs/graceful-fs.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(/*! fs */ "fs")
var polyfills = __webpack_require__(/*! ./polyfills.js */ "./node_modules/graceful-fs/polyfills.js")
var legacy = __webpack_require__(/*! ./legacy-streams.js */ "./node_modules/graceful-fs/legacy-streams.js")
var clone = __webpack_require__(/*! ./clone.js */ "./node_modules/graceful-fs/clone.js")

var util = __webpack_require__(/*! util */ "util")

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(/*! assert */ "assert").equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  var noReaddirOptionVersions = /^v[0-5]\./
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    var go$readdir = noReaddirOptionVersions.test(process.version)
      ? function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }
      : function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }

    return go$readdir(path, options, cb)

    function fs$readdirCallback (path, options, cb, startTime) {
      return function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([
            go$readdir,
            [path, options, cb],
            err,
            startTime || Date.now(),
            Date.now()
          ])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      }
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),

/***/ "./node_modules/graceful-fs/legacy-streams.js":
/*!****************************************************!*\
  !*** ./node_modules/graceful-fs/legacy-streams.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream)

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),

/***/ "./node_modules/graceful-fs/polyfills.js":
/*!***********************************************!*\
  !*** ./node_modules/graceful-fs/polyfills.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(/*! constants */ "constants")

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (fs.chmod && !fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (fs.chown && !fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = typeof fs.rename !== 'function' ? fs.rename
    : (function (fs$rename) {
      function rename (from, to, cb) {
        var start = Date.now()
        var backoff = 0;
        fs$rename(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM")
              && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er)
              })
            }, backoff)
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er)
        })
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)
      return rename
    })(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = typeof fs.read !== 'function' ? fs.read
  : (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else if (fs.futimes) {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),

/***/ "./node_modules/jsonfile/index.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let _fs
try {
  _fs = __webpack_require__(/*! graceful-fs */ "./node_modules/graceful-fs/graceful-fs.js")
} catch (_) {
  _fs = __webpack_require__(/*! fs */ "fs")
}
const universalify = __webpack_require__(/*! universalify */ "./node_modules/jsonfile/node_modules/universalify/index.js")
const { stringify, stripBom } = __webpack_require__(/*! ./utils */ "./node_modules/jsonfile/utils.js")

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  let data = await universalify.fromCallback(fs.readFile)(file, options)

  data = stripBom(data)

  let obj
  try {
    obj = JSON.parse(data, options ? options.reviver : null)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile)

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  try {
    let content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)

  await universalify.fromCallback(fs.writeFile)(file, str, options)
}

const writeFile = universalify.fromPromise(_writeFile)

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
}

module.exports = jsonfile


/***/ }),

/***/ "./node_modules/jsonfile/node_modules/universalify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/jsonfile/node_modules/universalify/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)
    else {
      return new Promise((resolve, reject) => {
        fn.call(
          this,
          ...args,
          (err, res) => (err != null) ? reject(err) : resolve(res)
        )
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}


/***/ }),

/***/ "./node_modules/jsonfile/utils.js":
/*!****************************************!*\
  !*** ./node_modules/jsonfile/utils.js ***!
  \****************************************/
/***/ ((module) => {

function stringify (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : ''
  const str = JSON.stringify(obj, replacer, spaces)

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  return content.replace(/^\uFEFF/, '')
}

module.exports = { stringify, stripBom }


/***/ }),

/***/ "./node_modules/lodash.get/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.get/index.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash.set/index.js":
/*!******************************************!*\
  !*** ./node_modules/lodash.set/index.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    splice = arrayProto.splice;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = isKey(path, object) ? [path] : castPath(path);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

module.exports = set;


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(/*! yallist */ "./node_modules/yallist/yallist.js")

const MAX = Symbol('max')
const LENGTH = Symbol('length')
const LENGTH_CALCULATOR = Symbol('lengthCalculator')
const ALLOW_STALE = Symbol('allowStale')
const MAX_AGE = Symbol('maxAge')
const DISPOSE = Symbol('dispose')
const NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet')
const LRU_LIST = Symbol('lruList')
const CACHE = Symbol('cache')
const UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet')

const naiveLength = () => 1

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
  constructor (options) {
    if (typeof options === 'number')
      options = { max: options }

    if (!options)
      options = {}

    if (options.max && (typeof options.max !== 'number' || options.max < 0))
      throw new TypeError('max must be a non-negative number')
    // Kind of weird to have a default max of Infinity, but oh well.
    const max = this[MAX] = options.max || Infinity

    const lc = options.length || naiveLength
    this[LENGTH_CALCULATOR] = (typeof lc !== 'function') ? naiveLength : lc
    this[ALLOW_STALE] = options.stale || false
    if (options.maxAge && typeof options.maxAge !== 'number')
      throw new TypeError('maxAge must be a number')
    this[MAX_AGE] = options.maxAge || 0
    this[DISPOSE] = options.dispose
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false
    this.reset()
  }

  // resize the cache when the max changes.
  set max (mL) {
    if (typeof mL !== 'number' || mL < 0)
      throw new TypeError('max must be a non-negative number')

    this[MAX] = mL || Infinity
    trim(this)
  }
  get max () {
    return this[MAX]
  }

  set allowStale (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  }
  get allowStale () {
    return this[ALLOW_STALE]
  }

  set maxAge (mA) {
    if (typeof mA !== 'number')
      throw new TypeError('maxAge must be a non-negative number')

    this[MAX_AGE] = mA
    trim(this)
  }
  get maxAge () {
    return this[MAX_AGE]
  }

  // resize the cache when the lengthCalculator changes.
  set lengthCalculator (lC) {
    if (typeof lC !== 'function')
      lC = naiveLength

    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(hit => {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      })
    }
    trim(this)
  }
  get lengthCalculator () { return this[LENGTH_CALCULATOR] }

  get length () { return this[LENGTH] }
  get itemCount () { return this[LRU_LIST].length }

  rforEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].tail; walker !== null;) {
      const prev = walker.prev
      forEachStep(this, fn, walker, thisp)
      walker = prev
    }
  }

  forEach (fn, thisp) {
    thisp = thisp || this
    for (let walker = this[LRU_LIST].head; walker !== null;) {
      const next = walker.next
      forEachStep(this, fn, walker, thisp)
      walker = next
    }
  }

  keys () {
    return this[LRU_LIST].toArray().map(k => k.key)
  }

  values () {
    return this[LRU_LIST].toArray().map(k => k.value)
  }

  reset () {
    if (this[DISPOSE] &&
        this[LRU_LIST] &&
        this[LRU_LIST].length) {
      this[LRU_LIST].forEach(hit => this[DISPOSE](hit.key, hit.value))
    }

    this[CACHE] = new Map() // hash of items by key
    this[LRU_LIST] = new Yallist() // list of items in order of use recency
    this[LENGTH] = 0 // length of items in the list
  }

  dump () {
    return this[LRU_LIST].map(hit =>
      isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter(h => h)
  }

  dumpLru () {
    return this[LRU_LIST]
  }

  set (key, value, maxAge) {
    maxAge = maxAge || this[MAX_AGE]

    if (maxAge && typeof maxAge !== 'number')
      throw new TypeError('maxAge must be a number')

    const now = maxAge ? Date.now() : 0
    const len = this[LENGTH_CALCULATOR](value, key)

    if (this[CACHE].has(key)) {
      if (len > this[MAX]) {
        del(this, this[CACHE].get(key))
        return false
      }

      const node = this[CACHE].get(key)
      const item = node.value

      // dispose of the old one before overwriting
      // split out into 2 ifs for better coverage tracking
      if (this[DISPOSE]) {
        if (!this[NO_DISPOSE_ON_SET])
          this[DISPOSE](key, item.value)
      }

      item.now = now
      item.maxAge = maxAge
      item.value = value
      this[LENGTH] += len - item.length
      item.length = len
      this.get(key)
      trim(this)
      return true
    }

    const hit = new Entry(key, value, len, now, maxAge)

    // oversized objects fall out of cache automatically.
    if (hit.length > this[MAX]) {
      if (this[DISPOSE])
        this[DISPOSE](key, value)

      return false
    }

    this[LENGTH] += hit.length
    this[LRU_LIST].unshift(hit)
    this[CACHE].set(key, this[LRU_LIST].head)
    trim(this)
    return true
  }

  has (key) {
    if (!this[CACHE].has(key)) return false
    const hit = this[CACHE].get(key).value
    return !isStale(this, hit)
  }

  get (key) {
    return get(this, key, true)
  }

  peek (key) {
    return get(this, key, false)
  }

  pop () {
    const node = this[LRU_LIST].tail
    if (!node)
      return null

    del(this, node)
    return node.value
  }

  del (key) {
    del(this, this[CACHE].get(key))
  }

  load (arr) {
    // reset the cache
    this.reset()

    const now = Date.now()
    // A previous serialized cache has the most recent items first
    for (let l = arr.length - 1; l >= 0; l--) {
      const hit = arr[l]
      const expiresAt = hit.e || 0
      if (expiresAt === 0)
        // the item was created without expiration in a non aged cache
        this.set(hit.k, hit.v)
      else {
        const maxAge = expiresAt - now
        // dont add already expired items
        if (maxAge > 0) {
          this.set(hit.k, hit.v, maxAge)
        }
      }
    }
  }

  prune () {
    this[CACHE].forEach((value, key) => get(this, key, false))
  }
}

const get = (self, key, doUse) => {
  const node = self[CACHE].get(key)
  if (node) {
    const hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE])
        return undefined
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET])
          node.value.now = Date.now()
        self[LRU_LIST].unshiftNode(node)
      }
    }
    return hit.value
  }
}

const isStale = (self, hit) => {
  if (!hit || (!hit.maxAge && !self[MAX_AGE]))
    return false

  const diff = Date.now() - hit.now
  return hit.maxAge ? diff > hit.maxAge
    : self[MAX_AGE] && (diff > self[MAX_AGE])
}

const trim = self => {
  if (self[LENGTH] > self[MAX]) {
    for (let walker = self[LRU_LIST].tail;
      self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      const prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

const del = (self, node) => {
  if (node) {
    const hit = node.value
    if (self[DISPOSE])
      self[DISPOSE](hit.key, hit.value)

    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

class Entry {
  constructor (key, value, length, now, maxAge) {
    this.key = key
    this.value = value
    this.length = length
    this.now = now
    this.maxAge = maxAge || 0
  }
}

const forEachStep = (self, fn, node, thisp) => {
  let hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE])
      hit = undefined
  }
  if (hit)
    fn.call(thisp, hit.value, hit.key, self)
}

module.exports = LRUCache


/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __webpack_require__(/*! path */ "path") } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(/*! brace-expansion */ "./node_modules/brace-expansion/index.js")

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "./node_modules/reflect-metadata/Reflect.js":
/*!**************************************************!*\
  !*** ./node_modules/reflect-metadata/Reflect.js ***!
  \**************************************************/
/***/ (() => {

/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var Reflect;
(function (Reflect) {
    // Metadata Proposal
    // https://rbuckton.github.io/reflect-metadata/
    (function (factory) {
        var root = typeof global === "object" ? global :
            typeof self === "object" ? self :
                typeof this === "object" ? this :
                    Function("return this;")();
        var exporter = makeExporter(Reflect);
        if (typeof root.Reflect === "undefined") {
            root.Reflect = Reflect;
        }
        else {
            exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
            return function (key, value) {
                if (typeof target[key] !== "function") {
                    Object.defineProperty(target, key, { configurable: true, writable: true, value: value });
                }
                if (previous)
                    previous(key, value);
            };
        }
    })(function (exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        // feature test for Symbol support
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function"; // feature test for Object.create support
        var supportsProto = { __proto__: [] } instanceof Array; // feature test for __proto__ support
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
            // create an object in dictionary mode (a.k.a. "slow" mode in v8)
            create: supportsCreate
                ? function () { return MakeDictionary(Object.create(null)); }
                : supportsProto
                    ? function () { return MakeDictionary({ __proto__: null }); }
                    : function () { return MakeDictionary({}); },
            has: downLevel
                ? function (map, key) { return hasOwn.call(map, key); }
                : function (map, key) { return key in map; },
            get: downLevel
                ? function (map, key) { return hasOwn.call(map, key) ? map[key] : undefined; }
                : function (map, key) { return map[key]; },
        };
        // Load global or shim versions of Map, Set, and WeakMap
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        // [[Metadata]] internal slot
        // https://rbuckton.github.io/reflect-metadata/#ordinary-object-internal-methods-and-internal-slots
        var Metadata = new _WeakMap();
        /**
         * Applies a set of decorators to a property of a target object.
         * @param decorators An array of decorators.
         * @param target The target object.
         * @param propertyKey (Optional) The property key to decorate.
         * @param attributes (Optional) The property descriptor for the target key.
         * @remarks Decorators are applied in reverse order.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Example = Reflect.decorate(decoratorsArray, Example);
         *
         *     // property (on constructor)
         *     Reflect.decorate(decoratorsArray, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.decorate(decoratorsArray, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Object.defineProperty(Example, "staticMethod",
         *         Reflect.decorate(decoratorsArray, Example, "staticMethod",
         *             Object.getOwnPropertyDescriptor(Example, "staticMethod")));
         *
         *     // method (on prototype)
         *     Object.defineProperty(Example.prototype, "method",
         *         Reflect.decorate(decoratorsArray, Example.prototype, "method",
         *             Object.getOwnPropertyDescriptor(Example.prototype, "method")));
         *
         */
        function decorate(decorators, target, propertyKey, attributes) {
            if (!IsUndefined(propertyKey)) {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
                    throw new TypeError();
                if (IsNull(attributes))
                    attributes = undefined;
                propertyKey = ToPropertyKey(propertyKey);
                return DecorateProperty(decorators, target, propertyKey, attributes);
            }
            else {
                if (!IsArray(decorators))
                    throw new TypeError();
                if (!IsConstructor(target))
                    throw new TypeError();
                return DecorateConstructor(decorators, target);
            }
        }
        exporter("decorate", decorate);
        // 4.1.2 Reflect.metadata(metadataKey, metadataValue)
        // https://rbuckton.github.io/reflect-metadata/#reflect.metadata
        /**
         * A default metadata decorator factory that can be used on a class, class member, or parameter.
         * @param metadataKey The key for the metadata entry.
         * @param metadataValue The value for the metadata entry.
         * @returns A decorator function.
         * @remarks
         * If `metadataKey` is already defined for the target and target key, the
         * metadataValue for that key will be overwritten.
         * @example
         *
         *     // constructor
         *     @Reflect.metadata(key, value)
         *     class Example {
         *     }
         *
         *     // property (on constructor, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticProperty;
         *     }
         *
         *     // property (on prototype, TypeScript only)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         property;
         *     }
         *
         *     // method (on constructor)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         static staticMethod() { }
         *     }
         *
         *     // method (on prototype)
         *     class Example {
         *         @Reflect.metadata(key, value)
         *         method() { }
         *     }
         *
         */
        function metadata(metadataKey, metadataValue) {
            function decorator(target, propertyKey) {
                if (!IsObject(target))
                    throw new TypeError();
                if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
                    throw new TypeError();
                OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
            }
            return decorator;
        }
        exporter("metadata", metadata);
        /**
         * Define a unique metadata entry on the target.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param metadataValue A value that contains attached metadata.
         * @param target The target object on which to define metadata.
         * @param propertyKey (Optional) The property key for the target.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     Reflect.defineMetadata("custom:annotation", options, Example);
         *
         *     // property (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticProperty");
         *
         *     // property (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "property");
         *
         *     // method (on constructor)
         *     Reflect.defineMetadata("custom:annotation", options, Example, "staticMethod");
         *
         *     // method (on prototype)
         *     Reflect.defineMetadata("custom:annotation", options, Example.prototype, "method");
         *
         *     // decorator factory as metadata-producing annotation.
         *     function MyAnnotation(options): Decorator {
         *         return (target, key?) => Reflect.defineMetadata("custom:annotation", options, target, key);
         *     }
         *
         */
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        /**
         * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        /**
         * Gets a value indicating whether the target object has the provided metadata key defined.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata key was defined on the target object; otherwise, `false`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.hasOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function hasOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        /**
         * Gets the metadata value for the provided metadata key on the target object.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function getOwnMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        /**
         * Gets the metadata keys defined on the target object or its prototype chain.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getMetadataKeys(Example.prototype, "method");
         *
         */
        function getMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        /**
         * Gets the unique metadata keys defined on the target object.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns An array of unique metadata keys.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.getOwnMetadataKeys(Example);
         *
         *     // property (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.getOwnMetadataKeys(Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.getOwnMetadataKeys(Example.prototype, "method");
         *
         */
        function getOwnMetadataKeys(target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        /**
         * Deletes the metadata entry from the target object with the provided key.
         * @param metadataKey A key used to store and retrieve metadata.
         * @param target The target object on which the metadata is defined.
         * @param propertyKey (Optional) The property key for the target.
         * @returns `true` if the metadata entry was found and deleted; otherwise, false.
         * @example
         *
         *     class Example {
         *         // property declarations are not part of ES6, though they are valid in TypeScript:
         *         // static staticProperty;
         *         // property;
         *
         *         constructor(p) { }
         *         static staticMethod(p) { }
         *         method(p) { }
         *     }
         *
         *     // constructor
         *     result = Reflect.deleteMetadata("custom:annotation", Example);
         *
         *     // property (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticProperty");
         *
         *     // property (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "property");
         *
         *     // method (on constructor)
         *     result = Reflect.deleteMetadata("custom:annotation", Example, "staticMethod");
         *
         *     // method (on prototype)
         *     result = Reflect.deleteMetadata("custom:annotation", Example.prototype, "method");
         *
         */
        function deleteMetadata(metadataKey, target, propertyKey) {
            if (!IsObject(target))
                throw new TypeError();
            if (!IsUndefined(propertyKey))
                propertyKey = ToPropertyKey(propertyKey);
            var metadataMap = GetOrCreateMetadataMap(target, propertyKey, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            if (!metadataMap.delete(metadataKey))
                return false;
            if (metadataMap.size > 0)
                return true;
            var targetMetadata = Metadata.get(target);
            targetMetadata.delete(propertyKey);
            if (targetMetadata.size > 0)
                return true;
            Metadata.delete(target);
            return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsConstructor(decorated))
                        throw new TypeError();
                    target = decorated;
                }
            }
            return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
            for (var i = decorators.length - 1; i >= 0; --i) {
                var decorator = decorators[i];
                var decorated = decorator(target, propertyKey, descriptor);
                if (!IsUndefined(decorated) && !IsNull(decorated)) {
                    if (!IsObject(decorated))
                        throw new TypeError();
                    descriptor = decorated;
                }
            }
            return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
            var targetMetadata = Metadata.get(O);
            if (IsUndefined(targetMetadata)) {
                if (!Create)
                    return undefined;
                targetMetadata = new _Map();
                Metadata.set(O, targetMetadata);
            }
            var metadataMap = targetMetadata.get(P);
            if (IsUndefined(metadataMap)) {
                if (!Create)
                    return undefined;
                metadataMap = new _Map();
                targetMetadata.set(P, metadataMap);
            }
            return metadataMap;
        }
        // 3.1.1.1 OrdinaryHasMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasmetadata
        function OrdinaryHasMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return true;
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryHasMetadata(MetadataKey, parent, P);
            return false;
        }
        // 3.1.2.1 OrdinaryHasOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryhasownmetadata
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return false;
            return ToBoolean(metadataMap.has(MetadataKey));
        }
        // 3.1.3.1 OrdinaryGetMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetmetadata
        function OrdinaryGetMetadata(MetadataKey, O, P) {
            var hasOwn = OrdinaryHasOwnMetadata(MetadataKey, O, P);
            if (hasOwn)
                return OrdinaryGetOwnMetadata(MetadataKey, O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (!IsNull(parent))
                return OrdinaryGetMetadata(MetadataKey, parent, P);
            return undefined;
        }
        // 3.1.4.1 OrdinaryGetOwnMetadata(MetadataKey, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarygetownmetadata
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return undefined;
            return metadataMap.get(MetadataKey);
        }
        // 3.1.5.1 OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarydefineownmetadata
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ true);
            metadataMap.set(MetadataKey, MetadataValue);
        }
        // 3.1.6.1 OrdinaryMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinarymetadatakeys
        function OrdinaryMetadataKeys(O, P) {
            var ownKeys = OrdinaryOwnMetadataKeys(O, P);
            var parent = OrdinaryGetPrototypeOf(O);
            if (parent === null)
                return ownKeys;
            var parentKeys = OrdinaryMetadataKeys(parent, P);
            if (parentKeys.length <= 0)
                return ownKeys;
            if (ownKeys.length <= 0)
                return parentKeys;
            var set = new _Set();
            var keys = [];
            for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
                var key = ownKeys_1[_i];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
                var key = parentKeys_1[_a];
                var hasKey = set.has(key);
                if (!hasKey) {
                    set.add(key);
                    keys.push(key);
                }
            }
            return keys;
        }
        // 3.1.7.1 OrdinaryOwnMetadataKeys(O, P)
        // https://rbuckton.github.io/reflect-metadata/#ordinaryownmetadatakeys
        function OrdinaryOwnMetadataKeys(O, P) {
            var keys = [];
            var metadataMap = GetOrCreateMetadataMap(O, P, /*Create*/ false);
            if (IsUndefined(metadataMap))
                return keys;
            var keysObj = metadataMap.keys();
            var iterator = GetIterator(keysObj);
            var k = 0;
            while (true) {
                var next = IteratorStep(iterator);
                if (!next) {
                    keys.length = k;
                    return keys;
                }
                var nextValue = IteratorValue(next);
                try {
                    keys[k] = nextValue;
                }
                catch (e) {
                    try {
                        IteratorClose(iterator);
                    }
                    finally {
                        throw e;
                    }
                }
                k++;
            }
        }
        // 6 ECMAScript Data Typ0es and Values
        // https://tc39.github.io/ecma262/#sec-ecmascript-data-types-and-values
        function Type(x) {
            if (x === null)
                return 1 /* Null */;
            switch (typeof x) {
                case "undefined": return 0 /* Undefined */;
                case "boolean": return 2 /* Boolean */;
                case "string": return 3 /* String */;
                case "symbol": return 4 /* Symbol */;
                case "number": return 5 /* Number */;
                case "object": return x === null ? 1 /* Null */ : 6 /* Object */;
                default: return 6 /* Object */;
            }
        }
        // 6.1.1 The Undefined Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-undefined-type
        function IsUndefined(x) {
            return x === undefined;
        }
        // 6.1.2 The Null Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-null-type
        function IsNull(x) {
            return x === null;
        }
        // 6.1.5 The Symbol Type
        // https://tc39.github.io/ecma262/#sec-ecmascript-language-types-symbol-type
        function IsSymbol(x) {
            return typeof x === "symbol";
        }
        // 6.1.7 The Object Type
        // https://tc39.github.io/ecma262/#sec-object-type
        function IsObject(x) {
            return typeof x === "object" ? x !== null : typeof x === "function";
        }
        // 7.1 Type Conversion
        // https://tc39.github.io/ecma262/#sec-type-conversion
        // 7.1.1 ToPrimitive(input [, PreferredType])
        // https://tc39.github.io/ecma262/#sec-toprimitive
        function ToPrimitive(input, PreferredType) {
            switch (Type(input)) {
                case 0 /* Undefined */: return input;
                case 1 /* Null */: return input;
                case 2 /* Boolean */: return input;
                case 3 /* String */: return input;
                case 4 /* Symbol */: return input;
                case 5 /* Number */: return input;
            }
            var hint = PreferredType === 3 /* String */ ? "string" : PreferredType === 5 /* Number */ ? "number" : "default";
            var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
            if (exoticToPrim !== undefined) {
                var result = exoticToPrim.call(input, hint);
                if (IsObject(result))
                    throw new TypeError();
                return result;
            }
            return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        // 7.1.1.1 OrdinaryToPrimitive(O, hint)
        // https://tc39.github.io/ecma262/#sec-ordinarytoprimitive
        function OrdinaryToPrimitive(O, hint) {
            if (hint === "string") {
                var toString_1 = O.toString;
                if (IsCallable(toString_1)) {
                    var result = toString_1.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            else {
                var valueOf = O.valueOf;
                if (IsCallable(valueOf)) {
                    var result = valueOf.call(O);
                    if (!IsObject(result))
                        return result;
                }
                var toString_2 = O.toString;
                if (IsCallable(toString_2)) {
                    var result = toString_2.call(O);
                    if (!IsObject(result))
                        return result;
                }
            }
            throw new TypeError();
        }
        // 7.1.2 ToBoolean(argument)
        // https://tc39.github.io/ecma262/2016/#sec-toboolean
        function ToBoolean(argument) {
            return !!argument;
        }
        // 7.1.12 ToString(argument)
        // https://tc39.github.io/ecma262/#sec-tostring
        function ToString(argument) {
            return "" + argument;
        }
        // 7.1.14 ToPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-topropertykey
        function ToPropertyKey(argument) {
            var key = ToPrimitive(argument, 3 /* String */);
            if (IsSymbol(key))
                return key;
            return ToString(key);
        }
        // 7.2 Testing and Comparison Operations
        // https://tc39.github.io/ecma262/#sec-testing-and-comparison-operations
        // 7.2.2 IsArray(argument)
        // https://tc39.github.io/ecma262/#sec-isarray
        function IsArray(argument) {
            return Array.isArray
                ? Array.isArray(argument)
                : argument instanceof Object
                    ? argument instanceof Array
                    : Object.prototype.toString.call(argument) === "[object Array]";
        }
        // 7.2.3 IsCallable(argument)
        // https://tc39.github.io/ecma262/#sec-iscallable
        function IsCallable(argument) {
            // NOTE: This is an approximation as we cannot check for [[Call]] internal method.
            return typeof argument === "function";
        }
        // 7.2.4 IsConstructor(argument)
        // https://tc39.github.io/ecma262/#sec-isconstructor
        function IsConstructor(argument) {
            // NOTE: This is an approximation as we cannot check for [[Construct]] internal method.
            return typeof argument === "function";
        }
        // 7.2.7 IsPropertyKey(argument)
        // https://tc39.github.io/ecma262/#sec-ispropertykey
        function IsPropertyKey(argument) {
            switch (Type(argument)) {
                case 3 /* String */: return true;
                case 4 /* Symbol */: return true;
                default: return false;
            }
        }
        // 7.3 Operations on Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-objects
        // 7.3.9 GetMethod(V, P)
        // https://tc39.github.io/ecma262/#sec-getmethod
        function GetMethod(V, P) {
            var func = V[P];
            if (func === undefined || func === null)
                return undefined;
            if (!IsCallable(func))
                throw new TypeError();
            return func;
        }
        // 7.4 Operations on Iterator Objects
        // https://tc39.github.io/ecma262/#sec-operations-on-iterator-objects
        function GetIterator(obj) {
            var method = GetMethod(obj, iteratorSymbol);
            if (!IsCallable(method))
                throw new TypeError(); // from Call
            var iterator = method.call(obj);
            if (!IsObject(iterator))
                throw new TypeError();
            return iterator;
        }
        // 7.4.4 IteratorValue(iterResult)
        // https://tc39.github.io/ecma262/2016/#sec-iteratorvalue
        function IteratorValue(iterResult) {
            return iterResult.value;
        }
        // 7.4.5 IteratorStep(iterator)
        // https://tc39.github.io/ecma262/#sec-iteratorstep
        function IteratorStep(iterator) {
            var result = iterator.next();
            return result.done ? false : result;
        }
        // 7.4.6 IteratorClose(iterator, completion)
        // https://tc39.github.io/ecma262/#sec-iteratorclose
        function IteratorClose(iterator) {
            var f = iterator["return"];
            if (f)
                f.call(iterator);
        }
        // 9.1 Ordinary Object Internal Methods and Internal Slots
        // https://tc39.github.io/ecma262/#sec-ordinary-object-internal-methods-and-internal-slots
        // 9.1.1.1 OrdinaryGetPrototypeOf(O)
        // https://tc39.github.io/ecma262/#sec-ordinarygetprototypeof
        function OrdinaryGetPrototypeOf(O) {
            var proto = Object.getPrototypeOf(O);
            if (typeof O !== "function" || O === functionPrototype)
                return proto;
            // TypeScript doesn't set __proto__ in ES5, as it's non-standard.
            // Try to determine the superclass constructor. Compatible implementations
            // must either set __proto__ on a subclass constructor to the superclass constructor,
            // or ensure each class has a valid `constructor` property on its prototype that
            // points back to the constructor.
            // If this is not the same as Function.[[Prototype]], then this is definately inherited.
            // This is the case when in ES6 or when using __proto__ in a compatible browser.
            if (proto !== functionPrototype)
                return proto;
            // If the super prototype is Object.prototype, null, or undefined, then we cannot determine the heritage.
            var prototype = O.prototype;
            var prototypeProto = prototype && Object.getPrototypeOf(prototype);
            if (prototypeProto == null || prototypeProto === Object.prototype)
                return proto;
            // If the constructor was not a function, then we cannot determine the heritage.
            var constructor = prototypeProto.constructor;
            if (typeof constructor !== "function")
                return proto;
            // If we have some kind of self-reference, then we cannot determine the heritage.
            if (constructor === O)
                return proto;
            // we have a pretty good guess at the heritage.
            return constructor;
        }
        // naive Map shim
        function CreateMapPolyfill() {
            var cacheSentinel = {};
            var arraySentinel = [];
            var MapIterator = /** @class */ (function () {
                function MapIterator(keys, values, selector) {
                    this._index = 0;
                    this._keys = keys;
                    this._values = values;
                    this._selector = selector;
                }
                MapIterator.prototype["@@iterator"] = function () { return this; };
                MapIterator.prototype[iteratorSymbol] = function () { return this; };
                MapIterator.prototype.next = function () {
                    var index = this._index;
                    if (index >= 0 && index < this._keys.length) {
                        var result = this._selector(this._keys[index], this._values[index]);
                        if (index + 1 >= this._keys.length) {
                            this._index = -1;
                            this._keys = arraySentinel;
                            this._values = arraySentinel;
                        }
                        else {
                            this._index++;
                        }
                        return { value: result, done: false };
                    }
                    return { value: undefined, done: true };
                };
                MapIterator.prototype.throw = function (error) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    throw error;
                };
                MapIterator.prototype.return = function (value) {
                    if (this._index >= 0) {
                        this._index = -1;
                        this._keys = arraySentinel;
                        this._values = arraySentinel;
                    }
                    return { value: value, done: true };
                };
                return MapIterator;
            }());
            return /** @class */ (function () {
                function Map() {
                    this._keys = [];
                    this._values = [];
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                }
                Object.defineProperty(Map.prototype, "size", {
                    get: function () { return this._keys.length; },
                    enumerable: true,
                    configurable: true
                });
                Map.prototype.has = function (key) { return this._find(key, /*insert*/ false) >= 0; };
                Map.prototype.get = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    return index >= 0 ? this._values[index] : undefined;
                };
                Map.prototype.set = function (key, value) {
                    var index = this._find(key, /*insert*/ true);
                    this._values[index] = value;
                    return this;
                };
                Map.prototype.delete = function (key) {
                    var index = this._find(key, /*insert*/ false);
                    if (index >= 0) {
                        var size = this._keys.length;
                        for (var i = index + 1; i < size; i++) {
                            this._keys[i - 1] = this._keys[i];
                            this._values[i - 1] = this._values[i];
                        }
                        this._keys.length--;
                        this._values.length--;
                        if (key === this._cacheKey) {
                            this._cacheKey = cacheSentinel;
                            this._cacheIndex = -2;
                        }
                        return true;
                    }
                    return false;
                };
                Map.prototype.clear = function () {
                    this._keys.length = 0;
                    this._values.length = 0;
                    this._cacheKey = cacheSentinel;
                    this._cacheIndex = -2;
                };
                Map.prototype.keys = function () { return new MapIterator(this._keys, this._values, getKey); };
                Map.prototype.values = function () { return new MapIterator(this._keys, this._values, getValue); };
                Map.prototype.entries = function () { return new MapIterator(this._keys, this._values, getEntry); };
                Map.prototype["@@iterator"] = function () { return this.entries(); };
                Map.prototype[iteratorSymbol] = function () { return this.entries(); };
                Map.prototype._find = function (key, insert) {
                    if (this._cacheKey !== key) {
                        this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
                    }
                    if (this._cacheIndex < 0 && insert) {
                        this._cacheIndex = this._keys.length;
                        this._keys.push(key);
                        this._values.push(undefined);
                    }
                    return this._cacheIndex;
                };
                return Map;
            }());
            function getKey(key, _) {
                return key;
            }
            function getValue(_, value) {
                return value;
            }
            function getEntry(key, value) {
                return [key, value];
            }
        }
        // naive Set shim
        function CreateSetPolyfill() {
            return /** @class */ (function () {
                function Set() {
                    this._map = new _Map();
                }
                Object.defineProperty(Set.prototype, "size", {
                    get: function () { return this._map.size; },
                    enumerable: true,
                    configurable: true
                });
                Set.prototype.has = function (value) { return this._map.has(value); };
                Set.prototype.add = function (value) { return this._map.set(value, value), this; };
                Set.prototype.delete = function (value) { return this._map.delete(value); };
                Set.prototype.clear = function () { this._map.clear(); };
                Set.prototype.keys = function () { return this._map.keys(); };
                Set.prototype.values = function () { return this._map.values(); };
                Set.prototype.entries = function () { return this._map.entries(); };
                Set.prototype["@@iterator"] = function () { return this.keys(); };
                Set.prototype[iteratorSymbol] = function () { return this.keys(); };
                return Set;
            }());
        }
        // naive WeakMap shim
        function CreateWeakMapPolyfill() {
            var UUID_SIZE = 16;
            var keys = HashMap.create();
            var rootKey = CreateUniqueKey();
            return /** @class */ (function () {
                function WeakMap() {
                    this._key = CreateUniqueKey();
                }
                WeakMap.prototype.has = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.has(table, this._key) : false;
                };
                WeakMap.prototype.get = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? HashMap.get(table, this._key) : undefined;
                };
                WeakMap.prototype.set = function (target, value) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ true);
                    table[this._key] = value;
                    return this;
                };
                WeakMap.prototype.delete = function (target) {
                    var table = GetOrCreateWeakMapTable(target, /*create*/ false);
                    return table !== undefined ? delete table[this._key] : false;
                };
                WeakMap.prototype.clear = function () {
                    // NOTE: not a real clear, just makes the previous data unreachable
                    this._key = CreateUniqueKey();
                };
                return WeakMap;
            }());
            function CreateUniqueKey() {
                var key;
                do
                    key = "@@WeakMap@@" + CreateUUID();
                while (HashMap.has(keys, key));
                keys[key] = true;
                return key;
            }
            function GetOrCreateWeakMapTable(target, create) {
                if (!hasOwn.call(target, rootKey)) {
                    if (!create)
                        return undefined;
                    Object.defineProperty(target, rootKey, { value: HashMap.create() });
                }
                return target[rootKey];
            }
            function FillRandomBytes(buffer, size) {
                for (var i = 0; i < size; ++i)
                    buffer[i] = Math.random() * 0xff | 0;
                return buffer;
            }
            function GenRandomBytes(size) {
                if (typeof Uint8Array === "function") {
                    if (typeof crypto !== "undefined")
                        return crypto.getRandomValues(new Uint8Array(size));
                    if (typeof msCrypto !== "undefined")
                        return msCrypto.getRandomValues(new Uint8Array(size));
                    return FillRandomBytes(new Uint8Array(size), size);
                }
                return FillRandomBytes(new Array(size), size);
            }
            function CreateUUID() {
                var data = GenRandomBytes(UUID_SIZE);
                // mark as random - RFC 4122 § 4.4
                data[6] = data[6] & 0x4f | 0x40;
                data[8] = data[8] & 0xbf | 0x80;
                var result = "";
                for (var offset = 0; offset < UUID_SIZE; ++offset) {
                    var byte = data[offset];
                    if (offset === 4 || offset === 6 || offset === 8)
                        result += "-";
                    if (byte < 16)
                        result += "0";
                    result += byte.toString(16).toLowerCase();
                }
                return result;
            }
        }
        // uses a heuristic used by v8 and chakra to force an object into dictionary mode.
        function MakeDictionary(obj) {
            obj.__ = undefined;
            delete obj.__;
            return obj;
        }
    });
})(Reflect || (Reflect = {}));


/***/ }),

/***/ "./node_modules/semver/classes/comparator.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/classes/comparator.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  }

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      } else {
        comp = comp.value
      }
    }

    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    } else {
      this.value = this.operator + this.semver.version
    }

    debug('comp', this)
  }

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp}`)
    }

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    }

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    } else {
      this.semver = new SemVer(m[2], this.options.loose)
    }
  }

  toString () {
    return this.value
  }

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    return cmp(version, this.operator, this.semver, this.options)
  }

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    }

    if (!options || typeof options !== 'object') {
      options = {
        loose: !!options,
        includePrerelease: false,
      }
    }

    if (this.operator === '') {
      if (this.value === '') {
        return true
      }
      return new Range(comp.value, options).test(this.value)
    } else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      }
      return new Range(this.value, options).test(comp.semver)
    }

    const sameDirectionIncreasing =
      (this.operator === '>=' || this.operator === '>') &&
      (comp.operator === '>=' || comp.operator === '>')
    const sameDirectionDecreasing =
      (this.operator === '<=' || this.operator === '<') &&
      (comp.operator === '<=' || comp.operator === '<')
    const sameSemVer = this.semver.version === comp.semver.version
    const differentDirectionsInclusive =
      (this.operator === '>=' || this.operator === '<=') &&
      (comp.operator === '>=' || comp.operator === '<=')
    const oppositeDirectionsLessThan =
      cmp(this.semver, '<', comp.semver, options) &&
      (this.operator === '>=' || this.operator === '>') &&
        (comp.operator === '<=' || comp.operator === '<')
    const oppositeDirectionsGreaterThan =
      cmp(this.semver, '>', comp.semver, options) &&
      (this.operator === '<=' || this.operator === '<') &&
        (comp.operator === '>=' || comp.operator === '>')

    return (
      sameDirectionIncreasing ||
      sameDirectionDecreasing ||
      (sameSemVer && differentDirectionsInclusive) ||
      oppositeDirectionsLessThan ||
      oppositeDirectionsGreaterThan
    )
  }
}

module.exports = Comparator

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const cmp = __webpack_require__(/*! ../functions/cmp */ "./node_modules/semver/functions/cmp.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ./range */ "./node_modules/semver/classes/range.js")


/***/ }),

/***/ "./node_modules/semver/classes/range.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/classes/range.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// hoisted class for cyclic dependency
class Range {
  constructor (range, options) {
    options = parseOptions(options)

    if (range instanceof Range) {
      if (
        range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease
      ) {
        return range
      } else {
        return new Range(range.raw, options)
      }
    }

    if (range instanceof Comparator) {
      // just put it in the set and return
      this.raw = range.value
      this.set = [[range]]
      this.format()
      return this
    }

    this.options = options
    this.loose = !!options.loose
    this.includePrerelease = !!options.includePrerelease

    // First, split based on boolean or ||
    this.raw = range
    this.set = range
      .split('||')
      // map the range to a 2d array of comparators
      .map(r => this.parseRange(r.trim()))
      // throw out any comparator lists that are empty
      // this generally means that it was not a valid range, which is allowed
      // in loose mode, but will still throw if the WHOLE range is invalid.
      .filter(c => c.length)

    if (!this.set.length) {
      throw new TypeError(`Invalid SemVer Range: ${range}`)
    }

    // if we have any that are not the null set, throw out null sets.
    if (this.set.length > 1) {
      // keep the first one, in case they're all null sets
      const first = this.set[0]
      this.set = this.set.filter(c => !isNullSet(c[0]))
      if (this.set.length === 0) {
        this.set = [first]
      } else if (this.set.length > 1) {
        // if we have any that are *, then the range is just *
        for (const c of this.set) {
          if (c.length === 1 && isAny(c[0])) {
            this.set = [c]
            break
          }
        }
      }
    }

    this.format()
  }

  format () {
    this.range = this.set
      .map((comps) => {
        return comps.join(' ').trim()
      })
      .join('||')
      .trim()
    return this.range
  }

  toString () {
    return this.range
  }

  parseRange (range) {
    range = range.trim()

    // memoize range parsing for performance.
    // this is a very hot path, and fully deterministic.
    const memoOpts = Object.keys(this.options).join(',')
    const memoKey = `parseRange:${memoOpts}:${range}`
    const cached = cache.get(memoKey)
    if (cached) {
      return cached
    }

    const loose = this.options.loose
    // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
    const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
    range = range.replace(hr, hyphenReplace(this.options.includePrerelease))
    debug('hyphen replace', range)
    // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
    range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
    debug('comparator trim', range)

    // `~ 1.2.3` => `~1.2.3`
    range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

    // `^ 1.2.3` => `^1.2.3`
    range = range.replace(re[t.CARETTRIM], caretTrimReplace)

    // normalize spaces
    range = range.split(/\s+/).join(' ')

    // At this point, the range is completely trimmed and
    // ready to be split into comparators.

    let rangeList = range
      .split(' ')
      .map(comp => parseComparator(comp, this.options))
      .join(' ')
      .split(/\s+/)
      // >=0.0.0 is equivalent to *
      .map(comp => replaceGTE0(comp, this.options))

    if (loose) {
      // in loose mode, throw out any that are not valid comparators
      rangeList = rangeList.filter(comp => {
        debug('loose invalid filter', comp, this.options)
        return !!comp.match(re[t.COMPARATORLOOSE])
      })
    }
    debug('range list', rangeList)

    // if any comparators are the null set, then replace with JUST null set
    // if more than one comparator, remove any * comparators
    // also, don't include the same comparator more than once
    const rangeMap = new Map()
    const comparators = rangeList.map(comp => new Comparator(comp, this.options))
    for (const comp of comparators) {
      if (isNullSet(comp)) {
        return [comp]
      }
      rangeMap.set(comp.value, comp)
    }
    if (rangeMap.size > 1 && rangeMap.has('')) {
      rangeMap.delete('')
    }

    const result = [...rangeMap.values()]
    cache.set(memoKey, result)
    return result
  }

  intersects (range, options) {
    if (!(range instanceof Range)) {
      throw new TypeError('a Range is required')
    }

    return this.set.some((thisComparators) => {
      return (
        isSatisfiable(thisComparators, options) &&
        range.set.some((rangeComparators) => {
          return (
            isSatisfiable(rangeComparators, options) &&
            thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options)
              })
            })
          )
        })
      )
    })
  }

  // if ANY of the sets match ALL of its comparators, then pass
  test (version) {
    if (!version) {
      return false
    }

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      } catch (er) {
        return false
      }
    }

    for (let i = 0; i < this.set.length; i++) {
      if (testSet(this.set[i], version, this.options)) {
        return true
      }
    }
    return false
  }
}
module.exports = Range

const LRU = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js")
const cache = new LRU({ max: 1000 })

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const Comparator = __webpack_require__(/*! ./comparator */ "./node_modules/semver/classes/comparator.js")
const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const SemVer = __webpack_require__(/*! ./semver */ "./node_modules/semver/classes/semver.js")
const {
  re,
  t,
  comparatorTrimReplace,
  tildeTrimReplace,
  caretTrimReplace,
} = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const isNullSet = c => c.value === '<0.0.0-0'
const isAny = c => c.value === ''

// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options) => {
  let result = true
  const remainingComparators = comparators.slice()
  let testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every((otherComparator) => {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options) => {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

const isX = id => !id || id.toLowerCase() === 'x' || id === '*'

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceTilde(c, options)
  }).join(' ')

const replaceTilde = (comp, options) => {
  const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('tilde', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0 <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0-0
      ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = `>=${M}.${m}.${p}-${pr
      } <${M}.${+m + 1}.0-0`
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0-0
      ret = `>=${M}.${m}.${p
      } <${M}.${+m + 1}.0-0`
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options) =>
  comp.trim().split(/\s+/).map((c) => {
    return replaceCaret(c, options)
  }).join(' ')

const replaceCaret = (comp, options) => {
  debug('caret', comp, options)
  const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  const z = options.includePrerelease ? '-0' : ''
  return comp.replace(r, (_, M, m, p, pr) => {
    debug('caret', comp, _, M, m, p, pr)
    let ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`
    } else if (isX(p)) {
      if (M === '0') {
        ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`
      } else {
        ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p}-${pr
          } <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p}-${pr
        } <${+M + 1}.0.0-0`
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${m}.${+p + 1}-0`
        } else {
          ret = `>=${M}.${m}.${p
          }${z} <${M}.${+m + 1}.0-0`
        }
      } else {
        ret = `>=${M}.${m}.${p
        } <${+M + 1}.0.0-0`
      }
    }

    debug('caret return', ret)
    return ret
  })
}

const replaceXRanges = (comp, options) => {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map((c) => {
    return replaceXRange(c, options)
  }).join(' ')
}

const replaceXRange = (comp, options) => {
  comp = comp.trim()
  const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, (ret, gtlt, M, m, p, pr) => {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    const xM = isX(M)
    const xm = xM || isX(m)
    const xp = xm || isX(p)
    const anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      if (gtlt === '<') {
        pr = '-0'
      }

      ret = `${gtlt + M}.${m}.${p}${pr}`
    } else if (xm) {
      ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`
    } else if (xp) {
      ret = `>=${M}.${m}.0${pr
      } <${M}.${+m + 1}.0-0`
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options) => {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

const replaceGTE0 = (comp, options) => {
  debug('replaceGTE0', comp, options)
  return comp.trim()
    .replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = incPr => ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) => {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = `>=${fM}.0.0${incPr ? '-0' : ''}`
  } else if (isX(fp)) {
    from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`
  } else if (fpr) {
    from = `>=${from}`
  } else {
    from = `>=${from}${incPr ? '-0' : ''}`
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = `<${+tM + 1}.0.0-0`
  } else if (isX(tp)) {
    to = `<${tM}.${+tm + 1}.0-0`
  } else if (tpr) {
    to = `<=${tM}.${tm}.${tp}-${tpr}`
  } else if (incPr) {
    to = `<${tM}.${tm}.${+tp + 1}-0`
  } else {
    to = `<=${to}`
  }

  return (`${from} ${to}`).trim()
}

const testSet = (set, version, options) => {
  for (let i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (let i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === Comparator.ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        const allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}


/***/ }),

/***/ "./node_modules/semver/classes/semver.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/classes/semver.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/semver/internal/debug.js")
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const { compareIdentifiers } = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
class SemVer {
  constructor (version, options) {
    options = parseOptions(options)

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose &&
          version.includePrerelease === !!options.includePrerelease) {
        return version
      } else {
        version = version.version
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(
        `version is longer than ${MAX_LENGTH} characters`
      )
    }

    debug('SemVer', version, options)
    this.options = options
    this.loose = !!options.loose
    // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.
    this.includePrerelease = !!options.includePrerelease

    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`)
    }

    this.raw = version

    // these are actually numbers
    this.major = +m[1]
    this.minor = +m[2]
    this.patch = +m[3]

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version')
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version')
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version')
    }

    // numberify any prerelease numeric ids
    if (!m[4]) {
      this.prerelease = []
    } else {
      this.prerelease = m[4].split('.').map((id) => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id
          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num
          }
        }
        return id
      })
    }

    this.build = m[5] ? m[5].split('.') : []
    this.format()
  }

  format () {
    this.version = `${this.major}.${this.minor}.${this.patch}`
    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`
    }
    return this.version
  }

  toString () {
    return this.version
  }

  compare (other) {
    debug('SemVer.compare', this.version, this.options, other)
    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0
      }
      other = new SemVer(other, this.options)
    }

    if (other.version === this.version) {
      return 0
    }

    return this.compareMain(other) || this.comparePre(other)
  }

  compareMain (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    return (
      compareIdentifiers(this.major, other.major) ||
      compareIdentifiers(this.minor, other.minor) ||
      compareIdentifiers(this.patch, other.patch)
    )
  }

  comparePre (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    // NOT having a prerelease is > having one
    if (this.prerelease.length && !other.prerelease.length) {
      return -1
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0
    }

    let i = 0
    do {
      const a = this.prerelease[i]
      const b = other.prerelease[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  compareBuild (other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options)
    }

    let i = 0
    do {
      const a = this.build[i]
      const b = other.build[i]
      debug('prerelease compare', i, a, b)
      if (a === undefined && b === undefined) {
        return 0
      } else if (b === undefined) {
        return 1
      } else if (a === undefined) {
        return -1
      } else if (a === b) {
        continue
      } else {
        return compareIdentifiers(a, b)
      }
    } while (++i)
  }

  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc (release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor = 0
        this.major++
        this.inc('pre', identifier)
        break
      case 'preminor':
        this.prerelease.length = 0
        this.patch = 0
        this.minor++
        this.inc('pre', identifier)
        break
      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0
        this.inc('patch', identifier)
        this.inc('pre', identifier)
        break
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.
      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier)
        }
        this.inc('pre', identifier)
        break

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        ) {
          this.major++
        }
        this.minor = 0
        this.patch = 0
        this.prerelease = []
        break
      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++
        }
        this.patch = 0
        this.prerelease = []
        break
      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++
        }
        this.prerelease = []
        break
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0]
        } else {
          let i = this.prerelease.length
          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++
              i = -2
            }
          }
          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0)
          }
        }
        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0]
            }
          } else {
            this.prerelease = [identifier, 0]
          }
        }
        break

      default:
        throw new Error(`invalid increment argument: ${release}`)
    }
    this.format()
    this.raw = this.version
    return this
  }
}

module.exports = SemVer


/***/ }),

/***/ "./node_modules/semver/functions/clean.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/clean.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const clean = (version, options) => {
  const s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}
module.exports = clean


/***/ }),

/***/ "./node_modules/semver/functions/cmp.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/cmp.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./neq */ "./node_modules/semver/functions/neq.js")
const gt = __webpack_require__(/*! ./gt */ "./node_modules/semver/functions/gt.js")
const gte = __webpack_require__(/*! ./gte */ "./node_modules/semver/functions/gte.js")
const lt = __webpack_require__(/*! ./lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ./lte */ "./node_modules/semver/functions/lte.js")

const cmp = (a, op, b, loose) => {
  switch (op) {
    case '===':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a === b

    case '!==':
      if (typeof a === 'object') {
        a = a.version
      }
      if (typeof b === 'object') {
        b = b.version
      }
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError(`Invalid operator: ${op}`)
  }
}
module.exports = cmp


/***/ }),

/***/ "./node_modules/semver/functions/coerce.js":
/*!*************************************************!*\
  !*** ./node_modules/semver/functions/coerce.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")

const coerce = (version, options) => {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  let match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    let next
    while ((next = re[t.COERCERTL].exec(version)) &&
        (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
            next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(`${match[2]}.${match[3] || '0'}.${match[4] || '0'}`, options)
}
module.exports = coerce


/***/ }),

/***/ "./node_modules/semver/functions/compare-build.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-build.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compareBuild = (a, b, loose) => {
  const versionA = new SemVer(a, loose)
  const versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}
module.exports = compareBuild


/***/ }),

/***/ "./node_modules/semver/functions/compare-loose.js":
/*!********************************************************!*\
  !*** ./node_modules/semver/functions/compare-loose.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const compareLoose = (a, b) => compare(a, b, true)
module.exports = compareLoose


/***/ }),

/***/ "./node_modules/semver/functions/compare.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/functions/compare.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const compare = (a, b, loose) =>
  new SemVer(a, loose).compare(new SemVer(b, loose))

module.exports = compare


/***/ }),

/***/ "./node_modules/semver/functions/diff.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/diff.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const eq = __webpack_require__(/*! ./eq */ "./node_modules/semver/functions/eq.js")

const diff = (version1, version2) => {
  if (eq(version1, version2)) {
    return null
  } else {
    const v1 = parse(version1)
    const v2 = parse(version2)
    const hasPre = v1.prerelease.length || v2.prerelease.length
    const prefix = hasPre ? 'pre' : ''
    const defaultResult = hasPre ? 'prerelease' : ''
    for (const key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}
module.exports = diff


/***/ }),

/***/ "./node_modules/semver/functions/eq.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/eq.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const eq = (a, b, loose) => compare(a, b, loose) === 0
module.exports = eq


/***/ }),

/***/ "./node_modules/semver/functions/gt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/gt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gt = (a, b, loose) => compare(a, b, loose) > 0
module.exports = gt


/***/ }),

/***/ "./node_modules/semver/functions/gte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/gte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const gte = (a, b, loose) => compare(a, b, loose) >= 0
module.exports = gte


/***/ }),

/***/ "./node_modules/semver/functions/inc.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/inc.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const inc = (version, release, options, identifier) => {
  if (typeof (options) === 'string') {
    identifier = options
    options = undefined
  }

  try {
    return new SemVer(
      version instanceof SemVer ? version.version : version,
      options
    ).inc(release, identifier).version
  } catch (er) {
    return null
  }
}
module.exports = inc


/***/ }),

/***/ "./node_modules/semver/functions/lt.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/functions/lt.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lt = (a, b, loose) => compare(a, b, loose) < 0
module.exports = lt


/***/ }),

/***/ "./node_modules/semver/functions/lte.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/lte.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const lte = (a, b, loose) => compare(a, b, loose) <= 0
module.exports = lte


/***/ }),

/***/ "./node_modules/semver/functions/major.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/major.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const major = (a, loose) => new SemVer(a, loose).major
module.exports = major


/***/ }),

/***/ "./node_modules/semver/functions/minor.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/minor.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const minor = (a, loose) => new SemVer(a, loose).minor
module.exports = minor


/***/ }),

/***/ "./node_modules/semver/functions/neq.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/functions/neq.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const neq = (a, b, loose) => compare(a, b, loose) !== 0
module.exports = neq


/***/ }),

/***/ "./node_modules/semver/functions/parse.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/parse.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { MAX_LENGTH } = __webpack_require__(/*! ../internal/constants */ "./node_modules/semver/internal/constants.js")
const { re, t } = __webpack_require__(/*! ../internal/re */ "./node_modules/semver/internal/re.js")
const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/semver/internal/parse-options.js")
const parse = (version, options) => {
  options = parseOptions(options)

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  const r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

module.exports = parse


/***/ }),

/***/ "./node_modules/semver/functions/patch.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/patch.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const patch = (a, loose) => new SemVer(a, loose).patch
module.exports = patch


/***/ }),

/***/ "./node_modules/semver/functions/prerelease.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/functions/prerelease.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const prerelease = (version, options) => {
  const parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}
module.exports = prerelease


/***/ }),

/***/ "./node_modules/semver/functions/rcompare.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/functions/rcompare.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compare = __webpack_require__(/*! ./compare */ "./node_modules/semver/functions/compare.js")
const rcompare = (a, b, loose) => compare(b, a, loose)
module.exports = rcompare


/***/ }),

/***/ "./node_modules/semver/functions/rsort.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/rsort.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose))
module.exports = rsort


/***/ }),

/***/ "./node_modules/semver/functions/satisfies.js":
/*!****************************************************!*\
  !*** ./node_modules/semver/functions/satisfies.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = (version, range, options) => {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}
module.exports = satisfies


/***/ }),

/***/ "./node_modules/semver/functions/sort.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/functions/sort.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const compareBuild = __webpack_require__(/*! ./compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose))
module.exports = sort


/***/ }),

/***/ "./node_modules/semver/functions/valid.js":
/*!************************************************!*\
  !*** ./node_modules/semver/functions/valid.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const parse = __webpack_require__(/*! ./parse */ "./node_modules/semver/functions/parse.js")
const valid = (version, options) => {
  const v = parse(version, options)
  return v ? v.version : null
}
module.exports = valid


/***/ }),

/***/ "./node_modules/semver/index.js":
/*!**************************************!*\
  !*** ./node_modules/semver/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// just pre-load all the stuff that index.js lazily exports
const internalRe = __webpack_require__(/*! ./internal/re */ "./node_modules/semver/internal/re.js")
const constants = __webpack_require__(/*! ./internal/constants */ "./node_modules/semver/internal/constants.js")
const SemVer = __webpack_require__(/*! ./classes/semver */ "./node_modules/semver/classes/semver.js")
const identifiers = __webpack_require__(/*! ./internal/identifiers */ "./node_modules/semver/internal/identifiers.js")
const parse = __webpack_require__(/*! ./functions/parse */ "./node_modules/semver/functions/parse.js")
const valid = __webpack_require__(/*! ./functions/valid */ "./node_modules/semver/functions/valid.js")
const clean = __webpack_require__(/*! ./functions/clean */ "./node_modules/semver/functions/clean.js")
const inc = __webpack_require__(/*! ./functions/inc */ "./node_modules/semver/functions/inc.js")
const diff = __webpack_require__(/*! ./functions/diff */ "./node_modules/semver/functions/diff.js")
const major = __webpack_require__(/*! ./functions/major */ "./node_modules/semver/functions/major.js")
const minor = __webpack_require__(/*! ./functions/minor */ "./node_modules/semver/functions/minor.js")
const patch = __webpack_require__(/*! ./functions/patch */ "./node_modules/semver/functions/patch.js")
const prerelease = __webpack_require__(/*! ./functions/prerelease */ "./node_modules/semver/functions/prerelease.js")
const compare = __webpack_require__(/*! ./functions/compare */ "./node_modules/semver/functions/compare.js")
const rcompare = __webpack_require__(/*! ./functions/rcompare */ "./node_modules/semver/functions/rcompare.js")
const compareLoose = __webpack_require__(/*! ./functions/compare-loose */ "./node_modules/semver/functions/compare-loose.js")
const compareBuild = __webpack_require__(/*! ./functions/compare-build */ "./node_modules/semver/functions/compare-build.js")
const sort = __webpack_require__(/*! ./functions/sort */ "./node_modules/semver/functions/sort.js")
const rsort = __webpack_require__(/*! ./functions/rsort */ "./node_modules/semver/functions/rsort.js")
const gt = __webpack_require__(/*! ./functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ./functions/lt */ "./node_modules/semver/functions/lt.js")
const eq = __webpack_require__(/*! ./functions/eq */ "./node_modules/semver/functions/eq.js")
const neq = __webpack_require__(/*! ./functions/neq */ "./node_modules/semver/functions/neq.js")
const gte = __webpack_require__(/*! ./functions/gte */ "./node_modules/semver/functions/gte.js")
const lte = __webpack_require__(/*! ./functions/lte */ "./node_modules/semver/functions/lte.js")
const cmp = __webpack_require__(/*! ./functions/cmp */ "./node_modules/semver/functions/cmp.js")
const coerce = __webpack_require__(/*! ./functions/coerce */ "./node_modules/semver/functions/coerce.js")
const Comparator = __webpack_require__(/*! ./classes/comparator */ "./node_modules/semver/classes/comparator.js")
const Range = __webpack_require__(/*! ./classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ./functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const toComparators = __webpack_require__(/*! ./ranges/to-comparators */ "./node_modules/semver/ranges/to-comparators.js")
const maxSatisfying = __webpack_require__(/*! ./ranges/max-satisfying */ "./node_modules/semver/ranges/max-satisfying.js")
const minSatisfying = __webpack_require__(/*! ./ranges/min-satisfying */ "./node_modules/semver/ranges/min-satisfying.js")
const minVersion = __webpack_require__(/*! ./ranges/min-version */ "./node_modules/semver/ranges/min-version.js")
const validRange = __webpack_require__(/*! ./ranges/valid */ "./node_modules/semver/ranges/valid.js")
const outside = __webpack_require__(/*! ./ranges/outside */ "./node_modules/semver/ranges/outside.js")
const gtr = __webpack_require__(/*! ./ranges/gtr */ "./node_modules/semver/ranges/gtr.js")
const ltr = __webpack_require__(/*! ./ranges/ltr */ "./node_modules/semver/ranges/ltr.js")
const intersects = __webpack_require__(/*! ./ranges/intersects */ "./node_modules/semver/ranges/intersects.js")
const simplifyRange = __webpack_require__(/*! ./ranges/simplify */ "./node_modules/semver/ranges/simplify.js")
const subset = __webpack_require__(/*! ./ranges/subset */ "./node_modules/semver/ranges/subset.js")
module.exports = {
  parse,
  valid,
  clean,
  inc,
  diff,
  major,
  minor,
  patch,
  prerelease,
  compare,
  rcompare,
  compareLoose,
  compareBuild,
  sort,
  rsort,
  gt,
  lt,
  eq,
  neq,
  gte,
  lte,
  cmp,
  coerce,
  Comparator,
  Range,
  satisfies,
  toComparators,
  maxSatisfying,
  minSatisfying,
  minVersion,
  validRange,
  outside,
  gtr,
  ltr,
  intersects,
  simplifyRange,
  subset,
  SemVer,
  re: internalRe.re,
  src: internalRe.src,
  tokens: internalRe.t,
  SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
  compareIdentifiers: identifiers.compareIdentifiers,
  rcompareIdentifiers: identifiers.rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/constants.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/internal/constants.js ***!
  \***************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0'

const MAX_LENGTH = 256
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16

module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH,
}


/***/ }),

/***/ "./node_modules/semver/internal/debug.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/internal/debug.js ***!
  \***********************************************/
/***/ ((module) => {

const debug = (
  typeof process === 'object' &&
  process.env &&
  process.env.NODE_DEBUG &&
  /\bsemver\b/i.test(process.env.NODE_DEBUG)
) ? (...args) => console.error('SEMVER', ...args)
  : () => {}

module.exports = debug


/***/ }),

/***/ "./node_modules/semver/internal/identifiers.js":
/*!*****************************************************!*\
  !*** ./node_modules/semver/internal/identifiers.js ***!
  \*****************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/
const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a)
  const bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a)

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers,
}


/***/ }),

/***/ "./node_modules/semver/internal/parse-options.js":
/*!*******************************************************!*\
  !*** ./node_modules/semver/internal/parse-options.js ***!
  \*******************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl']
const parseOptions = options =>
  !options ? {}
  : typeof options !== 'object' ? { loose: true }
  : opts.filter(k => options[k]).reduce((o, k) => {
    o[k] = true
    return o
  }, {})
module.exports = parseOptions


/***/ }),

/***/ "./node_modules/semver/internal/re.js":
/*!********************************************!*\
  !*** ./node_modules/semver/internal/re.js ***!
  \********************************************/
/***/ ((module, exports, __webpack_require__) => {

const { MAX_SAFE_COMPONENT_LENGTH } = __webpack_require__(/*! ./constants */ "./node_modules/semver/internal/constants.js")
const debug = __webpack_require__(/*! ./debug */ "./node_modules/semver/internal/debug.js")
exports = module.exports = {}

// The actual regexps go on exports.re
const re = exports.re = []
const src = exports.src = []
const t = exports.t = {}
let R = 0

const createToken = (name, value, isGlobal) => {
  const index = R++
  debug(name, index, value)
  t[name] = index
  src[index] = value
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined)
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*')
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+')

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*')

// ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})\\.` +
                   `(${src[t.NUMERICIDENTIFIER]})`)

createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
                        `(${src[t.NUMERICIDENTIFIERLOOSE]})`)

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]
}|${src[t.NONNUMERICIDENTIFIER]})`)

createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]
}|${src[t.NONNUMERICIDENTIFIER]})`)

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]
}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`)

createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]
}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`)

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+')

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]
}(?:\\.${src[t.BUILDIDENTIFIER]})*))`)

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]
}${src[t.PRERELEASE]}?${
  src[t.BUILD]}?`)

createToken('FULL', `^${src[t.FULLPLAIN]}$`)

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]
}${src[t.PRERELEASELOOSE]}?${
  src[t.BUILD]}?`)

createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`)

createToken('GTLT', '((?:<|>)?=?)')

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`)
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`)

createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
                   `(?:${src[t.PRERELEASE]})?${
                     src[t.BUILD]}?` +
                   `)?)?`)

createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
                        `(?:${src[t.PRERELEASELOOSE]})?${
                          src[t.BUILD]}?` +
                        `)?)?`)

createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`)
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`)

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCE', `${'(^|[^\\d])' +
              '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
              `(?:$|[^\\d])`)
createToken('COERCERTL', src[t.COERCE], true)

// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)')

createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true)
exports.tildeTrimReplace = '$1~'

createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`)
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`)

// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)')

createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true)
exports.caretTrimReplace = '$1^'

createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`)
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`)

// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`)
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`)

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]
}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true)
exports.comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` +
                   `\\s+-\\s+` +
                   `(${src[t.XRANGEPLAIN]})` +
                   `\\s*$`)

createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s+-\\s+` +
                        `(${src[t.XRANGEPLAINLOOSE]})` +
                        `\\s*$`)

// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*')
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$')
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$')


/***/ }),

/***/ "./node_modules/semver/ranges/gtr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/gtr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Determine if version is greater than all the versions possible in the range.
const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
const gtr = (version, range, options) => outside(version, range, '>', options)
module.exports = gtr


/***/ }),

/***/ "./node_modules/semver/ranges/intersects.js":
/*!**************************************************!*\
  !*** ./node_modules/semver/ranges/intersects.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const intersects = (r1, r2, options) => {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}
module.exports = intersects


/***/ }),

/***/ "./node_modules/semver/ranges/ltr.js":
/*!*******************************************!*\
  !*** ./node_modules/semver/ranges/ltr.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const outside = __webpack_require__(/*! ./outside */ "./node_modules/semver/ranges/outside.js")
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options) => outside(version, range, '<', options)
module.exports = ltr


/***/ }),

/***/ "./node_modules/semver/ranges/max-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/max-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

const maxSatisfying = (versions, range, options) => {
  let max = null
  let maxSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}
module.exports = maxSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-satisfying.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/min-satisfying.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const minSatisfying = (versions, range, options) => {
  let min = null
  let minSV = null
  let rangeObj = null
  try {
    rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach((v) => {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}
module.exports = minSatisfying


/***/ }),

/***/ "./node_modules/semver/ranges/min-version.js":
/*!***************************************************!*\
  !*** ./node_modules/semver/ranges/min-version.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")

const minVersion = (range, loose) => {
  range = new Range(range, loose)

  let minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let setMin = null
    comparators.forEach((comparator) => {
      // Clone to avoid manipulating the comparator's semver object.
      const compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!setMin || gt(compver, setMin)) {
            setMin = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error(`Unexpected operation: ${comparator.operator}`)
      }
    })
    if (setMin && (!minver || gt(minver, setMin))) {
      minver = setMin
    }
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}
module.exports = minVersion


/***/ }),

/***/ "./node_modules/semver/ranges/outside.js":
/*!***********************************************!*\
  !*** ./node_modules/semver/ranges/outside.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/semver/classes/semver.js")
const Comparator = __webpack_require__(/*! ../classes/comparator */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const satisfies = __webpack_require__(/*! ../functions/satisfies */ "./node_modules/semver/functions/satisfies.js")
const gt = __webpack_require__(/*! ../functions/gt */ "./node_modules/semver/functions/gt.js")
const lt = __webpack_require__(/*! ../functions/lt */ "./node_modules/semver/functions/lt.js")
const lte = __webpack_require__(/*! ../functions/lte */ "./node_modules/semver/functions/lte.js")
const gte = __webpack_require__(/*! ../functions/gte */ "./node_modules/semver/functions/gte.js")

const outside = (version, range, hilo, options) => {
  version = new SemVer(version, options)
  range = new Range(range, options)

  let gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisfies the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (let i = 0; i < range.set.length; ++i) {
    const comparators = range.set[i]

    let high = null
    let low = null

    comparators.forEach((comparator) => {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

module.exports = outside


/***/ }),

/***/ "./node_modules/semver/ranges/simplify.js":
/*!************************************************!*\
  !*** ./node_modules/semver/ranges/simplify.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")
module.exports = (versions, range, options) => {
  const set = []
  let first = null
  let prev = null
  const v = versions.sort((a, b) => compare(a, b, options))
  for (const version of v) {
    const included = satisfies(version, range, options)
    if (included) {
      prev = version
      if (!first) {
        first = version
      }
    } else {
      if (prev) {
        set.push([first, prev])
      }
      prev = null
      first = null
    }
  }
  if (first) {
    set.push([first, null])
  }

  const ranges = []
  for (const [min, max] of set) {
    if (min === max) {
      ranges.push(min)
    } else if (!max && min === v[0]) {
      ranges.push('*')
    } else if (!max) {
      ranges.push(`>=${min}`)
    } else if (min === v[0]) {
      ranges.push(`<=${max}`)
    } else {
      ranges.push(`${min} - ${max}`)
    }
  }
  const simplified = ranges.join(' || ')
  const original = typeof range.raw === 'string' ? range.raw : String(range)
  return simplified.length < original.length ? simplified : range
}


/***/ }),

/***/ "./node_modules/semver/ranges/subset.js":
/*!**********************************************!*\
  !*** ./node_modules/semver/ranges/subset.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range.js */ "./node_modules/semver/classes/range.js")
const Comparator = __webpack_require__(/*! ../classes/comparator.js */ "./node_modules/semver/classes/comparator.js")
const { ANY } = Comparator
const satisfies = __webpack_require__(/*! ../functions/satisfies.js */ "./node_modules/semver/functions/satisfies.js")
const compare = __webpack_require__(/*! ../functions/compare.js */ "./node_modules/semver/functions/compare.js")

// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true

const subset = (sub, dom, options = {}) => {
  if (sub === dom) {
    return true
  }

  sub = new Range(sub, options)
  dom = new Range(dom, options)
  let sawNonNull = false

  OUTER: for (const simpleSub of sub.set) {
    for (const simpleDom of dom.set) {
      const isSub = simpleSubset(simpleSub, simpleDom, options)
      sawNonNull = sawNonNull || isSub !== null
      if (isSub) {
        continue OUTER
      }
    }
    // the null set is a subset of everything, but null simple ranges in
    // a complex range should be ignored.  so if we saw a non-null range,
    // then we know this isn't a subset, but if EVERY simple range was null,
    // then it is a subset.
    if (sawNonNull) {
      return false
    }
  }
  return true
}

const simpleSubset = (sub, dom, options) => {
  if (sub === dom) {
    return true
  }

  if (sub.length === 1 && sub[0].semver === ANY) {
    if (dom.length === 1 && dom[0].semver === ANY) {
      return true
    } else if (options.includePrerelease) {
      sub = [new Comparator('>=0.0.0-0')]
    } else {
      sub = [new Comparator('>=0.0.0')]
    }
  }

  if (dom.length === 1 && dom[0].semver === ANY) {
    if (options.includePrerelease) {
      return true
    } else {
      dom = [new Comparator('>=0.0.0')]
    }
  }

  const eqSet = new Set()
  let gt, lt
  for (const c of sub) {
    if (c.operator === '>' || c.operator === '>=') {
      gt = higherGT(gt, c, options)
    } else if (c.operator === '<' || c.operator === '<=') {
      lt = lowerLT(lt, c, options)
    } else {
      eqSet.add(c.semver)
    }
  }

  if (eqSet.size > 1) {
    return null
  }

  let gtltComp
  if (gt && lt) {
    gtltComp = compare(gt.semver, lt.semver, options)
    if (gtltComp > 0) {
      return null
    } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
      return null
    }
  }

  // will iterate one or zero times
  for (const eq of eqSet) {
    if (gt && !satisfies(eq, String(gt), options)) {
      return null
    }

    if (lt && !satisfies(eq, String(lt), options)) {
      return null
    }

    for (const c of dom) {
      if (!satisfies(eq, String(c), options)) {
        return false
      }
    }

    return true
  }

  let higher, lower
  let hasDomLT, hasDomGT
  // if the subset has a prerelease, we need a comparator in the superset
  // with the same tuple and a prerelease, or it's not a subset
  let needDomLTPre = lt &&
    !options.includePrerelease &&
    lt.semver.prerelease.length ? lt.semver : false
  let needDomGTPre = gt &&
    !options.includePrerelease &&
    gt.semver.prerelease.length ? gt.semver : false
  // exception: <1.2.3-0 is the same as <1.2.3
  if (needDomLTPre && needDomLTPre.prerelease.length === 1 &&
      lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
    needDomLTPre = false
  }

  for (const c of dom) {
    hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>='
    hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<='
    if (gt) {
      if (needDomGTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomGTPre.major &&
            c.semver.minor === needDomGTPre.minor &&
            c.semver.patch === needDomGTPre.patch) {
          needDomGTPre = false
        }
      }
      if (c.operator === '>' || c.operator === '>=') {
        higher = higherGT(gt, c, options)
        if (higher === c && higher !== gt) {
          return false
        }
      } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
        return false
      }
    }
    if (lt) {
      if (needDomLTPre) {
        if (c.semver.prerelease && c.semver.prerelease.length &&
            c.semver.major === needDomLTPre.major &&
            c.semver.minor === needDomLTPre.minor &&
            c.semver.patch === needDomLTPre.patch) {
          needDomLTPre = false
        }
      }
      if (c.operator === '<' || c.operator === '<=') {
        lower = lowerLT(lt, c, options)
        if (lower === c && lower !== lt) {
          return false
        }
      } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
        return false
      }
    }
    if (!c.operator && (lt || gt) && gtltComp !== 0) {
      return false
    }
  }

  // if there was a < or >, and nothing in the dom, then must be false
  // UNLESS it was limited by another range in the other direction.
  // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
  if (gt && hasDomLT && !lt && gtltComp !== 0) {
    return false
  }

  if (lt && hasDomGT && !gt && gtltComp !== 0) {
    return false
  }

  // we needed a prerelease range in a specific tuple, but didn't get one
  // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
  // because it includes prereleases in the 1.2.3 tuple
  if (needDomGTPre || needDomLTPre) {
    return false
  }

  return true
}

// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp > 0 ? a
    : comp < 0 ? b
    : b.operator === '>' && a.operator === '>=' ? b
    : a
}

// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options) => {
  if (!a) {
    return b
  }
  const comp = compare(a.semver, b.semver, options)
  return comp < 0 ? a
    : comp > 0 ? b
    : b.operator === '<' && a.operator === '<=' ? b
    : a
}

module.exports = subset


/***/ }),

/***/ "./node_modules/semver/ranges/to-comparators.js":
/*!******************************************************!*\
  !*** ./node_modules/semver/ranges/to-comparators.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")

// Mostly just for testing and legacy API reasons
const toComparators = (range, options) =>
  new Range(range, options).set
    .map(comp => comp.map(c => c.value).join(' ').trim().split(' '))

module.exports = toComparators


/***/ }),

/***/ "./node_modules/semver/ranges/valid.js":
/*!*********************************************!*\
  !*** ./node_modules/semver/ranges/valid.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Range = __webpack_require__(/*! ../classes/range */ "./node_modules/semver/classes/range.js")
const validRange = (range, options) => {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}
module.exports = validRange


/***/ }),

/***/ "./node_modules/universalify/index.js":
/*!********************************************!*\
  !*** ./node_modules/universalify/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)
    else {
      return new Promise((resolve, reject) => {
        fn.apply(
          this,
          args.concat([(err, res) => err ? reject(err) : resolve(res)])
        )
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, args)
    else fn.apply(this, args.slice(0, -1)).then(r => cb(null, r), cb)
  }, 'name', { value: fn.name })
}


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/api.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/api.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/thenable.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.ProgressType = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.RAL = void 0;
exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
Object.defineProperty(exports, "RequestType", ({ enumerable: true, get: function () { return messages_1.RequestType; } }));
Object.defineProperty(exports, "RequestType0", ({ enumerable: true, get: function () { return messages_1.RequestType0; } }));
Object.defineProperty(exports, "RequestType1", ({ enumerable: true, get: function () { return messages_1.RequestType1; } }));
Object.defineProperty(exports, "RequestType2", ({ enumerable: true, get: function () { return messages_1.RequestType2; } }));
Object.defineProperty(exports, "RequestType3", ({ enumerable: true, get: function () { return messages_1.RequestType3; } }));
Object.defineProperty(exports, "RequestType4", ({ enumerable: true, get: function () { return messages_1.RequestType4; } }));
Object.defineProperty(exports, "RequestType5", ({ enumerable: true, get: function () { return messages_1.RequestType5; } }));
Object.defineProperty(exports, "RequestType6", ({ enumerable: true, get: function () { return messages_1.RequestType6; } }));
Object.defineProperty(exports, "RequestType7", ({ enumerable: true, get: function () { return messages_1.RequestType7; } }));
Object.defineProperty(exports, "RequestType8", ({ enumerable: true, get: function () { return messages_1.RequestType8; } }));
Object.defineProperty(exports, "RequestType9", ({ enumerable: true, get: function () { return messages_1.RequestType9; } }));
Object.defineProperty(exports, "ResponseError", ({ enumerable: true, get: function () { return messages_1.ResponseError; } }));
Object.defineProperty(exports, "ErrorCodes", ({ enumerable: true, get: function () { return messages_1.ErrorCodes; } }));
Object.defineProperty(exports, "NotificationType", ({ enumerable: true, get: function () { return messages_1.NotificationType; } }));
Object.defineProperty(exports, "NotificationType0", ({ enumerable: true, get: function () { return messages_1.NotificationType0; } }));
Object.defineProperty(exports, "NotificationType1", ({ enumerable: true, get: function () { return messages_1.NotificationType1; } }));
Object.defineProperty(exports, "NotificationType2", ({ enumerable: true, get: function () { return messages_1.NotificationType2; } }));
Object.defineProperty(exports, "NotificationType3", ({ enumerable: true, get: function () { return messages_1.NotificationType3; } }));
Object.defineProperty(exports, "NotificationType4", ({ enumerable: true, get: function () { return messages_1.NotificationType4; } }));
Object.defineProperty(exports, "NotificationType5", ({ enumerable: true, get: function () { return messages_1.NotificationType5; } }));
Object.defineProperty(exports, "NotificationType6", ({ enumerable: true, get: function () { return messages_1.NotificationType6; } }));
Object.defineProperty(exports, "NotificationType7", ({ enumerable: true, get: function () { return messages_1.NotificationType7; } }));
Object.defineProperty(exports, "NotificationType8", ({ enumerable: true, get: function () { return messages_1.NotificationType8; } }));
Object.defineProperty(exports, "NotificationType9", ({ enumerable: true, get: function () { return messages_1.NotificationType9; } }));
Object.defineProperty(exports, "ParameterStructures", ({ enumerable: true, get: function () { return messages_1.ParameterStructures; } }));
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
Object.defineProperty(exports, "LinkedMap", ({ enumerable: true, get: function () { return linkedMap_1.LinkedMap; } }));
Object.defineProperty(exports, "LRUCache", ({ enumerable: true, get: function () { return linkedMap_1.LRUCache; } }));
Object.defineProperty(exports, "Touch", ({ enumerable: true, get: function () { return linkedMap_1.Touch; } }));
const disposable_1 = __webpack_require__(/*! ./disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
Object.defineProperty(exports, "Disposable", ({ enumerable: true, get: function () { return disposable_1.Disposable; } }));
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
Object.defineProperty(exports, "Event", ({ enumerable: true, get: function () { return events_1.Event; } }));
Object.defineProperty(exports, "Emitter", ({ enumerable: true, get: function () { return events_1.Emitter; } }));
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
Object.defineProperty(exports, "CancellationTokenSource", ({ enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } }));
Object.defineProperty(exports, "CancellationToken", ({ enumerable: true, get: function () { return cancellation_1.CancellationToken; } }));
const messageReader_1 = __webpack_require__(/*! ./messageReader */ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js");
Object.defineProperty(exports, "MessageReader", ({ enumerable: true, get: function () { return messageReader_1.MessageReader; } }));
Object.defineProperty(exports, "AbstractMessageReader", ({ enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } }));
Object.defineProperty(exports, "ReadableStreamMessageReader", ({ enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } }));
const messageWriter_1 = __webpack_require__(/*! ./messageWriter */ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js");
Object.defineProperty(exports, "MessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.MessageWriter; } }));
Object.defineProperty(exports, "AbstractMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } }));
Object.defineProperty(exports, "WriteableStreamMessageWriter", ({ enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } }));
const connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-jsonrpc/lib/common/connection.js");
Object.defineProperty(exports, "ConnectionStrategy", ({ enumerable: true, get: function () { return connection_1.ConnectionStrategy; } }));
Object.defineProperty(exports, "ConnectionOptions", ({ enumerable: true, get: function () { return connection_1.ConnectionOptions; } }));
Object.defineProperty(exports, "NullLogger", ({ enumerable: true, get: function () { return connection_1.NullLogger; } }));
Object.defineProperty(exports, "createMessageConnection", ({ enumerable: true, get: function () { return connection_1.createMessageConnection; } }));
Object.defineProperty(exports, "ProgressType", ({ enumerable: true, get: function () { return connection_1.ProgressType; } }));
Object.defineProperty(exports, "Trace", ({ enumerable: true, get: function () { return connection_1.Trace; } }));
Object.defineProperty(exports, "TraceFormat", ({ enumerable: true, get: function () { return connection_1.TraceFormat; } }));
Object.defineProperty(exports, "SetTraceNotification", ({ enumerable: true, get: function () { return connection_1.SetTraceNotification; } }));
Object.defineProperty(exports, "LogTraceNotification", ({ enumerable: true, get: function () { return connection_1.LogTraceNotification; } }));
Object.defineProperty(exports, "ConnectionErrors", ({ enumerable: true, get: function () { return connection_1.ConnectionErrors; } }));
Object.defineProperty(exports, "ConnectionError", ({ enumerable: true, get: function () { return connection_1.ConnectionError; } }));
Object.defineProperty(exports, "CancellationReceiverStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } }));
Object.defineProperty(exports, "CancellationSenderStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } }));
Object.defineProperty(exports, "CancellationStrategy", ({ enumerable: true, get: function () { return connection_1.CancellationStrategy; } }));
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
exports.RAL = ral_1.default;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = ral_1.default().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
//# sourceMappingURL=cancellation.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/connection.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/connection.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.ConnectionOptions = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.Trace = exports.NullLogger = exports.ProgressType = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-jsonrpc/lib/common/messages.js");
const linkedMap_1 = __webpack_require__(/*! ./linkedMap */ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const cancellation_1 = __webpack_require__(/*! ./cancellation */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
var CancelNotification;
(function (CancelNotification) {
    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');
})(CancelNotification || (CancelNotification = {}));
var ProgressNotification;
(function (ProgressNotification) {
    ProgressNotification.type = new messages_1.NotificationType('$/progress');
})(ProgressNotification || (ProgressNotification = {}));
class ProgressType {
    constructor() {
    }
}
exports.ProgressType = ProgressType;
var StarRequestHandler;
(function (StarRequestHandler) {
    function is(value) {
        return Is.func(value);
    }
    StarRequestHandler.is = is;
})(StarRequestHandler || (StarRequestHandler = {}));
exports.NullLogger = Object.freeze({
    error: () => { },
    warn: () => { },
    info: () => { },
    log: () => { }
});
var Trace;
(function (Trace) {
    Trace[Trace["Off"] = 0] = "Off";
    Trace[Trace["Messages"] = 1] = "Messages";
    Trace[Trace["Verbose"] = 2] = "Verbose";
})(Trace = exports.Trace || (exports.Trace = {}));
(function (Trace) {
    function fromString(value) {
        if (!Is.string(value)) {
            return Trace.Off;
        }
        value = value.toLowerCase();
        switch (value) {
            case 'off':
                return Trace.Off;
            case 'messages':
                return Trace.Messages;
            case 'verbose':
                return Trace.Verbose;
            default:
                return Trace.Off;
        }
    }
    Trace.fromString = fromString;
    function toString(value) {
        switch (value) {
            case Trace.Off:
                return 'off';
            case Trace.Messages:
                return 'messages';
            case Trace.Verbose:
                return 'verbose';
            default:
                return 'off';
        }
    }
    Trace.toString = toString;
})(Trace = exports.Trace || (exports.Trace = {}));
var TraceFormat;
(function (TraceFormat) {
    TraceFormat["Text"] = "text";
    TraceFormat["JSON"] = "json";
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
(function (TraceFormat) {
    function fromString(value) {
        if (!Is.string(value)) {
            return TraceFormat.Text;
        }
        value = value.toLowerCase();
        if (value === 'json') {
            return TraceFormat.JSON;
        }
        else {
            return TraceFormat.Text;
        }
    }
    TraceFormat.fromString = fromString;
})(TraceFormat = exports.TraceFormat || (exports.TraceFormat = {}));
var SetTraceNotification;
(function (SetTraceNotification) {
    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');
})(SetTraceNotification = exports.SetTraceNotification || (exports.SetTraceNotification = {}));
var LogTraceNotification;
(function (LogTraceNotification) {
    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');
})(LogTraceNotification = exports.LogTraceNotification || (exports.LogTraceNotification = {}));
var ConnectionErrors;
(function (ConnectionErrors) {
    /**
     * The connection is closed.
     */
    ConnectionErrors[ConnectionErrors["Closed"] = 1] = "Closed";
    /**
     * The connection got disposed.
     */
    ConnectionErrors[ConnectionErrors["Disposed"] = 2] = "Disposed";
    /**
     * The connection is already in listening mode.
     */
    ConnectionErrors[ConnectionErrors["AlreadyListening"] = 3] = "AlreadyListening";
})(ConnectionErrors = exports.ConnectionErrors || (exports.ConnectionErrors = {}));
class ConnectionError extends Error {
    constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
    }
}
exports.ConnectionError = ConnectionError;
var ConnectionStrategy;
(function (ConnectionStrategy) {
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
    }
    ConnectionStrategy.is = is;
})(ConnectionStrategy = exports.ConnectionStrategy || (exports.ConnectionStrategy = {}));
var CancellationReceiverStrategy;
(function (CancellationReceiverStrategy) {
    CancellationReceiverStrategy.Message = Object.freeze({
        createCancellationTokenSource(_) {
            return new cancellation_1.CancellationTokenSource();
        }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
    }
    CancellationReceiverStrategy.is = is;
})(CancellationReceiverStrategy = exports.CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = {}));
var CancellationSenderStrategy;
(function (CancellationSenderStrategy) {
    CancellationSenderStrategy.Message = Object.freeze({
        sendCancellation(conn, id) {
            conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) { }
    });
    function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
    }
    CancellationSenderStrategy.is = is;
})(CancellationSenderStrategy = exports.CancellationSenderStrategy || (exports.CancellationSenderStrategy = {}));
var CancellationStrategy;
(function (CancellationStrategy) {
    CancellationStrategy.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
    });
    function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
    }
    CancellationStrategy.is = is;
})(CancellationStrategy = exports.CancellationStrategy || (exports.CancellationStrategy = {}));
var ConnectionOptions;
(function (ConnectionOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
    }
    ConnectionOptions.is = is;
})(ConnectionOptions = exports.ConnectionOptions || (exports.ConnectionOptions = {}));
var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["New"] = 1] = "New";
    ConnectionState[ConnectionState["Listening"] = 2] = "Listening";
    ConnectionState[ConnectionState["Closed"] = 3] = "Closed";
    ConnectionState[ConnectionState["Disposed"] = 4] = "Disposed";
})(ConnectionState || (ConnectionState = {}));
function createMessageConnection(messageReader, messageWriter, _logger, options) {
    const logger = _logger !== undefined ? _logger : exports.NullLogger;
    let sequenceNumber = 0;
    let notificationSequenceNumber = 0;
    let unknownResponseSequenceNumber = 0;
    const version = '2.0';
    let starRequestHandler = undefined;
    const requestHandlers = Object.create(null);
    let starNotificationHandler = undefined;
    const notificationHandlers = Object.create(null);
    const progressHandlers = new Map();
    let timer;
    let messageQueue = new linkedMap_1.LinkedMap();
    let responsePromises = Object.create(null);
    let knownCanceledRequests = new Set();
    let requestTokens = Object.create(null);
    let trace = Trace.Off;
    let traceFormat = TraceFormat.Text;
    let tracer;
    let state = ConnectionState.New;
    const errorEmitter = new events_1.Emitter();
    const closeEmitter = new events_1.Emitter();
    const unhandledNotificationEmitter = new events_1.Emitter();
    const unhandledProgressEmitter = new events_1.Emitter();
    const disposeEmitter = new events_1.Emitter();
    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;
    function createRequestQueueKey(id) {
        if (id === null) {
            throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return 'req-' + id.toString();
    }
    function createResponseQueueKey(id) {
        if (id === null) {
            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();
        }
        else {
            return 'res-' + id.toString();
        }
    }
    function createNotificationQueueKey() {
        return 'not-' + (++notificationSequenceNumber).toString();
    }
    function addMessageToQueue(queue, message) {
        if (messages_1.isRequestMessage(message)) {
            queue.set(createRequestQueueKey(message.id), message);
        }
        else if (messages_1.isResponseMessage(message)) {
            queue.set(createResponseQueueKey(message.id), message);
        }
        else {
            queue.set(createNotificationQueueKey(), message);
        }
    }
    function cancelUndispatched(_message) {
        return undefined;
    }
    function isListening() {
        return state === ConnectionState.Listening;
    }
    function isClosed() {
        return state === ConnectionState.Closed;
    }
    function isDisposed() {
        return state === ConnectionState.Disposed;
    }
    function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
            state = ConnectionState.Closed;
            closeEmitter.fire(undefined);
        }
        // If the connection is disposed don't sent close events.
    }
    function readErrorHandler(error) {
        errorEmitter.fire([error, undefined, undefined]);
    }
    function writeErrorHandler(data) {
        errorEmitter.fire(data);
    }
    messageReader.onClose(closeHandler);
    messageReader.onError(readErrorHandler);
    messageWriter.onClose(closeHandler);
    messageWriter.onError(writeErrorHandler);
    function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
            return;
        }
        timer = ral_1.default().timer.setImmediate(() => {
            timer = undefined;
            processMessageQueue();
        });
    }
    function processMessageQueue() {
        if (messageQueue.size === 0) {
            return;
        }
        const message = messageQueue.shift();
        try {
            if (messages_1.isRequestMessage(message)) {
                handleRequest(message);
            }
            else if (messages_1.isNotificationMessage(message)) {
                handleNotification(message);
            }
            else if (messages_1.isResponseMessage(message)) {
                handleResponse(message);
            }
            else {
                handleInvalidMessage(message);
            }
        }
        finally {
            triggerMessageQueue();
        }
    }
    const callback = (message) => {
        try {
            // We have received a cancellation message. Check if the message is still in the queue
            // and cancel it if allowed to do so.
            if (messages_1.isNotificationMessage(message) && message.method === CancelNotification.type.method) {
                const cancelId = message.params.id;
                const key = createRequestQueueKey(cancelId);
                const toCancel = messageQueue.get(key);
                if (messages_1.isRequestMessage(toCancel)) {
                    const strategy = options === null || options === void 0 ? void 0 : options.connectionStrategy;
                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
                    if (response && (response.error !== undefined || response.result !== undefined)) {
                        messageQueue.delete(key);
                        response.id = toCancel.id;
                        traceSendingResponse(response, message.method, Date.now());
                        messageWriter.write(response);
                        return;
                    }
                }
                const tokenKey = String(cancelId);
                const cancellationToken = requestTokens[tokenKey];
                // The request is already running. Cancel the token
                if (cancellationToken !== undefined) {
                    cancellationToken.cancel();
                    traceReceivedNotification(message);
                    return;
                }
                else {
                    // Remember the cancel but still queue the message to
                    // clean up state in process message.
                    knownCanceledRequests.add(cancelId);
                }
            }
            addMessageToQueue(messageQueue, message);
        }
        finally {
            triggerMessageQueue();
        }
    };
    function handleRequest(requestMessage) {
        if (isDisposed()) {
            // we return here silently since we fired an event when the
            // connection got disposed.
            return;
        }
        function reply(resultOrError, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id
            };
            if (resultOrError instanceof messages_1.ResponseError) {
                message.error = resultOrError.toJson();
            }
            else {
                message.result = resultOrError === undefined ? null : resultOrError;
            }
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replyError(error, method, startTime) {
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                error: error.toJson()
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        function replySuccess(result, method, startTime) {
            // The JSON RPC defines that a response must either have a result or an error
            // So we can't treat undefined as a valid response result.
            if (result === undefined) {
                result = null;
            }
            const message = {
                jsonrpc: version,
                id: requestMessage.id,
                result: result
            };
            traceSendingResponse(message, method, startTime);
            messageWriter.write(message);
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers[requestMessage.method];
        let type;
        let requestHandler;
        if (element) {
            type = element.type;
            requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
            const tokenKey = String(requestMessage.id);
            const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
                cancellationSource.cancel();
            }
            requestTokens[tokenKey] = cancellationSource;
            try {
                let handlerResult;
                if (requestHandler) {
                    if (requestMessage.params === undefined) {
                        if (type !== undefined && type.numberOfParams !== 0) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(cancellationSource.token);
                    }
                    else if (Array.isArray(requestMessage.params)) {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                            return;
                        }
                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
                    }
                }
                else if (starRequestHandler) {
                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
                }
                const promise = handlerResult;
                if (!handlerResult) {
                    delete requestTokens[tokenKey];
                    replySuccess(handlerResult, requestMessage.method, startTime);
                }
                else if (promise.then) {
                    promise.then((resultOrError) => {
                        delete requestTokens[tokenKey];
                        reply(resultOrError, requestMessage.method, startTime);
                    }, error => {
                        delete requestTokens[tokenKey];
                        if (error instanceof messages_1.ResponseError) {
                            replyError(error, requestMessage.method, startTime);
                        }
                        else if (error && Is.string(error.message)) {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                        }
                        else {
                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                        }
                    });
                }
                else {
                    delete requestTokens[tokenKey];
                    reply(handlerResult, requestMessage.method, startTime);
                }
            }
            catch (error) {
                delete requestTokens[tokenKey];
                if (error instanceof messages_1.ResponseError) {
                    reply(error, requestMessage.method, startTime);
                }
                else if (error && Is.string(error.message)) {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                }
                else {
                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
            }
        }
        else {
            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
    }
    function handleResponse(responseMessage) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        if (responseMessage.id === null) {
            if (responseMessage.error) {
                logger.error(`Received response message without id: Error is: \n${JSON.stringify(responseMessage.error, undefined, 4)}`);
            }
            else {
                logger.error(`Received response message without id. No further error information provided.`);
            }
        }
        else {
            const key = String(responseMessage.id);
            const responsePromise = responsePromises[key];
            traceReceivedResponse(responseMessage, responsePromise);
            if (responsePromise) {
                delete responsePromises[key];
                try {
                    if (responseMessage.error) {
                        const error = responseMessage.error;
                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
                    }
                    else if (responseMessage.result !== undefined) {
                        responsePromise.resolve(responseMessage.result);
                    }
                    else {
                        throw new Error('Should never happen.');
                    }
                }
                catch (error) {
                    if (error.message) {
                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
                    }
                    else {
                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
                    }
                }
            }
        }
    }
    function handleNotification(message) {
        if (isDisposed()) {
            // See handle request.
            return;
        }
        let type = undefined;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            knownCanceledRequests.delete(cancelId);
            traceReceivedNotification(message);
            return;
        }
        else {
            const element = notificationHandlers[message.method];
            if (element) {
                notificationHandler = element.handler;
                type = element.type;
            }
        }
        if (notificationHandler || starNotificationHandler) {
            try {
                traceReceivedNotification(message);
                if (notificationHandler) {
                    if (message.params === undefined) {
                        if (type !== undefined) {
                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                            }
                        }
                        notificationHandler();
                    }
                    else if (Array.isArray(message.params)) {
                        if (type !== undefined) {
                            if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                                logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                            }
                            if (type.numberOfParams !== message.params.length) {
                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${message.params.length} arguments`);
                            }
                        }
                        notificationHandler(...message.params);
                    }
                    else {
                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                        }
                        notificationHandler(message.params);
                    }
                }
                else if (starNotificationHandler) {
                    starNotificationHandler(message.method, message.params);
                }
            }
            catch (error) {
                if (error.message) {
                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
                }
                else {
                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
                }
            }
        }
        else {
            unhandledNotificationEmitter.fire(message);
        }
    }
    function handleInvalidMessage(message) {
        if (!message) {
            logger.error('Received empty message.');
            return;
        }
        logger.error(`Received message which is neither a response nor a notification message:\n${JSON.stringify(message, null, 4)}`);
        // Test whether we find an id to reject the promise
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
            const key = String(responseMessage.id);
            const responseHandler = responsePromises[key];
            if (responseHandler) {
                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));
            }
        }
    }
    function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('send-request', message);
        }
    }
    function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Sending notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('send-notification', message);
        }
    }
    function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        }
        else {
            logLSPMessage('send-response', message);
        }
    }
    function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose && message.params) {
                data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
            }
            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        }
        else {
            logLSPMessage('receive-request', message);
        }
    }
    function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.params) {
                    data = `Params: ${JSON.stringify(message.params, null, 4)}\n\n`;
                }
                else {
                    data = 'No parameters provided.\n\n';
                }
            }
            tracer.log(`Received notification '${message.method}'.`, data);
        }
        else {
            logLSPMessage('receive-notification', message);
        }
    }
    function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        if (traceFormat === TraceFormat.Text) {
            let data = undefined;
            if (trace === Trace.Verbose) {
                if (message.error && message.error.data) {
                    data = `Error data: ${JSON.stringify(message.error.data, null, 4)}\n\n`;
                }
                else {
                    if (message.result) {
                        data = `Result: ${JSON.stringify(message.result, null, 4)}\n\n`;
                    }
                    else if (message.error === undefined) {
                        data = 'No result returned.\n\n';
                    }
                }
            }
            if (responsePromise) {
                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';
                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
            }
            else {
                tracer.log(`Received response ${message.id} without active response promise.`, data);
            }
        }
        else {
            logLSPMessage('receive-response', message);
        }
    }
    function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
            return;
        }
        const lspMessage = {
            isLSPMessage: true,
            type,
            message,
            timestamp: Date.now()
        };
        tracer.log(lspMessage);
    }
    function throwIfClosedOrDisposed() {
        if (isClosed()) {
            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');
        }
        if (isDisposed()) {
            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');
        }
    }
    function throwIfListening() {
        if (isListening()) {
            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');
        }
    }
    function throwIfNotListening() {
        if (!isListening()) {
            throw new Error('Call listen() first.');
        }
    }
    function undefinedToNull(param) {
        if (param === undefined) {
            return null;
        }
        else {
            return param;
        }
    }
    function nullToUndefined(param) {
        if (param === null) {
            return undefined;
        }
        else {
            return param;
        }
    }
    function isNamedParam(param) {
        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';
    }
    function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
            case messages_1.ParameterStructures.auto:
                if (isNamedParam(param)) {
                    return nullToUndefined(param);
                }
                else {
                    return [undefinedToNull(param)];
                }
            case messages_1.ParameterStructures.byName:
                if (!isNamedParam(param)) {
                    throw new Error(`Received parameters by name but param is not an object literal.`);
                }
                return nullToUndefined(param);
            case messages_1.ParameterStructures.byPosition:
                return [undefinedToNull(param)];
            default:
                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
    }
    function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
            case 0:
                result = undefined;
                break;
            case 1:
                result = computeSingleParam(type.parameterStructures, params[0]);
                break;
            default:
                result = [];
                for (let i = 0; i < params.length && i < numberOfParams; i++) {
                    result.push(undefinedToNull(params[i]));
                }
                if (params.length < numberOfParams) {
                    for (let i = params.length; i < numberOfParams; i++) {
                        result.push(null);
                    }
                }
                break;
        }
        return result;
    }
    const connection = {
        sendNotification: (type, ...args) => {
            throwIfClosedOrDisposed();
            let method;
            let messageParams;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
            }
            const notificationMessage = {
                jsonrpc: version,
                method: method,
                params: messageParams
            };
            traceSendingNotification(notificationMessage);
            messageWriter.write(notificationMessage);
        },
        onNotification: (type, handler) => {
            throwIfClosedOrDisposed();
            let method;
            if (Is.func(type)) {
                starNotificationHandler = type;
            }
            else if (handler) {
                if (Is.string(type)) {
                    method = type;
                    notificationHandlers[type] = { type: undefined, handler };
                }
                else {
                    method = type.method;
                    notificationHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method !== undefined) {
                        delete notificationHandlers[method];
                    }
                    else {
                        starNotificationHandler = undefined;
                    }
                }
            };
        },
        onProgress: (_type, token, handler) => {
            if (progressHandlers.has(token)) {
                throw new Error(`Progress handler for token ${token} already registered`);
            }
            progressHandlers.set(token, handler);
            return {
                dispose: () => {
                    progressHandlers.delete(token);
                }
            };
        },
        sendProgress: (_type, token, value) => {
            connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
            throwIfClosedOrDisposed();
            throwIfNotListening();
            let method;
            let messageParams;
            let token = undefined;
            if (Is.string(type)) {
                method = type;
                const first = args[0];
                const last = args[args.length - 1];
                let paramStart = 0;
                let parameterStructures = messages_1.ParameterStructures.auto;
                if (messages_1.ParameterStructures.is(first)) {
                    paramStart = 1;
                    parameterStructures = first;
                }
                let paramEnd = args.length;
                if (cancellation_1.CancellationToken.is(last)) {
                    paramEnd = paramEnd - 1;
                    token = last;
                }
                const numberOfParams = paramEnd - paramStart;
                switch (numberOfParams) {
                    case 0:
                        messageParams = undefined;
                        break;
                    case 1:
                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                        break;
                    default:
                        if (parameterStructures === messages_1.ParameterStructures.byName) {
                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                        }
                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));
                        break;
                }
            }
            else {
                const params = args;
                method = type.method;
                messageParams = computeMessageParams(type, params);
                const numberOfParams = type.numberOfParams;
                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;
            }
            const id = sequenceNumber++;
            let disposable;
            if (token) {
                disposable = token.onCancellationRequested(() => {
                    cancellationStrategy.sender.sendCancellation(connection, id);
                });
            }
            const result = new Promise((resolve, reject) => {
                const requestMessage = {
                    jsonrpc: version,
                    id: id,
                    method: method,
                    params: messageParams
                };
                const resolveWithCleanup = (r) => {
                    resolve(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                const rejectWithCleanup = (r) => {
                    reject(r);
                    cancellationStrategy.sender.cleanup(id);
                    disposable === null || disposable === void 0 ? void 0 : disposable.dispose();
                };
                let responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
                traceSendingRequest(requestMessage);
                try {
                    messageWriter.write(requestMessage);
                }
                catch (e) {
                    // Writing the message failed. So we need to reject the promise.
                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : 'Unknown reason'));
                    responsePromise = null;
                }
                if (responsePromise) {
                    responsePromises[String(id)] = responsePromise;
                }
            });
            return result;
        },
        onRequest: (type, handler) => {
            throwIfClosedOrDisposed();
            let method = null;
            if (StarRequestHandler.is(type)) {
                method = undefined;
                starRequestHandler = type;
            }
            else if (Is.string(type)) {
                method = null;
                if (handler !== undefined) {
                    method = type;
                    requestHandlers[type] = { handler: handler, type: undefined };
                }
            }
            else {
                if (handler !== undefined) {
                    method = type.method;
                    requestHandlers[type.method] = { type, handler };
                }
            }
            return {
                dispose: () => {
                    if (method === null) {
                        return;
                    }
                    if (method !== undefined) {
                        delete requestHandlers[method];
                    }
                    else {
                        starRequestHandler = undefined;
                    }
                }
            };
        },
        trace: (_value, _tracer, sendNotificationOrTraceOptions) => {
            let _sendNotification = false;
            let _traceFormat = TraceFormat.Text;
            if (sendNotificationOrTraceOptions !== undefined) {
                if (Is.boolean(sendNotificationOrTraceOptions)) {
                    _sendNotification = sendNotificationOrTraceOptions;
                }
                else {
                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
                }
            }
            trace = _value;
            traceFormat = _traceFormat;
            if (trace === Trace.Off) {
                tracer = undefined;
            }
            else {
                tracer = _tracer;
            }
            if (_sendNotification && !isClosed() && !isDisposed()) {
                connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
            }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
            messageWriter.end();
        },
        dispose: () => {
            if (isDisposed()) {
                return;
            }
            state = ConnectionState.Disposed;
            disposeEmitter.fire(undefined);
            const error = new Error('Connection got disposed.');
            Object.keys(responsePromises).forEach((key) => {
                responsePromises[key].reject(error);
            });
            responsePromises = Object.create(null);
            requestTokens = Object.create(null);
            knownCanceledRequests = new Set();
            messageQueue = new linkedMap_1.LinkedMap();
            // Test for backwards compatibility
            if (Is.func(messageWriter.dispose)) {
                messageWriter.dispose();
            }
            if (Is.func(messageReader.dispose)) {
                messageReader.dispose();
            }
        },
        listen: () => {
            throwIfClosedOrDisposed();
            throwIfListening();
            state = ConnectionState.Listening;
            messageReader.listen(callback);
        },
        inspect: () => {
            // eslint-disable-next-line no-console
            ral_1.default().console.log('inspect');
        }
    };
    connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
            return;
        }
        tracer.log(params.message, trace === Trace.Verbose ? params.verbose : undefined);
    });
    connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
            handler(params.value);
        }
        else {
            unhandledProgressEmitter.fire(params);
        }
    });
    return connection;
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/disposable.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/disposable.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Disposable = void 0;
var Disposable;
(function (Disposable) {
    function create(func) {
        return {
            dispose: func
        };
    }
    Disposable.create = create;
})(Disposable = exports.Disposable || (exports.Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event = exports.Event || (exports.Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                ral_1.default().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/is.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/linkedMap.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/linkedMap.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _a;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LRUCache = exports.LinkedMap = exports.Touch = void 0;
var Touch;
(function (Touch) {
    Touch.None = 0;
    Touch.First = 1;
    Touch.AsOld = Touch.First;
    Touch.Last = 2;
    Touch.AsNew = Touch.Last;
})(Touch = exports.Touch || (exports.Touch = {}));
class LinkedMap {
    constructor() {
        this[_a] = 'LinkedMap';
        this._map = new Map();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state = 0;
    }
    clear() {
        this._map.clear();
        this._head = undefined;
        this._tail = undefined;
        this._size = 0;
        this._state++;
    }
    isEmpty() {
        return !this._head && !this._tail;
    }
    get size() {
        return this._size;
    }
    get first() {
        var _b;
        return (_b = this._head) === null || _b === void 0 ? void 0 : _b.value;
    }
    get last() {
        var _b;
        return (_b = this._tail) === null || _b === void 0 ? void 0 : _b.value;
    }
    has(key) {
        return this._map.has(key);
    }
    get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        if (touch !== Touch.None) {
            this.touch(item, touch);
        }
        return item.value;
    }
    set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
            item.value = value;
            if (touch !== Touch.None) {
                this.touch(item, touch);
            }
        }
        else {
            item = { key, value, next: undefined, previous: undefined };
            switch (touch) {
                case Touch.None:
                    this.addItemLast(item);
                    break;
                case Touch.First:
                    this.addItemFirst(item);
                    break;
                case Touch.Last:
                    this.addItemLast(item);
                    break;
                default:
                    this.addItemLast(item);
                    break;
            }
            this._map.set(key, item);
            this._size++;
        }
        return this;
    }
    delete(key) {
        return !!this.remove(key);
    }
    remove(key) {
        const item = this._map.get(key);
        if (!item) {
            return undefined;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    shift() {
        if (!this._head && !this._tail) {
            return undefined;
        }
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
    }
    forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
            if (thisArg) {
                callbackfn.bind(thisArg)(current.value, current.key, this);
            }
            else {
                callbackfn(current.value, current.key, this);
            }
            if (this._state !== state) {
                throw new Error(`LinkedMap got modified during iteration.`);
            }
            current = current.next;
        }
    }
    keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.key, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: current.value, done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
            [Symbol.iterator]: () => {
                return iterator;
            },
            next: () => {
                if (this._state !== state) {
                    throw new Error(`LinkedMap got modified during iteration.`);
                }
                if (current) {
                    const result = { value: [current.key, current.value], done: false };
                    current = current.next;
                    return result;
                }
                else {
                    return { value: undefined, done: true };
                }
            }
        };
        return iterator;
    }
    [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
    }
    trimOld(newSize) {
        if (newSize >= this.size) {
            return;
        }
        if (newSize === 0) {
            this.clear();
            return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
            this._map.delete(current.key);
            current = current.next;
            currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
            current.previous = undefined;
        }
        this._state++;
    }
    addItemFirst(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._tail = item;
        }
        else if (!this._head) {
            throw new Error('Invalid list');
        }
        else {
            item.next = this._head;
            this._head.previous = item;
        }
        this._head = item;
        this._state++;
    }
    addItemLast(item) {
        // First time Insert
        if (!this._head && !this._tail) {
            this._head = item;
        }
        else if (!this._tail) {
            throw new Error('Invalid list');
        }
        else {
            item.previous = this._tail;
            this._tail.next = item;
        }
        this._tail = item;
        this._state++;
    }
    removeItem(item) {
        if (item === this._head && item === this._tail) {
            this._head = undefined;
            this._tail = undefined;
        }
        else if (item === this._head) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.next) {
                throw new Error('Invalid list');
            }
            item.next.previous = undefined;
            this._head = item.next;
        }
        else if (item === this._tail) {
            // This can only happened if size === 1 which is handle
            // by the case above.
            if (!item.previous) {
                throw new Error('Invalid list');
            }
            item.previous.next = undefined;
            this._tail = item.previous;
        }
        else {
            const next = item.next;
            const previous = item.previous;
            if (!next || !previous) {
                throw new Error('Invalid list');
            }
            next.previous = previous;
            previous.next = next;
        }
        item.next = undefined;
        item.previous = undefined;
        this._state++;
    }
    touch(item, touch) {
        if (!this._head || !this._tail) {
            throw new Error('Invalid list');
        }
        if ((touch !== Touch.First && touch !== Touch.Last)) {
            return;
        }
        if (touch === Touch.First) {
            if (item === this._head) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item
            if (item === this._tail) {
                // previous must be defined since item was not head but is tail
                // So there are more than on item in the map
                previous.next = undefined;
                this._tail = previous;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            // Insert the node at head
            item.previous = undefined;
            item.next = this._head;
            this._head.previous = item;
            this._head = item;
            this._state++;
        }
        else if (touch === Touch.Last) {
            if (item === this._tail) {
                return;
            }
            const next = item.next;
            const previous = item.previous;
            // Unlink the item.
            if (item === this._head) {
                // next must be defined since item was not tail but is head
                // So there are more than on item in the map
                next.previous = undefined;
                this._head = next;
            }
            else {
                // Both next and previous are not undefined since item was neither head nor tail.
                next.previous = previous;
                previous.next = next;
            }
            item.next = undefined;
            item.previous = this._tail;
            this._tail.next = item;
            this._tail = item;
            this._state++;
        }
    }
    toJSON() {
        const data = [];
        this.forEach((value, key) => {
            data.push([key, value]);
        });
        return data;
    }
    fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
            this.set(key, value);
        }
    }
}
exports.LinkedMap = LinkedMap;
class LRUCache extends LinkedMap {
    constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
    }
    get limit() {
        return this._limit;
    }
    set limit(limit) {
        this._limit = limit;
        this.checkTrim();
    }
    get ratio() {
        return this._ratio;
    }
    set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
    }
    get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
    }
    peek(key) {
        return super.get(key, Touch.None);
    }
    set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
    }
    checkTrim() {
        if (this.size > this._limit) {
            this.trimOld(Math.round(this._limit * this._ratio));
        }
    }
}
exports.LRUCache = LRUCache;
//# sourceMappingURL=linkedMap.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMessageBuffer = void 0;
const CR = 13;
const LF = 10;
const CRLF = '\r\n';
class AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
    }
    get encoding() {
        return this._encoding;
    }
    append(chunk) {
        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
    }
    tryReadHeaders() {
        if (this._chunks.length === 0) {
            return undefined;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row: while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column: while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                    case CR:
                        switch (state) {
                            case 0:
                                state = 1;
                                break;
                            case 2:
                                state = 3;
                                break;
                            default:
                                state = 0;
                        }
                        break;
                    case LF:
                        switch (state) {
                            case 1:
                                state = 2;
                                break;
                            case 3:
                                state = 4;
                                offset++;
                                break row;
                            default:
                                state = 0;
                        }
                        break;
                    default:
                        state = 0;
                }
                offset++;
            }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
        }
        if (state !== 4) {
            return undefined;
        }
        // The buffer contains the two CRLF at the end. So we will
        // have two empty lines after the split at the end as well.
        const buffer = this._read(chunkBytesRead + offset);
        const result = new Map();
        const headers = this.toString(buffer, 'ascii').split(CRLF);
        if (headers.length < 2) {
            return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
            const header = headers[i];
            const index = header.indexOf(':');
            if (index === -1) {
                throw new Error('Message header must separate key and value using :');
            }
            const key = header.substr(0, index);
            const value = header.substr(index + 1).trim();
            result.set(key, value);
        }
        return result;
    }
    tryReadBody(length) {
        if (this._totalLength < length) {
            return undefined;
        }
        return this._read(length);
    }
    get numberOfBytes() {
        return this._totalLength;
    }
    _read(byteCount) {
        if (byteCount === 0) {
            return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
            throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
            // super fast path, precisely first chunk must be returned
            const chunk = this._chunks[0];
            this._chunks.shift();
            this._totalLength -= byteCount;
            return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
            // fast path, the reading is entirely within the first chunk
            const chunk = this._chunks[0];
            const result = this.asNative(chunk, byteCount);
            this._chunks[0] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            return result;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
            const chunk = this._chunks[chunkIndex];
            if (chunk.byteLength > byteCount) {
                // this chunk will survive
                const chunkPart = chunk.slice(0, byteCount);
                result.set(chunkPart, resultOffset);
                resultOffset += byteCount;
                this._chunks[chunkIndex] = chunk.slice(byteCount);
                this._totalLength -= byteCount;
                byteCount -= byteCount;
            }
            else {
                // this chunk will be entirely read
                result.set(chunk, resultOffset);
                resultOffset += chunk.byteLength;
                this._chunks.shift();
                this._totalLength -= chunk.byteLength;
                byteCount -= chunk.byteLength;
            }
        }
        return result;
    }
}
exports.AbstractMessageBuffer = AbstractMessageBuffer;
//# sourceMappingURL=messageBuffer.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageReader.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageReader.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var MessageReader;
(function (MessageReader) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&
            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
    }
    MessageReader.is = is;
})(MessageReader = exports.MessageReader || (exports.MessageReader = {}));
class AbstractMessageReader {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error) {
        this.errorEmitter.fire(this.asError(error));
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    get onPartialMessage() {
        return this.partialMessageEmitter.event;
    }
    firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageReader = AbstractMessageReader;
var ResolvedMessageReaderOptions;
(function (ResolvedMessageReaderOptions) {
    function fromOptions(options) {
        var _a;
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = new Map();
        if (options === undefined || typeof options === 'string') {
            charset = options !== null && options !== void 0 ? options : 'utf-8';
        }
        else {
            charset = (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8';
            if (options.contentDecoder !== undefined) {
                contentDecoder = options.contentDecoder;
                contentDecoders.set(contentDecoder.name, contentDecoder);
            }
            if (options.contentDecoders !== undefined) {
                for (const decoder of options.contentDecoders) {
                    contentDecoders.set(decoder.name, decoder);
                }
            }
            if (options.contentTypeDecoder !== undefined) {
                contentTypeDecoder = options.contentTypeDecoder;
                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
            }
            if (options.contentTypeDecoders !== undefined) {
                for (const decoder of options.contentTypeDecoders) {
                    contentTypeDecoders.set(decoder.name, decoder);
                }
            }
        }
        if (contentTypeDecoder === undefined) {
            contentTypeDecoder = ral_1.default().applicationJson.decoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
    }
    ResolvedMessageReaderOptions.fromOptions = fromOptions;
})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
class ReadableStreamMessageReader extends AbstractMessageReader {
    constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = ral_1.default().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 10000;
        this.nextMessageLength = -1;
        this.messageToken = 0;
    }
    set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
    }
    get partialMessageTimeout() {
        return this._partialMessageTimeout;
    }
    listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = undefined;
        this.callback = callback;
        const result = this.readable.onData((data) => {
            this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
    }
    onData(data) {
        this.buffer.append(data);
        while (true) {
            if (this.nextMessageLength === -1) {
                const headers = this.buffer.tryReadHeaders();
                if (!headers) {
                    return;
                }
                const contentLength = headers.get('Content-Length');
                if (!contentLength) {
                    throw new Error('Header must provide a Content-Length property.');
                }
                const length = parseInt(contentLength);
                if (isNaN(length)) {
                    throw new Error('Content-Length value must be a number.');
                }
                this.nextMessageLength = length;
            }
            const body = this.buffer.tryReadBody(this.nextMessageLength);
            if (body === undefined) {
                /** We haven't received the full message yet. */
                this.setPartialMessageTimer();
                return;
            }
            this.clearPartialMessageTimer();
            this.nextMessageLength = -1;
            let p;
            if (this.options.contentDecoder !== undefined) {
                p = this.options.contentDecoder.decode(body);
            }
            else {
                p = Promise.resolve(body);
            }
            p.then((value) => {
                this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
                    this.callback(msg);
                }, (error) => {
                    this.fireError(error);
                });
            }, (error) => {
                this.fireError(error);
            });
        }
    }
    clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
            this.partialMessageTimer.dispose();
            this.partialMessageTimer = undefined;
        }
    }
    setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
            return;
        }
        this.partialMessageTimer = ral_1.default().timer.setTimeout((token, timeout) => {
            this.partialMessageTimer = undefined;
            if (token === this.messageToken) {
                this.firePartialMessage({ messageToken: token, waitingTime: timeout });
                this.setPartialMessageTimer();
            }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
    }
}
exports.ReadableStreamMessageReader = ReadableStreamMessageReader;
//# sourceMappingURL=messageReader.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messageWriter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messageWriter.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const semaphore_1 = __webpack_require__(/*! ./semaphore */ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
const ContentLength = 'Content-Length: ';
const CRLF = '\r\n';
var MessageWriter;
(function (MessageWriter) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&
            Is.func(candidate.onError) && Is.func(candidate.write);
    }
    MessageWriter.is = is;
})(MessageWriter = exports.MessageWriter || (exports.MessageWriter = {}));
class AbstractMessageWriter {
    constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
    }
    dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
    }
    get onError() {
        return this.errorEmitter.event;
    }
    fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
    }
    get onClose() {
        return this.closeEmitter.event;
    }
    fireClose() {
        this.closeEmitter.fire(undefined);
    }
    asError(error) {
        if (error instanceof Error) {
            return error;
        }
        else {
            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);
        }
    }
}
exports.AbstractMessageWriter = AbstractMessageWriter;
var ResolvedMessageWriterOptions;
(function (ResolvedMessageWriterOptions) {
    function fromOptions(options) {
        var _a, _b;
        if (options === undefined || typeof options === 'string') {
            return { charset: options !== null && options !== void 0 ? options : 'utf-8', contentTypeEncoder: ral_1.default().applicationJson.encoder };
        }
        else {
            return { charset: (_a = options.charset) !== null && _a !== void 0 ? _a : 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: (_b = options.contentTypeEncoder) !== null && _b !== void 0 ? _b : ral_1.default().applicationJson.encoder };
        }
    }
    ResolvedMessageWriterOptions.fromOptions = fromOptions;
})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
class WriteableStreamMessageWriter extends AbstractMessageWriter {
    constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
    }
    async write(msg) {
        return this.writeSemaphore.lock(async () => {
            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
                if (this.options.contentEncoder !== undefined) {
                    return this.options.contentEncoder.encode(buffer);
                }
                else {
                    return buffer;
                }
            });
            return payload.then((buffer) => {
                const headers = [];
                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
                headers.push(CRLF);
                return this.doWrite(msg, headers, buffer);
            }, (error) => {
                this.fireError(error);
                throw error;
            });
        });
    }
    async doWrite(msg, headers, data) {
        try {
            await this.writable.write(headers.join(''), 'ascii');
            return this.writable.write(data);
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
        this.writable.end();
    }
}
exports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
//# sourceMappingURL=messageWriter.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/messages.js":
/*!************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/messages.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isResponseMessage = exports.isNotificationMessage = exports.isRequestMessage = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;
const is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
/**
 * Predefined error codes.
 */
var ErrorCodes;
(function (ErrorCodes) {
    // Defined by JSON RPC
    ErrorCodes.ParseError = -32700;
    ErrorCodes.InvalidRequest = -32600;
    ErrorCodes.MethodNotFound = -32601;
    ErrorCodes.InvalidParams = -32602;
    ErrorCodes.InternalError = -32603;
    /**
     * This is the start range of JSON RPC reserved error codes.
     * It doesn't denote a real error code. No application error codes should
     * be defined between the start and end range. For backwards
     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`
     * are left in the range.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;
    /** @deprecated use  jsonrpcReservedErrorRangeStart */
    ErrorCodes.serverErrorStart = ErrorCodes.jsonrpcReservedErrorRangeStart;
    ErrorCodes.MessageWriteError = -32099;
    ErrorCodes.MessageReadError = -32098;
    /**
     * Error code indicating that a server received a notification or
     * request before the server has received the `initialize` request.
     */
    ErrorCodes.ServerNotInitialized = -32002;
    ErrorCodes.UnknownErrorCode = -32001;
    /**
     * This is the end range of JSON RPC reserved error codes.
     * It doesn't denote a real error code.
     *
     * @since 3.16.0
    */
    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;
    /** @deprecated use  jsonrpcReservedErrorRangeEnd */
    ErrorCodes.serverErrorEnd = ErrorCodes.jsonrpcReservedErrorRangeEnd;
})(ErrorCodes = exports.ErrorCodes || (exports.ErrorCodes = {}));
/**
 * An error object return in a response in case a request
 * has failed.
 */
class ResponseError extends Error {
    constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
    }
    toJson() {
        const result = {
            code: this.code,
            message: this.message
        };
        if (this.data !== undefined) {
            result.data = this.data;
        }
        return result;
    }
}
exports.ResponseError = ResponseError;
class ParameterStructures {
    constructor(kind) {
        this.kind = kind;
    }
    static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
    }
    toString() {
        return this.kind;
    }
}
exports.ParameterStructures = ParameterStructures;
/**
 * The parameter structure is automatically inferred on the number of parameters
 * and the parameter type in case of a single param.
 */
ParameterStructures.auto = new ParameterStructures('auto');
/**
 * Forces `byPosition` parameter structure. This is useful if you have a single
 * parameter which has a literal type.
 */
ParameterStructures.byPosition = new ParameterStructures('byPosition');
/**
 * Forces `byName` parameter structure. This is only useful when having a single
 * parameter. The library will report errors if used with a different number of
 * parameters.
 */
ParameterStructures.byName = new ParameterStructures('byName');
/**
 * An abstract implementation of a MessageType.
 */
class AbstractMessageSignature {
    constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
    }
    get parameterStructures() {
        return ParameterStructures.auto;
    }
}
exports.AbstractMessageSignature = AbstractMessageSignature;
/**
 * Classes to type request response pairs
 */
class RequestType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.RequestType0 = RequestType0;
class RequestType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType = RequestType;
class RequestType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.RequestType1 = RequestType1;
class RequestType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.RequestType2 = RequestType2;
class RequestType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.RequestType3 = RequestType3;
class RequestType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.RequestType4 = RequestType4;
class RequestType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.RequestType5 = RequestType5;
class RequestType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.RequestType6 = RequestType6;
class RequestType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.RequestType7 = RequestType7;
class RequestType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.RequestType8 = RequestType8;
class RequestType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.RequestType9 = RequestType9;
class NotificationType extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType = NotificationType;
class NotificationType0 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 0);
    }
}
exports.NotificationType0 = NotificationType0;
class NotificationType1 extends AbstractMessageSignature {
    constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
    }
    get parameterStructures() {
        return this._parameterStructures;
    }
}
exports.NotificationType1 = NotificationType1;
class NotificationType2 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 2);
    }
}
exports.NotificationType2 = NotificationType2;
class NotificationType3 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 3);
    }
}
exports.NotificationType3 = NotificationType3;
class NotificationType4 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 4);
    }
}
exports.NotificationType4 = NotificationType4;
class NotificationType5 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 5);
    }
}
exports.NotificationType5 = NotificationType5;
class NotificationType6 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 6);
    }
}
exports.NotificationType6 = NotificationType6;
class NotificationType7 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 7);
    }
}
exports.NotificationType7 = NotificationType7;
class NotificationType8 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 8);
    }
}
exports.NotificationType8 = NotificationType8;
class NotificationType9 extends AbstractMessageSignature {
    constructor(method) {
        super(method, 9);
    }
}
exports.NotificationType9 = NotificationType9;
/**
 * Tests if the given message is a request message
 */
function isRequestMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
}
exports.isRequestMessage = isRequestMessage;
/**
 * Tests if the given message is a notification message
 */
function isNotificationMessage(message) {
    const candidate = message;
    return candidate && is.string(candidate.method) && message.id === void 0;
}
exports.isNotificationMessage = isNotificationMessage;
/**
 * Tests if the given message is a response message
 */
function isResponseMessage(message) {
    const candidate = message;
    return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
}
exports.isResponseMessage = isResponseMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;
//# sourceMappingURL=ral.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/semaphore.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/semaphore.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Semaphore = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
class Semaphore {
    constructor(capacity = 1) {
        if (capacity <= 0) {
            throw new Error('Capacity must be greater than 0');
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
    }
    lock(thunk) {
        return new Promise((resolve, reject) => {
            this._waiting.push({ thunk, resolve, reject });
            this.runNext();
        });
    }
    get active() {
        return this._active;
    }
    runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        ral_1.default().timer.setImmediate(() => this.doRunNext());
    }
    doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
            return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
            throw new Error(`To many thunks active`);
        }
        try {
            const result = next.thunk();
            if (result instanceof Promise) {
                result.then((value) => {
                    this._active--;
                    next.resolve(value);
                    this.runNext();
                }, (err) => {
                    this._active--;
                    next.reject(err);
                    this.runNext();
                });
            }
            else {
                this._active--;
                next.resolve(result);
                this.runNext();
            }
        }
        catch (err) {
            this._active--;
            next.reject(err);
            this.runNext();
        }
    }
}
exports.Semaphore = Semaphore;
//# sourceMappingURL=semaphore.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/main.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/main.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */
const ril_1 = __webpack_require__(/*! ./ril */ "./node_modules/vscode-jsonrpc/lib/node/ril.js");
// Install the node runtime abstract.
ril_1.default.install();
const api_1 = __webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js");
const path = __webpack_require__(/*! path */ "path");
const os = __webpack_require__(/*! os */ "os");
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const net_1 = __webpack_require__(/*! net */ "net");
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-jsonrpc/lib/common/api.js"), exports);
class IPCMessageReader extends api_1.AbstractMessageReader {
    constructor(process) {
        super();
        this.process = process;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose());
    }
    listen(callback) {
        this.process.on('message', callback);
        return api_1.Disposable.create(() => this.process.off('message', callback));
    }
}
exports.IPCMessageReader = IPCMessageReader;
class IPCMessageWriter extends api_1.AbstractMessageWriter {
    constructor(process) {
        super();
        this.process = process;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on('error', (error) => this.fireError(error));
        eventEmitter.on('close', () => this.fireClose);
    }
    write(msg) {
        try {
            if (typeof this.process.send === 'function') {
                this.process.send(msg, undefined, undefined, (error) => {
                    if (error) {
                        this.errorCount++;
                        this.handleError(error, msg);
                    }
                    else {
                        this.errorCount = 0;
                    }
                });
            }
            return Promise.resolve();
        }
        catch (error) {
            this.handleError(error, msg);
            return Promise.reject(error);
        }
    }
    handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
    }
    end() {
    }
}
exports.IPCMessageWriter = IPCMessageWriter;
class SocketMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(socket, encoding = 'utf-8') {
        super(ril_1.default().stream.asReadableStream(socket), encoding);
    }
}
exports.SocketMessageReader = SocketMessageReader;
class SocketMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(socket, options) {
        super(ril_1.default().stream.asWritableStream(socket), options);
        this.socket = socket;
    }
    dispose() {
        super.dispose();
        this.socket.destroy();
    }
}
exports.SocketMessageWriter = SocketMessageWriter;
class StreamMessageReader extends api_1.ReadableStreamMessageReader {
    constructor(readble, encoding) {
        super(ril_1.default().stream.asReadableStream(readble), encoding);
    }
}
exports.StreamMessageReader = StreamMessageReader;
class StreamMessageWriter extends api_1.WriteableStreamMessageWriter {
    constructor(writable, options) {
        super(ril_1.default().stream.asWritableStream(writable), options);
    }
}
exports.StreamMessageWriter = StreamMessageWriter;
const XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];
const safeIpcPathLengths = new Map([
    ['linux', 107],
    ['darwin', 103]
]);
function generateRandomPipeName() {
    const randomSuffix = crypto_1.randomBytes(21).toString('hex');
    if (process.platform === 'win32') {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
    }
    let result;
    if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
    }
    else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
    }
    const limit = safeIpcPathLengths.get(process.platform);
    if (limit !== undefined && result.length >= limit) {
        ril_1.default().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
    }
    return result;
}
exports.generateRandomPipeName = generateRandomPipeName;
function createClientPipeTransport(pipeName, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        let server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(pipeName, () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientPipeTransport = createClientPipeTransport;
function createServerPipeTransport(pipeName, encoding = 'utf-8') {
    const socket = net_1.createConnection(pipeName);
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerPipeTransport = createServerPipeTransport;
function createClientSocketTransport(port, encoding = 'utf-8') {
    let connectResolve;
    const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
    });
    return new Promise((resolve, reject) => {
        const server = net_1.createServer((socket) => {
            server.close();
            connectResolve([
                new SocketMessageReader(socket, encoding),
                new SocketMessageWriter(socket, encoding)
            ]);
        });
        server.on('error', reject);
        server.listen(port, '127.0.0.1', () => {
            server.removeListener('error', reject);
            resolve({
                onConnected: () => { return connected; }
            });
        });
    });
}
exports.createClientSocketTransport = createClientSocketTransport;
function createServerSocketTransport(port, encoding = 'utf-8') {
    const socket = net_1.createConnection(port, '127.0.0.1');
    return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
    ];
}
exports.createServerSocketTransport = createServerSocketTransport;
function isReadableStream(value) {
    const candidate = value;
    return candidate.read !== undefined && candidate.addListener !== undefined;
}
function isWritableStream(value) {
    const candidate = value;
    return candidate.write !== undefined && candidate.addListener !== undefined;
}
function createMessageConnection(input, output, logger, options) {
    if (!logger) {
        logger = api_1.NullLogger;
    }
    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
    if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return api_1.createMessageConnection(reader, writer, logger, options);
}
exports.createMessageConnection = createMessageConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/node/ril.js":
/*!*****************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/node/ril.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const ral_1 = __webpack_require__(/*! ../common/ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const util_1 = __webpack_require__(/*! util */ "util");
const disposable_1 = __webpack_require__(/*! ../common/disposable */ "./node_modules/vscode-jsonrpc/lib/common/disposable.js");
const messageBuffer_1 = __webpack_require__(/*! ../common/messageBuffer */ "./node_modules/vscode-jsonrpc/lib/common/messageBuffer.js");
class MessageBuffer extends messageBuffer_1.AbstractMessageBuffer {
    constructor(encoding = 'utf-8') {
        super(encoding);
    }
    emptyBuffer() {
        return MessageBuffer.emptyBuffer;
    }
    fromString(value, encoding) {
        return Buffer.from(value, encoding);
    }
    toString(value, encoding) {
        if (value instanceof Buffer) {
            return value.toString(encoding);
        }
        else {
            return new util_1.TextDecoder(encoding).decode(value);
        }
    }
    asNative(buffer, length) {
        if (length === undefined) {
            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        }
        else {
            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
    }
    allocNative(length) {
        return Buffer.allocUnsafe(length);
    }
}
MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
class ReadableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    onData(listener) {
        this.stream.on('data', listener);
        return disposable_1.Disposable.create(() => this.stream.off('data', listener));
    }
}
class WritableStreamWrapper {
    constructor(stream) {
        this.stream = stream;
    }
    onClose(listener) {
        this.stream.on('close', listener);
        return disposable_1.Disposable.create(() => this.stream.off('close', listener));
    }
    onError(listener) {
        this.stream.on('error', listener);
        return disposable_1.Disposable.create(() => this.stream.off('error', listener));
    }
    onEnd(listener) {
        this.stream.on('end', listener);
        return disposable_1.Disposable.create(() => this.stream.off('end', listener));
    }
    write(data, encoding) {
        return new Promise((resolve, reject) => {
            const callback = (error) => {
                if (error === undefined || error === null) {
                    resolve();
                }
                else {
                    reject(error);
                }
            };
            if (typeof data === 'string') {
                this.stream.write(data, encoding, callback);
            }
            else {
                this.stream.write(data, callback);
            }
        });
    }
    end() {
        this.stream.end();
    }
}
const _ril = Object.freeze({
    messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
    }),
    applicationJson: Object.freeze({
        encoder: Object.freeze({
            name: 'application/json',
            encode: (msg, options) => {
                try {
                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        }),
        decoder: Object.freeze({
            name: 'application/json',
            decode: (buffer, options) => {
                try {
                    if (buffer instanceof Buffer) {
                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
                    }
                    else {
                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
                    }
                }
                catch (err) {
                    return Promise.reject(err);
                }
            }
        })
    }),
    stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
    }),
    console: console,
    timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
            const handle = setTimeout(callback, ms, ...args);
            return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
            const handle = setImmediate(callback, ...args);
            return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
            const handle = setInterval(callback, ms, ...args);
            return { dispose: () => clearInterval(handle) };
        }
    })
});
function RIL() {
    return _ril;
}
(function (RIL) {
    function install() {
        ral_1.default.install(_ril);
    }
    RIL.install = install;
})(RIL || (RIL = {}));
exports["default"] = RIL;
//# sourceMappingURL=ril.js.map

/***/ }),

/***/ "./node_modules/vscode-jsonrpc/node.js":
/*!*********************************************!*\
  !*** ./node_modules/vscode-jsonrpc/node.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-jsonrpc/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/api.js":
/*!**************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/api.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js"), exports);
__exportStar(__webpack_require__(/*! ./commonClient */ "./node_modules/vscode-languageclient/lib/common/commonClient.js"), exports);
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/callHierarchy.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/callHierarchy.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class CallHierarchyProvider {
    constructor(client) {
        this.client = client;
        this.middleware = client.clientOptions.middleware;
    }
    prepareCallHierarchy(document, position, token) {
        const client = this.client;
        const middleware = this.middleware;
        const prepareCallHierarchy = (document, position, token) => {
            const params = client.code2ProtocolConverter.asTextDocumentPositionParams(document, position);
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyItems(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, token, error, null);
            });
        };
        return middleware.prepareCallHierarchy
            ? middleware.prepareCallHierarchy(document, position, token, prepareCallHierarchy)
            : prepareCallHierarchy(document, position, token);
    }
    provideCallHierarchyIncomingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyIncomingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyIncomingCalls(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyIncomingCalls
            ? middleware.provideCallHierarchyIncomingCalls(item, token, provideCallHierarchyIncomingCalls)
            : provideCallHierarchyIncomingCalls(item, token);
    }
    provideCallHierarchyOutgoingCalls(item, token) {
        const client = this.client;
        const middleware = this.middleware;
        const provideCallHierarchyOutgoingCalls = (item, token) => {
            const params = {
                item: client.code2ProtocolConverter.asCallHierarchyItem(item)
            };
            return client.sendRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, params, token).then((result) => {
                return client.protocol2CodeConverter.asCallHierarchyOutgoingCalls(result);
            }, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type, token, error, null);
            });
        };
        return middleware.provideCallHierarchyOutgoingCalls
            ? middleware.provideCallHierarchyOutgoingCalls(item, token, provideCallHierarchyOutgoingCalls)
            : provideCallHierarchyOutgoingCalls(item, token);
    }
}
class CallHierarchyFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type);
    }
    fillClientCapabilities(cap) {
        const capabilities = cap;
        const capability = ensure(ensure(capabilities, 'textDocument'), 'callHierarchy');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.callHierarchyProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const client = this._client;
        const provider = new CallHierarchyProvider(client);
        return [vscode_1.languages.registerCallHierarchyProvider(options.documentSelector, provider), provider];
    }
}
exports.CallHierarchyFeature = CallHierarchyFeature;
//# sourceMappingURL=callHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BaseLanguageClient = exports.LSPCancellationError = exports.MessageTransports = exports.TextDocumentFeature = exports.State = exports.RevealOutputChannelOn = exports.DiagnosticPullMode = exports.CloseAction = exports.ErrorAction = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./node_modules/vscode-languageclient/lib/common/configuration.js");
const c2p = __webpack_require__(/*! ./codeConverter */ "./node_modules/vscode-languageclient/lib/common/codeConverter.js");
const p2c = __webpack_require__(/*! ./protocolConverter */ "./node_modules/vscode-languageclient/lib/common/protocolConverter.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const async_1 = __webpack_require__(/*! ./utils/async */ "./node_modules/vscode-languageclient/lib/common/utils/async.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const progressPart_1 = __webpack_require__(/*! ./progressPart */ "./node_modules/vscode-languageclient/lib/common/progressPart.js");
class ConsoleLogger {
    error(message) {
        vscode_languageserver_protocol_1.RAL().console.error(message);
    }
    warn(message) {
        vscode_languageserver_protocol_1.RAL().console.warn(message);
    }
    info(message) {
        vscode_languageserver_protocol_1.RAL().console.info(message);
    }
    log(message) {
        vscode_languageserver_protocol_1.RAL().console.log(message);
    }
}
function createConnection(input, output, errorHandler, closeHandler, options) {
    let logger = new ConsoleLogger();
    let connection = vscode_languageserver_protocol_1.createProtocolConnection(input, output, logger, options);
    connection.onError((data) => { errorHandler(data[0], data[1], data[2]); });
    connection.onClose(closeHandler);
    let result = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(Is.string(type) ? type : type.method, handler),
        sendNotification: (type, params) => connection.sendNotification(Is.string(type) ? type : type.method, params),
        onNotification: (type, handler) => connection.onNotification(Is.string(type) ? type : type.method, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        trace: (value, tracer, sendNotificationOrTraceOptions) => {
            const defaultTraceOptions = {
                sendNotification: false,
                traceFormat: vscode_languageserver_protocol_1.TraceFormat.Text
            };
            if (sendNotificationOrTraceOptions === undefined) {
                connection.trace(value, tracer, defaultTraceOptions);
            }
            else if (Is.boolean(sendNotificationOrTraceOptions)) {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
            else {
                connection.trace(value, tracer, sendNotificationOrTraceOptions);
            }
        },
        initialize: (params) => connection.sendRequest(vscode_languageserver_protocol_1.InitializeRequest.type, params),
        shutdown: () => connection.sendRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, undefined),
        exit: () => connection.sendNotification(vscode_languageserver_protocol_1.ExitNotification.type),
        onLogMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, handler),
        onShowMessage: (handler) => connection.onNotification(vscode_languageserver_protocol_1.ShowMessageNotification.type, handler),
        onTelemetry: (handler) => connection.onNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, handler),
        didChangeConfiguration: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, params),
        didChangeWatchedFiles: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, params),
        didOpenTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, params),
        didChangeTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params),
        didCloseTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, params),
        didSaveTextDocument: (params) => connection.sendNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, params),
        onDiagnostics: (handler) => connection.onNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, handler),
        end: () => connection.end(),
        dispose: () => connection.dispose()
    };
    return result;
}
/**
 * An action to be performed when the connection is producing errors.
 */
var ErrorAction;
(function (ErrorAction) {
    /**
     * Continue running the server.
     */
    ErrorAction[ErrorAction["Continue"] = 1] = "Continue";
    /**
     * Shutdown the server.
     */
    ErrorAction[ErrorAction["Shutdown"] = 2] = "Shutdown";
})(ErrorAction = exports.ErrorAction || (exports.ErrorAction = {}));
/**
 * An action to be performed when the connection to a server got closed.
 */
var CloseAction;
(function (CloseAction) {
    /**
     * Don't restart the server. The connection stays closed.
     */
    CloseAction[CloseAction["DoNotRestart"] = 1] = "DoNotRestart";
    /**
     * Restart the server.
     */
    CloseAction[CloseAction["Restart"] = 2] = "Restart";
})(CloseAction = exports.CloseAction || (exports.CloseAction = {}));
class DefaultErrorHandler {
    constructor(name, maxRestartCount) {
        this.name = name;
        this.maxRestartCount = maxRestartCount;
        this.restarts = [];
    }
    error(_error, _message, count) {
        if (count && count <= 3) {
            return ErrorAction.Continue;
        }
        return ErrorAction.Shutdown;
    }
    closed() {
        this.restarts.push(Date.now());
        if (this.restarts.length <= this.maxRestartCount) {
            return CloseAction.Restart;
        }
        else {
            let diff = this.restarts[this.restarts.length - 1] - this.restarts[0];
            if (diff <= 3 * 60 * 1000) {
                void vscode_1.window.showErrorMessage(`The ${this.name} server crashed ${this.maxRestartCount + 1} times in the last 3 minutes. The server will not be restarted.`);
                return CloseAction.DoNotRestart;
            }
            else {
                this.restarts.shift();
                return CloseAction.Restart;
            }
        }
    }
}
var DiagnosticPullMode;
(function (DiagnosticPullMode) {
    DiagnosticPullMode["onType"] = "onType";
    DiagnosticPullMode["onSave"] = "onSave";
})(DiagnosticPullMode = exports.DiagnosticPullMode || (exports.DiagnosticPullMode = {}));
var RevealOutputChannelOn;
(function (RevealOutputChannelOn) {
    RevealOutputChannelOn[RevealOutputChannelOn["Info"] = 1] = "Info";
    RevealOutputChannelOn[RevealOutputChannelOn["Warn"] = 2] = "Warn";
    RevealOutputChannelOn[RevealOutputChannelOn["Error"] = 3] = "Error";
    RevealOutputChannelOn[RevealOutputChannelOn["Never"] = 4] = "Never";
})(RevealOutputChannelOn = exports.RevealOutputChannelOn || (exports.RevealOutputChannelOn = {}));
var State;
(function (State) {
    State[State["Stopped"] = 1] = "Stopped";
    State[State["Starting"] = 3] = "Starting";
    State[State["Running"] = 2] = "Running";
})(State = exports.State || (exports.State = {}));
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Initial"] = 0] = "Initial";
    ClientState[ClientState["Starting"] = 1] = "Starting";
    ClientState[ClientState["StartFailed"] = 2] = "StartFailed";
    ClientState[ClientState["Running"] = 3] = "Running";
    ClientState[ClientState["Stopping"] = 4] = "Stopping";
    ClientState[ClientState["Stopped"] = 5] = "Stopped";
})(ClientState || (ClientState = {}));
const SupportedSymbolKinds = [
    vscode_languageserver_protocol_1.SymbolKind.File,
    vscode_languageserver_protocol_1.SymbolKind.Module,
    vscode_languageserver_protocol_1.SymbolKind.Namespace,
    vscode_languageserver_protocol_1.SymbolKind.Package,
    vscode_languageserver_protocol_1.SymbolKind.Class,
    vscode_languageserver_protocol_1.SymbolKind.Method,
    vscode_languageserver_protocol_1.SymbolKind.Property,
    vscode_languageserver_protocol_1.SymbolKind.Field,
    vscode_languageserver_protocol_1.SymbolKind.Constructor,
    vscode_languageserver_protocol_1.SymbolKind.Enum,
    vscode_languageserver_protocol_1.SymbolKind.Interface,
    vscode_languageserver_protocol_1.SymbolKind.Function,
    vscode_languageserver_protocol_1.SymbolKind.Variable,
    vscode_languageserver_protocol_1.SymbolKind.Constant,
    vscode_languageserver_protocol_1.SymbolKind.String,
    vscode_languageserver_protocol_1.SymbolKind.Number,
    vscode_languageserver_protocol_1.SymbolKind.Boolean,
    vscode_languageserver_protocol_1.SymbolKind.Array,
    vscode_languageserver_protocol_1.SymbolKind.Object,
    vscode_languageserver_protocol_1.SymbolKind.Key,
    vscode_languageserver_protocol_1.SymbolKind.Null,
    vscode_languageserver_protocol_1.SymbolKind.EnumMember,
    vscode_languageserver_protocol_1.SymbolKind.Struct,
    vscode_languageserver_protocol_1.SymbolKind.Event,
    vscode_languageserver_protocol_1.SymbolKind.Operator,
    vscode_languageserver_protocol_1.SymbolKind.TypeParameter
];
const SupportedCompletionItemKinds = [
    vscode_languageserver_protocol_1.CompletionItemKind.Text,
    vscode_languageserver_protocol_1.CompletionItemKind.Method,
    vscode_languageserver_protocol_1.CompletionItemKind.Function,
    vscode_languageserver_protocol_1.CompletionItemKind.Constructor,
    vscode_languageserver_protocol_1.CompletionItemKind.Field,
    vscode_languageserver_protocol_1.CompletionItemKind.Variable,
    vscode_languageserver_protocol_1.CompletionItemKind.Class,
    vscode_languageserver_protocol_1.CompletionItemKind.Interface,
    vscode_languageserver_protocol_1.CompletionItemKind.Module,
    vscode_languageserver_protocol_1.CompletionItemKind.Property,
    vscode_languageserver_protocol_1.CompletionItemKind.Unit,
    vscode_languageserver_protocol_1.CompletionItemKind.Value,
    vscode_languageserver_protocol_1.CompletionItemKind.Enum,
    vscode_languageserver_protocol_1.CompletionItemKind.Keyword,
    vscode_languageserver_protocol_1.CompletionItemKind.Snippet,
    vscode_languageserver_protocol_1.CompletionItemKind.Color,
    vscode_languageserver_protocol_1.CompletionItemKind.File,
    vscode_languageserver_protocol_1.CompletionItemKind.Reference,
    vscode_languageserver_protocol_1.CompletionItemKind.Folder,
    vscode_languageserver_protocol_1.CompletionItemKind.EnumMember,
    vscode_languageserver_protocol_1.CompletionItemKind.Constant,
    vscode_languageserver_protocol_1.CompletionItemKind.Struct,
    vscode_languageserver_protocol_1.CompletionItemKind.Event,
    vscode_languageserver_protocol_1.CompletionItemKind.Operator,
    vscode_languageserver_protocol_1.CompletionItemKind.TypeParameter
];
const SupportedSymbolTags = [
    vscode_languageserver_protocol_1.SymbolTag.Deprecated
];
function ensure(target, key) {
    if (target[key] === undefined) {
        target[key] = {};
    }
    return target[key];
}
var FileFormattingOptions;
(function (FileFormattingOptions) {
    function fromConfiguration(document) {
        const filesConfig = vscode_1.workspace.getConfiguration('files', document);
        return {
            trimTrailingWhitespace: filesConfig.get('trimTrailingWhitespace'),
            trimFinalNewlines: filesConfig.get('trimFinalNewlines'),
            insertFinalNewline: filesConfig.get('insertFinalNewline'),
        };
    }
    FileFormattingOptions.fromConfiguration = fromConfiguration;
})(FileFormattingOptions || (FileFormattingOptions = {}));
var DynamicFeature;
(function (DynamicFeature) {
    function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.register) && Is.func(candidate.unregister) && Is.func(candidate.dispose) && candidate.registrationType !== undefined;
    }
    DynamicFeature.is = is;
})(DynamicFeature || (DynamicFeature = {}));
class DocumentNotifications {
    constructor(_client, _event, _type, _middleware, _createParams, _selectorFilter) {
        this._client = _client;
        this._event = _event;
        this._type = _type;
        this._middleware = _middleware;
        this._createParams = _createParams;
        this._selectorFilter = _selectorFilter;
        this._selectors = new Map();
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    static textDocumentFilter(selectors, textDocument) {
        for (const selector of selectors) {
            if (vscode_1.languages.match(selector, textDocument)) {
                return true;
            }
        }
        return false;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = this._event(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(data) {
        const doSend = (data) => {
            const params = this._createParams(data);
            this._client.sendNotification(this._type, params);
            this.notificationSent(data, this._type, params);
        };
        if (!this._selectorFilter || this._selectorFilter(this._selectors.values(), data)) {
            if (this._middleware) {
                this._middleware(data, (data) => doSend(data));
            }
            else {
                doSend(data);
            }
        }
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(data, type, params) {
        this._onNotificationSent.fire({ original: data, type, params });
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        this._onNotificationSent.dispose();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    getProvider(document) {
        for (const selector of this._selectors.values()) {
            if (vscode_1.languages.match(selector, document)) {
                return {
                    send: (data) => {
                        this.callback(data);
                    }
                };
            }
        }
        return undefined;
    }
}
class DidOpenTextDocumentFeature extends DocumentNotifications {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidOpenTextDocument, vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, client.clientOptions.middleware.didOpen, (textDocument) => client.code2ProtocolConverter.asOpenTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get openDocuments() {
        return this._syncedDocuments.values();
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type;
    }
    register(data) {
        super.register(data);
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let documentSelector = data.registerOptions.documentSelector;
        vscode_1.workspace.textDocuments.forEach((textDocument) => {
            let uri = textDocument.uri.toString();
            if (this._syncedDocuments.has(uri)) {
                return;
            }
            if (vscode_1.languages.match(documentSelector, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didOpen = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                if (middleware.didOpen) {
                    middleware.didOpen(textDocument, didOpen);
                }
                else {
                    didOpen(textDocument);
                }
                this._syncedDocuments.set(uri, textDocument);
            }
        });
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.set(textDocument.uri.toString(), textDocument);
    }
}
class DidCloseTextDocumentFeature extends DocumentNotifications {
    constructor(client, _syncedDocuments) {
        super(client, vscode_1.workspace.onDidCloseTextDocument, vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, client.clientOptions.middleware.didClose, (textDocument) => client.code2ProtocolConverter.asCloseTextDocumentParams(textDocument), DocumentNotifications.textDocumentFilter);
        this._syncedDocuments = _syncedDocuments;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.openClose) {
            this.register({ id: UUID.generateUuid(), registerOptions: { documentSelector: documentSelector } });
        }
    }
    notificationSent(textDocument, type, params) {
        super.notificationSent(textDocument, type, params);
        this._syncedDocuments.delete(textDocument.uri.toString());
    }
    unregister(id) {
        let selector = this._selectors.get(id);
        // The super call removed the selector from the map
        // of selectors.
        super.unregister(id);
        let selectors = this._selectors.values();
        this._syncedDocuments.forEach((textDocument) => {
            if (vscode_1.languages.match(selector, textDocument) && !this._selectorFilter(selectors, textDocument)) {
                let middleware = this._client.clientOptions.middleware;
                let didClose = (textDocument) => {
                    this._client.sendNotification(this._type, this._createParams(textDocument));
                };
                this._syncedDocuments.delete(textDocument.uri.toString());
                if (middleware.didClose) {
                    middleware.didClose(textDocument, didClose);
                }
                else {
                    didClose(textDocument);
                }
            }
        });
    }
}
class DidChangeTextDocumentFeature {
    constructor(_client) {
        this._client = _client;
        this._changeData = new Map();
        this._forcingDelivery = false;
        this._onNotificationSent = new vscode_1.EventEmitter();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.change !== undefined && textDocumentSyncOptions.change !== vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, { syncKind: textDocumentSyncOptions.change })
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onDidChangeTextDocument(this.callback, this);
        }
        this._changeData.set(data.id, {
            documentSelector: data.registerOptions.documentSelector,
            syncKind: data.registerOptions.syncKind
        });
    }
    callback(event) {
        // Text document changes are send for dirty changes as well. We don't
        // have dirty / un-dirty events in the LSP so we ignore content changes
        // with length zero.
        if (event.contentChanges.length === 0) {
            return;
        }
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, event.document)) {
                const middleware = this._client.clientOptions.middleware;
                if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental) {
                    const didChange = (event) => {
                        const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event);
                        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, event => didChange(event));
                    }
                    else {
                        didChange(event);
                    }
                }
                else if (changeData.syncKind === vscode_languageserver_protocol_1.TextDocumentSyncKind.Full) {
                    const didChange = (event) => {
                        const doSend = (event) => {
                            const params = this._client.code2ProtocolConverter.asChangeTextDocumentParams(event.document);
                            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                            this.notificationSent(event, vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, params);
                        };
                        if (this._changeDelayer) {
                            if (this._changeDelayer.uri !== event.document.uri.toString()) {
                                // Use this force delivery to track boolean state. Otherwise we might call two times.
                                this.forceDelivery();
                                this._changeDelayer.uri = event.document.uri.toString();
                            }
                            void this._changeDelayer.delayer.trigger(() => doSend(event));
                        }
                        else {
                            this._changeDelayer = {
                                uri: event.document.uri.toString(),
                                delayer: new async_1.Delayer(200)
                            };
                            void this._changeDelayer.delayer.trigger(() => doSend(event), -1);
                        }
                    };
                    if (middleware.didChange) {
                        middleware.didChange(event, event => didChange(event));
                    }
                    else {
                        didChange(event);
                    }
                }
            }
        }
    }
    get onNotificationSent() {
        return this._onNotificationSent.event;
    }
    notificationSent(changeEvent, type, params) {
        this._onNotificationSent.fire({ original: changeEvent, type, params });
    }
    unregister(id) {
        this._changeData.delete(id);
        if (this._changeData.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._changeDelayer = undefined;
        this._forcingDelivery = false;
        this._changeData.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    forceDelivery() {
        if (this._forcingDelivery || !this._changeDelayer) {
            return;
        }
        try {
            this._forcingDelivery = true;
            this._changeDelayer.delayer.forceDelivery();
        }
        finally {
            this._forcingDelivery = false;
        }
    }
    getProvider(document) {
        for (const changeData of this._changeData.values()) {
            if (vscode_1.languages.match(changeData.documentSelector, document)) {
                return {
                    send: (event) => {
                        this.callback(event);
                    }
                };
            }
        }
        return undefined;
    }
}
class WillSaveFeature extends DocumentNotifications {
    constructor(client) {
        super(client, vscode_1.workspace.onWillSaveTextDocument, vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, client.clientOptions.middleware.willSave, (willSaveEvent) => client.code2ProtocolConverter.asWillSaveTextDocumentParams(willSaveEvent), (selectors, willSaveEvent) => DocumentNotifications.textDocumentFilter(selectors, willSaveEvent.document));
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSave = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSave) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
}
class WillSaveWaitUntilFeature {
    constructor(_client) {
        this._client = _client;
        this._selectors = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type;
    }
    fillClientCapabilities(capabilities) {
        let value = ensure(ensure(capabilities, 'textDocument'), 'synchronization');
        value.willSaveWaitUntil = true;
    }
    initialize(capabilities, documentSelector) {
        let textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.willSaveWaitUntil) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: { documentSelector: documentSelector }
            });
        }
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        if (!this._listener) {
            this._listener = vscode_1.workspace.onWillSaveTextDocument(this.callback, this);
        }
        this._selectors.set(data.id, data.registerOptions.documentSelector);
    }
    callback(event) {
        if (DocumentNotifications.textDocumentFilter(this._selectors.values(), event.document)) {
            let middleware = this._client.clientOptions.middleware;
            let willSaveWaitUntil = (event) => {
                return this._client.sendRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, this._client.code2ProtocolConverter.asWillSaveTextDocumentParams(event)).then((edits) => {
                    let vEdits = this._client.protocol2CodeConverter.asTextEdits(edits);
                    return vEdits === undefined ? [] : vEdits;
                });
            };
            event.waitUntil(middleware.willSaveWaitUntil
                ? middleware.willSaveWaitUntil(event, willSaveWaitUntil)
                : willSaveWaitUntil(event));
        }
    }
    unregister(id) {
        this._selectors.delete(id);
        if (this._selectors.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._selectors.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
}
class DidSaveTextDocumentFeature extends DocumentNotifications {
    constructor(client) {
        super(client, vscode_1.workspace.onDidSaveTextDocument, vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, client.clientOptions.middleware.didSave, (textDocument) => client.code2ProtocolConverter.asSaveTextDocumentParams(textDocument, this._includeText), DocumentNotifications.textDocumentFilter);
        this._includeText = false;
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'synchronization').didSave = true;
    }
    initialize(capabilities, documentSelector) {
        const textDocumentSyncOptions = capabilities.resolvedTextDocumentSync;
        if (documentSelector && textDocumentSyncOptions && textDocumentSyncOptions.save) {
            const saveOptions = typeof textDocumentSyncOptions.save === 'boolean'
                ? { includeText: false }
                : { includeText: !!textDocumentSyncOptions.save.includeText };
            this.register({
                id: UUID.generateUuid(),
                registerOptions: Object.assign({}, { documentSelector: documentSelector }, saveOptions)
            });
        }
    }
    register(data) {
        this._includeText = !!data.registerOptions.includeText;
        super.register(data);
    }
}
class FileSystemWatcherFeature {
    constructor(_client, _notifyFileEvent) {
        this._client = _client;
        this._notifyFileEvent = _notifyFileEvent;
        this._watchers = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeWatchedFiles').dynamicRegistration = true;
    }
    initialize(_capabilities, _documentSelector) {
    }
    register(data) {
        if (!Array.isArray(data.registerOptions.watchers)) {
            return;
        }
        let disposables = [];
        for (let watcher of data.registerOptions.watchers) {
            if (!Is.string(watcher.globPattern)) {
                continue;
            }
            let watchCreate = true, watchChange = true, watchDelete = true;
            if (watcher.kind !== undefined && watcher.kind !== null) {
                watchCreate = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Create) !== 0;
                watchChange = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Change) !== 0;
                watchDelete = (watcher.kind & vscode_languageserver_protocol_1.WatchKind.Delete) !== 0;
            }
            let fileSystemWatcher = vscode_1.workspace.createFileSystemWatcher(watcher.globPattern, !watchCreate, !watchChange, !watchDelete);
            this.hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete);
            disposables.push(fileSystemWatcher);
        }
        this._watchers.set(data.id, disposables);
    }
    registerRaw(id, fileSystemWatchers) {
        let disposables = [];
        for (let fileSystemWatcher of fileSystemWatchers) {
            this.hookListeners(fileSystemWatcher, true, true, true, disposables);
        }
        this._watchers.set(id, disposables);
    }
    hookListeners(fileSystemWatcher, watchCreate, watchChange, watchDelete, listeners) {
        if (watchCreate) {
            fileSystemWatcher.onDidCreate((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Created
            }), null, listeners);
        }
        if (watchChange) {
            fileSystemWatcher.onDidChange((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Changed
            }), null, listeners);
        }
        if (watchDelete) {
            fileSystemWatcher.onDidDelete((resource) => this._notifyFileEvent({
                uri: this._client.code2ProtocolConverter.asUri(resource),
                type: vscode_languageserver_protocol_1.FileChangeType.Deleted
            }), null, listeners);
        }
    }
    unregister(id) {
        let disposables = this._watchers.get(id);
        if (disposables) {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        }
    }
    dispose() {
        this._watchers.forEach((disposables) => {
            for (let disposable of disposables) {
                disposable.dispose();
            }
        });
        this._watchers.clear();
    }
}
class TextDocumentFeature {
    constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        if (!data.registerOptions.documentSelector) {
            return;
        }
        let registration = this.registerLanguageProvider(data.registerOptions, data.id);
        this._registrations.set(data.id, { disposable: registration[0], data, provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((value) => {
            value.disposable.dispose();
        });
        this._registrations.clear();
    }
    getRegistration(documentSelector, capability) {
        if (!capability) {
            return [undefined, undefined];
        }
        else if (vscode_languageserver_protocol_1.TextDocumentRegistrationOptions.is(capability)) {
            const id = vscode_languageserver_protocol_1.StaticRegistrationOptions.hasId(capability) ? capability.id : UUID.generateUuid();
            const selector = capability.documentSelector || documentSelector;
            if (selector) {
                return [id, Object.assign({}, capability, { documentSelector: selector })];
            }
        }
        else if (Is.boolean(capability) && capability === true || vscode_languageserver_protocol_1.WorkDoneProgressOptions.is(capability)) {
            if (!documentSelector) {
                return [undefined, undefined];
            }
            let options = (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
            return [UUID.generateUuid(), options];
        }
        return [undefined, undefined];
    }
    getRegistrationOptions(documentSelector, capability) {
        if (!documentSelector || !capability) {
            return undefined;
        }
        return (Is.boolean(capability) && capability === true ? { documentSelector } : Object.assign({}, capability, { documentSelector }));
    }
    getProvider(textDocument) {
        for (const registration of this._registrations.values()) {
            let selector = registration.data.registerOptions.documentSelector;
            if (selector !== null && vscode_1.languages.match(selector, textDocument)) {
                return registration.provider;
            }
        }
        return undefined;
    }
    getAllProviders() {
        const result = [];
        for (const item of this._registrations.values()) {
            result.push(item.provider);
        }
        return result;
    }
}
exports.TextDocumentFeature = TextDocumentFeature;
class WorkspaceFeature {
    constructor(_client, _registrationType) {
        this._client = _client;
        this._registrationType = _registrationType;
        this._registrations = new Map();
    }
    get registrationType() {
        return this._registrationType;
    }
    register(data) {
        const registration = this.registerLanguageProvider(data.registerOptions);
        this._registrations.set(data.id, { disposable: registration[0], provider: registration[1] });
    }
    unregister(id) {
        let registration = this._registrations.get(id);
        if (registration !== undefined) {
            registration.disposable.dispose();
        }
    }
    dispose() {
        this._registrations.forEach((registration) => {
            registration.disposable.dispose();
        });
        this._registrations.clear();
    }
    getProviders() {
        const result = [];
        for (const registration of this._registrations.values()) {
            result.push(registration.provider);
        }
        return result;
    }
}
class CompletionItemFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CompletionRequest.type);
        this.labelDetailsSupport = new Map();
    }
    fillClientCapabilities(capabilities) {
        let completion = ensure(ensure(capabilities, 'textDocument'), 'completion');
        completion.dynamicRegistration = true;
        completion.contextSupport = true;
        completion.completionItem = {
            snippetSupport: true,
            commitCharactersSupport: true,
            documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText],
            deprecatedSupport: true,
            preselectSupport: true,
            tagSupport: { valueSet: [vscode_languageserver_protocol_1.CompletionItemTag.Deprecated] },
            insertReplaceSupport: true,
            resolveSupport: {
                properties: ['documentation', 'detail', 'additionalTextEdits']
            },
            insertTextModeSupport: { valueSet: [vscode_languageserver_protocol_1.InsertTextMode.asIs, vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation] },
            labelDetailsSupport: true
        };
        completion.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        completion.completionItemKind = { valueSet: SupportedCompletionItemKinds };
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.completionProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options, id) {
        var _a;
        this.labelDetailsSupport.set(id, !!((_a = options.completionItem) === null || _a === void 0 ? void 0 : _a.labelDetailsSupport));
        const triggerCharacters = options.triggerCharacters || [];
        const provider = {
            provideCompletionItems: (document, position, token, context) => {
                const client = this._client;
                const middleware = this._client.clientOptions.middleware;
                const provideCompletionItems = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CompletionRequest.type, client.code2ProtocolConverter.asCompletionParams(document, position, context), token).then(client.protocol2CodeConverter.asCompletionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionRequest.type, token, error, null);
                    });
                };
                return middleware.provideCompletionItem
                    ? middleware.provideCompletionItem(document, position, context, token, provideCompletionItems)
                    : provideCompletionItems(document, position, context, token);
            },
            resolveCompletionItem: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCompletionItem = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, client.code2ProtocolConverter.asCompletionItem(item, !!this.labelDetailsSupport.get(id)), token).then(client.protocol2CodeConverter.asCompletionItem, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCompletionItem
                        ? middleware.resolveCompletionItem(item, token, resolveCompletionItem)
                        : resolveCompletionItem(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCompletionItemProvider(options.documentSelector, provider, ...triggerCharacters), provider];
    }
}
class HoverFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.HoverRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const hoverCapability = (ensure(ensure(capabilities, 'textDocument'), 'hover'));
        hoverCapability.dynamicRegistration = true;
        hoverCapability.contentFormat = [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText];
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.hoverProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideHover: (document, position, token) => {
                const client = this._client;
                const provideHover = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.HoverRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asHover, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.HoverRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideHover
                    ? middleware.provideHover(document, position, token, provideHover)
                    : provideHover(document, position, token);
            }
        };
        return [vscode_1.languages.registerHoverProvider(options.documentSelector, provider), provider];
    }
}
class SignatureHelpFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SignatureHelpRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let config = ensure(ensure(capabilities, 'textDocument'), 'signatureHelp');
        config.dynamicRegistration = true;
        config.signatureInformation = { documentationFormat: [vscode_languageserver_protocol_1.MarkupKind.Markdown, vscode_languageserver_protocol_1.MarkupKind.PlainText] };
        config.signatureInformation.parameterInformation = { labelOffsetSupport: true };
        config.signatureInformation.activeParameterSupport = true;
        config.contextSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.signatureHelpProvider);
        if (!options) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: options
        });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSignatureHelp: (document, position, token, context) => {
                const client = this._client;
                const providerSignatureHelp = (document, position, context, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, client.code2ProtocolConverter.asSignatureHelpParams(document, position, context), token).then(client.protocol2CodeConverter.asSignatureHelp, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSignatureHelp
                    ? middleware.provideSignatureHelp(document, position, context, token, providerSignatureHelp)
                    : providerSignatureHelp(document, position, context, token);
            }
        };
        let disposable;
        if (options.retriggerCharacters === undefined) {
            const triggerCharacters = options.triggerCharacters || [];
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, ...triggerCharacters);
        }
        else {
            const metaData = {
                triggerCharacters: options.triggerCharacters || [],
                retriggerCharacters: options.retriggerCharacters || []
            };
            disposable = vscode_1.languages.registerSignatureHelpProvider(options.documentSelector, provider, metaData);
        }
        return [disposable, provider];
    }
}
class DefinitionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let definitionSupport = ensure(ensure(capabilities, 'textDocument'), 'definition');
        definitionSupport.dynamicRegistration = true;
        definitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.definitionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDefinition: (document, position, token) => {
                const client = this._client;
                const provideDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDefinition
                    ? middleware.provideDefinition(document, position, token, provideDefinition)
                    : provideDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerDefinitionProvider(options.documentSelector, provider), provider];
    }
}
class ReferencesFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ReferencesRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'references').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.referencesProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideReferences: (document, position, options, token) => {
                const client = this._client;
                const _providerReferences = (document, position, options, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, client.code2ProtocolConverter.asReferenceParams(document, position, options), token).then(client.protocol2CodeConverter.asReferences, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideReferences
                    ? middleware.provideReferences(document, position, options, token, _providerReferences)
                    : _providerReferences(document, position, options, token);
            }
        };
        return [vscode_1.languages.registerReferenceProvider(options.documentSelector, provider), provider];
    }
}
class DocumentHighlightFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentHighlightRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'documentHighlight').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentHighlightProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentHighlights: (document, position, token) => {
                const client = this._client;
                const _provideDocumentHighlights = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDocumentHighlights, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentHighlights
                    ? middleware.provideDocumentHighlights(document, position, token, _provideDocumentHighlights)
                    : _provideDocumentHighlights(document, position, token);
            }
        };
        return [vscode_1.languages.registerDocumentHighlightProvider(options.documentSelector, provider), provider];
    }
}
class DocumentSymbolFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, 'textDocument'), 'documentSymbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.hierarchicalDocumentSymbolSupport = true;
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
        symbolCapabilities.labelSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentSymbolProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentSymbols: (document, token) => {
                const client = this._client;
                const _provideDocumentSymbols = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, client.code2ProtocolConverter.asDocumentSymbolParams(document), token).then((data) => {
                        if (data === null) {
                            return undefined;
                        }
                        if (data.length === 0) {
                            return [];
                        }
                        else {
                            let element = data[0];
                            if (vscode_languageserver_protocol_1.DocumentSymbol.is(element)) {
                                return client.protocol2CodeConverter.asDocumentSymbols(data);
                            }
                            else {
                                return client.protocol2CodeConverter.asSymbolInformations(data);
                            }
                        }
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentSymbols
                    ? middleware.provideDocumentSymbols(document, token, _provideDocumentSymbols)
                    : _provideDocumentSymbols(document, token);
            }
        };
        const metaData = options.label !== undefined ? { label: options.label } : undefined;
        return [vscode_1.languages.registerDocumentSymbolProvider(options.documentSelector, provider, metaData), provider];
    }
}
class WorkspaceSymbolFeature extends WorkspaceFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let symbolCapabilities = ensure(ensure(capabilities, 'workspace'), 'symbol');
        symbolCapabilities.dynamicRegistration = true;
        symbolCapabilities.symbolKind = {
            valueSet: SupportedSymbolKinds
        };
        symbolCapabilities.tagSupport = {
            valueSet: SupportedSymbolTags
        };
    }
    initialize(capabilities) {
        if (!capabilities.workspaceSymbolProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: capabilities.workspaceSymbolProvider === true ? { workDoneProgress: false } : capabilities.workspaceSymbolProvider
        });
    }
    registerLanguageProvider(_options) {
        const provider = {
            provideWorkspaceSymbols: (query, token) => {
                const client = this._client;
                const provideWorkspaceSymbols = (query, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, { query }, token).then(client.protocol2CodeConverter.asSymbolInformations, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideWorkspaceSymbols
                    ? middleware.provideWorkspaceSymbols(query, token, provideWorkspaceSymbols)
                    : provideWorkspaceSymbols(query, token);
            }
        };
        return [vscode_1.languages.registerWorkspaceSymbolProvider(provider), provider];
    }
}
class CodeActionFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeActionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const cap = ensure(ensure(capabilities, 'textDocument'), 'codeAction');
        cap.dynamicRegistration = true;
        cap.isPreferredSupport = true;
        cap.disabledSupport = true;
        cap.dataSupport = true;
        // We can only resolve the edit property.
        cap.resolveSupport = {
            properties: ['edit']
        };
        cap.codeActionLiteralSupport = {
            codeActionKind: {
                valueSet: [
                    vscode_languageserver_protocol_1.CodeActionKind.Empty,
                    vscode_languageserver_protocol_1.CodeActionKind.QuickFix,
                    vscode_languageserver_protocol_1.CodeActionKind.Refactor,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorExtract,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorInline,
                    vscode_languageserver_protocol_1.CodeActionKind.RefactorRewrite,
                    vscode_languageserver_protocol_1.CodeActionKind.Source,
                    vscode_languageserver_protocol_1.CodeActionKind.SourceOrganizeImports
                ]
            }
        };
        cap.honorsChangeAnnotations = false;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeActionProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideCodeActions: (document, range, context, token) => {
                const client = this._client;
                const _provideCodeActions = (document, range, context, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        context: client.code2ProtocolConverter.asCodeActionContext(context)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, params, token).then((values) => {
                        if (values === null) {
                            return undefined;
                        }
                        const result = [];
                        for (let item of values) {
                            if (vscode_languageserver_protocol_1.Command.is(item)) {
                                result.push(client.protocol2CodeConverter.asCommand(item));
                            }
                            else {
                                result.push(client.protocol2CodeConverter.asCodeAction(item));
                            }
                        }
                        return result;
                    }, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeActions
                    ? middleware.provideCodeActions(document, range, context, token, _provideCodeActions)
                    : _provideCodeActions(document, range, context, token);
            },
            resolveCodeAction: options.resolveProvider
                ? (item, token) => {
                    const client = this._client;
                    const middleware = this._client.clientOptions.middleware;
                    const resolveCodeAction = (item, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, client.code2ProtocolConverter.asCodeAction(item), token).then(client.protocol2CodeConverter.asCodeAction, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, token, error, item);
                        });
                    };
                    return middleware.resolveCodeAction
                        ? middleware.resolveCodeAction(item, token, resolveCodeAction)
                        : resolveCodeAction(item, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeActionsProvider(options.documentSelector, provider, (options.codeActionKinds
                ? { providedCodeActionKinds: this._client.protocol2CodeConverter.asCodeActionKinds(options.codeActionKinds) }
                : undefined)), provider];
    }
}
class CodeLensFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.CodeLensRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'codeLens').dynamicRegistration = true;
        ensure(ensure(capabilities, 'workspace'), 'codeLens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.CodeLensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeCodeLensEmitter.fire();
            }
        });
        const options = this.getRegistrationOptions(documentSelector, capabilities.codeLensProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const eventEmitter = new vscode_1.EventEmitter();
        const provider = {
            onDidChangeCodeLenses: eventEmitter.event,
            provideCodeLenses: (document, token) => {
                const client = this._client;
                const provideCodeLenses = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, client.code2ProtocolConverter.asCodeLensParams(document), token).then(client.protocol2CodeConverter.asCodeLenses, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideCodeLenses
                    ? middleware.provideCodeLenses(document, token, provideCodeLenses)
                    : provideCodeLenses(document, token);
            },
            resolveCodeLens: (options.resolveProvider)
                ? (codeLens, token) => {
                    const client = this._client;
                    const resolveCodeLens = (codeLens, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, client.code2ProtocolConverter.asCodeLens(codeLens), token).then(client.protocol2CodeConverter.asCodeLens, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, token, error, codeLens);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveCodeLens
                        ? middleware.resolveCodeLens(codeLens, token, resolveCodeLens)
                        : resolveCodeLens(codeLens, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerCodeLensProvider(options.documentSelector, provider), { provider, onDidChangeCodeLensEmitter: eventEmitter }];
    }
}
class DocumentFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'formatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentFormattingEdits: (document, options, token) => {
                const client = this._client;
                const provideDocumentFormattingEdits = (document, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentFormattingEdits
                    ? middleware.provideDocumentFormattingEdits(document, options, token, provideDocumentFormattingEdits)
                    : provideDocumentFormattingEdits(document, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentRangeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'rangeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentRangeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentRangeFormattingEdits: (document, range, options, token) => {
                const client = this._client;
                const provideDocumentRangeFormattingEdits = (document, range, options, token) => {
                    const params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        range: client.code2ProtocolConverter.asRange(range),
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentRangeFormattingEdits
                    ? middleware.provideDocumentRangeFormattingEdits(document, range, options, token, provideDocumentRangeFormattingEdits)
                    : provideDocumentRangeFormattingEdits(document, range, options, token);
            }
        };
        return [vscode_1.languages.registerDocumentRangeFormattingEditProvider(options.documentSelector, provider), provider];
    }
}
class DocumentOnTypeFormattingFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'onTypeFormatting').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentOnTypeFormattingProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideOnTypeFormattingEdits: (document, position, ch, options, token) => {
                const client = this._client;
                const provideOnTypeFormattingEdits = (document, position, ch, options, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        ch: ch,
                        options: client.code2ProtocolConverter.asFormattingOptions(options, FileFormattingOptions.fromConfiguration(document))
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, params, token).then(client.protocol2CodeConverter.asTextEdits, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideOnTypeFormattingEdits
                    ? middleware.provideOnTypeFormattingEdits(document, position, ch, options, token, provideOnTypeFormattingEdits)
                    : provideOnTypeFormattingEdits(document, position, ch, options, token);
            }
        };
        const moreTriggerCharacter = options.moreTriggerCharacter || [];
        return [vscode_1.languages.registerOnTypeFormattingEditProvider(options.documentSelector, provider, options.firstTriggerCharacter, ...moreTriggerCharacter), provider];
    }
}
class RenameFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.RenameRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let rename = ensure(ensure(capabilities, 'textDocument'), 'rename');
        rename.dynamicRegistration = true;
        rename.prepareSupport = true;
        rename.prepareSupportDefaultBehavior = vscode_languageserver_protocol_1.PrepareSupportDefaultBehavior.Identifier;
        rename.honorsChangeAnnotations = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.renameProvider);
        if (!options) {
            return;
        }
        if (Is.boolean(capabilities.renameProvider)) {
            options.prepareProvider = false;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideRenameEdits: (document, position, newName, token) => {
                const client = this._client;
                const provideRenameEdits = (document, position, newName, token) => {
                    let params = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        position: client.code2ProtocolConverter.asPosition(position),
                        newName: newName
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.RenameRequest.type, params, token).then(client.protocol2CodeConverter.asWorkspaceEdit, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.RenameRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideRenameEdits
                    ? middleware.provideRenameEdits(document, position, newName, token, provideRenameEdits)
                    : provideRenameEdits(document, position, newName, token);
            },
            prepareRename: options.prepareProvider
                ? (document, position, token) => {
                    const client = this._client;
                    const prepareRename = (document, position, token) => {
                        let params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            position: client.code2ProtocolConverter.asPosition(position),
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, params, token).then((result) => {
                            if (vscode_languageserver_protocol_1.Range.is(result)) {
                                return client.protocol2CodeConverter.asRange(result);
                            }
                            else if (this.isDefaultBehavior(result)) {
                                return result.defaultBehavior === true
                                    ? null
                                    : Promise.reject(new Error(`The element can't be renamed.`));
                            }
                            else if (result && vscode_languageserver_protocol_1.Range.is(result.range)) {
                                return {
                                    range: client.protocol2CodeConverter.asRange(result.range),
                                    placeholder: result.placeholder
                                };
                            }
                            // To cancel the rename vscode API expects a rejected promise.
                            return Promise.reject(new Error(`The element can't be renamed.`));
                        }, (error) => {
                            if (typeof error.message === 'string') {
                                throw new Error(error.message);
                            }
                            else {
                                throw new Error(`The element can't be renamed.`);
                            }
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.prepareRename
                        ? middleware.prepareRename(document, position, token, prepareRename)
                        : prepareRename(document, position, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerRenameProvider(options.documentSelector, provider), provider];
    }
    isDefaultBehavior(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.defaultBehavior);
    }
}
class DocumentLinkFeature extends TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentLinkRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const documentLinkCapabilities = ensure(ensure(capabilities, 'textDocument'), 'documentLink');
        documentLinkCapabilities.dynamicRegistration = true;
        documentLinkCapabilities.tooltipSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const options = this.getRegistrationOptions(documentSelector, capabilities.documentLinkProvider);
        if (!options) {
            return;
        }
        this.register({ id: UUID.generateUuid(), registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDocumentLinks: (document, token) => {
                const client = this._client;
                const provideDocumentLinks = (document, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, client.code2ProtocolConverter.asDocumentLinkParams(document), token).then(client.protocol2CodeConverter.asDocumentLinks, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentLinks
                    ? middleware.provideDocumentLinks(document, token, provideDocumentLinks)
                    : provideDocumentLinks(document, token);
            },
            resolveDocumentLink: options.resolveProvider
                ? (link, token) => {
                    const client = this._client;
                    let resolveDocumentLink = (link, token) => {
                        return client.sendRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, client.code2ProtocolConverter.asDocumentLink(link), token).then(client.protocol2CodeConverter.asDocumentLink, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, token, error, link);
                        });
                    };
                    const middleware = client.clientOptions.middleware;
                    return middleware.resolveDocumentLink
                        ? middleware.resolveDocumentLink(link, token, resolveDocumentLink)
                        : resolveDocumentLink(link, token);
                }
                : undefined
        };
        return [vscode_1.languages.registerDocumentLinkProvider(options.documentSelector, provider), provider];
    }
}
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'didChangeConfiguration').dynamicRegistration = true;
    }
    initialize() {
        let section = this._client.clientOptions.synchronize.configurationSection;
        if (section !== undefined) {
            this.register({
                id: UUID.generateUuid(),
                registerOptions: {
                    section: section
                }
            });
        }
    }
    register(data) {
        let disposable = vscode_1.workspace.onDidChangeConfiguration((event) => {
            this.onDidChangeConfiguration(data.registerOptions.section, event);
        });
        this._listeners.set(data.id, disposable);
        if (data.registerOptions.section !== undefined) {
            this.onDidChangeConfiguration(data.registerOptions.section, undefined);
        }
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable) {
            this._listeners.delete(id);
            disposable.dispose();
        }
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    onDidChangeConfiguration(configurationSection, event) {
        let sections;
        if (Is.string(configurationSection)) {
            sections = [configurationSection];
        }
        else {
            sections = configurationSection;
        }
        if (sections !== undefined && event !== undefined) {
            let affected = sections.some((section) => event.affectsConfiguration(section));
            if (!affected) {
                return;
            }
        }
        let didChangeConfiguration = (sections) => {
            if (sections === undefined) {
                this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: null });
                return;
            }
            this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, { settings: this.extractSettingsInformation(sections) });
        };
        let middleware = this.getMiddleware();
        middleware
            ? middleware(sections, didChangeConfiguration)
            : didChangeConfiguration(sections);
    }
    extractSettingsInformation(keys) {
        function ensurePath(config, path) {
            let current = config;
            for (let i = 0; i < path.length - 1; i++) {
                let obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        let resource = this._client.clientOptions.workspaceFolder
            ? this._client.clientOptions.workspaceFolder.uri
            : undefined;
        let result = Object.create(null);
        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let index = key.indexOf('.');
            let config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index), resource).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(undefined, resource).get(key);
            }
            if (config) {
                let path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = configuration_1.toJSONObject(config);
            }
        }
        return result;
    }
    getMiddleware() {
        let middleware = this._client.clientOptions.middleware;
        if (middleware.workspace && middleware.workspace.didChangeConfiguration) {
            return middleware.workspace.didChangeConfiguration;
        }
        else {
            return undefined;
        }
    }
}
class ExecuteCommandFeature {
    constructor(_client) {
        this._client = _client;
        this._commands = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.ExecuteCommandRequest.type;
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'workspace'), 'executeCommand').dynamicRegistration = true;
    }
    initialize(capabilities) {
        if (!capabilities.executeCommandProvider) {
            return;
        }
        this.register({
            id: UUID.generateUuid(),
            registerOptions: Object.assign({}, capabilities.executeCommandProvider)
        });
    }
    register(data) {
        const client = this._client;
        const middleware = client.clientOptions.middleware;
        const executeCommand = (command, args) => {
            let params = {
                command,
                arguments: args
            };
            return client.sendRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, params).then(undefined, (error) => {
                return client.handleFailedRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, undefined, error, undefined);
            });
        };
        if (data.registerOptions.commands) {
            const disposables = [];
            for (const command of data.registerOptions.commands) {
                disposables.push(vscode_1.commands.registerCommand(command, (...args) => {
                    return middleware.executeCommand
                        ? middleware.executeCommand(command, args, executeCommand)
                        : executeCommand(command, args);
                }));
            }
            this._commands.set(data.id, disposables);
        }
    }
    unregister(id) {
        let disposables = this._commands.get(id);
        if (disposables) {
            disposables.forEach(disposable => disposable.dispose());
        }
    }
    dispose() {
        this._commands.forEach((value) => {
            value.forEach(disposable => disposable.dispose());
        });
        this._commands.clear();
    }
}
var MessageTransports;
(function (MessageTransports) {
    function is(value) {
        let candidate = value;
        return candidate && vscode_languageserver_protocol_1.MessageReader.is(value.reader) && vscode_languageserver_protocol_1.MessageWriter.is(value.writer);
    }
    MessageTransports.is = is;
})(MessageTransports = exports.MessageTransports || (exports.MessageTransports = {}));
class OnReady {
    constructor(_resolve, _reject) {
        this._resolve = _resolve;
        this._reject = _reject;
        this._used = false;
    }
    get isUsed() {
        return this._used;
    }
    resolve() {
        this._used = true;
        this._resolve();
    }
    reject(error) {
        this._used = true;
        this._reject(error);
    }
}
class LSPCancellationError extends vscode_1.CancellationError {
    constructor(data) {
        super();
        this.data = data;
    }
}
exports.LSPCancellationError = LSPCancellationError;
class BaseLanguageClient {
    constructor(id, name, clientOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this._traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        this._features = [];
        this._dynamicFeatures = new Map();
        this._id = id;
        this._name = name;
        clientOptions = clientOptions || {};
        const markdown = { isTrusted: false };
        if (clientOptions.markdown !== undefined && clientOptions.markdown.isTrusted === true) {
            markdown.isTrusted = true;
        }
        this._clientOptions = {
            documentSelector: (_a = clientOptions.documentSelector) !== null && _a !== void 0 ? _a : [],
            synchronize: (_b = clientOptions.synchronize) !== null && _b !== void 0 ? _b : {},
            diagnosticCollectionName: clientOptions.diagnosticCollectionName,
            outputChannelName: (_c = clientOptions.outputChannelName) !== null && _c !== void 0 ? _c : this._name,
            revealOutputChannelOn: (_d = clientOptions.revealOutputChannelOn) !== null && _d !== void 0 ? _d : RevealOutputChannelOn.Error,
            stdioEncoding: (_e = clientOptions.stdioEncoding) !== null && _e !== void 0 ? _e : 'utf8',
            initializationOptions: clientOptions.initializationOptions,
            initializationFailedHandler: clientOptions.initializationFailedHandler,
            progressOnInitialization: !!clientOptions.progressOnInitialization,
            errorHandler: (_f = clientOptions.errorHandler) !== null && _f !== void 0 ? _f : this.createDefaultErrorHandler((_g = clientOptions.connectionOptions) === null || _g === void 0 ? void 0 : _g.maxRestartCount),
            middleware: (_h = clientOptions.middleware) !== null && _h !== void 0 ? _h : {},
            uriConverters: clientOptions.uriConverters,
            workspaceFolder: clientOptions.workspaceFolder,
            connectionOptions: clientOptions.connectionOptions,
            markdown,
            diagnosticPullOptions: (_j = clientOptions.diagnosticPullOptions) !== null && _j !== void 0 ? _j : { onChange: true, onSave: false }
        };
        this._clientOptions.synchronize = this._clientOptions.synchronize || {};
        this._state = ClientState.Initial;
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        this._initializeResult = undefined;
        if (clientOptions.outputChannel) {
            this._outputChannel = clientOptions.outputChannel;
            this._disposeOutputChannel = false;
        }
        else {
            this._outputChannel = undefined;
            this._disposeOutputChannel = true;
        }
        this._traceOutputChannel = clientOptions.traceOutputChannel;
        this._listeners = undefined;
        this._providers = undefined;
        this._diagnostics = undefined;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise((resolve, reject) => {
            this._onReadyCallbacks = new OnReady(resolve, reject);
        });
        this._onStop = undefined;
        this._telemetryEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._stateChangeEmitter = new vscode_languageserver_protocol_1.Emitter();
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
        this._tracer = {
            log: (messageOrDataObject, data) => {
                if (Is.string(messageOrDataObject)) {
                    this.logTrace(messageOrDataObject, data);
                }
                else {
                    this.logObjectTrace(messageOrDataObject);
                }
            },
        };
        this._c2p = c2p.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.code2Protocol : undefined);
        this._p2c = p2c.createConverter(clientOptions.uriConverters ? clientOptions.uriConverters.protocol2Code : undefined, this._clientOptions.markdown.isTrusted);
        this._syncedDocuments = new Map();
        this.registerBuiltinFeatures();
    }
    get state() {
        return this._state;
    }
    set state(value) {
        let oldState = this.getPublicState();
        this._state = value;
        let newState = this.getPublicState();
        if (newState !== oldState) {
            this._stateChangeEmitter.fire({ oldState, newState });
        }
    }
    getPublicState() {
        if (this.state === ClientState.Running) {
            return State.Running;
        }
        else if (this.state === ClientState.Starting) {
            return State.Starting;
        }
        else {
            return State.Stopped;
        }
    }
    get initializeResult() {
        return this._initializeResult;
    }
    sendRequest(type, ...params) {
        if (!this.isConnectionActive()) {
            throw new Error(`Language client is not ready yet when handling ${Is.string(type) ? type : type.method}`);
        }
        this.forceDocumentSync();
        try {
            return this._resolvedConnection.sendRequest(type, ...params);
        }
        catch (error) {
            this.error(`Sending request ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onRequest(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error(`Language client is not ready yet when handling ${Is.string(type) ? type : type.method}`);
        }
        try {
            return this._resolvedConnection.onRequest(type, handler);
        }
        catch (error) {
            this.error(`Registering request handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    sendNotification(type, params) {
        if (!this.isConnectionActive()) {
            throw new Error(`Language client is not ready yet when handling ${Is.string(type) ? type : type.method}`);
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendNotification(type, params);
        }
        catch (error) {
            this.error(`Sending notification ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onNotification(type, handler) {
        if (!this.isConnectionActive()) {
            throw new Error(`Language client is not ready yet when handling ${Is.string(type) ? type : type.method}`);
        }
        try {
            return this._resolvedConnection.onNotification(type, handler);
        }
        catch (error) {
            this.error(`Registering notification handler ${Is.string(type) ? type : type.method} failed.`, error);
            throw error;
        }
    }
    onProgress(type, token, handler) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet when trying to send progress');
        }
        try {
            if (vscode_languageserver_protocol_1.WorkDoneProgress.is(type)) {
                const handleWorkDoneProgress = this._clientOptions.middleware.handleWorkDoneProgress;
                if (handleWorkDoneProgress !== undefined) {
                    return this._resolvedConnection.onProgress(type, token, (params) => {
                        handleWorkDoneProgress(token, params, () => handler(params));
                    });
                }
            }
            return this._resolvedConnection.onProgress(type, token, handler);
        }
        catch (error) {
            this.error(`Registering progress handler for token ${token} failed.`, error);
            throw error;
        }
    }
    sendProgress(type, token, value) {
        if (!this.isConnectionActive()) {
            throw new Error('Language client is not ready yet when trying to send progress');
        }
        this.forceDocumentSync();
        try {
            this._resolvedConnection.sendProgress(type, token, value);
        }
        catch (error) {
            this.error(`Sending progress for token ${token} failed.`, error);
            throw error;
        }
    }
    get clientOptions() {
        return this._clientOptions;
    }
    get protocol2CodeConverter() {
        return this._p2c;
    }
    get code2ProtocolConverter() {
        return this._c2p;
    }
    get onTelemetry() {
        return this._telemetryEmitter.event;
    }
    get onDidChangeState() {
        return this._stateChangeEmitter.event;
    }
    get outputChannel() {
        if (!this._outputChannel) {
            this._outputChannel = vscode_1.window.createOutputChannel(this._clientOptions.outputChannelName ? this._clientOptions.outputChannelName : this._name);
        }
        return this._outputChannel;
    }
    get traceOutputChannel() {
        if (this._traceOutputChannel) {
            return this._traceOutputChannel;
        }
        return this.outputChannel;
    }
    get diagnostics() {
        return this._diagnostics;
    }
    createDefaultErrorHandler(maxRestartCount) {
        if (maxRestartCount !== undefined && maxRestartCount < 0) {
            throw new Error(`Invalid maxRestartCount: ${maxRestartCount}`);
        }
        return new DefaultErrorHandler(this._name, maxRestartCount !== null && maxRestartCount !== void 0 ? maxRestartCount : 4);
    }
    set trace(value) {
        this._trace = value;
        this.onReady().then(() => {
            this.resolveConnection().then((connection) => {
                connection.trace(this._trace, this._tracer, {
                    sendNotification: false,
                    traceFormat: this._traceFormat
                });
            }, () => this.info(`Setting trace value failed`, undefined, false));
        }, () => {
        });
    }
    data2String(data) {
        if (data instanceof vscode_languageserver_protocol_1.ResponseError) {
            const responseError = data;
            return `  Message: ${responseError.message}\n  Code: ${responseError.code} ${responseError.data ? '\n' + responseError.data.toString() : ''}`;
        }
        if (data instanceof Error) {
            if (Is.string(data.stack)) {
                return data.stack;
            }
            return data.message;
        }
        if (Is.string(data)) {
            return data;
        }
        return data.toString();
    }
    info(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Info  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Info) {
            this.showNotificationMessage();
        }
    }
    warn(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Warn  - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Warn) {
            this.showNotificationMessage();
        }
    }
    error(message, data, showNotification = true) {
        this.outputChannel.appendLine(`[Error - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data !== null && data !== undefined) {
            this.outputChannel.appendLine(this.data2String(data));
        }
        if (showNotification && this._clientOptions.revealOutputChannelOn <= RevealOutputChannelOn.Error) {
            this.showNotificationMessage();
        }
    }
    showNotificationMessage() {
        void vscode_1.window.showInformationMessage('A request has failed. See the output for more information.', 'Go to output').then(() => {
            this.outputChannel.show(true);
        });
    }
    logTrace(message, data) {
        this.traceOutputChannel.appendLine(`[Trace - ${(new Date().toLocaleTimeString())}] ${message}`);
        if (data) {
            this.traceOutputChannel.appendLine(this.data2String(data));
        }
    }
    logObjectTrace(data) {
        if (data.isLSPMessage && data.type) {
            this.traceOutputChannel.append(`[LSP   - ${(new Date().toLocaleTimeString())}] `);
        }
        else {
            this.traceOutputChannel.append(`[Trace - ${(new Date().toLocaleTimeString())}] `);
        }
        if (data) {
            this.traceOutputChannel.appendLine(`${JSON.stringify(data)}`);
        }
    }
    needsStart() {
        return this.state === ClientState.Initial || this.state === ClientState.Stopping || this.state === ClientState.Stopped;
    }
    needsStop() {
        return this.state === ClientState.Starting || this.state === ClientState.Running;
    }
    onReady() {
        return this._onReady;
    }
    isConnectionActive() {
        return this.state === ClientState.Running && !!this._resolvedConnection;
    }
    start() {
        if (this._onReadyCallbacks.isUsed) {
            this._onReady = new Promise((resolve, reject) => {
                this._onReadyCallbacks = new OnReady(resolve, reject);
            });
        }
        this._listeners = [];
        this._providers = [];
        // If we restart then the diagnostics collection is reused.
        if (!this._diagnostics) {
            this._diagnostics = this._clientOptions.diagnosticCollectionName
                ? vscode_1.languages.createDiagnosticCollection(this._clientOptions.diagnosticCollectionName)
                : vscode_1.languages.createDiagnosticCollection();
        }
        this.state = ClientState.Starting;
        this.resolveConnection().then((connection) => {
            connection.onLogMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        this.error(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        this.warn(message.message, undefined, false);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        this.info(message.message, undefined, false);
                        break;
                    default:
                        this.outputChannel.appendLine(message.message);
                }
            });
            connection.onShowMessage((message) => {
                switch (message.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        void vscode_1.window.showErrorMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        void vscode_1.window.showWarningMessage(message.message);
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        void vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        void vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, (params) => {
                let messageFunc;
                switch (params.type) {
                    case vscode_languageserver_protocol_1.MessageType.Error:
                        messageFunc = vscode_1.window.showErrorMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Warning:
                        messageFunc = vscode_1.window.showWarningMessage;
                        break;
                    case vscode_languageserver_protocol_1.MessageType.Info:
                        messageFunc = vscode_1.window.showInformationMessage;
                        break;
                    default:
                        messageFunc = vscode_1.window.showInformationMessage;
                }
                let actions = params.actions || [];
                return messageFunc(params.message, ...actions);
            });
            connection.onTelemetry((data) => {
                this._telemetryEmitter.fire(data);
            });
            connection.onRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, async (params) => {
                var _a;
                const showDocument = async (params) => {
                    const uri = this.protocol2CodeConverter.asUri(params.uri);
                    try {
                        if (params.external === true) {
                            const success = await vscode_1.env.openExternal(uri);
                            return { success };
                        }
                        else {
                            const options = {};
                            if (params.selection !== undefined) {
                                options.selection = this.protocol2CodeConverter.asRange(params.selection);
                            }
                            if (params.takeFocus === undefined || params.takeFocus === false) {
                                options.preserveFocus = true;
                            }
                            else if (params.takeFocus === true) {
                                options.preserveFocus = false;
                            }
                            await vscode_1.window.showTextDocument(uri, options);
                            return { success: true };
                        }
                    }
                    catch (error) {
                        return { success: true };
                    }
                };
                const middleware = (_a = this._clientOptions.middleware.window) === null || _a === void 0 ? void 0 : _a.showDocument;
                if (middleware !== undefined) {
                    return middleware(params, showDocument);
                }
                else {
                    return showDocument(params);
                }
            });
            connection.listen();
            // Error is handled in the initialize call.
            return this.initialize(connection);
        }).then(undefined, (error) => {
            this.state = ClientState.StartFailed;
            this._onReadyCallbacks.reject(error);
            this.error('Starting client failed', error);
            void vscode_1.window.showErrorMessage(`Couldn't start client ${this._name}`);
        });
        return new vscode_1.Disposable(() => {
            if (this.needsStop()) {
                this.stop().then(undefined, (error) => {
                    this.error(`Stopping server failed.`, error, false);
                });
            }
        });
    }
    resolveConnection() {
        if (!this._connectionPromise) {
            this._connectionPromise = this.createConnection();
        }
        return this._connectionPromise;
    }
    initialize(connection) {
        this.refreshTrace(connection, false);
        let initOption = this._clientOptions.initializationOptions;
        let rootPath = this._clientOptions.workspaceFolder
            ? this._clientOptions.workspaceFolder.uri.fsPath
            : this._clientGetRootPath();
        let initParams = {
            processId: null,
            clientInfo: {
                name: vscode_1.env.appName,
                version: vscode_1.version
            },
            locale: this.getLocale(),
            rootPath: rootPath ? rootPath : null,
            rootUri: rootPath ? this._c2p.asUri(vscode_1.Uri.file(rootPath)) : null,
            capabilities: this.computeClientCapabilities(),
            initializationOptions: Is.func(initOption) ? initOption() : initOption,
            trace: vscode_languageserver_protocol_1.Trace.toString(this._trace),
            workspaceFolders: null
        };
        this.fillInitializeParams(initParams);
        if (this._clientOptions.progressOnInitialization) {
            const token = UUID.generateUuid();
            const part = new progressPart_1.ProgressPart(connection, token);
            initParams.workDoneToken = token;
            return this.doInitialize(connection, initParams).then((result) => {
                part.done();
                return result;
            }, (error) => {
                part.cancel();
                throw error;
            });
        }
        else {
            return this.doInitialize(connection, initParams);
        }
    }
    doInitialize(connection, initParams) {
        return connection.initialize(initParams).then((result) => {
            this._resolvedConnection = connection;
            this._initializeResult = result;
            this.state = ClientState.Running;
            let textDocumentSyncOptions = undefined;
            if (Is.number(result.capabilities.textDocumentSync)) {
                if (result.capabilities.textDocumentSync === vscode_languageserver_protocol_1.TextDocumentSyncKind.None) {
                    textDocumentSyncOptions = {
                        openClose: false,
                        change: vscode_languageserver_protocol_1.TextDocumentSyncKind.None,
                        save: undefined
                    };
                }
                else {
                    textDocumentSyncOptions = {
                        openClose: true,
                        change: result.capabilities.textDocumentSync,
                        save: {
                            includeText: false
                        }
                    };
                }
            }
            else if (result.capabilities.textDocumentSync !== undefined && result.capabilities.textDocumentSync !== null) {
                textDocumentSyncOptions = result.capabilities.textDocumentSync;
            }
            this._capabilities = Object.assign({}, result.capabilities, { resolvedTextDocumentSync: textDocumentSyncOptions });
            connection.onDiagnostics(params => this.handleDiagnostics(params));
            connection.onRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params => this.handleRegistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/registerFeature', params => this.handleRegistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params => this.handleUnregistrationRequest(params));
            // See https://github.com/Microsoft/vscode-languageserver-node/issues/199
            connection.onRequest('client/unregisterFeature', params => this.handleUnregistrationRequest(params));
            connection.onRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params => this.handleApplyWorkspaceEdit(params));
            connection.sendNotification(vscode_languageserver_protocol_1.InitializedNotification.type, {});
            this.hookFileEvents(connection);
            this.hookConfigurationChanged(connection);
            this.initializeFeatures(connection);
            this._onReadyCallbacks.resolve();
            return result;
        }).then(undefined, (error) => {
            if (this._clientOptions.initializationFailedHandler) {
                if (this._clientOptions.initializationFailedHandler(error)) {
                    void this.initialize(connection);
                }
                else {
                    void this.stop();
                    this._onReadyCallbacks.reject(error);
                }
            }
            else if (error instanceof vscode_languageserver_protocol_1.ResponseError && error.data && error.data.retry) {
                void vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: 'retry' }).then(item => {
                    if (item && item.id === 'retry') {
                        void this.initialize(connection);
                    }
                    else {
                        void this.stop();
                        this._onReadyCallbacks.reject(error);
                    }
                });
            }
            else {
                if (error && error.message) {
                    void vscode_1.window.showErrorMessage(error.message);
                }
                this.error('Server initialization failed.', error);
                void this.stop();
                this._onReadyCallbacks.reject(error);
            }
            throw error;
        });
    }
    _clientGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    stop() {
        this._initializeResult = undefined;
        if (!this._connectionPromise) {
            this.state = ClientState.Stopped;
            return Promise.resolve();
        }
        if (this.state === ClientState.Stopping && this._onStop) {
            return this._onStop;
        }
        this.state = ClientState.Stopping;
        this.cleanUp(false);
        // unhook listeners
        return this._onStop = this.resolveConnection().then(connection => {
            return connection.shutdown().then(() => {
                connection.exit();
                connection.end();
                connection.dispose();
                this.state = ClientState.Stopped;
                this.cleanUpChannel();
                this._onStop = undefined;
                this._connectionPromise = undefined;
                this._resolvedConnection = undefined;
            });
        });
    }
    cleanUp(channel = true, diagnostics = true) {
        if (this._listeners) {
            this._listeners.forEach(listener => listener.dispose());
            this._listeners = undefined;
        }
        if (this._providers) {
            this._providers.forEach(provider => provider.dispose());
            this._providers = undefined;
        }
        if (this._syncedDocuments) {
            this._syncedDocuments.clear();
        }
        for (const feature of this._features.values()) {
            feature.dispose();
        }
        if (channel) {
            this.cleanUpChannel();
        }
        if (diagnostics && this._diagnostics) {
            this._diagnostics.dispose();
            this._diagnostics = undefined;
        }
    }
    cleanUpChannel() {
        if (this._outputChannel && this._disposeOutputChannel) {
            this._outputChannel.dispose();
            this._outputChannel = undefined;
        }
    }
    notifyFileEvent(event) {
        var _a;
        const client = this;
        function didChangeWatchedFile(event) {
            client._fileEvents.push(event);
            void client._fileEventDelayer.trigger(() => {
                client.onReady().then(() => {
                    void client.resolveConnection().then(connection => {
                        if (client.isConnectionActive()) {
                            client.forceDocumentSync();
                            connection.didChangeWatchedFiles({ changes: client._fileEvents });
                        }
                        client._fileEvents = [];
                    });
                }, (error) => {
                    client.error(`Notify file events failed.`, error);
                });
            });
        }
        const workSpaceMiddleware = (_a = this.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        (workSpaceMiddleware === null || workSpaceMiddleware === void 0 ? void 0 : workSpaceMiddleware.didChangeWatchedFile) ? workSpaceMiddleware.didChangeWatchedFile(event, didChangeWatchedFile) : didChangeWatchedFile(event);
    }
    forceDocumentSync() {
        if (this._didChangeTextDocumentFeature === undefined) {
            this._didChangeTextDocumentFeature = this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type.method);
        }
        this._didChangeTextDocumentFeature.forceDelivery();
    }
    handleDiagnostics(params) {
        if (!this._diagnostics) {
            return;
        }
        let uri = this._p2c.asUri(params.uri);
        let diagnostics = this._p2c.asDiagnostics(params.diagnostics);
        let middleware = this.clientOptions.middleware;
        if (middleware.handleDiagnostics) {
            middleware.handleDiagnostics(uri, diagnostics, (uri, diagnostics) => this.setDiagnostics(uri, diagnostics));
        }
        else {
            this.setDiagnostics(uri, diagnostics);
        }
    }
    setDiagnostics(uri, diagnostics) {
        if (!this._diagnostics) {
            return;
        }
        this._diagnostics.set(uri, diagnostics);
    }
    createConnection() {
        let errorHandler = (error, message, count) => {
            this.handleConnectionError(error, message, count);
        };
        let closeHandler = () => {
            this.handleConnectionClosed();
        };
        return this.createMessageTransports(this._clientOptions.stdioEncoding || 'utf8').then((transports) => {
            return createConnection(transports.reader, transports.writer, errorHandler, closeHandler, this._clientOptions.connectionOptions);
        });
    }
    handleConnectionClosed() {
        // Check whether this is a normal shutdown in progress or the client stopped normally.
        if (this.state === ClientState.Stopped) {
            return;
        }
        try {
            if (this._resolvedConnection) {
                this._resolvedConnection.dispose();
            }
        }
        catch (error) {
            // Disposing a connection could fail if error cases.
        }
        let action = CloseAction.DoNotRestart;
        if (this.state !== ClientState.Stopping) {
            try {
                action = this._clientOptions.errorHandler.closed();
            }
            catch (error) {
                // Ignore errors coming from the error handler.
            }
        }
        this._connectionPromise = undefined;
        this._resolvedConnection = undefined;
        if (action === CloseAction.DoNotRestart) {
            this.error('Connection to server got closed. Server will not be restarted.');
            if (this.state === ClientState.Starting) {
                this._onReadyCallbacks.reject(new Error(`Connection to server got closed. Server will not be restarted.`));
                this.state = ClientState.StartFailed;
            }
            else {
                this.state = ClientState.Stopped;
            }
            this.cleanUp(false, true);
        }
        else if (action === CloseAction.Restart) {
            this.info('Connection to server got closed. Server will restart.');
            this.cleanUp(false, false);
            this.state = ClientState.Initial;
            this.start();
        }
    }
    handleConnectionError(error, message, count) {
        let action = this._clientOptions.errorHandler.error(error, message, count);
        if (action === ErrorAction.Shutdown) {
            this.error('Connection to server is erroring. Shutting down server.');
            this.stop().then(undefined, (error) => {
                this.error(`Stopping server failed`, error, false);
            });
        }
    }
    hookConfigurationChanged(connection) {
        vscode_1.workspace.onDidChangeConfiguration(() => {
            this.refreshTrace(connection, true);
        });
    }
    refreshTrace(connection, sendNotification = false) {
        let config = vscode_1.workspace.getConfiguration(this._id);
        let trace = vscode_languageserver_protocol_1.Trace.Off;
        let traceFormat = vscode_languageserver_protocol_1.TraceFormat.Text;
        if (config) {
            const traceConfig = config.get('trace.server', 'off');
            if (typeof traceConfig === 'string') {
                trace = vscode_languageserver_protocol_1.Trace.fromString(traceConfig);
            }
            else {
                trace = vscode_languageserver_protocol_1.Trace.fromString(config.get('trace.server.verbosity', 'off'));
                traceFormat = vscode_languageserver_protocol_1.TraceFormat.fromString(config.get('trace.server.format', 'text'));
            }
        }
        this._trace = trace;
        this._traceFormat = traceFormat;
        connection.trace(this._trace, this._tracer, {
            sendNotification,
            traceFormat: this._traceFormat
        });
    }
    hookFileEvents(_connection) {
        let fileEvents = this._clientOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        let watchers;
        if (Is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        this._dynamicFeatures.get(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type.method).registerRaw(UUID.generateUuid(), watchers);
    }
    registerFeatures(features) {
        for (let feature of features) {
            this.registerFeature(feature);
        }
    }
    registerFeature(feature) {
        this._features.push(feature);
        if (DynamicFeature.is(feature)) {
            const registrationType = feature.registrationType;
            this._dynamicFeatures.set(registrationType.method, feature);
        }
    }
    getFeature(request) {
        return this._dynamicFeatures.get(request);
    }
    registerBuiltinFeatures() {
        this.registerFeature(new ConfigurationFeature(this));
        this.registerFeature(new DidOpenTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new DidChangeTextDocumentFeature(this));
        this.registerFeature(new WillSaveFeature(this));
        this.registerFeature(new WillSaveWaitUntilFeature(this));
        this.registerFeature(new DidSaveTextDocumentFeature(this));
        this.registerFeature(new DidCloseTextDocumentFeature(this, this._syncedDocuments));
        this.registerFeature(new FileSystemWatcherFeature(this, (event) => this.notifyFileEvent(event)));
        this.registerFeature(new CompletionItemFeature(this));
        this.registerFeature(new HoverFeature(this));
        this.registerFeature(new SignatureHelpFeature(this));
        this.registerFeature(new DefinitionFeature(this));
        this.registerFeature(new ReferencesFeature(this));
        this.registerFeature(new DocumentHighlightFeature(this));
        this.registerFeature(new DocumentSymbolFeature(this));
        this.registerFeature(new WorkspaceSymbolFeature(this));
        this.registerFeature(new CodeActionFeature(this));
        this.registerFeature(new CodeLensFeature(this));
        this.registerFeature(new DocumentFormattingFeature(this));
        this.registerFeature(new DocumentRangeFormattingFeature(this));
        this.registerFeature(new DocumentOnTypeFormattingFeature(this));
        this.registerFeature(new RenameFeature(this));
        this.registerFeature(new DocumentLinkFeature(this));
        this.registerFeature(new ExecuteCommandFeature(this));
    }
    fillInitializeParams(params) {
        for (let feature of this._features) {
            if (Is.func(feature.fillInitializeParams)) {
                feature.fillInitializeParams(params);
            }
        }
    }
    computeClientCapabilities() {
        const result = {};
        ensure(result, 'workspace').applyEdit = true;
        const workspaceEdit = ensure(ensure(result, 'workspace'), 'workspaceEdit');
        workspaceEdit.documentChanges = true;
        workspaceEdit.resourceOperations = [vscode_languageserver_protocol_1.ResourceOperationKind.Create, vscode_languageserver_protocol_1.ResourceOperationKind.Rename, vscode_languageserver_protocol_1.ResourceOperationKind.Delete];
        workspaceEdit.failureHandling = vscode_languageserver_protocol_1.FailureHandlingKind.TextOnlyTransactional;
        workspaceEdit.normalizesLineEndings = true;
        workspaceEdit.changeAnnotationSupport = {
            groupsOnLabel: true
        };
        const diagnostics = ensure(ensure(result, 'textDocument'), 'publishDiagnostics');
        diagnostics.relatedInformation = true;
        diagnostics.versionSupport = false;
        diagnostics.tagSupport = { valueSet: [vscode_languageserver_protocol_1.DiagnosticTag.Unnecessary, vscode_languageserver_protocol_1.DiagnosticTag.Deprecated] };
        diagnostics.codeDescriptionSupport = true;
        diagnostics.dataSupport = true;
        const windowCapabilities = ensure(result, 'window');
        const showMessage = ensure(windowCapabilities, 'showMessage');
        showMessage.messageActionItem = { additionalPropertiesSupport: true };
        const showDocument = ensure(windowCapabilities, 'showDocument');
        showDocument.support = true;
        const generalCapabilities = ensure(result, 'general');
        generalCapabilities.staleRequestSupport = {
            cancel: true,
            retryOnContentModified: Array.from(BaseLanguageClient.RequestsToCancelOnContentModified)
        };
        generalCapabilities.regularExpressions = { engine: 'ECMAScript', version: 'ES2020' };
        generalCapabilities.markdown = { parser: 'marked', version: '1.1.0' };
        for (let feature of this._features) {
            feature.fillClientCapabilities(result);
        }
        return result;
    }
    initializeFeatures(_connection) {
        let documentSelector = this._clientOptions.documentSelector;
        for (let feature of this._features) {
            feature.initialize(this._capabilities, documentSelector);
        }
    }
    handleRegistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (const registration of params.registrations) {
                const feature = this._dynamicFeatures.get(registration.method);
                if (feature === undefined) {
                    reject(new Error(`No feature implementation for ${registration.method} found. Registration failed.`));
                    return;
                }
                const options = registration.registerOptions || {};
                options.documentSelector = options.documentSelector || this._clientOptions.documentSelector;
                const data = {
                    id: registration.id,
                    registerOptions: options
                };
                try {
                    feature.register(data);
                }
                catch (err) {
                    reject(err);
                    return;
                }
            }
            resolve();
        });
    }
    handleUnregistrationRequest(params) {
        return new Promise((resolve, reject) => {
            for (let unregistration of params.unregisterations) {
                const feature = this._dynamicFeatures.get(unregistration.method);
                if (!feature) {
                    reject(new Error(`No feature implementation for ${unregistration.method} found. Unregistration failed.`));
                    return;
                }
                feature.unregister(unregistration.id);
            }
            resolve();
        });
    }
    handleApplyWorkspaceEdit(params) {
        // This is some sort of workaround since the version check should be done by VS Code in the Workspace.applyEdit.
        // However doing it here adds some safety since the server can lag more behind then an extension.
        let workspaceEdit = params.edit;
        let openTextDocuments = new Map();
        vscode_1.workspace.textDocuments.forEach((document) => openTextDocuments.set(document.uri.toString(), document));
        let versionMismatch = false;
        if (workspaceEdit.documentChanges) {
            for (const change of workspaceEdit.documentChanges) {
                if (vscode_languageserver_protocol_1.TextDocumentEdit.is(change) && change.textDocument.version && change.textDocument.version >= 0) {
                    let textDocument = openTextDocuments.get(change.textDocument.uri);
                    if (textDocument && textDocument.version !== change.textDocument.version) {
                        versionMismatch = true;
                        break;
                    }
                }
            }
        }
        if (versionMismatch) {
            return Promise.resolve({ applied: false });
        }
        return Is.asPromise(vscode_1.workspace.applyEdit(this._p2c.asWorkspaceEdit(params.edit)).then((value) => { return { applied: value }; }));
    }
    handleFailedRequest(type, token, error, defaultValue) {
        // If we get a request cancel or a content modified don't log anything.
        if (error instanceof vscode_languageserver_protocol_1.ResponseError) {
            if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.RequestCancelled || error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ServerCancelled) {
                if (token !== undefined && token.isCancellationRequested) {
                    return defaultValue;
                }
                else {
                    if (error.data !== undefined) {
                        throw new LSPCancellationError(error.data);
                    }
                    else {
                        throw new vscode_1.CancellationError();
                    }
                }
            }
            else if (error.code === vscode_languageserver_protocol_1.LSPErrorCodes.ContentModified) {
                if (BaseLanguageClient.RequestsToCancelOnContentModified.has(type.method)) {
                    throw new vscode_1.CancellationError();
                }
                else {
                    return defaultValue;
                }
            }
        }
        this.error(`Request ${type.method} failed.`, error);
        throw error;
    }
}
exports.BaseLanguageClient = BaseLanguageClient;
BaseLanguageClient.RequestsToCancelOnContentModified = new Set([
    vscode_languageserver_protocol_1.SemanticTokensRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensRangeRequest.method,
    vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.method
]);
//# sourceMappingURL=client.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/codeConverter.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/codeConverter.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js");
const protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js");
const protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js");
const protocolCodeAction_1 = __webpack_require__(/*! ./protocolCodeAction */ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js");
const protocolDiagnostic_1 = __webpack_require__(/*! ./protocolDiagnostic */ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js");
const protocolCallHierarchyItem_1 = __webpack_require__(/*! ./protocolCallHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
var InsertReplaceRange;
(function (InsertReplaceRange) {
    function is(value) {
        const candidate = value;
        return candidate && !!candidate.inserting && !!candidate.replacing;
    }
    InsertReplaceRange.is = is;
})(InsertReplaceRange || (InsertReplaceRange = {}));
function createConverter(uriConverter) {
    const nullConverter = (value) => value.toString();
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri)
        };
    }
    function asVersionedTextDocumentIdentifier(textDocument) {
        return {
            uri: _uriConverter(textDocument.uri),
            version: textDocument.version
        };
    }
    function asOpenTextDocumentParams(textDocument) {
        return {
            textDocument: {
                uri: _uriConverter(textDocument.uri),
                languageId: textDocument.languageId,
                version: textDocument.version,
                text: textDocument.getText()
            }
        };
    }
    function isTextDocumentChangeEvent(value) {
        let candidate = value;
        return !!candidate.document && !!candidate.contentChanges;
    }
    function isTextDocument(value) {
        let candidate = value;
        return !!candidate.uri && !!candidate.version;
    }
    function asChangeTextDocumentParams(arg) {
        if (isTextDocument(arg)) {
            let result = {
                textDocument: {
                    uri: _uriConverter(arg.uri),
                    version: arg.version
                },
                contentChanges: [{ text: arg.getText() }]
            };
            return result;
        }
        else if (isTextDocumentChangeEvent(arg)) {
            let document = arg.document;
            let result = {
                textDocument: {
                    uri: _uriConverter(document.uri),
                    version: document.version
                },
                contentChanges: arg.contentChanges.map((change) => {
                    let range = change.range;
                    return {
                        range: {
                            start: { line: range.start.line, character: range.start.character },
                            end: { line: range.end.line, character: range.end.character }
                        },
                        rangeLength: change.rangeLength,
                        text: change.text
                    };
                })
            };
            return result;
        }
        else {
            throw Error('Unsupported text document change parameter');
        }
    }
    function asCloseTextDocumentParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asSaveTextDocumentParams(textDocument, includeContent = false) {
        let result = {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
        if (includeContent) {
            result.text = textDocument.getText();
        }
        return result;
    }
    function asTextDocumentSaveReason(reason) {
        switch (reason) {
            case code.TextDocumentSaveReason.Manual:
                return proto.TextDocumentSaveReason.Manual;
            case code.TextDocumentSaveReason.AfterDelay:
                return proto.TextDocumentSaveReason.AfterDelay;
            case code.TextDocumentSaveReason.FocusOut:
                return proto.TextDocumentSaveReason.FocusOut;
        }
        return proto.TextDocumentSaveReason.Manual;
    }
    function asWillSaveTextDocumentParams(event) {
        return {
            textDocument: asTextDocumentIdentifier(event.document),
            reason: asTextDocumentSaveReason(event.reason)
        };
    }
    function asDidCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asDidRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asDidDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillCreateFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asWillRenameFilesParams(event) {
        return {
            files: event.files.map((file) => ({
                oldUri: _uriConverter(file.oldUri),
                newUri: _uriConverter(file.newUri),
            })),
        };
    }
    function asWillDeleteFilesParams(event) {
        return {
            files: event.files.map((fileUri) => ({
                uri: _uriConverter(fileUri),
            })),
        };
    }
    function asTextDocumentPositionParams(textDocument, position) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position)
        };
    }
    function asCompletionTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.CompletionTriggerKind.TriggerCharacter:
                return proto.CompletionTriggerKind.TriggerCharacter;
            case code.CompletionTriggerKind.TriggerForIncompleteCompletions:
                return proto.CompletionTriggerKind.TriggerForIncompleteCompletions;
            default:
                return proto.CompletionTriggerKind.Invoked;
        }
    }
    function asCompletionParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                triggerKind: asCompletionTriggerKind(context.triggerKind),
                triggerCharacter: context.triggerCharacter
            }
        };
    }
    function asSignatureHelpTriggerKind(triggerKind) {
        switch (triggerKind) {
            case code.SignatureHelpTriggerKind.Invoke:
                return proto.SignatureHelpTriggerKind.Invoked;
            case code.SignatureHelpTriggerKind.TriggerCharacter:
                return proto.SignatureHelpTriggerKind.TriggerCharacter;
            case code.SignatureHelpTriggerKind.ContentChange:
                return proto.SignatureHelpTriggerKind.ContentChange;
        }
    }
    function asParameterInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label
        };
    }
    function asParameterInformations(values) {
        return values.map(asParameterInformation);
    }
    function asSignatureInformation(value) {
        // We leave the documentation out on purpose since it usually adds no
        // value for the server.
        return {
            label: value.label,
            parameters: asParameterInformations(value.parameters)
        };
    }
    function asSignatureInformations(values) {
        return values.map(asSignatureInformation);
    }
    function asSignatureHelp(value) {
        if (value === undefined) {
            return value;
        }
        return {
            signatures: asSignatureInformations(value.signatures),
            activeSignature: value.activeSignature,
            activeParameter: value.activeParameter
        };
    }
    function asSignatureHelpParams(textDocument, position, context) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: {
                isRetrigger: context.isRetrigger,
                triggerCharacter: context.triggerCharacter,
                triggerKind: asSignatureHelpTriggerKind(context.triggerKind),
                activeSignatureHelp: asSignatureHelp(context.activeSignatureHelp)
            }
        };
    }
    function asWorkerPosition(position) {
        return { line: position.line, character: position.character };
    }
    function asPosition(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { line: value.line > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.line, character: value.character > vscode_languageserver_protocol_1.uinteger.MAX_VALUE ? vscode_languageserver_protocol_1.uinteger.MAX_VALUE : value.character };
    }
    function asPositions(value) {
        let result = [];
        for (let elem of value) {
            result.push(asPosition(elem));
        }
        return result;
    }
    function asRange(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return { start: asPosition(value.start), end: asPosition(value.end) };
    }
    function asLocation(value) {
        if (value === undefined || value === null) {
            return value;
        }
        return proto.Location.create(asUri(value.uri), asRange(value.range));
    }
    function asDiagnosticSeverity(value) {
        switch (value) {
            case code.DiagnosticSeverity.Error:
                return proto.DiagnosticSeverity.Error;
            case code.DiagnosticSeverity.Warning:
                return proto.DiagnosticSeverity.Warning;
            case code.DiagnosticSeverity.Information:
                return proto.DiagnosticSeverity.Information;
            case code.DiagnosticSeverity.Hint:
                return proto.DiagnosticSeverity.Hint;
        }
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case code.DiagnosticTag.Unnecessary:
                return proto.DiagnosticTag.Unnecessary;
            case code.DiagnosticTag.Deprecated:
                return proto.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asRelatedInformation(item) {
        return {
            message: item.message,
            location: asLocation(item.location)
        };
    }
    function asRelatedInformations(items) {
        return items.map(asRelatedInformation);
    }
    function asDiagnosticCode(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        if (Is.number(value) || Is.string(value)) {
            return value;
        }
        return { value: value.value, target: asUri(value.target) };
    }
    function asDiagnostic(item) {
        const result = proto.Diagnostic.create(asRange(item.range), item.message);
        const protocolDiagnostic = item instanceof protocolDiagnostic_1.ProtocolDiagnostic ? item : undefined;
        if (protocolDiagnostic !== undefined && protocolDiagnostic.data !== undefined) {
            result.data = protocolDiagnostic.data;
        }
        const code = asDiagnosticCode(item.code);
        if (protocolDiagnostic_1.DiagnosticCode.is(code)) {
            if (protocolDiagnostic !== undefined && protocolDiagnostic.hasDiagnosticCode) {
                result.code = code;
            }
            else {
                result.code = code.value;
                result.codeDescription = { href: code.target };
            }
        }
        else {
            result.code = code;
        }
        if (Is.number(item.severity)) {
            result.severity = asDiagnosticSeverity(item.severity);
        }
        if (Array.isArray(item.tags)) {
            result.tags = asDiagnosticTags(item.tags);
        }
        if (item.relatedInformation) {
            result.relatedInformation = asRelatedInformations(item.relatedInformation);
        }
        if (item.source) {
            result.source = item.source;
        }
        return result;
    }
    function asDiagnostics(items) {
        if (items === undefined || items === null) {
            return items;
        }
        return items.map(asDiagnostic);
    }
    function asDocumentation(format, documentation) {
        switch (format) {
            case '$string':
                return documentation;
            case proto.MarkupKind.PlainText:
                return { kind: format, value: documentation };
            case proto.MarkupKind.Markdown:
                return { kind: format, value: documentation.value };
            default:
                return `Unsupported Markup content received. Kind is: ${format}`;
        }
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case code.CompletionItemTag.Deprecated:
                return proto.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined) {
            return tags;
        }
        const result = [];
        for (let tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItemKind(value, original) {
        if (original !== undefined) {
            return original;
        }
        return value + 1;
    }
    function asCompletionItem(item, labelDetailsSupport = false) {
        let labelDetails;
        let label;
        if (item.label2 !== undefined) {
            label = item.label2.name;
            if (labelDetailsSupport) {
                labelDetails = { parameters: item.label2.parameters, qualifier: item.label2.qualifier, type: item.label2.type };
            }
        }
        else {
            label = item.label;
        }
        let result = { label: label };
        if (labelDetails !== undefined) {
            result.labelDetails = labelDetails;
        }
        let protocolItem = item instanceof protocolCompletionItem_1.default ? item : undefined;
        if (item.detail) {
            result.detail = item.detail;
        }
        // We only send items back we created. So this can't be something else than
        // a string right now.
        if (item.documentation) {
            if (!protocolItem || protocolItem.documentationFormat === '$string') {
                result.documentation = item.documentation;
            }
            else {
                result.documentation = asDocumentation(protocolItem.documentationFormat, item.documentation);
            }
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        fillPrimaryInsertText(result, item);
        if (Is.number(item.kind)) {
            result.kind = asCompletionItemKind(item.kind, protocolItem && protocolItem.originalItemKind);
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (item.commitCharacters) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        const tags = asCompletionItemTags(item.tags);
        if (protocolItem) {
            if (protocolItem.data !== undefined) {
                result.data = protocolItem.data;
            }
            if (protocolItem.deprecated === true || protocolItem.deprecated === false) {
                if (protocolItem.deprecated === true && tags !== undefined && tags.length > 0) {
                    const index = tags.indexOf(code.CompletionItemTag.Deprecated);
                    if (index !== -1) {
                        tags.splice(index, 1);
                    }
                }
                result.deprecated = protocolItem.deprecated;
            }
            if (protocolItem.insertTextMode !== undefined) {
                result.insertTextMode = protocolItem.insertTextMode;
            }
        }
        if (tags !== undefined && tags.length > 0) {
            result.tags = tags;
        }
        if (result.insertTextMode === undefined && item.keepWhitespace === true) {
            result.insertTextMode = vscode_languageserver_protocol_1.InsertTextMode.adjustIndentation;
        }
        return result;
    }
    function fillPrimaryInsertText(target, source) {
        let format = proto.InsertTextFormat.PlainText;
        let text = undefined;
        let range = undefined;
        if (source.textEdit) {
            text = source.textEdit.newText;
            range = source.textEdit.range;
        }
        else if (source.insertText instanceof code.SnippetString) {
            format = proto.InsertTextFormat.Snippet;
            text = source.insertText.value;
        }
        else {
            text = source.insertText;
        }
        if (source.range) {
            range = source.range;
        }
        target.insertTextFormat = format;
        if (source.fromEdit && text !== undefined && range !== undefined) {
            target.textEdit = asCompletionTextEdit(text, range);
        }
        else {
            target.insertText = text;
        }
    }
    function asCompletionTextEdit(newText, range) {
        if (InsertReplaceRange.is(range)) {
            return proto.InsertReplaceEdit.create(newText, asRange(range.inserting), asRange(range.replacing));
        }
        else {
            return { newText, range: asRange(range) };
        }
    }
    function asTextEdit(edit) {
        return { range: asRange(edit.range), newText: edit.newText };
    }
    function asTextEdits(edits) {
        if (edits === undefined || edits === null) {
            return edits;
        }
        return edits.map(asTextEdit);
    }
    function asSymbolKind(item) {
        if (item <= code.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return (item + 1);
        }
        return proto.SymbolKind.Property;
    }
    function asSymbolTag(item) {
        return item;
    }
    function asSymbolTags(items) {
        return items.map(asSymbolTag);
    }
    function asReferenceParams(textDocument, position, options) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument),
            position: asWorkerPosition(position),
            context: { includeDeclaration: options.includeDeclaration }
        };
    }
    function asCodeAction(item) {
        let result = proto.CodeAction.create(item.title);
        if (item instanceof protocolCodeAction_1.default && item.data !== undefined) {
            result.data = item.data;
        }
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            throw new Error(`VS Code code actions can only be converted to a protocol code action without an edit.`);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeActionContext(context) {
        if (context === undefined || context === null) {
            return context;
        }
        let only;
        if (context.only && Is.string(context.only.value)) {
            only = [context.only.value];
        }
        return proto.CodeActionContext.create(asDiagnostics(context.diagnostics), only);
    }
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        return item.value;
    }
    function asCommand(item) {
        let result = proto.Command.create(item.title, item.command);
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCodeLens(item) {
        let result = proto.CodeLens.create(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item instanceof protocolCodeLens_1.default) {
            if (item.data) {
                result.data = item.data;
            }
        }
        return result;
    }
    function asFormattingOptions(options, fileOptions) {
        const result = { tabSize: options.tabSize, insertSpaces: options.insertSpaces };
        if (fileOptions.trimTrailingWhitespace) {
            result.trimTrailingWhitespace = true;
        }
        if (fileOptions.trimFinalNewlines) {
            result.trimFinalNewlines = true;
        }
        if (fileOptions.insertFinalNewline) {
            result.insertFinalNewline = true;
        }
        return result;
    }
    function asDocumentSymbolParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCodeLensParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asDocumentLink(item) {
        let result = proto.DocumentLink.create(asRange(item.range));
        if (item.target) {
            result.target = asUri(item.target);
        }
        if (item.tooltip !== undefined) {
            result.tooltip = item.tooltip;
        }
        let protocolItem = item instanceof protocolDocumentLink_1.default ? item : undefined;
        if (protocolItem && protocolItem.data) {
            result.data = protocolItem.data;
        }
        return result;
    }
    function asDocumentLinkParams(textDocument) {
        return {
            textDocument: asTextDocumentIdentifier(textDocument)
        };
    }
    function asCallHierarchyItem(value) {
        const result = {
            name: value.name,
            kind: asSymbolKind(value.kind),
            uri: asUri(value.uri),
            range: asRange(value.range),
            selectionRange: asRange(value.selectionRange)
        };
        if (value.detail !== undefined && value.detail.length > 0) {
            result.detail = value.detail;
        }
        if (value.tags !== undefined) {
            result.tags = asSymbolTags(value.tags);
        }
        if (value instanceof protocolCallHierarchyItem_1.default && value.data !== undefined) {
            result.data = value.data;
        }
        return result;
    }
    return {
        asUri,
        asTextDocumentIdentifier,
        asVersionedTextDocumentIdentifier,
        asOpenTextDocumentParams,
        asChangeTextDocumentParams,
        asCloseTextDocumentParams,
        asSaveTextDocumentParams,
        asWillSaveTextDocumentParams,
        asDidCreateFilesParams,
        asDidRenameFilesParams,
        asDidDeleteFilesParams,
        asWillCreateFilesParams,
        asWillRenameFilesParams,
        asWillDeleteFilesParams,
        asTextDocumentPositionParams,
        asCompletionParams,
        asSignatureHelpParams,
        asWorkerPosition,
        asRange,
        asPosition,
        asPositions,
        asLocation,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asDiagnostic,
        asDiagnostics,
        asCompletionItem,
        asTextEdit,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asReferenceParams,
        asCodeAction,
        asCodeActionContext,
        asCommand,
        asCodeLens,
        asFormattingOptions,
        asDocumentSymbolParams,
        asCodeLensParams,
        asDocumentLink,
        asDocumentLinkParams,
        asCallHierarchyItem
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=codeConverter.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/colorProvider.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/colorProvider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorProviderFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ColorProviderFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DocumentColorRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'colorProvider').dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.colorProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideColorPresentations: (color, context, token) => {
                const client = this._client;
                const provideColorPresentations = (color, context, token) => {
                    const requestParams = {
                        color,
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(context.document),
                        range: client.code2ProtocolConverter.asRange(context.range)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, requestParams, token).then(this.asColorPresentations.bind(this), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideColorPresentations
                    ? middleware.provideColorPresentations(color, context, token, provideColorPresentations)
                    : provideColorPresentations(color, context, token);
            },
            provideDocumentColors: (document, token) => {
                const client = this._client;
                const provideDocumentColors = (document, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, requestParams, token).then(this.asColorInformations.bind(this), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDocumentColors
                    ? middleware.provideDocumentColors(document, token, provideDocumentColors)
                    : provideDocumentColors(document, token);
            }
        };
        return [vscode_1.languages.registerColorProvider(options.documentSelector, provider), provider];
    }
    asColor(color) {
        return new vscode_1.Color(color.red, color.green, color.blue, color.alpha);
    }
    asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(ci => {
                return new vscode_1.ColorInformation(this._client.protocol2CodeConverter.asRange(ci.range), this.asColor(ci.color));
            });
        }
        return [];
    }
    asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(cp => {
                let presentation = new vscode_1.ColorPresentation(cp.label);
                presentation.additionalTextEdits = this._client.protocol2CodeConverter.asTextEdits(cp.additionalTextEdits);
                presentation.textEdit = this._client.protocol2CodeConverter.asTextEdit(cp.textEdit);
                return presentation;
            });
        }
        return [];
    }
}
exports.ColorProviderFeature = ColorProviderFeature;
//# sourceMappingURL=colorProvider.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/commonClient.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/commonClient.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProposedFeatures = exports.CommonLanguageClient = void 0;
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
const colorProvider_1 = __webpack_require__(/*! ./colorProvider */ "./node_modules/vscode-languageclient/lib/common/colorProvider.js");
const configuration_1 = __webpack_require__(/*! ./configuration */ "./node_modules/vscode-languageclient/lib/common/configuration.js");
const implementation_1 = __webpack_require__(/*! ./implementation */ "./node_modules/vscode-languageclient/lib/common/implementation.js");
const typeDefinition_1 = __webpack_require__(/*! ./typeDefinition */ "./node_modules/vscode-languageclient/lib/common/typeDefinition.js");
const workspaceFolders_1 = __webpack_require__(/*! ./workspaceFolders */ "./node_modules/vscode-languageclient/lib/common/workspaceFolders.js");
const foldingRange_1 = __webpack_require__(/*! ./foldingRange */ "./node_modules/vscode-languageclient/lib/common/foldingRange.js");
const declaration_1 = __webpack_require__(/*! ./declaration */ "./node_modules/vscode-languageclient/lib/common/declaration.js");
const selectionRange_1 = __webpack_require__(/*! ./selectionRange */ "./node_modules/vscode-languageclient/lib/common/selectionRange.js");
const progress_1 = __webpack_require__(/*! ./progress */ "./node_modules/vscode-languageclient/lib/common/progress.js");
const callHierarchy_1 = __webpack_require__(/*! ./callHierarchy */ "./node_modules/vscode-languageclient/lib/common/callHierarchy.js");
const semanticTokens_1 = __webpack_require__(/*! ./semanticTokens */ "./node_modules/vscode-languageclient/lib/common/semanticTokens.js");
const fileOperations_1 = __webpack_require__(/*! ./fileOperations */ "./node_modules/vscode-languageclient/lib/common/fileOperations.js");
const linkedEditingRange_1 = __webpack_require__(/*! ./linkedEditingRange */ "./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js");
class CommonLanguageClient extends client_1.BaseLanguageClient {
    constructor(id, name, clientOptions) {
        super(id, name, clientOptions);
    }
    registerProposedFeatures() {
        this.registerFeatures(ProposedFeatures.createAll(this));
    }
    registerBuiltinFeatures() {
        super.registerBuiltinFeatures();
        this.registerFeature(new configuration_1.ConfigurationFeature(this));
        this.registerFeature(new typeDefinition_1.TypeDefinitionFeature(this));
        this.registerFeature(new implementation_1.ImplementationFeature(this));
        this.registerFeature(new colorProvider_1.ColorProviderFeature(this));
        this.registerFeature(new workspaceFolders_1.WorkspaceFoldersFeature(this));
        this.registerFeature(new foldingRange_1.FoldingRangeFeature(this));
        this.registerFeature(new declaration_1.DeclarationFeature(this));
        this.registerFeature(new selectionRange_1.SelectionRangeFeature(this));
        this.registerFeature(new progress_1.ProgressFeature(this));
        this.registerFeature(new callHierarchy_1.CallHierarchyFeature(this));
        this.registerFeature(new semanticTokens_1.SemanticTokensFeature(this));
        this.registerFeature(new linkedEditingRange_1.LinkedEditingFeature(this));
        this.registerFeature(new fileOperations_1.DidCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.DidDeleteFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillCreateFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillRenameFilesFeature(this));
        this.registerFeature(new fileOperations_1.WillDeleteFilesFeature(this));
    }
}
exports.CommonLanguageClient = CommonLanguageClient;
// Exporting proposed protocol.
const pd = __webpack_require__(/*! ./proposed.diagnostic */ "./node_modules/vscode-languageclient/lib/common/proposed.diagnostic.js");
var ProposedFeatures;
(function (ProposedFeatures) {
    function createAll(_client) {
        let result = [
            new pd.DiagnosticFeature(_client)
        ];
        return result;
    }
    ProposedFeatures.createAll = createAll;
})(ProposedFeatures = exports.ProposedFeatures || (exports.ProposedFeatures = {}));
//# sourceMappingURL=commonClient.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/configuration.js":
/*!************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/configuration.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toJSONObject = exports.ConfigurationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
class ConfigurationFeature {
    constructor(_client) {
        this._client = _client;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.configuration = true;
    }
    initialize() {
        let client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, (params, token) => {
            let configuration = (params) => {
                let result = [];
                for (let item of params.items) {
                    let resource = item.scopeUri !== void 0 && item.scopeUri !== null ? this._client.protocol2CodeConverter.asUri(item.scopeUri) : undefined;
                    result.push(this.getConfiguration(resource, item.section !== null ? item.section : undefined));
                }
                return result;
            };
            let middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.configuration
                ? middleware.configuration(params, token, configuration)
                : configuration(params, token);
        });
    }
    getConfiguration(resource, section) {
        let result = null;
        if (section) {
            let index = section.lastIndexOf('.');
            if (index === -1) {
                result = toJSONObject(vscode_1.workspace.getConfiguration(undefined, resource).get(section));
            }
            else {
                let config = vscode_1.workspace.getConfiguration(section.substr(0, index), resource);
                if (config) {
                    result = toJSONObject(config.get(section.substr(index + 1)));
                }
            }
        }
        else {
            let config = vscode_1.workspace.getConfiguration(undefined, resource);
            result = {};
            for (let key of Object.keys(config)) {
                if (config.has(key)) {
                    result[key] = toJSONObject(config.get(key));
                }
            }
        }
        if (result === undefined) {
            result = null;
        }
        return result;
    }
    dispose() {
    }
}
exports.ConfigurationFeature = ConfigurationFeature;
function toJSONObject(obj) {
    if (obj) {
        if (Array.isArray(obj)) {
            return obj.map(toJSONObject);
        }
        else if (typeof obj === 'object') {
            const res = Object.create(null);
            for (const key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    res[key] = toJSONObject(obj[key]);
                }
            }
            return res;
        }
    }
    return obj;
}
exports.toJSONObject = toJSONObject;
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/declaration.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/declaration.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class DeclarationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.DeclarationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const declarationSupport = ensure(ensure(capabilities, 'textDocument'), 'declaration');
        declarationSupport.dynamicRegistration = true;
        declarationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const [id, options] = this.getRegistration(documentSelector, capabilities.declarationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideDeclaration: (document, position, token) => {
                const client = this._client;
                const provideDeclaration = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDeclarationResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideDeclaration
                    ? middleware.provideDeclaration(document, position, token, provideDeclaration)
                    : provideDeclaration(document, position, token);
            }
        };
        return [vscode_1.languages.registerDeclarationProvider(options.documentSelector, provider), provider];
    }
}
exports.DeclarationFeature = DeclarationFeature;
//# sourceMappingURL=declaration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/fileOperations.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/fileOperations.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
function access(target, key) {
    return target[key];
}
function assign(target, key, value) {
    target[key] = value;
}
class FileOperationFeature {
    constructor(client, event, registrationType, clientCapability, serverCapability) {
        this._filters = new Map();
        this._client = client;
        this._event = event;
        this._registrationType = registrationType;
        this._clientCapability = clientCapability;
        this._serverCapability = serverCapability;
    }
    get registrationType() {
        return this._registrationType;
    }
    fillClientCapabilities(capabilities) {
        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');
        // this happens n times but it is the same value so we tolerate this.
        assign(value, 'dynamicRegistration', true);
        assign(value, this._clientCapability, true);
    }
    initialize(capabilities) {
        var _a;
        const options = (_a = capabilities.workspace) === null || _a === void 0 ? void 0 : _a.fileOperations;
        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;
        if ((capability === null || capability === void 0 ? void 0 : capability.filters) !== undefined) {
            try {
                this.register({
                    id: UUID.generateUuid(),
                    registerOptions: { filters: capability.filters }
                });
            }
            catch (e) {
                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);
            }
        }
    }
    register(data) {
        if (!this._listener) {
            this._listener = this._event(this.send, this);
        }
        const minimatchFilter = data.registerOptions.filters.map((filter) => {
            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));
            if (!matcher.makeRe()) {
                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);
            }
            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };
        });
        this._filters.set(data.id, minimatchFilter);
    }
    unregister(id) {
        this._filters.delete(id);
        if (this._filters.size === 0 && this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    dispose() {
        this._filters.clear();
        if (this._listener) {
            this._listener.dispose();
            this._listener = undefined;
        }
    }
    async filter(event, prop) {
        // (Asynchronously) map each file onto a boolean of whether it matches
        // any of the globs.
        const fileMatches = await Promise.all(event.files.map(async (item) => {
            const uri = prop(item);
            // Use fsPath to make this consistent with file system watchers but help
            // minimatch to use '/' instead of `\\` if present.
            const path = uri.fsPath.replace(/\\/g, '/');
            for (const filters of this._filters.values()) {
                for (const filter of filters) {
                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {
                        continue;
                    }
                    if (filter.matcher.match(path)) {
                        // The pattern matches. If kind is undefined then everything is ok
                        if (filter.kind === undefined) {
                            return true;
                        }
                        const fileType = await FileOperationFeature.getFileType(uri);
                        // If we can't determine the file type than we treat it as a match.
                        // Dropping it would be another alternative.
                        if (fileType === undefined) {
                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);
                            return true;
                        }
                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {
                            return true;
                        }
                    }
                    else if (filter.kind === proto.FileOperationPatternKind.folder) {
                        const fileType = await FileOperationFeature.getFileType(uri);
                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }));
        // Filter the files to those that matched.
        const files = event.files.filter((_, index) => fileMatches[index]);
        return Object.assign(Object.assign({}, event), { files });
    }
    static async getFileType(uri) {
        try {
            return (await code.workspace.fs.stat(uri)).type;
        }
        catch (e) {
            return undefined;
        }
    }
    static asMinimatchOptions(options) {
        if (options === undefined) {
            return undefined;
        }
        if (options.ignoreCase === true) {
            return { nocase: true };
        }
        return undefined;
    }
}
class NotificationFileOperationFeature extends FileOperationFeature {
    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, notificationType, clientCapability, serverCapability);
        this._notificationType = notificationType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = async (event) => {
                this._client.sendNotification(this._notificationType, this._createParams(event));
            };
            this.doSend(filteredEvent, next);
        }
    }
}
class DidCreateFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didCreateFiles)
            ? middleware.didCreateFiles(event, next)
            : next(event);
    }
}
exports.DidCreateFilesFeature = DidCreateFilesFeature;
class DidRenameFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didRenameFiles)
            ? middleware.didRenameFiles(event, next)
            : next(event);
    }
}
exports.DidRenameFilesFeature = DidRenameFilesFeature;
class DidDeleteFilesFeature extends NotificationFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.didDeleteFiles)
            ? middleware.didDeleteFiles(event, next)
            : next(event);
    }
}
exports.DidDeleteFilesFeature = DidDeleteFilesFeature;
class RequestFileOperationFeature extends FileOperationFeature {
    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {
        super(client, event, requestType, clientCapability, serverCapability);
        this._requestType = requestType;
        this._accessUri = accessUri;
        this._createParams = createParams;
    }
    async send(originalEvent) {
        const waitUntil = this.waitUntil(originalEvent);
        originalEvent.waitUntil(waitUntil);
    }
    async waitUntil(originalEvent) {
        // Create a copy of the event that has the files filtered to match what the
        // server wants.
        const filteredEvent = await this.filter(originalEvent, this._accessUri);
        if (filteredEvent.files.length) {
            const next = (event) => {
                return this._client.sendRequest(this._requestType, this._createParams(event))
                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);
            };
            return this.doSend(filteredEvent, next);
        }
        else {
            return undefined;
        }
    }
}
class WillCreateFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willCreateFiles)
            ? middleware.willCreateFiles(event, next)
            : next(event);
    }
}
exports.WillCreateFilesFeature = WillCreateFilesFeature;
class WillRenameFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willRenameFiles)
            ? middleware.willRenameFiles(event, next)
            : next(event);
    }
}
exports.WillRenameFilesFeature = WillRenameFilesFeature;
class WillDeleteFilesFeature extends RequestFileOperationFeature {
    constructor(client) {
        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);
    }
    doSend(event, next) {
        var _a;
        const middleware = (_a = this._client.clientOptions.middleware) === null || _a === void 0 ? void 0 : _a.workspace;
        return (middleware === null || middleware === void 0 ? void 0 : middleware.willDeleteFiles)
            ? middleware.willDeleteFiles(event, next)
            : next(event);
    }
}
exports.WillDeleteFilesFeature = WillDeleteFilesFeature;
//# sourceMappingURL=fileOperations.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/foldingRange.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/foldingRange.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class FoldingRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.FoldingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'foldingRange');
        capability.dynamicRegistration = true;
        capability.rangeLimit = 5000;
        capability.lineFoldingOnly = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.foldingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideFoldingRanges: (document, context, token) => {
                const client = this._client;
                const provideFoldingRanges = (document, _, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, requestParams, token).then(FoldingRangeFeature.asFoldingRanges, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideFoldingRanges
                    ? middleware.provideFoldingRanges(document, context, token, provideFoldingRanges)
                    : provideFoldingRanges(document, context, token);
            }
        };
        return [vscode_1.languages.registerFoldingRangeProvider(options.documentSelector, provider), provider];
    }
    static asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case vscode_languageserver_protocol_1.FoldingRangeKind.Comment:
                    return vscode_1.FoldingRangeKind.Comment;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Imports:
                    return vscode_1.FoldingRangeKind.Imports;
                case vscode_languageserver_protocol_1.FoldingRangeKind.Region:
                    return vscode_1.FoldingRangeKind.Region;
            }
        }
        return void 0;
    }
    static asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(r => {
                return new vscode_1.FoldingRange(r.startLine, r.endLine, FoldingRangeFeature.asFoldingRangeKind(r.kind));
            });
        }
        return [];
    }
}
exports.FoldingRangeFeature = FoldingRangeFeature;
//# sourceMappingURL=foldingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/implementation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/implementation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class ImplementationFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.ImplementationRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let implementationSupport = ensure(ensure(capabilities, 'textDocument'), 'implementation');
        implementationSupport.dynamicRegistration = true;
        implementationSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.implementationProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideImplementation: (document, position, token) => {
                const client = this._client;
                const provideImplementation = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideImplementation
                    ? middleware.provideImplementation(document, position, token, provideImplementation)
                    : provideImplementation(document, position, token);
            }
        };
        return [vscode_1.languages.registerImplementationProvider(options.documentSelector, provider), provider];
    }
}
exports.ImplementationFeature = ImplementationFeature;
//# sourceMappingURL=implementation.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/linkedEditingRange.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/vscode-proposed.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingFeature = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const proto = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class LinkedEditingFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, proto.LinkedEditingRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        const linkedEditingSupport = ensure(ensure(capabilities, 'textDocument'), 'linkedEditingRange');
        linkedEditingSupport.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.linkedEditingRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideLinkedEditingRanges: (document, position, token) => {
                const client = this._client;
                const provideLinkedEditing = (document, position, token) => {
                    return client.sendRequest(proto.LinkedEditingRangeRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asLinkedEditingRanges, (error) => {
                        return client.handleFailedRequest(proto.LinkedEditingRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideLinkedEditingRange
                    ? middleware.provideLinkedEditingRange(document, position, token, provideLinkedEditing)
                    : provideLinkedEditing(document, position, token);
            }
        };
        return [code.languages.registerLinkedEditingRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.LinkedEditingFeature = LinkedEditingFeature;
//# sourceMappingURL=linkedEditingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/progress.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/progress.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressFeature = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const progressPart_1 = __webpack_require__(/*! ./progressPart */ "./node_modules/vscode-languageclient/lib/common/progressPart.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class ProgressFeature {
    constructor(_client) {
        this._client = _client;
        this.activeParts = new Set();
    }
    fillClientCapabilities(capabilities) {
        ensure(capabilities, 'window').workDoneProgress = true;
    }
    initialize() {
        const client = this._client;
        const deleteHandler = (part) => {
            this.activeParts.delete(part);
        };
        const createHandler = (params) => {
            this.activeParts.add(new progressPart_1.ProgressPart(this._client, params.token, deleteHandler));
        };
        client.onRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, createHandler);
    }
    dispose() {
        for (const part of this.activeParts) {
            part.done();
        }
        this.activeParts.clear();
    }
}
exports.ProgressFeature = ProgressFeature;
//# sourceMappingURL=progress.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/progressPart.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/progressPart.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProgressPart = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
class ProgressPart {
    constructor(_client, _token, done) {
        this._client = _client;
        this._token = _token;
        this._reported = 0;
        this._disposable = this._client.onProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, (value) => {
            switch (value.kind) {
                case 'begin':
                    this.begin(value);
                    break;
                case 'report':
                    this.report(value);
                    break;
                case 'end':
                    this.done();
                    done && done(this);
                    break;
            }
        });
    }
    begin(params) {
        // Since we don't use commands this will be a silent window progress with a hidden notification.
        void vscode_1.window.withProgress({ location: vscode_1.ProgressLocation.Window, cancellable: params.cancellable, title: params.title }, async (progress, cancellationToken) => {
            this._progress = progress;
            this._infinite = params.percentage === undefined;
            this._cancellationToken = cancellationToken;
            this._cancellationToken.onCancellationRequested(() => {
                this._client.sendNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, { token: this._token });
            });
            this.report(params);
            return new Promise((resolve, reject) => {
                this._resolve = resolve;
                this._reject = reject;
            });
        });
    }
    report(params) {
        if (this._infinite && Is.string(params.message)) {
            this._progress.report({ message: params.message });
        }
        else if (Is.number(params.percentage)) {
            let percentage = Math.max(0, Math.min(params.percentage, 100));
            let delta = Math.max(0, percentage - this._reported);
            this._progress.report({ message: params.message, increment: delta });
            this._reported += delta;
        }
    }
    cancel() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._reject) {
            this._reject();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
    done() {
        if (this._disposable) {
            this._disposable.dispose();
            this._disposable = undefined;
        }
        if (this._resolve) {
            this._resolve();
            this._resolve = undefined;
            this._reject = undefined;
        }
    }
}
exports.ProgressPart = ProgressPart;
//# sourceMappingURL=progressPart.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/proposed.diagnostic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/proposed.diagnostic.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticFeature = exports.vsdiag = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const uuid_1 = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
var vsdiag;
(function (vsdiag) {
    let DocumentDiagnosticReportKind;
    (function (DocumentDiagnosticReportKind) {
        DocumentDiagnosticReportKind["full"] = "full";
        DocumentDiagnosticReportKind["unChanged"] = "unChanged";
    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));
})(vsdiag = exports.vsdiag || (exports.vsdiag = {}));
var RequestStateKind;
(function (RequestStateKind) {
    RequestStateKind["active"] = "open";
    RequestStateKind["reschedule"] = "reschedule";
    RequestStateKind["outDated"] = "drop";
})(RequestStateKind || (RequestStateKind = {}));
class EditorTracker {
    constructor() {
        this.open = new Set();
        const openEditorsHandler = () => {
            this.open.clear();
            for (const info of vscode_1.window.openEditors) {
                this.open.add(info.resource.toString());
            }
        };
        openEditorsHandler();
        this.disposable = vscode_1.window.onDidChangeOpenEditors(openEditorsHandler);
    }
    dispose() {
        this.disposable.dispose();
    }
    isActive(textDocument) {
        var _a;
        return ((_a = vscode_1.window.activeTextEditor) === null || _a === void 0 ? void 0 : _a.document) === textDocument;
    }
    isVisible(textDocument) {
        return this.open.has(textDocument.uri.toString());
    }
}
var PullState;
(function (PullState) {
    PullState[PullState["document"] = 1] = "document";
    PullState[PullState["workspace"] = 2] = "workspace";
})(PullState || (PullState = {}));
class DocumentPullStateTracker {
    constructor() {
        this.documentPullStates = new Map();
        this.workspacePullStates = new Map();
    }
    track(kind, document, arg1, arg2) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        const [key, uri, version, resultId] = typeof document === 'string'
            ? [document, vscode_1.Uri.parse(document), arg1, arg2]
            : [document.uri.toString(), document.uri, document.version, arg1];
        let state = states.get(key);
        if (state === undefined) {
            state = { document: uri, pulledVersion: version, resultId };
            states.set(key, state);
        }
        else {
            state.pulledVersion = version;
            state.resultId = resultId;
        }
        return state;
    }
    unTrack(kind, textDocument) {
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        states.delete(textDocument.uri.toString());
    }
    tracks(kind, document) {
        const key = typeof document === 'string' ? document : document.uri.toString();
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return states.has(key);
    }
    getResultId(kind, textDocument) {
        var _a;
        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;
        return (_a = states.get(textDocument.uri.toString())) === null || _a === void 0 ? void 0 : _a.resultId;
    }
    getAllResultIds() {
        const result = [];
        for (let [uri, value] of this.workspacePullStates) {
            if (this.documentPullStates.has(uri)) {
                value = this.documentPullStates.get(uri);
            }
            if (value.resultId !== undefined) {
                result.push({ uri, value: value.resultId });
            }
        }
        return result;
    }
}
class DiagnosticRequestor {
    constructor(client, editorTracker, options) {
        this.client = client;
        this.editorTracker = editorTracker;
        this.options = options;
        this.isDisposed = false;
        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();
        this.provider = this.createProvider();
        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);
        this.openRequests = new Map();
        this.documentStates = new DocumentPullStateTracker();
        this.workspaceErrorCounter = 0;
    }
    knows(kind, textDocument) {
        return this.documentStates.tracks(kind, textDocument);
    }
    pull(textDocument, cb) {
        this.pullAsync(textDocument).then(() => {
            if (cb) {
                cb();
            }
        }, (error) => {
            this.client.error(`Document pull failed for text document ${textDocument.uri.toString()}`, error, false);
        });
    }
    async pullAsync(textDocument) {
        var _a;
        const key = textDocument.uri.toString();
        const currentRequestState = this.openRequests.get(key);
        const documentState = this.documentStates.track(PullState.document, textDocument);
        if (currentRequestState === undefined) {
            const tokenSource = new vscode_1.CancellationTokenSource();
            this.openRequests.set(key, { state: RequestStateKind.active, version: textDocument.version, textDocument, tokenSource });
            let report;
            let afterState;
            try {
                report = (_a = await this.provider.provideDiagnostics(textDocument, this.documentStates.getResultId(PullState.document, textDocument), tokenSource.token)) !== null && _a !== void 0 ? _a : { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
            }
            catch (error) {
                if (error instanceof client_1.LSPCancellationError && vscode_languageserver_protocol_1.Proposed.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {
                    afterState = { state: RequestStateKind.outDated, textDocument };
                }
                if (afterState === undefined && error instanceof vscode_1.CancellationError) {
                    afterState = { state: RequestStateKind.reschedule, textDocument };
                }
                else {
                    throw error;
                }
            }
            afterState = afterState !== null && afterState !== void 0 ? afterState : this.openRequests.get(key);
            if (afterState === undefined) {
                // This shouldn't happen. Log it
                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);
                this.diagnostics.delete(textDocument.uri);
                return;
            }
            this.openRequests.delete(key);
            if (!this.editorTracker.isVisible(textDocument)) {
                this.documentStates.unTrack(PullState.document, textDocument);
                return;
            }
            if (afterState.state === RequestStateKind.outDated) {
                return;
            }
            // report is only undefined if the request has thrown.
            if (report !== undefined) {
                if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    this.diagnostics.set(textDocument.uri, report.items);
                }
                documentState.resultId = report.resultId;
            }
            if (afterState.state === RequestStateKind.reschedule) {
                this.pull(textDocument);
            }
        }
        else {
            if (currentRequestState.state === RequestStateKind.active) {
                // Cancel the current request and reschedule a new one when the old one returned.
                currentRequestState.tokenSource.cancel();
                this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument: currentRequestState.textDocument });
            }
            else if (currentRequestState.state === RequestStateKind.outDated) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument: currentRequestState.textDocument });
            }
        }
    }
    cleanupPull(textDocument) {
        const key = textDocument.uri.toString();
        const request = this.openRequests.get(key);
        if (this.options.workspaceDiagnostics || this.options.interFileDependencies) {
            if (request !== undefined) {
                this.openRequests.set(key, { state: RequestStateKind.reschedule, textDocument: textDocument });
            }
            else {
                this.pull(textDocument);
            }
        }
        else {
            if (request !== undefined) {
                if (request.state === RequestStateKind.active) {
                    request.tokenSource.cancel();
                }
                this.openRequests.set(key, { state: RequestStateKind.outDated, textDocument: textDocument });
            }
            this.diagnostics.delete(textDocument.uri);
        }
    }
    pullWorkspace() {
        this.pullWorkspaceAsync().then(() => {
            this.workspaceTimeout = vscode_languageserver_protocol_1.RAL().timer.setTimeout(() => {
                this.pullWorkspace();
            }, 2000);
        }, (error) => {
            if (!(error instanceof client_1.LSPCancellationError) && !vscode_languageserver_protocol_1.Proposed.DiagnosticServerCancellationData.is(error.data)) {
                this.client.error(`Workspace diagnostic pull failed.`, error, false);
                this.workspaceErrorCounter++;
            }
            if (this.workspaceErrorCounter <= 5) {
                this.workspaceTimeout = vscode_languageserver_protocol_1.RAL().timer.setTimeout(() => {
                    this.pullWorkspace();
                }, 2000);
            }
        });
    }
    async pullWorkspaceAsync() {
        if (!this.provider.provideWorkspaceDiagnostics) {
            return;
        }
        if (this.workspaceCancellation !== undefined) {
            this.workspaceCancellation.cancel();
            this.workspaceCancellation = undefined;
        }
        this.workspaceCancellation = new vscode_1.CancellationTokenSource();
        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {
            return {
                uri: this.client.protocol2CodeConverter.asUri(item.uri),
                value: item.value
            };
        });
        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {
            var _a;
            if (!chunk || this.isDisposed) {
                return;
            }
            for (const item of chunk.items) {
                if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {
                    // Favour document pull result over workspace results. So skip if it is tracked
                    // as a document result.
                    if (!this.documentStates.tracks(PullState.document, item.uri.toString())) {
                        this.diagnostics.set(item.uri, item.items);
                    }
                }
                this.documentStates.track(PullState.workspace, item.uri.toString(), (_a = item.version) !== null && _a !== void 0 ? _a : undefined, item.resultId);
            }
        });
    }
    createProvider() {
        const result = {
            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,
            provideDiagnostics: (textDocument, previousResultId, token) => {
                const provideDiagnostics = (textDocument, previousResultId, token) => {
                    const params = {
                        identifier: this.options.identifier,
                        textDocument: { uri: this.client.code2ProtocolConverter.asUri(textDocument.uri) },
                        previousResultId: previousResultId
                    };
                    return this.client.sendRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, params, token).then((result) => {
                        if (result === undefined || result === null || this.isDisposed) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };
                        }
                        if (result.kind === vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticReportKind.full) {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result.resultId, items: this.client.protocol2CodeConverter.asDiagnostics(result.items) };
                        }
                        else {
                            return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result.resultId };
                        }
                    }, (error) => {
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, token, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });
                    });
                };
                const middleware = this.client.clientOptions.middleware;
                return middleware.provideDiagnostics
                    ? middleware.provideDiagnostics(textDocument, previousResultId, token, provideDiagnostics)
                    : provideDiagnostics(textDocument, previousResultId, token);
            }
        };
        if (this.options.workspaceDiagnostics) {
            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {
                const convertReport = (report) => {
                    if (report.kind === vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticReportKind.full) {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.full,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version,
                            items: this.client.protocol2CodeConverter.asDiagnostics(report.items)
                        };
                    }
                    else {
                        return {
                            kind: vsdiag.DocumentDiagnosticReportKind.unChanged,
                            uri: this.client.protocol2CodeConverter.asUri(report.uri),
                            resultId: report.resultId,
                            version: report.version
                        };
                    }
                };
                const convertPreviousResultIds = (resultIds) => {
                    const converted = [];
                    for (const item of resultIds) {
                        converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });
                    }
                    return converted;
                };
                const provideDiagnostics = (resultIds, token) => {
                    const partialResultToken = uuid_1.generateUuid();
                    const disposable = this.client.onProgress(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.partialResult, partialResultToken, (partialResult) => {
                        if (partialResult === undefined || partialResult === null) {
                            resultReporter(null);
                            return;
                        }
                        const converted = {
                            items: []
                        };
                        for (const item of partialResult.items) {
                            converted.items.push(convertReport(item));
                        }
                        resultReporter(converted);
                    });
                    const params = {
                        identifier: this.options.identifier,
                        previousResultIds: convertPreviousResultIds(resultIds),
                        partialResultToken: partialResultToken
                    };
                    return this.client.sendRequest(vscode_languageserver_protocol_1.Proposed.WorkspaceDiagnosticRequest.type, params, token).then((result) => {
                        const converted = {
                            items: []
                        };
                        for (const item of result.items) {
                            converted.items.push(convertReport(item));
                        }
                        disposable.dispose();
                        resultReporter(converted);
                        return { items: [] };
                    }, (error) => {
                        disposable.dispose();
                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type, token, error, { items: [] });
                    });
                };
                const middleware = this.client.clientOptions.middleware;
                return middleware.provideWorkspaceDiagnostics
                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics)
                    : provideDiagnostics(resultIds, token, resultReporter);
            };
        }
        return result;
    }
    dispose() {
        var _a, _b;
        this.isDisposed = true;
        // Cancel and clear workspace pull if present.
        (_a = this.workspaceCancellation) === null || _a === void 0 ? void 0 : _a.cancel();
        (_b = this.workspaceTimeout) === null || _b === void 0 ? void 0 : _b.dispose();
        // Cancel all request and mark open requests as outdated.
        for (const [key, request] of this.openRequests) {
            if (request.state === RequestStateKind.active) {
                request.tokenSource.cancel();
            }
            this.openRequests.set(key, { state: RequestStateKind.outDated, textDocument: request.textDocument });
        }
    }
}
class BackgroundScheduler {
    constructor(diagnosticRequestor) {
        this.diagnosticRequestor = diagnosticRequestor;
        this.documents = new vscode_languageserver_protocol_1.LinkedMap();
    }
    add(textDocument) {
        const key = textDocument.uri.toString();
        if (this.documents.has(key)) {
            return;
        }
        this.documents.set(textDocument.uri.toString(), textDocument, vscode_languageserver_protocol_1.Touch.Last);
        this.trigger();
    }
    remove(textDocument) {
        const key = textDocument.uri.toString();
        if (this.documents.has(key)) {
            this.documents.delete(key);
            // Do a last pull
            this.diagnosticRequestor.pull(textDocument);
        }
        // No more documents. Stop background activity.
        if (this.documents.size === 0) {
            this.stop();
        }
        else if (textDocument === this.endDocument) {
            // Make sure we have a correct last document. It could have
            this.endDocument = this.documents.last;
        }
    }
    trigger() {
        // We have a round running. So simply make sure we run up to the
        // last document
        if (this.intervalHandle !== undefined) {
            this.endDocument = this.documents.last;
            return;
        }
        this.endDocument = this.documents.last;
        this.intervalHandle = vscode_languageserver_protocol_1.RAL().timer.setInterval(() => {
            const document = this.documents.first;
            if (document !== undefined) {
                this.diagnosticRequestor.pull(document);
                this.documents.set(document.uri.toString(), document, vscode_languageserver_protocol_1.Touch.Last);
                if (document === this.endDocument) {
                    this.stop();
                }
            }
        }, 200);
    }
    dispose() {
        this.stop();
        this.documents.clear();
    }
    stop() {
        var _a;
        (_a = this.intervalHandle) === null || _a === void 0 ? void 0 : _a.dispose();
        this.intervalHandle = undefined;
        this.endDocument = undefined;
    }
}
class DiagnosticFeatureProviderImpl {
    constructor(client, editorTracker, options) {
        var _a, _b;
        const diagnosticPullOptions = (_a = client.clientOptions.diagnosticPullOptions) !== null && _a !== void 0 ? _a : { onChange: true, onSave: false };
        const documentSelector = options.documentSelector;
        const disposables = [];
        const matches = (textDocument) => {
            return vscode_1.languages.match(documentSelector, textDocument) > 0 && editorTracker.isVisible(textDocument);
        };
        this.diagnosticRequestor = new DiagnosticRequestor(client, editorTracker, options);
        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);
        const addToBackgroundIfNeeded = (textDocument) => {
            if (!matches(textDocument) || !options.interFileDependencies || this.activeTextDocument === textDocument) {
                return;
            }
            this.backgroundScheduler.add(textDocument);
        };
        this.activeTextDocument = (_b = vscode_1.window.activeTextEditor) === null || _b === void 0 ? void 0 : _b.document;
        vscode_1.window.onDidChangeActiveTextEditor((editor) => {
            const oldActive = this.activeTextDocument;
            this.activeTextDocument = editor === null || editor === void 0 ? void 0 : editor.document;
            if (oldActive !== undefined) {
                addToBackgroundIfNeeded(oldActive);
            }
            if (this.activeTextDocument !== undefined) {
                this.backgroundScheduler.remove(this.activeTextDocument);
            }
        });
        // We always pull on open.
        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);
        disposables.push(openFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }));
        // Pull all diagnostics for documents that are already open
        for (const textDocument of vscode_1.workspace.textDocuments) {
            if (matches(textDocument)) {
                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });
            }
        }
        if (diagnosticPullOptions.onChange) {
            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);
            disposables.push(changeFeature.onNotificationSent(async (event) => {
                const textDocument = event.original.document;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, client_1.DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument) && event.original.contentChanges.length > 0) {
                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        if (diagnosticPullOptions.onSave) {
            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);
            disposables.push(saveFeature.onNotificationSent((event) => {
                const textDocument = event.original;
                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, client_1.DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {
                    this.diagnosticRequestor.pull(event.original, () => { this.backgroundScheduler.trigger(); });
                }
            }));
        }
        // When the document closes clear things up
        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);
        disposables.push(closeFeature.onNotificationSent((event) => {
            const textDocument = event.original;
            this.diagnosticRequestor.cleanupPull(textDocument);
            this.backgroundScheduler.remove(textDocument);
        }));
        // We received a did change from the server.
        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {
            for (const textDocument of vscode_1.workspace.textDocuments) {
                if (matches(textDocument)) {
                    this.diagnosticRequestor.pull(textDocument);
                }
            }
        });
        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.
        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {
            this.diagnosticRequestor.pullWorkspace();
        }
        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);
    }
    get onDidChangeDiagnosticsEmitter() {
        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;
    }
    get diagnostics() {
        return this.diagnosticRequestor.provider;
    }
}
class DiagnosticFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.Proposed.DocumentDiagnosticRequest.type);
        this.editorTracker = new EditorTracker();
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');
        capability.dynamicRegistration = true;
        // We first need to decide how a UI will look with related documents.
        // An easy implementation would be to only show related diagnostics for
        // the active editor.
        capability.relatedDocumentSupport = false;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.Proposed.DiagnosticRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeDiagnosticsEmitter.fire();
            }
        });
        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    dispose() {
        this.editorTracker.dispose();
        super.dispose();
    }
    registerLanguageProvider(options) {
        const provider = new DiagnosticFeatureProviderImpl(this._client, this.editorTracker, options);
        return [provider.disposable, provider];
    }
}
exports.DiagnosticFeature = DiagnosticFeature;
//# sourceMappingURL=proposed.diagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCallHierarchyItem extends code.CallHierarchyItem {
    constructor(kind, name, detail, uri, range, selectionRange, data) {
        super(kind, name, detail, uri, range, selectionRange);
        if (data !== undefined) {
            this.data = data;
        }
    }
}
exports["default"] = ProtocolCallHierarchyItem;
//# sourceMappingURL=protocolCallHierarchyItem.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const vscode = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCodeAction extends vscode.CodeAction {
    constructor(title, data) {
        super(title);
        this.data = data;
    }
}
exports["default"] = ProtocolCodeAction;
//# sourceMappingURL=protocolCodeAction.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCodeLens extends code.CodeLens {
    constructor(range) {
        super(range);
    }
}
exports["default"] = ProtocolCodeLens;
//# sourceMappingURL=protocolCodeLens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolCompletionItem extends code.CompletionItem {
    constructor(label) {
        super(label);
    }
}
exports["default"] = ProtocolCompletionItem;
//# sourceMappingURL=protocolCompletionItem.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolConverter.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolConverter.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
/// <reference path="../../typings/vscode-proposed.d.ts" />
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createConverter = void 0;
const code = __webpack_require__(/*! vscode */ "vscode");
const ls = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const protocolCompletionItem_1 = __webpack_require__(/*! ./protocolCompletionItem */ "./node_modules/vscode-languageclient/lib/common/protocolCompletionItem.js");
const protocolCodeLens_1 = __webpack_require__(/*! ./protocolCodeLens */ "./node_modules/vscode-languageclient/lib/common/protocolCodeLens.js");
const protocolDocumentLink_1 = __webpack_require__(/*! ./protocolDocumentLink */ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js");
const protocolCodeAction_1 = __webpack_require__(/*! ./protocolCodeAction */ "./node_modules/vscode-languageclient/lib/common/protocolCodeAction.js");
const protocolDiagnostic_1 = __webpack_require__(/*! ./protocolDiagnostic */ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js");
const protocolCallHierarchyItem_1 = __webpack_require__(/*! ./protocolCallHierarchyItem */ "./node_modules/vscode-languageclient/lib/common/protocolCallHierarchyItem.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
var CodeBlock;
(function (CodeBlock) {
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.language) && Is.string(candidate.value);
    }
    CodeBlock.is = is;
})(CodeBlock || (CodeBlock = {}));
function createConverter(uriConverter, trustMarkdown) {
    const nullConverter = (value) => code.Uri.parse(value);
    const _uriConverter = uriConverter || nullConverter;
    function asUri(value) {
        return _uriConverter(value);
    }
    function asDiagnostics(diagnostics) {
        return diagnostics.map(asDiagnostic);
    }
    function asDiagnostic(diagnostic) {
        let result = new protocolDiagnostic_1.ProtocolDiagnostic(asRange(diagnostic.range), diagnostic.message, asDiagnosticSeverity(diagnostic.severity), diagnostic.data);
        if (diagnostic.code !== undefined) {
            if (ls.CodeDescription.is(diagnostic.codeDescription)) {
                result.code = {
                    value: diagnostic.code,
                    target: asUri(diagnostic.codeDescription.href)
                };
            }
            else if (protocolDiagnostic_1.DiagnosticCode.is(diagnostic.code)) {
                result.hasDiagnosticCode = true;
                result.code = {
                    value: diagnostic.code.value,
                    target: asUri(diagnostic.code.target)
                };
            }
            else {
                result.code = diagnostic.code;
            }
        }
        if (diagnostic.source) {
            result.source = diagnostic.source;
        }
        if (diagnostic.relatedInformation) {
            result.relatedInformation = asRelatedInformation(diagnostic.relatedInformation);
        }
        if (Array.isArray(diagnostic.tags)) {
            result.tags = asDiagnosticTags(diagnostic.tags);
        }
        return result;
    }
    function asRelatedInformation(relatedInformation) {
        return relatedInformation.map(asDiagnosticRelatedInformation);
    }
    function asDiagnosticRelatedInformation(information) {
        return new code.DiagnosticRelatedInformation(asLocation(information.location), information.message);
    }
    function asDiagnosticTags(tags) {
        if (!tags) {
            return undefined;
        }
        let result = [];
        for (let tag of tags) {
            let converted = asDiagnosticTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length > 0 ? result : undefined;
    }
    function asDiagnosticTag(tag) {
        switch (tag) {
            case ls.DiagnosticTag.Unnecessary:
                return code.DiagnosticTag.Unnecessary;
            case ls.DiagnosticTag.Deprecated:
                return code.DiagnosticTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asPosition(value) {
        if (!value) {
            return undefined;
        }
        return new code.Position(value.line, value.character);
    }
    function asRange(value) {
        if (!value) {
            return undefined;
        }
        return new code.Range(asPosition(value.start), asPosition(value.end));
    }
    function asRanges(value) {
        return value.map(value => asRange(value));
    }
    function asDiagnosticSeverity(value) {
        if (value === undefined || value === null) {
            return code.DiagnosticSeverity.Error;
        }
        switch (value) {
            case ls.DiagnosticSeverity.Error:
                return code.DiagnosticSeverity.Error;
            case ls.DiagnosticSeverity.Warning:
                return code.DiagnosticSeverity.Warning;
            case ls.DiagnosticSeverity.Information:
                return code.DiagnosticSeverity.Information;
            case ls.DiagnosticSeverity.Hint:
                return code.DiagnosticSeverity.Hint;
        }
        return code.DiagnosticSeverity.Error;
    }
    function asHoverContent(value) {
        if (Is.string(value)) {
            return asMarkdownString(value);
        }
        else if (CodeBlock.is(value)) {
            let result = asMarkdownString();
            return result.appendCodeblock(value.value, value.language);
        }
        else if (Array.isArray(value)) {
            let result = [];
            for (let element of value) {
                let item = asMarkdownString();
                if (CodeBlock.is(element)) {
                    item.appendCodeblock(element.value, element.language);
                }
                else {
                    item.appendMarkdown(element);
                }
                result.push(item);
            }
            return result;
        }
        else {
            let result;
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    result = asMarkdownString();
                    result.appendText(value.value);
                    return result;
                default:
                    result = asMarkdownString();
                    result.appendText(`Unsupported Markup content received. Kind is: ${value.kind}`);
                    return result;
            }
        }
    }
    function asDocumentation(value) {
        if (Is.string(value)) {
            return value;
        }
        else {
            switch (value.kind) {
                case ls.MarkupKind.Markdown:
                    return asMarkdownString(value.value);
                case ls.MarkupKind.PlainText:
                    return value.value;
                default:
                    return `Unsupported Markup content received. Kind is: ${value.kind}`;
            }
        }
    }
    function asMarkdownString(value) {
        const result = new code.MarkdownString(value);
        if (trustMarkdown === true) {
            result.isTrusted = trustMarkdown;
        }
        return result;
    }
    function asHover(hover) {
        if (!hover) {
            return undefined;
        }
        return new code.Hover(asHoverContent(hover.contents), asRange(hover.range));
    }
    function asCompletionResult(result) {
        if (!result) {
            return undefined;
        }
        if (Array.isArray(result)) {
            let items = result;
            return items.map(asCompletionItem);
        }
        let list = result;
        return new code.CompletionList(list.items.map(asCompletionItem), list.isIncomplete);
    }
    function asCompletionItemKind(value) {
        // Protocol item kind is 1 based, codes item kind is zero based.
        if (ls.CompletionItemKind.Text <= value && value <= ls.CompletionItemKind.TypeParameter) {
            return [value - 1, undefined];
        }
        return [code.CompletionItemKind.Text, value];
    }
    function asCompletionItemTag(tag) {
        switch (tag) {
            case ls.CompletionItemTag.Deprecated:
                return code.CompletionItemTag.Deprecated;
        }
        return undefined;
    }
    function asCompletionItemTags(tags) {
        if (tags === undefined || tags === null) {
            return [];
        }
        const result = [];
        for (const tag of tags) {
            const converted = asCompletionItemTag(tag);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result;
    }
    function asCompletionItem(item) {
        const tags = asCompletionItemTags(item.tags);
        const result = new protocolCompletionItem_1.default(item.label);
        const label2 = asCompletionItemLabel(item);
        if (label2 !== undefined) {
            result.label2 = label2;
        }
        if (item.detail) {
            result.detail = item.detail;
        }
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
            result.documentationFormat = Is.string(item.documentation) ? '$string' : item.documentation.kind;
        }
        if (item.filterText) {
            result.filterText = item.filterText;
        }
        const insertText = asCompletionInsertText(item);
        if (insertText) {
            result.insertText = insertText.text;
            result.range = insertText.range;
            result.fromEdit = insertText.fromEdit;
        }
        if (Is.number(item.kind)) {
            let [itemKind, original] = asCompletionItemKind(item.kind);
            result.kind = itemKind;
            if (original) {
                result.originalItemKind = original;
            }
        }
        if (item.sortText) {
            result.sortText = item.sortText;
        }
        if (item.additionalTextEdits) {
            result.additionalTextEdits = asTextEdits(item.additionalTextEdits);
        }
        if (Is.stringArray(item.commitCharacters)) {
            result.commitCharacters = item.commitCharacters.slice();
        }
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.deprecated === true || item.deprecated === false) {
            result.deprecated = item.deprecated;
            if (item.deprecated === true) {
                tags.push(code.CompletionItemTag.Deprecated);
            }
        }
        if (item.preselect === true || item.preselect === false) {
            result.preselect = item.preselect;
        }
        if (item.data !== undefined) {
            result.data = item.data;
        }
        if (tags.length > 0) {
            result.tags = tags;
        }
        if (item.insertTextMode !== undefined) {
            result.insertTextMode = item.insertTextMode;
            if (item.insertTextMode === vscode_languageserver_protocol_1.InsertTextMode.asIs) {
                result.keepWhitespace = true;
            }
        }
        return result;
    }
    function asCompletionItemLabel(item) {
        if (vscode_languageserver_protocol_1.CompletionItemLabelDetails.is(item.labelDetails)) {
            return { name: item.label, parameters: item.labelDetails.parameters, qualifier: item.labelDetails.qualifier, type: item.labelDetails.type };
        }
        else {
            return undefined;
        }
    }
    function asCompletionInsertText(item) {
        if (item.textEdit) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.textEdit.newText), range: asCompletionRange(item.textEdit), fromEdit: true };
            }
            else {
                return { text: item.textEdit.newText, range: asCompletionRange(item.textEdit), fromEdit: true };
            }
        }
        else if (item.insertText) {
            if (item.insertTextFormat === ls.InsertTextFormat.Snippet) {
                return { text: new code.SnippetString(item.insertText), fromEdit: false };
            }
            else {
                return { text: item.insertText, fromEdit: false };
            }
        }
        else {
            return undefined;
        }
    }
    function asCompletionRange(value) {
        if (ls.InsertReplaceEdit.is(value)) {
            return { inserting: asRange(value.insert), replacing: asRange(value.replace) };
        }
        else {
            return asRange(value.range);
        }
    }
    function asTextEdit(edit) {
        if (!edit) {
            return undefined;
        }
        return new code.TextEdit(asRange(edit.range), edit.newText);
    }
    function asTextEdits(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asTextEdit);
    }
    function asSignatureHelp(item) {
        if (!item) {
            return undefined;
        }
        let result = new code.SignatureHelp();
        if (Is.number(item.activeSignature)) {
            result.activeSignature = item.activeSignature;
        }
        else {
            // activeSignature was optional in the past
            result.activeSignature = 0;
        }
        if (Is.number(item.activeParameter)) {
            result.activeParameter = item.activeParameter;
        }
        else {
            // activeParameter was optional in the past
            result.activeParameter = 0;
        }
        if (item.signatures) {
            result.signatures = asSignatureInformations(item.signatures);
        }
        return result;
    }
    function asSignatureInformations(items) {
        return items.map(asSignatureInformation);
    }
    function asSignatureInformation(item) {
        let result = new code.SignatureInformation(item.label);
        if (item.documentation !== undefined) {
            result.documentation = asDocumentation(item.documentation);
        }
        if (item.parameters !== undefined) {
            result.parameters = asParameterInformations(item.parameters);
        }
        if (item.activeParameter !== undefined) {
            result.activeParameter = item.activeParameter;
        }
        {
            return result;
        }
    }
    function asParameterInformations(item) {
        return item.map(asParameterInformation);
    }
    function asParameterInformation(item) {
        let result = new code.ParameterInformation(item.label);
        if (item.documentation) {
            result.documentation = asDocumentation(item.documentation);
        }
        return result;
    }
    function asLocation(item) {
        if (!item) {
            return undefined;
        }
        return new code.Location(_uriConverter(item.uri), asRange(item.range));
    }
    function asDeclarationResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asDefinitionResult(item) {
        if (!item) {
            return undefined;
        }
        return asLocationResult(item);
    }
    function asLocationLink(item) {
        if (!item) {
            return undefined;
        }
        let result = {
            targetUri: _uriConverter(item.targetUri),
            targetRange: asRange(item.targetRange),
            originSelectionRange: asRange(item.originSelectionRange),
            targetSelectionRange: asRange(item.targetSelectionRange)
        };
        if (!result.targetSelectionRange) {
            throw new Error(`targetSelectionRange must not be undefined or null`);
        }
        return result;
    }
    function asLocationResult(item) {
        if (!item) {
            return undefined;
        }
        if (Is.array(item)) {
            if (item.length === 0) {
                return [];
            }
            else if (ls.LocationLink.is(item[0])) {
                let links = item;
                return links.map((link) => asLocationLink(link));
            }
            else {
                let locations = item;
                return locations.map((location) => asLocation(location));
            }
        }
        else if (ls.LocationLink.is(item)) {
            return [asLocationLink(item)];
        }
        else {
            return asLocation(item);
        }
    }
    function asReferences(values) {
        if (!values) {
            return undefined;
        }
        return values.map(location => asLocation(location));
    }
    function asDocumentHighlights(values) {
        if (!values) {
            return undefined;
        }
        return values.map(asDocumentHighlight);
    }
    function asDocumentHighlight(item) {
        let result = new code.DocumentHighlight(asRange(item.range));
        if (Is.number(item.kind)) {
            result.kind = asDocumentHighlightKind(item.kind);
        }
        return result;
    }
    function asDocumentHighlightKind(item) {
        switch (item) {
            case ls.DocumentHighlightKind.Text:
                return code.DocumentHighlightKind.Text;
            case ls.DocumentHighlightKind.Read:
                return code.DocumentHighlightKind.Read;
            case ls.DocumentHighlightKind.Write:
                return code.DocumentHighlightKind.Write;
        }
        return code.DocumentHighlightKind.Text;
    }
    function asSymbolInformations(values, uri) {
        if (!values) {
            return undefined;
        }
        return values.map(information => asSymbolInformation(information, uri));
    }
    function asSymbolKind(item) {
        if (item <= ls.SymbolKind.TypeParameter) {
            // Symbol kind is one based in the protocol and zero based in code.
            return item - 1;
        }
        return code.SymbolKind.Property;
    }
    function asSymbolTag(value) {
        switch (value) {
            case ls.SymbolTag.Deprecated:
                return code.SymbolTag.Deprecated;
            default:
                return undefined;
        }
    }
    function asSymbolTags(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        const result = [];
        for (const item of items) {
            const converted = asSymbolTag(item);
            if (converted !== undefined) {
                result.push(converted);
            }
        }
        return result.length === 0 ? undefined : result;
    }
    function asSymbolInformation(item, uri) {
        // Symbol kind is one based in the protocol and zero based in code.
        let result = new code.SymbolInformation(item.name, asSymbolKind(item.kind), asRange(item.location.range), item.location.uri ? _uriConverter(item.location.uri) : uri);
        fillTags(result, item);
        if (item.containerName) {
            result.containerName = item.containerName;
        }
        return result;
    }
    function asDocumentSymbols(values) {
        if (values === undefined || values === null) {
            return undefined;
        }
        return values.map(asDocumentSymbol);
    }
    function asDocumentSymbol(value) {
        let result = new code.DocumentSymbol(value.name, value.detail || '', asSymbolKind(value.kind), asRange(value.range), asRange(value.selectionRange));
        fillTags(result, value);
        if (value.children !== undefined && value.children.length > 0) {
            let children = [];
            for (let child of value.children) {
                children.push(asDocumentSymbol(child));
            }
            result.children = children;
        }
        return result;
    }
    function fillTags(result, value) {
        result.tags = asSymbolTags(value.tags);
        if (value.deprecated) {
            if (!result.tags) {
                result.tags = [code.SymbolTag.Deprecated];
            }
            else {
                if (!result.tags.includes(code.SymbolTag.Deprecated)) {
                    result.tags = result.tags.concat(code.SymbolTag.Deprecated);
                }
            }
        }
    }
    function asCommand(item) {
        let result = { title: item.title, command: item.command };
        if (item.arguments) {
            result.arguments = item.arguments;
        }
        return result;
    }
    function asCommands(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asCommand);
    }
    const kindMapping = new Map();
    kindMapping.set(ls.CodeActionKind.Empty, code.CodeActionKind.Empty);
    kindMapping.set(ls.CodeActionKind.QuickFix, code.CodeActionKind.QuickFix);
    kindMapping.set(ls.CodeActionKind.Refactor, code.CodeActionKind.Refactor);
    kindMapping.set(ls.CodeActionKind.RefactorExtract, code.CodeActionKind.RefactorExtract);
    kindMapping.set(ls.CodeActionKind.RefactorInline, code.CodeActionKind.RefactorInline);
    kindMapping.set(ls.CodeActionKind.RefactorRewrite, code.CodeActionKind.RefactorRewrite);
    kindMapping.set(ls.CodeActionKind.Source, code.CodeActionKind.Source);
    kindMapping.set(ls.CodeActionKind.SourceOrganizeImports, code.CodeActionKind.SourceOrganizeImports);
    function asCodeActionKind(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = kindMapping.get(item);
        if (result) {
            return result;
        }
        let parts = item.split('.');
        result = code.CodeActionKind.Empty;
        for (let part of parts) {
            result = result.append(part);
        }
        return result;
    }
    function asCodeActionKinds(items) {
        if (items === undefined || items === null) {
            return undefined;
        }
        return items.map(kind => asCodeActionKind(kind));
    }
    function asCodeAction(item) {
        if (item === undefined || item === null) {
            return undefined;
        }
        let result = new protocolCodeAction_1.default(item.title, item.data);
        if (item.kind !== undefined) {
            result.kind = asCodeActionKind(item.kind);
        }
        if (item.diagnostics !== undefined) {
            result.diagnostics = asDiagnostics(item.diagnostics);
        }
        if (item.edit !== undefined) {
            result.edit = asWorkspaceEdit(item.edit);
        }
        if (item.command !== undefined) {
            result.command = asCommand(item.command);
        }
        if (item.isPreferred !== undefined) {
            result.isPreferred = item.isPreferred;
        }
        if (item.disabled !== undefined) {
            result.disabled = { reason: item.disabled.reason };
        }
        return result;
    }
    function asCodeLens(item) {
        if (!item) {
            return undefined;
        }
        let result = new protocolCodeLens_1.default(asRange(item.range));
        if (item.command) {
            result.command = asCommand(item.command);
        }
        if (item.data !== undefined && item.data !== null) {
            result.data = item.data;
        }
        return result;
    }
    function asCodeLenses(items) {
        if (!items) {
            return undefined;
        }
        return items.map((codeLens) => asCodeLens(codeLens));
    }
    function asWorkspaceEdit(item) {
        if (!item) {
            return undefined;
        }
        const sharedMetadata = new Map();
        if (item.changeAnnotations !== undefined) {
            for (const key of Object.keys(item.changeAnnotations)) {
                const metaData = asWorkspaceEditEntryMetadata(item.changeAnnotations[key]);
                sharedMetadata.set(key, metaData);
            }
        }
        const asMetadata = (annotation) => {
            if (annotation === undefined) {
                return undefined;
            }
            else {
                return sharedMetadata.get(annotation);
            }
        };
        const result = new code.WorkspaceEdit();
        if (item.documentChanges) {
            for (const change of item.documentChanges) {
                if (ls.CreateFile.is(change)) {
                    result.createFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.RenameFile.is(change)) {
                    result.renameFile(_uriConverter(change.oldUri), _uriConverter(change.newUri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.DeleteFile.is(change)) {
                    result.deleteFile(_uriConverter(change.uri), change.options, asMetadata(change.annotationId));
                }
                else if (ls.TextDocumentEdit.is(change)) {
                    const uri = _uriConverter(change.textDocument.uri);
                    for (const edit of change.edits) {
                        if (vscode_languageserver_protocol_1.AnnotatedTextEdit.is(edit)) {
                            result.replace(uri, asRange(edit.range), edit.newText, asMetadata(edit.annotationId));
                        }
                        else {
                            result.replace(uri, asRange(edit.range), edit.newText);
                        }
                    }
                }
                else {
                    throw new Error(`Unknown workspace edit change received:\n${JSON.stringify(change, undefined, 4)}`);
                }
            }
        }
        else if (item.changes) {
            Object.keys(item.changes).forEach(key => {
                result.set(_uriConverter(key), asTextEdits(item.changes[key]));
            });
        }
        return result;
    }
    function asWorkspaceEditEntryMetadata(annotation) {
        if (annotation === undefined) {
            return undefined;
        }
        return { label: annotation.label, needsConfirmation: !!annotation.needsConfirmation, description: annotation.description };
    }
    function asDocumentLink(item) {
        let range = asRange(item.range);
        let target = item.target ? asUri(item.target) : undefined;
        // target must be optional in DocumentLink
        let link = new protocolDocumentLink_1.default(range, target);
        if (item.tooltip !== undefined) {
            link.tooltip = item.tooltip;
        }
        if (item.data !== undefined && item.data !== null) {
            link.data = item.data;
        }
        return link;
    }
    function asDocumentLinks(items) {
        if (!items) {
            return undefined;
        }
        return items.map(asDocumentLink);
    }
    function asColor(color) {
        return new code.Color(color.red, color.green, color.blue, color.alpha);
    }
    function asColorInformation(ci) {
        return new code.ColorInformation(asRange(ci.range), asColor(ci.color));
    }
    function asColorInformations(colorInformation) {
        if (Array.isArray(colorInformation)) {
            return colorInformation.map(asColorInformation);
        }
        return undefined;
    }
    function asColorPresentation(cp) {
        let presentation = new code.ColorPresentation(cp.label);
        presentation.additionalTextEdits = asTextEdits(cp.additionalTextEdits);
        if (cp.textEdit) {
            presentation.textEdit = asTextEdit(cp.textEdit);
        }
        return presentation;
    }
    function asColorPresentations(colorPresentations) {
        if (Array.isArray(colorPresentations)) {
            return colorPresentations.map(asColorPresentation);
        }
        return undefined;
    }
    function asFoldingRangeKind(kind) {
        if (kind) {
            switch (kind) {
                case ls.FoldingRangeKind.Comment:
                    return code.FoldingRangeKind.Comment;
                case ls.FoldingRangeKind.Imports:
                    return code.FoldingRangeKind.Imports;
                case ls.FoldingRangeKind.Region:
                    return code.FoldingRangeKind.Region;
            }
        }
        return undefined;
    }
    function asFoldingRange(r) {
        return new code.FoldingRange(r.startLine, r.endLine, asFoldingRangeKind(r.kind));
    }
    function asFoldingRanges(foldingRanges) {
        if (Array.isArray(foldingRanges)) {
            return foldingRanges.map(asFoldingRange);
        }
        return undefined;
    }
    function asSelectionRange(selectionRange) {
        return new code.SelectionRange(asRange(selectionRange.range), selectionRange.parent ? asSelectionRange(selectionRange.parent) : undefined);
    }
    function asSelectionRanges(selectionRanges) {
        if (!Array.isArray(selectionRanges)) {
            return [];
        }
        let result = [];
        for (let range of selectionRanges) {
            result.push(asSelectionRange(range));
        }
        return result;
    }
    function asCallHierarchyItem(item) {
        if (item === null) {
            return undefined;
        }
        let result = new protocolCallHierarchyItem_1.default(asSymbolKind(item.kind), item.name, item.detail || '', asUri(item.uri), asRange(item.range), asRange(item.selectionRange), item.data);
        if (item.tags !== undefined) {
            result.tags = asSymbolTags(item.tags);
        }
        return result;
    }
    function asCallHierarchyItems(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyItem(item));
    }
    function asCallHierarchyIncomingCall(item) {
        return new code.CallHierarchyIncomingCall(asCallHierarchyItem(item.from), asRanges(item.fromRanges));
    }
    function asCallHierarchyIncomingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyIncomingCall(item));
    }
    function asCallHierarchyOutgoingCall(item) {
        return new code.CallHierarchyOutgoingCall(asCallHierarchyItem(item.to), asRanges(item.fromRanges));
    }
    function asCallHierarchyOutgoingCalls(items) {
        if (items === null) {
            return undefined;
        }
        return items.map(item => asCallHierarchyOutgoingCall(item));
    }
    function asSemanticTokens(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokens(new Uint32Array(value.data), value.resultId);
    }
    function asSemanticTokensEdit(value) {
        return new code.SemanticTokensEdit(value.start, value.deleteCount, value.data !== undefined ? new Uint32Array(value.data) : undefined);
    }
    function asSemanticTokensEdits(value) {
        if (value === undefined || value === null) {
            return undefined;
        }
        return new code.SemanticTokensEdits(value.edits.map(asSemanticTokensEdit), value.resultId);
    }
    function asSemanticTokensLegend(value) {
        return value;
    }
    function asLinkedEditingRanges(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new code.LinkedEditingRanges(asRanges(value.ranges), asRegularExpression(value.wordPattern));
    }
    function asRegularExpression(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        return new RegExp(value);
    }
    return {
        asUri,
        asDiagnostics,
        asDiagnostic,
        asRange,
        asRanges,
        asPosition,
        asDiagnosticSeverity,
        asDiagnosticTag,
        asHover,
        asCompletionResult,
        asCompletionItem,
        asTextEdit,
        asTextEdits,
        asSignatureHelp,
        asSignatureInformations,
        asSignatureInformation,
        asParameterInformations,
        asParameterInformation,
        asDeclarationResult,
        asDefinitionResult,
        asLocation,
        asReferences,
        asDocumentHighlights,
        asDocumentHighlight,
        asDocumentHighlightKind,
        asSymbolKind,
        asSymbolTag,
        asSymbolTags,
        asSymbolInformations,
        asSymbolInformation,
        asDocumentSymbols,
        asDocumentSymbol,
        asCommand,
        asCommands,
        asCodeAction,
        asCodeActionKind,
        asCodeActionKinds,
        asCodeLens,
        asCodeLenses,
        asWorkspaceEdit,
        asDocumentLink,
        asDocumentLinks,
        asFoldingRangeKind,
        asFoldingRange,
        asFoldingRanges,
        asColor,
        asColorInformation,
        asColorInformations,
        asColorPresentation,
        asColorPresentations,
        asSelectionRange,
        asSelectionRanges,
        asSemanticTokensLegend,
        asSemanticTokens,
        asSemanticTokensEdit,
        asSemanticTokensEdits,
        asCallHierarchyItem,
        asCallHierarchyItems,
        asCallHierarchyIncomingCall,
        asCallHierarchyIncomingCalls,
        asCallHierarchyOutgoingCall,
        asCallHierarchyOutgoingCalls,
        asLinkedEditingRanges: asLinkedEditingRanges
    };
}
exports.createConverter = createConverter;
//# sourceMappingURL=protocolConverter.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolDiagnostic.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolDiagnostic = exports.DiagnosticCode = void 0;
const vscode = __webpack_require__(/*! vscode */ "vscode");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
var DiagnosticCode;
(function (DiagnosticCode) {
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && (Is.number(candidate.value) || Is.string(candidate.value)) && Is.string(candidate.target);
    }
    DiagnosticCode.is = is;
})(DiagnosticCode = exports.DiagnosticCode || (exports.DiagnosticCode = {}));
class ProtocolDiagnostic extends vscode.Diagnostic {
    constructor(range, message, severity, data) {
        super(range, message, severity);
        this.data = data;
        this.hasDiagnosticCode = false;
    }
}
exports.ProtocolDiagnostic = ProtocolDiagnostic;
//# sourceMappingURL=protocolDiagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/protocolDocumentLink.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
const code = __webpack_require__(/*! vscode */ "vscode");
class ProtocolDocumentLink extends code.DocumentLink {
    constructor(range, target) {
        super(range, target);
    }
}
exports["default"] = ProtocolDocumentLink;
//# sourceMappingURL=protocolDocumentLink.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/selectionRange.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/selectionRange.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = Object.create(null);
    }
    return target[key];
}
class SelectionRangeFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SelectionRangeRequest.type);
    }
    fillClientCapabilities(capabilities) {
        let capability = ensure(ensure(capabilities, 'textDocument'), 'selectionRange');
        capability.dynamicRegistration = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.selectionRangeProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideSelectionRanges: (document, positions, token) => {
                const client = this._client;
                const provideSelectionRanges = (document, positions, token) => {
                    const requestParams = {
                        textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                        positions: client.code2ProtocolConverter.asPositions(positions)
                    };
                    return client.sendRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, requestParams, token).then((ranges) => client.protocol2CodeConverter.asSelectionRanges(ranges), (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideSelectionRanges
                    ? middleware.provideSelectionRanges(document, positions, token, provideSelectionRanges)
                    : provideSelectionRanges(document, positions, token);
            }
        };
        return [vscode_1.languages.registerSelectionRangeProvider(options.documentSelector, provider), provider];
    }
}
exports.SelectionRangeFeature = SelectionRangeFeature;
//# sourceMappingURL=selectionRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/semanticTokens.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/semanticTokens.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensFeature = void 0;
const vscode = __webpack_require__(/*! vscode */ "vscode");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class SemanticTokensFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.SemanticTokensRegistrationType.type);
    }
    fillClientCapabilities(capabilities) {
        const capability = ensure(ensure(capabilities, 'textDocument'), 'semanticTokens');
        capability.dynamicRegistration = true;
        capability.tokenTypes = [
            vscode_languageserver_protocol_1.SemanticTokenTypes.namespace,
            vscode_languageserver_protocol_1.SemanticTokenTypes.type,
            vscode_languageserver_protocol_1.SemanticTokenTypes.class,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enum,
            vscode_languageserver_protocol_1.SemanticTokenTypes.interface,
            vscode_languageserver_protocol_1.SemanticTokenTypes.struct,
            vscode_languageserver_protocol_1.SemanticTokenTypes.typeParameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.parameter,
            vscode_languageserver_protocol_1.SemanticTokenTypes.variable,
            vscode_languageserver_protocol_1.SemanticTokenTypes.property,
            vscode_languageserver_protocol_1.SemanticTokenTypes.enumMember,
            vscode_languageserver_protocol_1.SemanticTokenTypes.event,
            vscode_languageserver_protocol_1.SemanticTokenTypes.function,
            vscode_languageserver_protocol_1.SemanticTokenTypes.method,
            vscode_languageserver_protocol_1.SemanticTokenTypes.macro,
            vscode_languageserver_protocol_1.SemanticTokenTypes.keyword,
            vscode_languageserver_protocol_1.SemanticTokenTypes.modifier,
            vscode_languageserver_protocol_1.SemanticTokenTypes.comment,
            vscode_languageserver_protocol_1.SemanticTokenTypes.string,
            vscode_languageserver_protocol_1.SemanticTokenTypes.number,
            vscode_languageserver_protocol_1.SemanticTokenTypes.regexp,
            vscode_languageserver_protocol_1.SemanticTokenTypes.operator
        ];
        capability.tokenModifiers = [
            vscode_languageserver_protocol_1.SemanticTokenModifiers.declaration,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.definition,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.readonly,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.static,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.deprecated,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.abstract,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.async,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.modification,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.documentation,
            vscode_languageserver_protocol_1.SemanticTokenModifiers.defaultLibrary
        ];
        capability.formats = [vscode_languageserver_protocol_1.TokenFormat.Relative];
        capability.requests = {
            range: true,
            full: {
                delta: true
            }
        };
        capability.multilineTokenSupport = false;
        capability.overlappingTokenSupport = false;
        ensure(ensure(capabilities, 'workspace'), 'semanticTokens').refreshSupport = true;
    }
    initialize(capabilities, documentSelector) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type, async () => {
            for (const provider of this.getAllProviders()) {
                provider.onDidChangeSemanticTokensEmitter.fire();
            }
        });
        const [id, options] = this.getRegistration(documentSelector, capabilities.semanticTokensProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const fullProvider = Is.boolean(options.full) ? options.full : options.full !== undefined;
        const hasEditProvider = options.full !== undefined && typeof options.full !== 'boolean' && options.full.delta === true;
        const eventEmitter = new vscode.EventEmitter();
        const documentProvider = fullProvider
            ? {
                onDidChangeSemanticTokens: eventEmitter.event,
                provideDocumentSemanticTokens: (document, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentSemanticTokens = (document, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, params, token).then((result) => {
                            return client.protocol2CodeConverter.asSemanticTokens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentSemanticTokens
                        ? middleware.provideDocumentSemanticTokens(document, token, provideDocumentSemanticTokens)
                        : provideDocumentSemanticTokens(document, token);
                },
                provideDocumentSemanticTokensEdits: hasEditProvider
                    ? (document, previousResultId, token) => {
                        const client = this._client;
                        const middleware = client.clientOptions.middleware;
                        const provideDocumentSemanticTokensEdits = (document, previousResultId, token) => {
                            const params = {
                                textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                                previousResultId
                            };
                            return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, params, token).then((result) => {
                                if (vscode_languageserver_protocol_1.SemanticTokens.is(result)) {
                                    return client.protocol2CodeConverter.asSemanticTokens(result);
                                }
                                else {
                                    return client.protocol2CodeConverter.asSemanticTokensEdits(result);
                                }
                            }, (error) => {
                                return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type, token, error, null);
                            });
                        };
                        return middleware.provideDocumentSemanticTokensEdits
                            ? middleware.provideDocumentSemanticTokensEdits(document, previousResultId, token, provideDocumentSemanticTokensEdits)
                            : provideDocumentSemanticTokensEdits(document, previousResultId, token);
                    }
                    : undefined
            }
            : undefined;
        const hasRangeProvider = options.range === true;
        const rangeProvider = hasRangeProvider
            ? {
                provideDocumentRangeSemanticTokens: (document, range, token) => {
                    const client = this._client;
                    const middleware = client.clientOptions.middleware;
                    const provideDocumentRangeSemanticTokens = (document, range, token) => {
                        const params = {
                            textDocument: client.code2ProtocolConverter.asTextDocumentIdentifier(document),
                            range: client.code2ProtocolConverter.asRange(range)
                        };
                        return client.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, params, token).then((result) => {
                            return client.protocol2CodeConverter.asSemanticTokens(result);
                        }, (error) => {
                            return client.handleFailedRequest(vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type, token, error, null);
                        });
                    };
                    return middleware.provideDocumentRangeSemanticTokens
                        ? middleware.provideDocumentRangeSemanticTokens(document, range, token, provideDocumentRangeSemanticTokens)
                        : provideDocumentRangeSemanticTokens(document, range, token);
                }
            }
            : undefined;
        const disposables = [];
        const client = this._client;
        const legend = client.protocol2CodeConverter.asSemanticTokensLegend(options.legend);
        if (documentProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentSemanticTokensProvider(options.documentSelector, documentProvider, legend));
        }
        if (rangeProvider !== undefined) {
            disposables.push(vscode.languages.registerDocumentRangeSemanticTokensProvider(options.documentSelector, rangeProvider, legend));
        }
        return [new vscode.Disposable(() => disposables.forEach(item => item.dispose())), { range: rangeProvider, full: documentProvider, onDidChangeSemanticTokensEmitter: eventEmitter }];
    }
}
exports.SemanticTokensFeature = SemanticTokensFeature;
//# sourceMappingURL=semanticTokens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/typeDefinition.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/typeDefinition.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionFeature = void 0;
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
const client_1 = __webpack_require__(/*! ./client */ "./node_modules/vscode-languageclient/lib/common/client.js");
function ensure(target, key) {
    if (target[key] === void 0) {
        target[key] = {};
    }
    return target[key];
}
class TypeDefinitionFeature extends client_1.TextDocumentFeature {
    constructor(client) {
        super(client, vscode_languageserver_protocol_1.TypeDefinitionRequest.type);
    }
    fillClientCapabilities(capabilities) {
        ensure(ensure(capabilities, 'textDocument'), 'typeDefinition').dynamicRegistration = true;
        let typeDefinitionSupport = ensure(ensure(capabilities, 'textDocument'), 'typeDefinition');
        typeDefinitionSupport.dynamicRegistration = true;
        typeDefinitionSupport.linkSupport = true;
    }
    initialize(capabilities, documentSelector) {
        let [id, options] = this.getRegistration(documentSelector, capabilities.typeDefinitionProvider);
        if (!id || !options) {
            return;
        }
        this.register({ id: id, registerOptions: options });
    }
    registerLanguageProvider(options) {
        const provider = {
            provideTypeDefinition: (document, position, token) => {
                const client = this._client;
                const provideTypeDefinition = (document, position, token) => {
                    return client.sendRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, client.code2ProtocolConverter.asTextDocumentPositionParams(document, position), token).then(client.protocol2CodeConverter.asDefinitionResult, (error) => {
                        return client.handleFailedRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, token, error, null);
                    });
                };
                const middleware = client.clientOptions.middleware;
                return middleware.provideTypeDefinition
                    ? middleware.provideTypeDefinition(document, position, token, provideTypeDefinition)
                    : provideTypeDefinition(document, position, token);
            }
        };
        return [vscode_1.languages.registerTypeDefinitionProvider(options.documentSelector, provider), provider];
    }
}
exports.TypeDefinitionFeature = TypeDefinitionFeature;
//# sourceMappingURL=typeDefinition.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/async.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/async.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Delayer = void 0;
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
class Delayer {
    constructor(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = undefined;
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
    }
    trigger(task, delay = this.defaultDelay) {
        this.task = task;
        if (delay >= 0) {
            this.cancelTimeout();
        }
        if (!this.completionPromise) {
            this.completionPromise = new Promise((resolve) => {
                this.onSuccess = resolve;
            }).then(() => {
                this.completionPromise = undefined;
                this.onSuccess = undefined;
                var result = this.task();
                this.task = undefined;
                return result;
            });
        }
        if (delay >= 0 || this.timeout === void 0) {
            this.timeout = vscode_languageserver_protocol_1.RAL().timer.setTimeout(() => {
                this.timeout = undefined;
                this.onSuccess(undefined);
            }, delay >= 0 ? delay : this.defaultDelay);
        }
        return this.completionPromise;
    }
    forceDelivery() {
        if (!this.completionPromise) {
            return undefined;
        }
        this.cancelTimeout();
        let result = this.task();
        this.completionPromise = undefined;
        this.onSuccess = undefined;
        this.task = undefined;
        return result;
    }
    isTriggered() {
        return this.timeout !== undefined;
    }
    cancel() {
        this.cancelTimeout();
        this.completionPromise = undefined;
    }
    cancelTimeout() {
        if (this.timeout !== undefined) {
            this.timeout.dispose();
            this.timeout = undefined;
        }
    }
}
exports.Delayer = Delayer;
//# sourceMappingURL=async.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/is.js":
/*!*******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/is.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asPromise = exports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function thenable(value) {
    return value && func(value.then);
}
exports.thenable = thenable;
function asPromise(value) {
    if (value instanceof Promise) {
        return value;
    }
    else if (thenable(value)) {
        return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
        });
    }
    else {
        return Promise.resolve(value);
    }
}
exports.asPromise = asPromise;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/utils/uuid.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;
class ValueUUID {
    constructor(_value) {
        this._value = _value;
        // empty
    }
    asHex() {
        return this._value;
    }
    equals(other) {
        return this.asHex() === other.asHex();
    }
}
class V4UUID extends ValueUUID {
    constructor() {
        super([
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            '4',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._oneOf(V4UUID._timeHighBits),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            '-',
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
            V4UUID._randomHex(),
        ].join(''));
    }
    static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
    }
    static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
    }
}
V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
/**
 * An empty UUID that contains only zeros.
 */
exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
function v4() {
    return new V4UUID();
}
exports.v4 = v4;
const _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function isUUID(value) {
    return _UUIDPattern.test(value);
}
exports.isUUID = isUUID;
/**
 * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
 * @param value A uuid string.
 */
function parse(value) {
    if (!isUUID(value)) {
        throw new Error('invalid uuid');
    }
    return new ValueUUID(value);
}
exports.parse = parse;
function generateUuid() {
    return v4().asHex();
}
exports.generateUuid = generateUuid;
//# sourceMappingURL=uuid.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/common/workspaceFolders.js":
/*!***************************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/common/workspaceFolders.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkspaceFoldersFeature = exports.arrayDiff = void 0;
const UUID = __webpack_require__(/*! ./utils/uuid */ "./node_modules/vscode-languageclient/lib/common/utils/uuid.js");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const vscode_languageserver_protocol_1 = __webpack_require__(/*! vscode-languageserver-protocol */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");
function access(target, key) {
    if (target === void 0) {
        return undefined;
    }
    return target[key];
}
function arrayDiff(left, right) {
    return left.filter(element => right.indexOf(element) < 0);
}
exports.arrayDiff = arrayDiff;
class WorkspaceFoldersFeature {
    constructor(_client) {
        this._client = _client;
        this._listeners = new Map();
    }
    get registrationType() {
        return vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type;
    }
    fillInitializeParams(params) {
        const folders = vscode_1.workspace.workspaceFolders;
        this.initializeWithFolders(folders);
        if (folders === void 0) {
            params.workspaceFolders = null;
        }
        else {
            params.workspaceFolders = folders.map(folder => this.asProtocol(folder));
        }
    }
    initializeWithFolders(currentWorkspaceFolders) {
        this._initialFolders = currentWorkspaceFolders;
    }
    fillClientCapabilities(capabilities) {
        capabilities.workspace = capabilities.workspace || {};
        capabilities.workspace.workspaceFolders = true;
    }
    initialize(capabilities) {
        const client = this._client;
        client.onRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type, (token) => {
            const workspaceFolders = () => {
                const folders = vscode_1.workspace.workspaceFolders;
                if (folders === undefined) {
                    return null;
                }
                const result = folders.map((folder) => {
                    return this.asProtocol(folder);
                });
                return result;
            };
            const middleware = client.clientOptions.middleware.workspace;
            return middleware && middleware.workspaceFolders
                ? middleware.workspaceFolders(token, workspaceFolders)
                : workspaceFolders(token);
        });
        const value = access(access(access(capabilities, 'workspace'), 'workspaceFolders'), 'changeNotifications');
        let id;
        if (typeof value === 'string') {
            id = value;
        }
        else if (value === true) {
            id = UUID.generateUuid();
        }
        if (id) {
            this.register({ id: id, registerOptions: undefined });
        }
    }
    sendInitialEvent(currentWorkspaceFolders) {
        if (this._initialFolders && currentWorkspaceFolders) {
            const removed = arrayDiff(this._initialFolders, currentWorkspaceFolders);
            const added = arrayDiff(currentWorkspaceFolders, this._initialFolders);
            if (added.length > 0 || removed.length > 0) {
                this.doSendEvent(added, removed);
            }
        }
        else if (this._initialFolders) {
            this.doSendEvent([], this._initialFolders);
        }
        else if (currentWorkspaceFolders) {
            this.doSendEvent(currentWorkspaceFolders, []);
        }
    }
    doSendEvent(addedFolders, removedFolders) {
        let params = {
            event: {
                added: addedFolders.map(folder => this.asProtocol(folder)),
                removed: removedFolders.map(folder => this.asProtocol(folder))
            }
        };
        this._client.sendNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, params);
    }
    register(data) {
        let id = data.id;
        let client = this._client;
        let disposable = vscode_1.workspace.onDidChangeWorkspaceFolders((event) => {
            let didChangeWorkspaceFolders = (event) => {
                this.doSendEvent(event.added, event.removed);
            };
            let middleware = client.clientOptions.middleware.workspace;
            middleware && middleware.didChangeWorkspaceFolders
                ? middleware.didChangeWorkspaceFolders(event, didChangeWorkspaceFolders)
                : didChangeWorkspaceFolders(event);
        });
        this._listeners.set(id, disposable);
        this.sendInitialEvent(vscode_1.workspace.workspaceFolders);
    }
    unregister(id) {
        let disposable = this._listeners.get(id);
        if (disposable === void 0) {
            return;
        }
        this._listeners.delete(id);
        disposable.dispose();
    }
    dispose() {
        for (let disposable of this._listeners.values()) {
            disposable.dispose();
        }
        this._listeners.clear();
    }
    asProtocol(workspaceFolder) {
        if (workspaceFolder === void 0) {
            return null;
        }
        return { uri: this._client.code2ProtocolConverter.asUri(workspaceFolder.uri), name: workspaceFolder.name };
    }
}
exports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
//# sourceMappingURL=workspaceFolders.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/node/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/node/main.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingMonitor = exports.LanguageClient = exports.TransportKind = void 0;
const cp = __webpack_require__(/*! child_process */ "child_process");
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const SemVer = __webpack_require__(/*! semver */ "./node_modules/semver/index.js");
const vscode_1 = __webpack_require__(/*! vscode */ "vscode");
const Is = __webpack_require__(/*! ../common/utils/is */ "./node_modules/vscode-languageclient/lib/common/utils/is.js");
const commonClient_1 = __webpack_require__(/*! ../common/commonClient */ "./node_modules/vscode-languageclient/lib/common/commonClient.js");
const client_1 = __webpack_require__(/*! ../common/client */ "./node_modules/vscode-languageclient/lib/common/client.js");
const processes_1 = __webpack_require__(/*! ./processes */ "./node_modules/vscode-languageclient/lib/node/processes.js");
const node_1 = __webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js");
__exportStar(__webpack_require__(/*! vscode-languageserver-protocol/node */ "./node_modules/vscode-languageserver-protocol/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageclient/lib/common/api.js"), exports);
const REQUIRED_VSCODE_VERSION = '^1.53.0'; // do not change format, updated by `updateVSCode` script
var Executable;
(function (Executable) {
    function is(value) {
        return Is.string(value.command);
    }
    Executable.is = is;
})(Executable || (Executable = {}));
var TransportKind;
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
    TransportKind[TransportKind["pipe"] = 2] = "pipe";
    TransportKind[TransportKind["socket"] = 3] = "socket";
})(TransportKind = exports.TransportKind || (exports.TransportKind = {}));
var Transport;
(function (Transport) {
    function isSocket(value) {
        let candidate = value;
        return candidate && candidate.kind === TransportKind.socket && Is.number(candidate.port);
    }
    Transport.isSocket = isSocket;
})(Transport || (Transport = {}));
var NodeModule;
(function (NodeModule) {
    function is(value) {
        return Is.string(value.module);
    }
    NodeModule.is = is;
})(NodeModule || (NodeModule = {}));
var StreamInfo;
(function (StreamInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.writer !== undefined && candidate.reader !== undefined;
    }
    StreamInfo.is = is;
})(StreamInfo || (StreamInfo = {}));
var ChildProcessInfo;
(function (ChildProcessInfo) {
    function is(value) {
        let candidate = value;
        return candidate && candidate.process !== undefined && typeof candidate.detached === 'boolean';
    }
    ChildProcessInfo.is = is;
})(ChildProcessInfo || (ChildProcessInfo = {}));
class LanguageClient extends commonClient_1.CommonLanguageClient {
    constructor(arg1, arg2, arg3, arg4, arg5) {
        let id;
        let name;
        let serverOptions;
        let clientOptions;
        let forceDebug;
        if (Is.string(arg2)) {
            id = arg1;
            name = arg2;
            serverOptions = arg3;
            clientOptions = arg4;
            forceDebug = !!arg5;
        }
        else {
            id = arg1.toLowerCase();
            name = arg1;
            serverOptions = arg2;
            clientOptions = arg3;
            forceDebug = arg4;
        }
        if (forceDebug === undefined) {
            forceDebug = false;
        }
        super(id, name, clientOptions);
        this._serverOptions = serverOptions;
        this._forceDebug = forceDebug;
        this._isInDebugMode = forceDebug;
        try {
            this.checkVersion();
        }
        catch (error) {
            if (Is.string(error.message)) {
                this.outputChannel.appendLine(error.message);
            }
            throw error;
        }
    }
    checkVersion() {
        let codeVersion = SemVer.parse(vscode_1.version);
        if (!codeVersion) {
            throw new Error(`No valid VS Code version detected. Version string is: ${vscode_1.version}`);
        }
        // Remove the insider pre-release since we stay API compatible.
        if (codeVersion.prerelease && codeVersion.prerelease.length > 0) {
            codeVersion.prerelease = [];
        }
        if (!SemVer.satisfies(codeVersion, REQUIRED_VSCODE_VERSION)) {
            throw new Error(`The language client requires VS Code version ${REQUIRED_VSCODE_VERSION} but received version ${vscode_1.version}`);
        }
    }
    get isInDebugMode() {
        return this._isInDebugMode;
    }
    stop() {
        return super.stop().then(() => {
            if (this._serverProcess) {
                let toCheck = this._serverProcess;
                this._serverProcess = undefined;
                if (this._isDetached === undefined || !this._isDetached) {
                    this.checkProcessDied(toCheck);
                }
                this._isDetached = undefined;
            }
        });
    }
    checkProcessDied(childProcess) {
        if (!childProcess) {
            return;
        }
        setTimeout(() => {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
                // All is fine.
            }
        }, 2000);
    }
    handleConnectionClosed() {
        this._serverProcess = undefined;
        super.handleConnectionClosed();
    }
    fillInitializeParams(params) {
        super.fillInitializeParams(params);
        if (params.processId === null) {
            params.processId = process.pid;
        }
    }
    createMessageTransports(encoding) {
        function getEnvironment(env, fork) {
            if (!env && !fork) {
                return undefined;
            }
            let result = Object.create(null);
            Object.keys(process.env).forEach(key => result[key] = process.env[key]);
            if (fork) {
                result['ELECTRON_RUN_AS_NODE'] = '1';
                result['ELECTRON_NO_ASAR'] = '1';
            }
            if (env) {
                Object.keys(env).forEach(key => result[key] = env[key]);
            }
            return result;
        }
        const debugStartWith = ['--debug=', '--debug-brk=', '--inspect=', '--inspect-brk='];
        const debugEquals = ['--debug', '--debug-brk', '--inspect', '--inspect-brk'];
        function startedInDebugMode() {
            let args = process.execArgv;
            if (args) {
                return args.some((arg) => {
                    return debugStartWith.some(value => arg.startsWith(value)) ||
                        debugEquals.some(value => arg === value);
                });
            }
            return false;
        }
        function assertStdio(process) {
            if (process.stdin === null || process.stdout === null || process.stderr === null) {
                throw new Error('Process created without stdio streams');
            }
        }
        let server = this._serverOptions;
        // We got a function.
        if (Is.func(server)) {
            return server().then((result) => {
                if (client_1.MessageTransports.is(result)) {
                    this._isDetached = !!result.detached;
                    return result;
                }
                else if (StreamInfo.is(result)) {
                    this._isDetached = !!result.detached;
                    return { reader: new node_1.StreamMessageReader(result.reader), writer: new node_1.StreamMessageWriter(result.writer) };
                }
                else {
                    let cp;
                    if (ChildProcessInfo.is(result)) {
                        cp = result.process;
                        this._isDetached = result.detached;
                    }
                    else {
                        cp = result;
                        this._isDetached = false;
                    }
                    cp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                    return { reader: new node_1.StreamMessageReader(cp.stdout), writer: new node_1.StreamMessageWriter(cp.stdin) };
                }
            });
        }
        let json;
        let runDebug = server;
        if (runDebug.run || runDebug.debug) {
            if (this._forceDebug || startedInDebugMode()) {
                json = runDebug.debug;
                this._isInDebugMode = true;
            }
            else {
                json = runDebug.run;
                this._isInDebugMode = false;
            }
        }
        else {
            json = server;
        }
        return this._getServerWorkingDir(json.options).then(serverWorkingDir => {
            if (NodeModule.is(json) && json.module) {
                let node = json;
                let transport = node.transport || TransportKind.stdio;
                if (node.runtime) {
                    let args = [];
                    let options = node.options || Object.create(null);
                    if (options.execArgv) {
                        options.execArgv.forEach(element => args.push(element));
                    }
                    args.push(node.module);
                    if (node.args) {
                        node.args.forEach(element => args.push(element));
                    }
                    const execOptions = Object.create(null);
                    execOptions.cwd = serverWorkingDir;
                    execOptions.env = getEnvironment(options.env, false);
                    const runtime = this._getRuntimePath(node.runtime, serverWorkingDir);
                    let pipeName = undefined;
                    if (transport === TransportKind.ipc) {
                        // exec options not correctly typed in lib
                        execOptions.stdio = [null, null, null, 'ipc'];
                        args.push('--node-ipc');
                    }
                    else if (transport === TransportKind.stdio) {
                        args.push('--stdio');
                    }
                    else if (transport === TransportKind.pipe) {
                        pipeName = node_1.generateRandomPipeName();
                        args.push(`--pipe=${pipeName}`);
                    }
                    else if (Transport.isSocket(transport)) {
                        args.push(`--socket=${transport.port}`);
                    }
                    args.push(`--clientProcessId=${process.pid.toString()}`);
                    if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                        let serverProcess = cp.spawn(runtime, args, execOptions);
                        if (!serverProcess || !serverProcess.pid) {
                            return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                        }
                        this._serverProcess = serverProcess;
                        serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                        if (transport === TransportKind.ipc) {
                            serverProcess.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return Promise.resolve({ reader: new node_1.IPCMessageReader(serverProcess), writer: new node_1.IPCMessageWriter(serverProcess) });
                        }
                        else {
                            return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
                        }
                    }
                    else if (transport === TransportKind.pipe) {
                        return node_1.createClientPipeTransport(pipeName).then((transport) => {
                            let process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                    else if (Transport.isSocket(transport)) {
                        return node_1.createClientSocketTransport(transport.port).then((transport) => {
                            let process = cp.spawn(runtime, args, execOptions);
                            if (!process || !process.pid) {
                                return Promise.reject(`Launching server using runtime ${runtime} failed.`);
                            }
                            this._serverProcess = process;
                            process.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            process.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            return transport.onConnected().then((protocol) => {
                                return { reader: protocol[0], writer: protocol[1] };
                            });
                        });
                    }
                }
                else {
                    let pipeName = undefined;
                    return new Promise((resolve, reject) => {
                        let args = node.args && node.args.slice() || [];
                        if (transport === TransportKind.ipc) {
                            args.push('--node-ipc');
                        }
                        else if (transport === TransportKind.stdio) {
                            args.push('--stdio');
                        }
                        else if (transport === TransportKind.pipe) {
                            pipeName = node_1.generateRandomPipeName();
                            args.push(`--pipe=${pipeName}`);
                        }
                        else if (Transport.isSocket(transport)) {
                            args.push(`--socket=${transport.port}`);
                        }
                        args.push(`--clientProcessId=${process.pid.toString()}`);
                        let options = node.options || Object.create(null);
                        options.env = getEnvironment(options.env, true);
                        options.execArgv = options.execArgv || [];
                        options.cwd = serverWorkingDir;
                        options.silent = true;
                        if (transport === TransportKind.ipc || transport === TransportKind.stdio) {
                            let sp = cp.fork(node.module, args || [], options);
                            assertStdio(sp);
                            this._serverProcess = sp;
                            sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                            if (transport === TransportKind.ipc) {
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                resolve({ reader: new node_1.IPCMessageReader(this._serverProcess), writer: new node_1.IPCMessageWriter(this._serverProcess) });
                            }
                            else {
                                resolve({ reader: new node_1.StreamMessageReader(sp.stdout), writer: new node_1.StreamMessageWriter(sp.stdin) });
                            }
                        }
                        else if (transport === TransportKind.pipe) {
                            node_1.createClientPipeTransport(pipeName).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                        else if (Transport.isSocket(transport)) {
                            node_1.createClientSocketTransport(transport.port).then((transport) => {
                                let sp = cp.fork(node.module, args || [], options);
                                assertStdio(sp);
                                this._serverProcess = sp;
                                sp.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                sp.stdout.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                                transport.onConnected().then((protocol) => {
                                    resolve({ reader: protocol[0], writer: protocol[1] });
                                }, reject);
                            }, reject);
                        }
                    });
                }
            }
            else if (Executable.is(json) && json.command) {
                let command = json;
                let args = command.args || [];
                let options = Object.assign({}, command.options);
                options.cwd = options.cwd || serverWorkingDir;
                let serverProcess = cp.spawn(command.command, args, options);
                if (!serverProcess || !serverProcess.pid) {
                    return Promise.reject(`Launching server using command ${command.command} failed.`);
                }
                serverProcess.stderr.on('data', data => this.outputChannel.append(Is.string(data) ? data : data.toString(encoding)));
                this._serverProcess = serverProcess;
                this._isDetached = !!options.detached;
                return Promise.resolve({ reader: new node_1.StreamMessageReader(serverProcess.stdout), writer: new node_1.StreamMessageWriter(serverProcess.stdin) });
            }
            return Promise.reject(new Error(`Unsupported server configuration ` + JSON.stringify(server, null, 4)));
        });
    }
    _getRuntimePath(runtime, serverWorkingDirectory) {
        if (path.isAbsolute(runtime)) {
            return runtime;
        }
        const mainRootPath = this._mainGetRootPath();
        if (mainRootPath !== undefined) {
            const result = path.join(mainRootPath, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        if (serverWorkingDirectory !== undefined) {
            const result = path.join(serverWorkingDirectory, runtime);
            if (fs.existsSync(result)) {
                return result;
            }
        }
        return runtime;
    }
    _mainGetRootPath() {
        let folders = vscode_1.workspace.workspaceFolders;
        if (!folders || folders.length === 0) {
            return undefined;
        }
        let folder = folders[0];
        if (folder.uri.scheme === 'file') {
            return folder.uri.fsPath;
        }
        return undefined;
    }
    _getServerWorkingDir(options) {
        let cwd = options && options.cwd;
        if (!cwd) {
            cwd = this.clientOptions.workspaceFolder
                ? this.clientOptions.workspaceFolder.uri.fsPath
                : this._mainGetRootPath();
        }
        if (cwd) {
            // make sure the folder exists otherwise creating the process will fail
            return new Promise(s => {
                fs.lstat(cwd, (err, stats) => {
                    s(!err && stats.isDirectory() ? cwd : undefined);
                });
            });
        }
        return Promise.resolve(undefined);
    }
    getLocale() {
        const envValue = process.env['VSCODE_NLS_CONFIG'];
        if (envValue === undefined) {
            return 'en';
        }
        let config = undefined;
        try {
            config = JSON.parse(envValue);
        }
        catch (err) {
        }
        if (config === undefined || typeof config.locale !== 'string') {
            return 'en';
        }
        return config.locale;
    }
}
exports.LanguageClient = LanguageClient;
class SettingMonitor {
    constructor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    start() {
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(() => {
            if (this._client.needsStop()) {
                void this._client.stop();
            }
        });
    }
    onDidChangeConfiguration() {
        let index = this._setting.indexOf('.');
        let primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        let rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        let enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            void this._client.stop();
        }
    }
}
exports.SettingMonitor = SettingMonitor;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/lib/node/processes.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageclient/lib/node/processes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.terminate = void 0;
const cp = __webpack_require__(/*! child_process */ "child_process");
const path_1 = __webpack_require__(/*! path */ "path");
const isWindows = (process.platform === 'win32');
const isMacintosh = (process.platform === 'darwin');
const isLinux = (process.platform === 'linux');
function terminate(process, cwd) {
    if (isWindows) {
        try {
            // This we run in Atom execFileSync is available.
            // Ignore stderr since this is otherwise piped to parent.stderr
            // which might be already closed.
            let options = {
                stdio: ['pipe', 'pipe', 'ignore']
            };
            if (cwd) {
                options.cwd = cwd;
            }
            cp.execFileSync('taskkill', ['/T', '/F', '/PID', process.pid.toString()], options);
            return true;
        }
        catch (err) {
            return false;
        }
    }
    else if (isLinux || isMacintosh) {
        try {
            var cmd = path_1.join(__dirname, 'terminateProcess.sh');
            var result = cp.spawnSync(cmd, [process.pid.toString()]);
            return result.error ? false : true;
        }
        catch (err) {
            return false;
        }
    }
    else {
        process.kill('SIGKILL');
        return true;
    }
}
exports.terminate = terminate;
//# sourceMappingURL=processes.js.map

/***/ }),

/***/ "./node_modules/vscode-languageclient/node.js":
/*!****************************************************!*\
  !*** ./node_modules/vscode-languageclient/node.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageclient/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/api.js":
/*!***********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/api.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Proposed = exports.LSPErrorCodes = exports.createProtocolConnection = void 0;
__exportStar(__webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js"), exports);
__exportStar(__webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js"), exports);
__exportStar(__webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js"), exports);
__exportStar(__webpack_require__(/*! ./protocol */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js"), exports);
var connection_1 = __webpack_require__(/*! ./connection */ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js");
Object.defineProperty(exports, "createProtocolConnection", ({ enumerable: true, get: function () { return connection_1.createProtocolConnection; } }));
var LSPErrorCodes;
(function (LSPErrorCodes) {
    /**
    * This is the start range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeStart = -32899;
    /**
     * The server cancelled the request. This error code should
     * only be used for requests that explicitly support being
     * server cancellable.
     *
     * @since 3.17.0
     */
    LSPErrorCodes.ServerCancelled = -32802;
    /**
     * The server detected that the content of a document got
     * modified outside normal conditions. A server should
     * NOT send this error code if it detects a content change
     * in it unprocessed messages. The result even computed
     * on an older state might still be useful for the client.
     *
     * If a client decides that a result is not of any use anymore
     * the client should cancel the request.
     */
    LSPErrorCodes.ContentModified = -32801;
    /**
     * The client has canceled a request and a server as detected
     * the cancel.
     */
    LSPErrorCodes.RequestCancelled = -32800;
    /**
    * This is the end range of LSP reserved error codes.
    * It doesn't denote a real error code.
    *
    * @since 3.16.0
    */
    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;
})(LSPErrorCodes = exports.LSPErrorCodes || (exports.LSPErrorCodes = {}));
const diag = __webpack_require__(/*! ./proposed.diagnostic */ "./node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js");
var Proposed;
(function (Proposed) {
    Proposed.DiagnosticServerCancellationData = diag.DiagnosticServerCancellationData;
    Proposed.DocumentDiagnosticReportKind = diag.DocumentDiagnosticReportKind;
    Proposed.DocumentDiagnosticRequest = diag.DocumentDiagnosticRequest;
    Proposed.WorkspaceDiagnosticRequest = diag.WorkspaceDiagnosticRequest;
    Proposed.DiagnosticRefreshRequest = diag.DiagnosticRefreshRequest;
})(Proposed = exports.Proposed || (exports.Proposed = {}));
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/connection.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/connection.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
function createProtocolConnection(input, output, logger, options) {
    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
    }
    return vscode_jsonrpc_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=connection.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/messages.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
class RegistrationType {
    constructor(method) {
        this.method = method;
    }
}
exports.RegistrationType = RegistrationType;
class ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolRequestType0 = ProtocolRequestType0;
class ProtocolRequestType extends vscode_jsonrpc_1.RequestType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolRequestType = ProtocolRequestType;
class ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {
    constructor(method) {
        super(method);
    }
}
exports.ProtocolNotificationType0 = ProtocolNotificationType0;
class ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {
    constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
    }
}
exports.ProtocolNotificationType = ProtocolNotificationType;
// let x: ProtocolNotificationType<number, { value: number}>;
// let y: ProtocolNotificationType<string, { value: number}>;
// x = y;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/proposed.diagnostic.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * @since 3.17.0 - proposed state
 */
var DiagnosticServerCancellationData;
(function (DiagnosticServerCancellationData) {
    function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
    }
    DiagnosticServerCancellationData.is = is;
})(DiagnosticServerCancellationData = exports.DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = {}));
/**
 * The document diagnostic report kinds.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticReportKind;
(function (DocumentDiagnosticReportKind) {
    /**
     * A diagnostic report with a full
     * set of problems.
     */
    DocumentDiagnosticReportKind["full"] = "full";
    /**
     * A report indicating that the last
     * returned report is still accurate.
     */
    DocumentDiagnosticReportKind["unChanged"] = "unChanged";
})(DocumentDiagnosticReportKind = exports.DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = {}));
/**
 * The document diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DocumentDiagnosticRequest;
(function (DocumentDiagnosticRequest) {
    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';
    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);
    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(DocumentDiagnosticRequest = exports.DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = {}));
/**
 * The workspace diagnostic request definition.
 *
 * @since 3.17.0 - proposed state
 */
var WorkspaceDiagnosticRequest;
(function (WorkspaceDiagnosticRequest) {
    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';
    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);
    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();
})(WorkspaceDiagnosticRequest = exports.WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = {}));
/**
 * The diagnostic refresh request definition.
 *
 * @since 3.17.0 - proposed state
 */
var DiagnosticRefreshRequest;
(function (DiagnosticRefreshRequest) {
    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;
    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);
})(DiagnosticRefreshRequest = exports.DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = {}));
//# sourceMappingURL=proposed.diagnostic.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) TypeFox, Microsoft and others. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to result a `CallHierarchyItem` in a document at a given position.
 * Can be used as an input to a incoming or outgoing call hierarchy.
 *
 * @since 3.16.0
 */
var CallHierarchyPrepareRequest;
(function (CallHierarchyPrepareRequest) {
    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';
    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);
})(CallHierarchyPrepareRequest = exports.CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = {}));
/**
 * A request to resolve the incoming calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyIncomingCallsRequest;
(function (CallHierarchyIncomingCallsRequest) {
    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';
    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);
})(CallHierarchyIncomingCallsRequest = exports.CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = {}));
/**
 * A request to resolve the outgoing calls for a given `CallHierarchyItem`.
 *
 * @since 3.16.0
 */
var CallHierarchyOutgoingCallsRequest;
(function (CallHierarchyOutgoingCallsRequest) {
    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';
    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);
})(CallHierarchyOutgoingCallsRequest = exports.CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = {}));
//# sourceMappingURL=protocol.callHierarchy.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to list all color symbols found in a given text document. The request's
 * parameter is of type [DocumentColorParams](#DocumentColorParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var DocumentColorRequest;
(function (DocumentColorRequest) {
    DocumentColorRequest.method = 'textDocument/documentColor';
    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);
})(DocumentColorRequest = exports.DocumentColorRequest || (exports.DocumentColorRequest = {}));
/**
 * A request to list all presentation for a color. The request's
 * parameter is of type [ColorPresentationParams](#ColorPresentationParams) the
 * response is of type [ColorInformation[]](#ColorInformation) or a Thenable
 * that resolves to such.
 */
var ColorPresentationRequest;
(function (ColorPresentationRequest) {
    ColorPresentationRequest.type = new messages_1.ProtocolRequestType('textDocument/colorPresentation');
})(ColorPresentationRequest = exports.ColorPresentationRequest || (exports.ColorPresentationRequest = {}));
//# sourceMappingURL=protocol.colorProvider.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConfigurationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The 'workspace/configuration' request is sent from the server to the client to fetch a certain
 * configuration setting.
 *
 * This pull model replaces the old push model were the client signaled configuration change via an
 * event. If the server still needs to react to configuration changes (since the server caches the
 * result of `workspace/configuration` requests) the server should register for an empty configuration
 * change event and empty the cache if such an event is received.
 */
var ConfigurationRequest;
(function (ConfigurationRequest) {
    ConfigurationRequest.type = new messages_1.ProtocolRequestType('workspace/configuration');
})(ConfigurationRequest = exports.ConfigurationRequest || (exports.ConfigurationRequest = {}));
//# sourceMappingURL=protocol.configuration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeclarationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Declaration](#Declaration)
 * or a typed array of [DeclarationLink](#DeclarationLink) or a Thenable that resolves
 * to such.
 */
var DeclarationRequest;
(function (DeclarationRequest) {
    DeclarationRequest.method = 'textDocument/declaration';
    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);
})(DeclarationRequest = exports.DeclarationRequest || (exports.DeclarationRequest = {}));
//# sourceMappingURL=protocol.declaration.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A pattern kind describing if a glob pattern matches a file a folder or
 * both.
 *
 * @since 3.16.0
 */
var FileOperationPatternKind;
(function (FileOperationPatternKind) {
    /**
     * The pattern matches a file only.
     */
    FileOperationPatternKind.file = 'file';
    /**
     * The pattern matches a folder only.
     */
    FileOperationPatternKind.folder = 'folder';
})(FileOperationPatternKind = exports.FileOperationPatternKind || (exports.FileOperationPatternKind = {}));
/**
 * The will create files request is sent from the client to the server before files are actually
 * created as long as the creation is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillCreateFilesRequest;
(function (WillCreateFilesRequest) {
    WillCreateFilesRequest.method = 'workspace/willCreateFiles';
    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);
})(WillCreateFilesRequest = exports.WillCreateFilesRequest || (exports.WillCreateFilesRequest = {}));
/**
 * The did create files notification is sent from the client to the server when
 * files were created from within the client.
 *
 * @since 3.16.0
 */
var DidCreateFilesNotification;
(function (DidCreateFilesNotification) {
    DidCreateFilesNotification.method = 'workspace/didCreateFiles';
    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);
})(DidCreateFilesNotification = exports.DidCreateFilesNotification || (exports.DidCreateFilesNotification = {}));
/**
 * The will rename files request is sent from the client to the server before files are actually
 * renamed as long as the rename is triggered from within the client.
 *
 * @since 3.16.0
 */
var WillRenameFilesRequest;
(function (WillRenameFilesRequest) {
    WillRenameFilesRequest.method = 'workspace/willRenameFiles';
    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);
})(WillRenameFilesRequest = exports.WillRenameFilesRequest || (exports.WillRenameFilesRequest = {}));
/**
 * The did rename files notification is sent from the client to the server when
 * files were renamed from within the client.
 *
 * @since 3.16.0
 */
var DidRenameFilesNotification;
(function (DidRenameFilesNotification) {
    DidRenameFilesNotification.method = 'workspace/didRenameFiles';
    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);
})(DidRenameFilesNotification = exports.DidRenameFilesNotification || (exports.DidRenameFilesNotification = {}));
/**
 * The will delete files request is sent from the client to the server before files are actually
 * deleted as long as the deletion is triggered from within the client.
 *
 * @since 3.16.0
 */
var DidDeleteFilesNotification;
(function (DidDeleteFilesNotification) {
    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';
    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);
})(DidDeleteFilesNotification = exports.DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = {}));
/**
 * The did delete files notification is sent from the client to the server when
 * files were deleted from within the client.
 *
 * @since 3.16.0
 */
var WillDeleteFilesRequest;
(function (WillDeleteFilesRequest) {
    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';
    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);
})(WillDeleteFilesRequest = exports.WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = {}));
//# sourceMappingURL=protocol.fileOperations.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FoldingRangeRequest = exports.FoldingRangeKind = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind = exports.FoldingRangeKind || (exports.FoldingRangeKind = {}));
/**
 * A request to provide folding ranges in a document. The request's
 * parameter is of type [FoldingRangeParams](#FoldingRangeParams), the
 * response is of type [FoldingRangeList](#FoldingRangeList) or a Thenable
 * that resolves to such.
 */
var FoldingRangeRequest;
(function (FoldingRangeRequest) {
    FoldingRangeRequest.method = 'textDocument/foldingRange';
    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);
})(FoldingRangeRequest = exports.FoldingRangeRequest || (exports.FoldingRangeRequest = {}));
//# sourceMappingURL=protocol.foldingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementationRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the implementation locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var ImplementationRequest;
(function (ImplementationRequest) {
    ImplementationRequest.method = 'textDocument/implementation';
    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);
})(ImplementationRequest = exports.ImplementationRequest || (exports.ImplementationRequest = {}));
//# sourceMappingURL=protocol.implementation.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeError = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.DocumentFilter = void 0;
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
const Is = __webpack_require__(/*! ./utils/is */ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js");
const protocol_implementation_1 = __webpack_require__(/*! ./protocol.implementation */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js");
Object.defineProperty(exports, "ImplementationRequest", ({ enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } }));
const protocol_typeDefinition_1 = __webpack_require__(/*! ./protocol.typeDefinition */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js");
Object.defineProperty(exports, "TypeDefinitionRequest", ({ enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } }));
const protocol_workspaceFolders_1 = __webpack_require__(/*! ./protocol.workspaceFolders */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js");
Object.defineProperty(exports, "WorkspaceFoldersRequest", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.WorkspaceFoldersRequest; } }));
Object.defineProperty(exports, "DidChangeWorkspaceFoldersNotification", ({ enumerable: true, get: function () { return protocol_workspaceFolders_1.DidChangeWorkspaceFoldersNotification; } }));
const protocol_configuration_1 = __webpack_require__(/*! ./protocol.configuration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js");
Object.defineProperty(exports, "ConfigurationRequest", ({ enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } }));
const protocol_colorProvider_1 = __webpack_require__(/*! ./protocol.colorProvider */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js");
Object.defineProperty(exports, "DocumentColorRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } }));
Object.defineProperty(exports, "ColorPresentationRequest", ({ enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } }));
const protocol_foldingRange_1 = __webpack_require__(/*! ./protocol.foldingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js");
Object.defineProperty(exports, "FoldingRangeRequest", ({ enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } }));
const protocol_declaration_1 = __webpack_require__(/*! ./protocol.declaration */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js");
Object.defineProperty(exports, "DeclarationRequest", ({ enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } }));
const protocol_selectionRange_1 = __webpack_require__(/*! ./protocol.selectionRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js");
Object.defineProperty(exports, "SelectionRangeRequest", ({ enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } }));
const protocol_progress_1 = __webpack_require__(/*! ./protocol.progress */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js");
Object.defineProperty(exports, "WorkDoneProgress", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } }));
Object.defineProperty(exports, "WorkDoneProgressCreateRequest", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } }));
Object.defineProperty(exports, "WorkDoneProgressCancelNotification", ({ enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } }));
const protocol_callHierarchy_1 = __webpack_require__(/*! ./protocol.callHierarchy */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js");
Object.defineProperty(exports, "CallHierarchyIncomingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyOutgoingCallsRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } }));
Object.defineProperty(exports, "CallHierarchyPrepareRequest", ({ enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } }));
const protocol_semanticTokens_1 = __webpack_require__(/*! ./protocol.semanticTokens */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js");
Object.defineProperty(exports, "TokenFormat", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } }));
Object.defineProperty(exports, "SemanticTokensRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } }));
Object.defineProperty(exports, "SemanticTokensDeltaRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } }));
Object.defineProperty(exports, "SemanticTokensRangeRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } }));
Object.defineProperty(exports, "SemanticTokensRefreshRequest", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } }));
Object.defineProperty(exports, "SemanticTokensRegistrationType", ({ enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } }));
const protocol_showDocument_1 = __webpack_require__(/*! ./protocol.showDocument */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js");
Object.defineProperty(exports, "ShowDocumentRequest", ({ enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } }));
const protocol_linkedEditingRange_1 = __webpack_require__(/*! ./protocol.linkedEditingRange */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js");
Object.defineProperty(exports, "LinkedEditingRangeRequest", ({ enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } }));
const protocol_fileOperations_1 = __webpack_require__(/*! ./protocol.fileOperations */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js");
Object.defineProperty(exports, "FileOperationPatternKind", ({ enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } }));
Object.defineProperty(exports, "DidCreateFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } }));
Object.defineProperty(exports, "WillCreateFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } }));
Object.defineProperty(exports, "DidRenameFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } }));
Object.defineProperty(exports, "WillRenameFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } }));
Object.defineProperty(exports, "DidDeleteFilesNotification", ({ enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } }));
Object.defineProperty(exports, "WillDeleteFilesRequest", ({ enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } }));
const protocol_moniker_1 = __webpack_require__(/*! ./protocol.moniker */ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js");
Object.defineProperty(exports, "UniquenessLevel", ({ enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } }));
Object.defineProperty(exports, "MonikerKind", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } }));
Object.defineProperty(exports, "MonikerRequest", ({ enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } }));
// @ts-ignore: to avoid inlining LocationLink as dynamic import
let __noDynamicImport;
/**
 * The DocumentFilter namespace provides helper functions to work with
 * [DocumentFilter](#DocumentFilter) literals.
 */
var DocumentFilter;
(function (DocumentFilter) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
    }
    DocumentFilter.is = is;
})(DocumentFilter = exports.DocumentFilter || (exports.DocumentFilter = {}));
/**
 * The DocumentSelector namespace provides helper functions to work with
 * [DocumentSelector](#DocumentSelector)s.
 */
var DocumentSelector;
(function (DocumentSelector) {
    function is(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        for (let elem of value) {
            if (!Is.string(elem) && !DocumentFilter.is(elem)) {
                return false;
            }
        }
        return true;
    }
    DocumentSelector.is = is;
})(DocumentSelector = exports.DocumentSelector || (exports.DocumentSelector = {}));
/**
 * The `client/registerCapability` request is sent from the server to the client to register a new capability
 * handler on the client side.
 */
var RegistrationRequest;
(function (RegistrationRequest) {
    RegistrationRequest.type = new messages_1.ProtocolRequestType('client/registerCapability');
})(RegistrationRequest = exports.RegistrationRequest || (exports.RegistrationRequest = {}));
/**
 * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability
 * handler on the client side.
 */
var UnregistrationRequest;
(function (UnregistrationRequest) {
    UnregistrationRequest.type = new messages_1.ProtocolRequestType('client/unregisterCapability');
})(UnregistrationRequest = exports.UnregistrationRequest || (exports.UnregistrationRequest = {}));
var ResourceOperationKind;
(function (ResourceOperationKind) {
    /**
     * Supports creating new files and folders.
     */
    ResourceOperationKind.Create = 'create';
    /**
     * Supports renaming existing files and folders.
     */
    ResourceOperationKind.Rename = 'rename';
    /**
     * Supports deleting existing files and folders.
     */
    ResourceOperationKind.Delete = 'delete';
})(ResourceOperationKind = exports.ResourceOperationKind || (exports.ResourceOperationKind = {}));
var FailureHandlingKind;
(function (FailureHandlingKind) {
    /**
     * Applying the workspace change is simply aborted if one of the changes provided
     * fails. All operations executed before the failing operation stay executed.
     */
    FailureHandlingKind.Abort = 'abort';
    /**
     * All operations are executed transactional. That means they either all
     * succeed or no changes at all are applied to the workspace.
     */
    FailureHandlingKind.Transactional = 'transactional';
    /**
     * If the workspace edit contains only textual file changes they are executed transactional.
     * If resource changes (create, rename or delete file) are part of the change the failure
     * handling strategy is abort.
     */
    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';
    /**
     * The client tries to undo the operations already executed. But there is no
     * guarantee that this is succeeding.
     */
    FailureHandlingKind.Undo = 'undo';
})(FailureHandlingKind = exports.FailureHandlingKind || (exports.FailureHandlingKind = {}));
/**
 * The StaticRegistrationOptions namespace provides helper functions to work with
 * [StaticRegistrationOptions](#StaticRegistrationOptions) literals.
 */
var StaticRegistrationOptions;
(function (StaticRegistrationOptions) {
    function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
    }
    StaticRegistrationOptions.hasId = hasId;
})(StaticRegistrationOptions = exports.StaticRegistrationOptions || (exports.StaticRegistrationOptions = {}));
/**
 * The TextDocumentRegistrationOptions namespace provides helper functions to work with
 * [TextDocumentRegistrationOptions](#TextDocumentRegistrationOptions) literals.
 */
var TextDocumentRegistrationOptions;
(function (TextDocumentRegistrationOptions) {
    function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
    }
    TextDocumentRegistrationOptions.is = is;
})(TextDocumentRegistrationOptions = exports.TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = {}));
/**
 * The WorkDoneProgressOptions namespace provides helper functions to work with
 * [WorkDoneProgressOptions](#WorkDoneProgressOptions) literals.
 */
var WorkDoneProgressOptions;
(function (WorkDoneProgressOptions) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));
    }
    WorkDoneProgressOptions.is = is;
    function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
    }
    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;
})(WorkDoneProgressOptions = exports.WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = {}));
/**
 * The initialize request is sent from the client to the server.
 * It is sent once as the request after starting up the server.
 * The requests parameter is of type [InitializeParams](#InitializeParams)
 * the response if of type [InitializeResult](#InitializeResult) of a Thenable that
 * resolves to such.
 */
var InitializeRequest;
(function (InitializeRequest) {
    InitializeRequest.type = new messages_1.ProtocolRequestType('initialize');
})(InitializeRequest = exports.InitializeRequest || (exports.InitializeRequest = {}));
/**
 * Known error codes for an `InitializeError`;
 */
var InitializeError;
(function (InitializeError) {
    /**
     * If the protocol version provided by the client can't be handled by the server.
     * @deprecated This initialize error got replaced by client capabilities. There is
     * no version handshake in version 3.0x
     */
    InitializeError.unknownProtocolVersion = 1;
})(InitializeError = exports.InitializeError || (exports.InitializeError = {}));
/**
 * The initialized notification is sent from the client to the
 * server after the client is fully initialized and the server
 * is allowed to send requests from the server to the client.
 */
var InitializedNotification;
(function (InitializedNotification) {
    InitializedNotification.type = new messages_1.ProtocolNotificationType('initialized');
})(InitializedNotification = exports.InitializedNotification || (exports.InitializedNotification = {}));
//---- Shutdown Method ----
/**
 * A shutdown request is sent from the client to the server.
 * It is sent once when the client decides to shutdown the
 * server. The only notification that is sent after a shutdown request
 * is the exit event.
 */
var ShutdownRequest;
(function (ShutdownRequest) {
    ShutdownRequest.type = new messages_1.ProtocolRequestType0('shutdown');
})(ShutdownRequest = exports.ShutdownRequest || (exports.ShutdownRequest = {}));
//---- Exit Notification ----
/**
 * The exit event is sent from the client to the server to
 * ask the server to exit its process.
 */
var ExitNotification;
(function (ExitNotification) {
    ExitNotification.type = new messages_1.ProtocolNotificationType0('exit');
})(ExitNotification = exports.ExitNotification || (exports.ExitNotification = {}));
/**
 * The configuration change notification is sent from the client to the server
 * when the client's configuration has changed. The notification contains
 * the changed configuration as defined by the language client.
 */
var DidChangeConfigurationNotification;
(function (DidChangeConfigurationNotification) {
    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeConfiguration');
})(DidChangeConfigurationNotification = exports.DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = {}));
//---- Message show and log notifications ----
/**
 * The message type
 */
var MessageType;
(function (MessageType) {
    /**
     * An error message.
     */
    MessageType.Error = 1;
    /**
     * A warning message.
     */
    MessageType.Warning = 2;
    /**
     * An information message.
     */
    MessageType.Info = 3;
    /**
     * A log message.
     */
    MessageType.Log = 4;
})(MessageType = exports.MessageType || (exports.MessageType = {}));
/**
 * The show message notification is sent from a server to a client to ask
 * the client to display a particular message in the user interface.
 */
var ShowMessageNotification;
(function (ShowMessageNotification) {
    ShowMessageNotification.type = new messages_1.ProtocolNotificationType('window/showMessage');
})(ShowMessageNotification = exports.ShowMessageNotification || (exports.ShowMessageNotification = {}));
/**
 * The show message request is sent from the server to the client to show a message
 * and a set of options actions to the user.
 */
var ShowMessageRequest;
(function (ShowMessageRequest) {
    ShowMessageRequest.type = new messages_1.ProtocolRequestType('window/showMessageRequest');
})(ShowMessageRequest = exports.ShowMessageRequest || (exports.ShowMessageRequest = {}));
/**
 * The log message notification is sent from the server to the client to ask
 * the client to log a particular message.
 */
var LogMessageNotification;
(function (LogMessageNotification) {
    LogMessageNotification.type = new messages_1.ProtocolNotificationType('window/logMessage');
})(LogMessageNotification = exports.LogMessageNotification || (exports.LogMessageNotification = {}));
//---- Telemetry notification
/**
 * The telemetry event notification is sent from the server to the client to ask
 * the client to log telemetry data.
 */
var TelemetryEventNotification;
(function (TelemetryEventNotification) {
    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType('telemetry/event');
})(TelemetryEventNotification = exports.TelemetryEventNotification || (exports.TelemetryEventNotification = {}));
/**
 * Defines how the host (editor) should sync
 * document changes to the language server.
 */
var TextDocumentSyncKind;
(function (TextDocumentSyncKind) {
    /**
     * Documents should not be synced at all.
     */
    TextDocumentSyncKind.None = 0;
    /**
     * Documents are synced by always sending the full content
     * of the document.
     */
    TextDocumentSyncKind.Full = 1;
    /**
     * Documents are synced by sending the full content on open.
     * After that only incremental updates to the document are
     * send.
     */
    TextDocumentSyncKind.Incremental = 2;
})(TextDocumentSyncKind = exports.TextDocumentSyncKind || (exports.TextDocumentSyncKind = {}));
/**
 * The document open notification is sent from the client to the server to signal
 * newly opened text documents. The document's truth is now managed by the client
 * and the server must not try to read the document's truth using the document's
 * uri. Open in this sense means it is managed by the client. It doesn't necessarily
 * mean that its content is presented in an editor. An open notification must not
 * be sent more than once without a corresponding close notification send before.
 * This means open and close notification must be balanced and the max open count
 * is one.
 */
var DidOpenTextDocumentNotification;
(function (DidOpenTextDocumentNotification) {
    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';
    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);
})(DidOpenTextDocumentNotification = exports.DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = {}));
var TextDocumentContentChangeEvent;
(function (TextDocumentContentChangeEvent) {
    /**
     * Checks whether the information describes a delta event.
     */
    function isIncremental(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    TextDocumentContentChangeEvent.isIncremental = isIncremental;
    /**
     * Checks whether the information describes a full replacement event.
     */
    function isFull(event) {
        let candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
    TextDocumentContentChangeEvent.isFull = isFull;
})(TextDocumentContentChangeEvent = exports.TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = {}));
/**
 * The document change notification is sent from the client to the server to signal
 * changes to a text document.
 */
var DidChangeTextDocumentNotification;
(function (DidChangeTextDocumentNotification) {
    DidChangeTextDocumentNotification.method = 'textDocument/didChange';
    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);
})(DidChangeTextDocumentNotification = exports.DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = {}));
/**
 * The document close notification is sent from the client to the server when
 * the document got closed in the client. The document's truth now exists where
 * the document's uri points to (e.g. if the document's uri is a file uri the
 * truth now exists on disk). As with the open notification the close notification
 * is about managing the document's content. Receiving a close notification
 * doesn't mean that the document was open in an editor before. A close
 * notification requires a previous open notification to be sent.
 */
var DidCloseTextDocumentNotification;
(function (DidCloseTextDocumentNotification) {
    DidCloseTextDocumentNotification.method = 'textDocument/didClose';
    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);
})(DidCloseTextDocumentNotification = exports.DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = {}));
/**
 * The document save notification is sent from the client to the server when
 * the document got saved in the client.
 */
var DidSaveTextDocumentNotification;
(function (DidSaveTextDocumentNotification) {
    DidSaveTextDocumentNotification.method = 'textDocument/didSave';
    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);
})(DidSaveTextDocumentNotification = exports.DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
/**
 * A document will save notification is sent from the client to the server before
 * the document is actually saved.
 */
var WillSaveTextDocumentNotification;
(function (WillSaveTextDocumentNotification) {
    WillSaveTextDocumentNotification.method = 'textDocument/willSave';
    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);
})(WillSaveTextDocumentNotification = exports.WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = {}));
/**
 * A document will save request is sent from the client to the server before
 * the document is actually saved. The request can return an array of TextEdits
 * which will be applied to the text document before it is saved. Please note that
 * clients might drop results if computing the text edits took too long or if a
 * server constantly fails on this request. This is done to keep the save fast and
 * reliable.
 */
var WillSaveTextDocumentWaitUntilRequest;
(function (WillSaveTextDocumentWaitUntilRequest) {
    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';
    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);
})(WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = {}));
/**
 * The watched files notification is sent from the client to the server when
 * the client detects changes to file watched by the language client.
 */
var DidChangeWatchedFilesNotification;
(function (DidChangeWatchedFilesNotification) {
    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWatchedFiles');
})(DidChangeWatchedFilesNotification = exports.DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = {}));
/**
 * The file event type
 */
var FileChangeType;
(function (FileChangeType) {
    /**
     * The file got created.
     */
    FileChangeType.Created = 1;
    /**
     * The file got changed.
     */
    FileChangeType.Changed = 2;
    /**
     * The file got deleted.
     */
    FileChangeType.Deleted = 3;
})(FileChangeType = exports.FileChangeType || (exports.FileChangeType = {}));
var WatchKind;
(function (WatchKind) {
    /**
     * Interested in create events.
     */
    WatchKind.Create = 1;
    /**
     * Interested in change events
     */
    WatchKind.Change = 2;
    /**
     * Interested in delete events
     */
    WatchKind.Delete = 4;
})(WatchKind = exports.WatchKind || (exports.WatchKind = {}));
/**
 * Diagnostics notification are sent from the server to the client to signal
 * results of validation runs.
 */
var PublishDiagnosticsNotification;
(function (PublishDiagnosticsNotification) {
    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType('textDocument/publishDiagnostics');
})(PublishDiagnosticsNotification = exports.PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = {}));
/**
 * How a completion was triggered
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    /**
     * Completion was triggered by typing an identifier (24x7 code
     * complete), manual invocation (e.g Ctrl+Space) or via API.
     */
    CompletionTriggerKind.Invoked = 1;
    /**
     * Completion was triggered by a trigger character specified by
     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.
     */
    CompletionTriggerKind.TriggerCharacter = 2;
    /**
     * Completion was re-triggered as current completion list is incomplete
     */
    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;
})(CompletionTriggerKind = exports.CompletionTriggerKind || (exports.CompletionTriggerKind = {}));
/**
 * Request to request completion at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response
 * is of type [CompletionItem[]](#CompletionItem) or [CompletionList](#CompletionList)
 * or a Thenable that resolves to such.
 *
 * The request can delay the computation of the [`detail`](#CompletionItem.detail)
 * and [`documentation`](#CompletionItem.documentation) properties to the `completionItem/resolve`
 * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,
 * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.
 */
var CompletionRequest;
(function (CompletionRequest) {
    CompletionRequest.method = 'textDocument/completion';
    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);
})(CompletionRequest = exports.CompletionRequest || (exports.CompletionRequest = {}));
/**
 * Request to resolve additional information for a given completion item.The request's
 * parameter is of type [CompletionItem](#CompletionItem) the response
 * is of type [CompletionItem](#CompletionItem) or a Thenable that resolves to such.
 */
var CompletionResolveRequest;
(function (CompletionResolveRequest) {
    CompletionResolveRequest.method = 'completionItem/resolve';
    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);
})(CompletionResolveRequest = exports.CompletionResolveRequest || (exports.CompletionResolveRequest = {}));
/**
 * Request to request hover information at a given text document position. The request's
 * parameter is of type [TextDocumentPosition](#TextDocumentPosition) the response is of
 * type [Hover](#Hover) or a Thenable that resolves to such.
 */
var HoverRequest;
(function (HoverRequest) {
    HoverRequest.method = 'textDocument/hover';
    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);
})(HoverRequest = exports.HoverRequest || (exports.HoverRequest = {}));
/**
 * How a signature help was triggered.
 *
 * @since 3.15.0
 */
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    /**
     * Signature help was invoked manually by the user or by a command.
     */
    SignatureHelpTriggerKind.Invoked = 1;
    /**
     * Signature help was triggered by a trigger character.
     */
    SignatureHelpTriggerKind.TriggerCharacter = 2;
    /**
     * Signature help was triggered by the cursor moving or by the document content changing.
     */
    SignatureHelpTriggerKind.ContentChange = 3;
})(SignatureHelpTriggerKind = exports.SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = {}));
var SignatureHelpRequest;
(function (SignatureHelpRequest) {
    SignatureHelpRequest.method = 'textDocument/signatureHelp';
    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);
})(SignatureHelpRequest = exports.SignatureHelpRequest || (exports.SignatureHelpRequest = {}));
/**
 * A request to resolve the definition location of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the response is of either type [Definition](#Definition)
 * or a typed array of [DefinitionLink](#DefinitionLink) or a Thenable that resolves
 * to such.
 */
var DefinitionRequest;
(function (DefinitionRequest) {
    DefinitionRequest.method = 'textDocument/definition';
    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);
})(DefinitionRequest = exports.DefinitionRequest || (exports.DefinitionRequest = {}));
/**
 * A request to resolve project-wide references for the symbol denoted
 * by the given text document position. The request's parameter is of
 * type [ReferenceParams](#ReferenceParams) the response is of type
 * [Location[]](#Location) or a Thenable that resolves to such.
 */
var ReferencesRequest;
(function (ReferencesRequest) {
    ReferencesRequest.method = 'textDocument/references';
    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);
})(ReferencesRequest = exports.ReferencesRequest || (exports.ReferencesRequest = {}));
/**
 * Request to resolve a [DocumentHighlight](#DocumentHighlight) for a given
 * text document position. The request's parameter is of type [TextDocumentPosition]
 * (#TextDocumentPosition) the request response is of type [DocumentHighlight[]]
 * (#DocumentHighlight) or a Thenable that resolves to such.
 */
var DocumentHighlightRequest;
(function (DocumentHighlightRequest) {
    DocumentHighlightRequest.method = 'textDocument/documentHighlight';
    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);
})(DocumentHighlightRequest = exports.DocumentHighlightRequest || (exports.DocumentHighlightRequest = {}));
/**
 * A request to list all symbols found in a given text document. The request's
 * parameter is of type [TextDocumentIdentifier](#TextDocumentIdentifier) the
 * response is of type [SymbolInformation[]](#SymbolInformation) or a Thenable
 * that resolves to such.
 */
var DocumentSymbolRequest;
(function (DocumentSymbolRequest) {
    DocumentSymbolRequest.method = 'textDocument/documentSymbol';
    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);
})(DocumentSymbolRequest = exports.DocumentSymbolRequest || (exports.DocumentSymbolRequest = {}));
/**
 * A request to provide commands for the given text document and range.
 */
var CodeActionRequest;
(function (CodeActionRequest) {
    CodeActionRequest.method = 'textDocument/codeAction';
    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);
})(CodeActionRequest = exports.CodeActionRequest || (exports.CodeActionRequest = {}));
/**
 * Request to resolve additional information for a given code action.The request's
 * parameter is of type [CodeAction](#CodeAction) the response
 * is of type [CodeAction](#CodeAction) or a Thenable that resolves to such.
 */
var CodeActionResolveRequest;
(function (CodeActionResolveRequest) {
    CodeActionResolveRequest.method = 'codeAction/resolve';
    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);
})(CodeActionResolveRequest = exports.CodeActionResolveRequest || (exports.CodeActionResolveRequest = {}));
/**
 * A request to list project-wide symbols matching the query string given
 * by the [WorkspaceSymbolParams](#WorkspaceSymbolParams). The response is
 * of type [SymbolInformation[]](#SymbolInformation) or a Thenable that
 * resolves to such.
 */
var WorkspaceSymbolRequest;
(function (WorkspaceSymbolRequest) {
    WorkspaceSymbolRequest.method = 'workspace/symbol';
    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);
})(WorkspaceSymbolRequest = exports.WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = {}));
/**
 * A request to provide code lens for the given text document.
 */
var CodeLensRequest;
(function (CodeLensRequest) {
    CodeLensRequest.method = 'textDocument/codeLens';
    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);
})(CodeLensRequest = exports.CodeLensRequest || (exports.CodeLensRequest = {}));
/**
 * A request to resolve a command for a given code lens.
 */
var CodeLensResolveRequest;
(function (CodeLensResolveRequest) {
    CodeLensResolveRequest.method = 'codeLens/resolve';
    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);
})(CodeLensResolveRequest = exports.CodeLensResolveRequest || (exports.CodeLensResolveRequest = {}));
/**
 * A request to refresh all code actions
 *
 * @since 3.16.0
 */
var CodeLensRefreshRequest;
(function (CodeLensRefreshRequest) {
    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;
    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);
})(CodeLensRefreshRequest = exports.CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = {}));
/**
 * A request to provide document links
 */
var DocumentLinkRequest;
(function (DocumentLinkRequest) {
    DocumentLinkRequest.method = 'textDocument/documentLink';
    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);
})(DocumentLinkRequest = exports.DocumentLinkRequest || (exports.DocumentLinkRequest = {}));
/**
 * Request to resolve additional information for a given document link. The request's
 * parameter is of type [DocumentLink](#DocumentLink) the response
 * is of type [DocumentLink](#DocumentLink) or a Thenable that resolves to such.
 */
var DocumentLinkResolveRequest;
(function (DocumentLinkResolveRequest) {
    DocumentLinkResolveRequest.method = 'documentLink/resolve';
    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);
})(DocumentLinkResolveRequest = exports.DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = {}));
/**
 * A request to to format a whole document.
 */
var DocumentFormattingRequest;
(function (DocumentFormattingRequest) {
    DocumentFormattingRequest.method = 'textDocument/formatting';
    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);
})(DocumentFormattingRequest = exports.DocumentFormattingRequest || (exports.DocumentFormattingRequest = {}));
/**
 * A request to to format a range in a document.
 */
var DocumentRangeFormattingRequest;
(function (DocumentRangeFormattingRequest) {
    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';
    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);
})(DocumentRangeFormattingRequest = exports.DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = {}));
/**
 * A request to format a document on type.
 */
var DocumentOnTypeFormattingRequest;
(function (DocumentOnTypeFormattingRequest) {
    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';
    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);
})(DocumentOnTypeFormattingRequest = exports.DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = {}));
//---- Rename ----------------------------------------------
var PrepareSupportDefaultBehavior;
(function (PrepareSupportDefaultBehavior) {
    /**
     * The client's default behavior is to select the identifier
     * according the to language's syntax rule.
     */
    PrepareSupportDefaultBehavior.Identifier = 1;
})(PrepareSupportDefaultBehavior = exports.PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = {}));
/**
 * A request to rename a symbol.
 */
var RenameRequest;
(function (RenameRequest) {
    RenameRequest.method = 'textDocument/rename';
    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);
})(RenameRequest = exports.RenameRequest || (exports.RenameRequest = {}));
/**
 * A request to test and perform the setup necessary for a rename.
 *
 * @since 3.16 - support for default behavior
 */
var PrepareRenameRequest;
(function (PrepareRenameRequest) {
    PrepareRenameRequest.method = 'textDocument/prepareRename';
    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);
})(PrepareRenameRequest = exports.PrepareRenameRequest || (exports.PrepareRenameRequest = {}));
/**
 * A request send from the client to the server to execute a command. The request might return
 * a workspace edit which the client will apply to the workspace.
 */
var ExecuteCommandRequest;
(function (ExecuteCommandRequest) {
    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType('workspace/executeCommand');
})(ExecuteCommandRequest = exports.ExecuteCommandRequest || (exports.ExecuteCommandRequest = {}));
/**
 * A request sent from the server to the client to modified certain resources.
 */
var ApplyWorkspaceEditRequest;
(function (ApplyWorkspaceEditRequest) {
    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');
})(ApplyWorkspaceEditRequest = exports.ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = {}));
//# sourceMappingURL=protocol.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedEditingRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide ranges that can be edited together.
 *
 * @since 3.16.0
 */
var LinkedEditingRangeRequest;
(function (LinkedEditingRangeRequest) {
    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';
    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);
})(LinkedEditingRangeRequest = exports.LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = {}));
//# sourceMappingURL=protocol.linkedEditingRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js":
/*!************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * Moniker uniqueness level to define scope of the moniker.
 *
 * @since 3.16.0
 */
var UniquenessLevel;
(function (UniquenessLevel) {
    /**
     * The moniker is only unique inside a document
     */
    UniquenessLevel["document"] = "document";
    /**
     * The moniker is unique inside a project for which a dump got created
     */
    UniquenessLevel["project"] = "project";
    /**
     * The moniker is unique inside the group to which a project belongs
     */
    UniquenessLevel["group"] = "group";
    /**
     * The moniker is unique inside the moniker scheme.
     */
    UniquenessLevel["scheme"] = "scheme";
    /**
     * The moniker is globally unique
     */
    UniquenessLevel["global"] = "global";
})(UniquenessLevel = exports.UniquenessLevel || (exports.UniquenessLevel = {}));
/**
 * The moniker kind.
 *
 * @since 3.16.0
 */
var MonikerKind;
(function (MonikerKind) {
    /**
     * The moniker represent a symbol that is imported into a project
     */
    MonikerKind["import"] = "import";
    /**
     * The moniker represents a symbol that is exported from a project
     */
    MonikerKind["export"] = "export";
    /**
     * The moniker represents a symbol that is local to a project (e.g. a local
     * variable of a function, a class not visible outside the project, ...)
     */
    MonikerKind["local"] = "local";
})(MonikerKind = exports.MonikerKind || (exports.MonikerKind = {}));
/**
 * A request to get the moniker of a symbol at a given text document position.
 * The request parameter is of type [TextDocumentPositionParams](#TextDocumentPositionParams).
 * The response is of type [Moniker[]](#Moniker[]) or `null`.
 */
var MonikerRequest;
(function (MonikerRequest) {
    MonikerRequest.method = 'textDocument/moniker';
    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);
})(MonikerRequest = exports.MonikerRequest || (exports.MonikerRequest = {}));
//# sourceMappingURL=protocol.moniker.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;
const vscode_jsonrpc_1 = __webpack_require__(/*! vscode-jsonrpc */ "./node_modules/vscode-jsonrpc/lib/node/main.js");
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
var WorkDoneProgress;
(function (WorkDoneProgress) {
    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();
    function is(value) {
        return value === WorkDoneProgress.type;
    }
    WorkDoneProgress.is = is;
})(WorkDoneProgress = exports.WorkDoneProgress || (exports.WorkDoneProgress = {}));
/**
 * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress
 * reporting from the server.
 */
var WorkDoneProgressCreateRequest;
(function (WorkDoneProgressCreateRequest) {
    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType('window/workDoneProgress/create');
})(WorkDoneProgressCreateRequest = exports.WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = {}));
/**
 * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress
 * initiated on the server side.
 */
var WorkDoneProgressCancelNotification;
(function (WorkDoneProgressCancelNotification) {
    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType('window/workDoneProgress/cancel');
})(WorkDoneProgressCancelNotification = exports.WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = {}));
//# sourceMappingURL=protocol.progress.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionRangeRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to provide selection ranges in a document. The request's
 * parameter is of type [SelectionRangeParams](#SelectionRangeParams), the
 * response is of type [SelectionRange[]](#SelectionRange[]) or a Thenable
 * that resolves to such.
 */
var SelectionRangeRequest;
(function (SelectionRangeRequest) {
    SelectionRangeRequest.method = 'textDocument/selectionRange';
    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);
})(SelectionRangeRequest = exports.SelectionRangeRequest || (exports.SelectionRangeRequest = {}));
//# sourceMappingURL=protocol.selectionRange.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
//------- 'textDocument/semanticTokens' -----
var TokenFormat;
(function (TokenFormat) {
    TokenFormat.Relative = 'relative';
})(TokenFormat = exports.TokenFormat || (exports.TokenFormat = {}));
var SemanticTokensRegistrationType;
(function (SemanticTokensRegistrationType) {
    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';
    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);
})(SemanticTokensRegistrationType = exports.SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRequest;
(function (SemanticTokensRequest) {
    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';
    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);
})(SemanticTokensRequest = exports.SemanticTokensRequest || (exports.SemanticTokensRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensDeltaRequest;
(function (SemanticTokensDeltaRequest) {
    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';
    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);
})(SemanticTokensDeltaRequest = exports.SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRangeRequest;
(function (SemanticTokensRangeRequest) {
    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';
    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);
})(SemanticTokensRangeRequest = exports.SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = {}));
/**
 * @since 3.16.0
 */
var SemanticTokensRefreshRequest;
(function (SemanticTokensRefreshRequest) {
    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;
    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);
})(SemanticTokensRefreshRequest = exports.SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = {}));
//# sourceMappingURL=protocol.semanticTokens.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShowDocumentRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * A request to show a document. This request might open an
 * external program depending on the value of the URI to open.
 * For example a request to open `https://code.visualstudio.com/`
 * will very likely open the URI in a WEB browser.
 *
 * @since 3.16.0
*/
var ShowDocumentRequest;
(function (ShowDocumentRequest) {
    ShowDocumentRequest.method = 'window/showDocument';
    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);
})(ShowDocumentRequest = exports.ShowDocumentRequest || (exports.ShowDocumentRequest = {}));
//# sourceMappingURL=protocol.showDocument.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitionRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
// @ts-ignore: to avoid inlining LocatioLink as dynamic import
let __noDynamicImport;
/**
 * A request to resolve the type definition locations of a symbol at a given text
 * document position. The request's parameter is of type [TextDocumentPositioParams]
 * (#TextDocumentPositionParams) the response is of type [Definition](#Definition) or a
 * Thenable that resolves to such.
 */
var TypeDefinitionRequest;
(function (TypeDefinitionRequest) {
    TypeDefinitionRequest.method = 'textDocument/typeDefinition';
    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);
})(TypeDefinitionRequest = exports.TypeDefinitionRequest || (exports.TypeDefinitionRequest = {}));
//# sourceMappingURL=protocol.typeDefinition.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolders.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;
const messages_1 = __webpack_require__(/*! ./messages */ "./node_modules/vscode-languageserver-protocol/lib/common/messages.js");
/**
 * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.
 */
var WorkspaceFoldersRequest;
(function (WorkspaceFoldersRequest) {
    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0('workspace/workspaceFolders');
})(WorkspaceFoldersRequest = exports.WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = {}));
/**
 * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace
 * folder configuration changes.
 */
var DidChangeWorkspaceFoldersNotification;
(function (DidChangeWorkspaceFoldersNotification) {
    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType('workspace/didChangeWorkspaceFolders');
})(DidChangeWorkspaceFoldersNotification = exports.DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = {}));
//# sourceMappingURL=protocol.workspaceFolders.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js":
/*!****************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/common/utils/is.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;
function typedArray(value, check) {
    return Array.isArray(value) && value.every(check);
}
exports.typedArray = typedArray;
function objectLiteral(value) {
    // Strictly speaking class instances pass this check as well. Since the LSP
    // doesn't use classes we ignore this for now. If we do we need to add something
    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
    return value !== null && typeof value === 'object';
}
exports.objectLiteral = objectLiteral;
//# sourceMappingURL=is.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/lib/node/main.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/lib/node/main.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createProtocolConnection = void 0;
const node_1 = __webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js");
__exportStar(__webpack_require__(/*! vscode-jsonrpc/node */ "./node_modules/vscode-jsonrpc/node.js"), exports);
__exportStar(__webpack_require__(/*! ../common/api */ "./node_modules/vscode-languageserver-protocol/lib/common/api.js"), exports);
function createProtocolConnection(input, output, logger, options) {
    return node_1.createMessageConnection(input, output, logger, options);
}
exports.createProtocolConnection = createProtocolConnection;
//# sourceMappingURL=main.js.map

/***/ }),

/***/ "./node_modules/vscode-languageserver-protocol/node.js":
/*!*************************************************************!*\
  !*** ./node_modules/vscode-languageserver-protocol/node.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ----------------------------------------------------------------------------------------- */


module.exports = __webpack_require__(/*! ./lib/node/main */ "./node_modules/vscode-languageserver-protocol/lib/node/main.js");

/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnotatedTextEdit": () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   "ChangeAnnotation": () => (/* binding */ ChangeAnnotation),
/* harmony export */   "ChangeAnnotationIdentifier": () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   "CodeAction": () => (/* binding */ CodeAction),
/* harmony export */   "CodeActionContext": () => (/* binding */ CodeActionContext),
/* harmony export */   "CodeActionKind": () => (/* binding */ CodeActionKind),
/* harmony export */   "CodeDescription": () => (/* binding */ CodeDescription),
/* harmony export */   "CodeLens": () => (/* binding */ CodeLens),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "ColorInformation": () => (/* binding */ ColorInformation),
/* harmony export */   "ColorPresentation": () => (/* binding */ ColorPresentation),
/* harmony export */   "Command": () => (/* binding */ Command),
/* harmony export */   "CompletionItem": () => (/* binding */ CompletionItem),
/* harmony export */   "CompletionItemKind": () => (/* binding */ CompletionItemKind),
/* harmony export */   "CompletionItemLabelDetails": () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   "CompletionItemTag": () => (/* binding */ CompletionItemTag),
/* harmony export */   "CompletionList": () => (/* binding */ CompletionList),
/* harmony export */   "CreateFile": () => (/* binding */ CreateFile),
/* harmony export */   "DeleteFile": () => (/* binding */ DeleteFile),
/* harmony export */   "Diagnostic": () => (/* binding */ Diagnostic),
/* harmony export */   "DiagnosticRelatedInformation": () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   "DiagnosticSeverity": () => (/* binding */ DiagnosticSeverity),
/* harmony export */   "DiagnosticTag": () => (/* binding */ DiagnosticTag),
/* harmony export */   "DocumentHighlight": () => (/* binding */ DocumentHighlight),
/* harmony export */   "DocumentHighlightKind": () => (/* binding */ DocumentHighlightKind),
/* harmony export */   "DocumentLink": () => (/* binding */ DocumentLink),
/* harmony export */   "DocumentSymbol": () => (/* binding */ DocumentSymbol),
/* harmony export */   "EOL": () => (/* binding */ EOL),
/* harmony export */   "FoldingRange": () => (/* binding */ FoldingRange),
/* harmony export */   "FoldingRangeKind": () => (/* binding */ FoldingRangeKind),
/* harmony export */   "FormattingOptions": () => (/* binding */ FormattingOptions),
/* harmony export */   "Hover": () => (/* binding */ Hover),
/* harmony export */   "InsertReplaceEdit": () => (/* binding */ InsertReplaceEdit),
/* harmony export */   "InsertTextFormat": () => (/* binding */ InsertTextFormat),
/* harmony export */   "InsertTextMode": () => (/* binding */ InsertTextMode),
/* harmony export */   "Location": () => (/* binding */ Location),
/* harmony export */   "LocationLink": () => (/* binding */ LocationLink),
/* harmony export */   "MarkedString": () => (/* binding */ MarkedString),
/* harmony export */   "MarkupContent": () => (/* binding */ MarkupContent),
/* harmony export */   "MarkupKind": () => (/* binding */ MarkupKind),
/* harmony export */   "OptionalVersionedTextDocumentIdentifier": () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   "ParameterInformation": () => (/* binding */ ParameterInformation),
/* harmony export */   "Position": () => (/* binding */ Position),
/* harmony export */   "Range": () => (/* binding */ Range),
/* harmony export */   "RenameFile": () => (/* binding */ RenameFile),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "SemanticTokenModifiers": () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   "SemanticTokenTypes": () => (/* binding */ SemanticTokenTypes),
/* harmony export */   "SemanticTokens": () => (/* binding */ SemanticTokens),
/* harmony export */   "SignatureInformation": () => (/* binding */ SignatureInformation),
/* harmony export */   "SymbolInformation": () => (/* binding */ SymbolInformation),
/* harmony export */   "SymbolKind": () => (/* binding */ SymbolKind),
/* harmony export */   "SymbolTag": () => (/* binding */ SymbolTag),
/* harmony export */   "TextDocument": () => (/* binding */ TextDocument),
/* harmony export */   "TextDocumentEdit": () => (/* binding */ TextDocumentEdit),
/* harmony export */   "TextDocumentIdentifier": () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   "TextDocumentItem": () => (/* binding */ TextDocumentItem),
/* harmony export */   "TextEdit": () => (/* binding */ TextEdit),
/* harmony export */   "VersionedTextDocumentIdentifier": () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   "WorkspaceChange": () => (/* binding */ WorkspaceChange),
/* harmony export */   "WorkspaceEdit": () => (/* binding */ WorkspaceEdit),
/* harmony export */   "integer": () => (/* binding */ integer),
/* harmony export */   "uinteger": () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && (Range.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange))
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && candidate !== null && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var _a;
        var candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        var result = { label: label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        var candidate = value;
        return typeof candidate === 'string';
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range: range, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range: range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.delete = function (range, annotation) {
        var edit;
        var id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
        if (value === undefined) {
            throw new Error("Text edit change is not configured to manage change annotations.");
        }
    };
    return TextEditChangeImpl;
}());
/**
 * A helper class
 */
var ChangeAnnotations = /** @class */ (function () {
    function ChangeAnnotations(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    ChangeAnnotations.prototype.all = function () {
        return this._annotations;
    };
    Object.defineProperty(ChangeAnnotations.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: false,
        configurable: true
    });
    ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === undefined) {
            throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    };
    ChangeAnnotations.prototype.nextId = function () {
        this._counter++;
        return this._counter.toString();
    };
    return ChangeAnnotations;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (TextDocumentEdit.is(change)) {
                        var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            this.initDocumentChanges();
            if (this._changeAnnotations !== undefined) {
                if (this._changeAnnotations.size === 0) {
                    this._workspaceEdit.changeAnnotations = undefined;
                }
                else {
                    this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                }
            }
            return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.initDocumentChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    };
    WorkspaceChange.prototype.initChanges = function () {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [OptionalVersionedTextDocumentIdentifier](#OptionalVersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText: newText, insert: insert, replace: replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the [InsertReplaceEdit](#InsertReplaceEdit) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        var candidate = value;
        return candidate && (Is.string(candidate.parameters) || candidate.parameters === undefined) &&
            (Is.string(candidate.qualifier) || candidate.qualifier === undefined) && (Is.string(candidate.type) || candidate.type === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        var result = { title: title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        var candidate = value;
        return candidate !== undefined && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: false,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";

module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = function* () {
    for (let walker = this.head; walker; walker = walker.next) {
      yield walker.value
    }
  }
}


/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null

  return next
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.splice = function (start, deleteCount, ...nodes) {
  if (start > this.length) {
    start = this.length - 1
  }
  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next
  }

  var ret = []
  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value)
    walker = this.removeNode(walker)
  }
  if (walker === null) {
    walker = this.tail
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev
  }

  for (var i = 0; i < nodes.length; i++) {
    walker = insert(this, walker, nodes[i])
  }
  return ret;
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function insert (self, node, value) {
  var inserted = node === self.head ?
    new Node(value, null, node, self) :
    new Node(value, node, node.next, self)

  if (inserted.next === null) {
    self.tail = inserted
  }
  if (inserted.prev === null) {
    self.head = inserted
  }

  self.length++

  return inserted
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(/*! ./iterator.js */ "./node_modules/yallist/iterator.js")(Yallist)
} catch (er) {}


/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "async_hooks":
/*!******************************!*\
  !*** external "async_hooks" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "console":
/*!**************************!*\
  !*** external "console" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("console");

/***/ }),

/***/ "constants":
/*!****************************!*\
  !*** external "constants" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "diagnostics_channel":
/*!**************************************!*\
  !*** external "diagnostics_channel" ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = require("diagnostics_channel");

/***/ }),

/***/ "dns":
/*!**********************!*\
  !*** external "dns" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("dns");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "perf_hooks":
/*!*****************************!*\
  !*** external "perf_hooks" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("perf_hooks");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "stream/web":
/*!*****************************!*\
  !*** external "stream/web" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream/web");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "util/types":
/*!*****************************!*\
  !*** external "util/types" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("util/types");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/FileLike.js":
/*!****************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/FileLike.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _FormDataEncoder_instances, _FormDataEncoder_CRLF, _FormDataEncoder_CRLF_BYTES, _FormDataEncoder_CRLF_BYTES_LENGTH, _FormDataEncoder_DASHES, _FormDataEncoder_encoder, _FormDataEncoder_footer, _FormDataEncoder_form, _FormDataEncoder_options, _FormDataEncoder_getFieldHeader;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Encoder = exports.FormDataEncoder = void 0;
const createBoundary_1 = __importDefault(__webpack_require__(/*! ./util/createBoundary */ "../../node_modules/form-data-encoder/lib/cjs/util/createBoundary.js"));
const isPlainObject_1 = __importDefault(__webpack_require__(/*! ./util/isPlainObject */ "../../node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js"));
const normalizeValue_1 = __importDefault(__webpack_require__(/*! ./util/normalizeValue */ "../../node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js"));
const escapeName_1 = __importDefault(__webpack_require__(/*! ./util/escapeName */ "../../node_modules/form-data-encoder/lib/cjs/util/escapeName.js"));
const isFileLike_1 = __webpack_require__(/*! ./util/isFileLike */ "../../node_modules/form-data-encoder/lib/cjs/util/isFileLike.js");
const isFormData_1 = __webpack_require__(/*! ./util/isFormData */ "../../node_modules/form-data-encoder/lib/cjs/util/isFormData.js");
const defaultOptions = {
    enableAdditionalHeaders: false
};
class FormDataEncoder {
    constructor(form, boundaryOrOptions, options) {
        _FormDataEncoder_instances.add(this);
        _FormDataEncoder_CRLF.set(this, "\r\n");
        _FormDataEncoder_CRLF_BYTES.set(this, void 0);
        _FormDataEncoder_CRLF_BYTES_LENGTH.set(this, void 0);
        _FormDataEncoder_DASHES.set(this, "-".repeat(2));
        _FormDataEncoder_encoder.set(this, new TextEncoder());
        _FormDataEncoder_footer.set(this, void 0);
        _FormDataEncoder_form.set(this, void 0);
        _FormDataEncoder_options.set(this, void 0);
        if (!(0, isFormData_1.isFormData)(form)) {
            throw new TypeError("Expected first argument to be a FormData instance.");
        }
        let boundary;
        if ((0, isPlainObject_1.default)(boundaryOrOptions)) {
            options = boundaryOrOptions;
        }
        else {
            boundary = boundaryOrOptions;
        }
        if (!boundary) {
            boundary = (0, createBoundary_1.default)();
        }
        if (typeof boundary !== "string") {
            throw new TypeError("Expected boundary argument to be a string.");
        }
        if (options && !(0, isPlainObject_1.default)(options)) {
            throw new TypeError("Expected options argument to be an object.");
        }
        __classPrivateFieldSet(this, _FormDataEncoder_form, form, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_options, { ...defaultOptions, ...options }, "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")), "f");
        __classPrivateFieldSet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f").byteLength, "f");
        this.boundary = `form-data-boundary-${boundary}`;
        this.contentType = `multipart/form-data; boundary=${this.boundary}`;
        __classPrivateFieldSet(this, _FormDataEncoder_footer, __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`), "f");
        this.contentLength = String(this.getContentLength());
        this.headers = Object.freeze({
            "Content-Type": this.contentType,
            "Content-Length": this.contentLength
        });
        Object.defineProperties(this, {
            boundary: { writable: false, configurable: false },
            contentType: { writable: false, configurable: false },
            contentLength: { writable: false, configurable: false },
            headers: { writable: false, configurable: false }
        });
    }
    getContentLength() {
        let length = 0;
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f")) {
            const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
            length += __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value).byteLength;
            length += (0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength;
            length += __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES_LENGTH, "f");
        }
        return length + __classPrivateFieldGet(this, _FormDataEncoder_footer, "f").byteLength;
    }
    *values() {
        for (const [name, raw] of __classPrivateFieldGet(this, _FormDataEncoder_form, "f").entries()) {
            const value = (0, isFileLike_1.isFileLike)(raw) ? raw : __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode((0, normalizeValue_1.default)(raw));
            yield __classPrivateFieldGet(this, _FormDataEncoder_instances, "m", _FormDataEncoder_getFieldHeader).call(this, name, value);
            yield value;
            yield __classPrivateFieldGet(this, _FormDataEncoder_CRLF_BYTES, "f");
        }
        yield __classPrivateFieldGet(this, _FormDataEncoder_footer, "f");
    }
    async *encode() {
        for (const part of this.values()) {
            if ((0, isFileLike_1.isFileLike)(part)) {
                yield* part.stream();
            }
            else {
                yield part;
            }
        }
    }
    [(_FormDataEncoder_CRLF = new WeakMap(), _FormDataEncoder_CRLF_BYTES = new WeakMap(), _FormDataEncoder_CRLF_BYTES_LENGTH = new WeakMap(), _FormDataEncoder_DASHES = new WeakMap(), _FormDataEncoder_encoder = new WeakMap(), _FormDataEncoder_footer = new WeakMap(), _FormDataEncoder_form = new WeakMap(), _FormDataEncoder_options = new WeakMap(), _FormDataEncoder_instances = new WeakSet(), _FormDataEncoder_getFieldHeader = function _FormDataEncoder_getFieldHeader(name, value) {
        let header = "";
        header += `${__classPrivateFieldGet(this, _FormDataEncoder_DASHES, "f")}${this.boundary}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
        header += `Content-Disposition: form-data; name="${(0, escapeName_1.default)(name)}"`;
        if ((0, isFileLike_1.isFileLike)(value)) {
            header += `; filename="${(0, escapeName_1.default)(value.name)}"${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}`;
            header += `Content-Type: ${value.type || "application/octet-stream"}`;
        }
        if (__classPrivateFieldGet(this, _FormDataEncoder_options, "f").enableAdditionalHeaders === true) {
            header += `${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f")}Content-Length: ${(0, isFileLike_1.isFileLike)(value) ? value.size : value.byteLength}`;
        }
        return __classPrivateFieldGet(this, _FormDataEncoder_encoder, "f").encode(`${header}${__classPrivateFieldGet(this, _FormDataEncoder_CRLF, "f").repeat(2)}`);
    }, Symbol.iterator)]() {
        return this.values();
    }
    [Symbol.asyncIterator]() {
        return this.encode();
    }
}
exports.FormDataEncoder = FormDataEncoder;
exports.Encoder = FormDataEncoder;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/FormDataLike.js":
/*!********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/FormDataLike.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./FormDataEncoder */ "../../node_modules/form-data-encoder/lib/cjs/FormDataEncoder.js"), exports);
__exportStar(__webpack_require__(/*! ./FileLike */ "../../node_modules/form-data-encoder/lib/cjs/FileLike.js"), exports);
__exportStar(__webpack_require__(/*! ./FormDataLike */ "../../node_modules/form-data-encoder/lib/cjs/FormDataLike.js"), exports);
__exportStar(__webpack_require__(/*! ./util/isFileLike */ "../../node_modules/form-data-encoder/lib/cjs/util/isFileLike.js"), exports);
__exportStar(__webpack_require__(/*! ./util/isFormData */ "../../node_modules/form-data-encoder/lib/cjs/util/isFormData.js"), exports);


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/createBoundary.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/createBoundary.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const alphabet = "abcdefghijklmnopqrstuvwxyz0123456789";
function createBoundary() {
    let size = 16;
    let res = "";
    while (size--) {
        res += alphabet[(Math.random() * alphabet.length) << 0];
    }
    return res;
}
exports["default"] = createBoundary;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/escapeName.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/escapeName.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const escapeName = (name) => String(name)
    .replace(/\r/g, "%0D")
    .replace(/\n/g, "%0A")
    .replace(/"/g, "%22");
exports["default"] = escapeName;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/isFileLike.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/isFileLike.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFileLike = void 0;
const isFunction_1 = __importDefault(__webpack_require__(/*! ./isFunction */ "../../node_modules/form-data-encoder/lib/cjs/util/isFunction.js"));
const isFileLike = (value) => Boolean(value
    && typeof value === "object"
    && (0, isFunction_1.default)(value.constructor)
    && value[Symbol.toStringTag] === "File"
    && (0, isFunction_1.default)(value.stream)
    && value.name != null
    && value.size != null
    && value.lastModified != null);
exports.isFileLike = isFileLike;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/isFormData.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/isFormData.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFormDataLike = exports.isFormData = void 0;
const isFunction_1 = __importDefault(__webpack_require__(/*! ./isFunction */ "../../node_modules/form-data-encoder/lib/cjs/util/isFunction.js"));
const isFormData = (value) => Boolean(value
    && (0, isFunction_1.default)(value.constructor)
    && value[Symbol.toStringTag] === "FormData"
    && (0, isFunction_1.default)(value.append)
    && (0, isFunction_1.default)(value.getAll)
    && (0, isFunction_1.default)(value.entries)
    && (0, isFunction_1.default)(value[Symbol.iterator]));
exports.isFormData = isFormData;
exports.isFormDataLike = exports.isFormData;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/isFunction.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/isFunction.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const isFunction = (value) => (typeof value === "function");
exports["default"] = isFunction;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/isPlainObject.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const getType = (value) => (Object.prototype.toString.call(value).slice(8, -1).toLowerCase());
function isPlainObject(value) {
    if (getType(value) !== "object") {
        return false;
    }
    const pp = Object.getPrototypeOf(value);
    if (pp === null || pp === undefined) {
        return true;
    }
    const Ctor = pp.constructor && pp.constructor.toString();
    return Ctor === Object.toString();
}
exports["default"] = isPlainObject;


/***/ }),

/***/ "../../node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/form-data-encoder/lib/cjs/util/normalizeValue.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
const normalizeValue = (value) => String(value)
    .replace(/\r|\n/g, (match, i, str) => {
    if ((match === "\r" && str[i + 1] !== "\n")
        || (match === "\n" && str[i - 1] !== "\r")) {
        return "\r\n";
    }
    return match;
});
exports["default"] = normalizeValue;


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/Blob.js":
/*!********************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/Blob.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _Blob_parts, _Blob_type, _Blob_size;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Blob = void 0;
const web_streams_polyfill_1 = __webpack_require__(/*! web-streams-polyfill */ "../../node_modules/web-streams-polyfill/dist/ponyfill.js");
const isFunction_1 = __webpack_require__(/*! ./isFunction */ "../../node_modules/formdata-node/lib/cjs/isFunction.js");
const blobHelpers_1 = __webpack_require__(/*! ./blobHelpers */ "../../node_modules/formdata-node/lib/cjs/blobHelpers.js");
class Blob {
    constructor(blobParts = [], options = {}) {
        _Blob_parts.set(this, []);
        _Blob_type.set(this, "");
        _Blob_size.set(this, 0);
        options !== null && options !== void 0 ? options : (options = {});
        if (typeof blobParts !== "object" || blobParts === null) {
            throw new TypeError("Failed to construct 'Blob': "
                + "The provided value cannot be converted to a sequence.");
        }
        if (!(0, isFunction_1.isFunction)(blobParts[Symbol.iterator])) {
            throw new TypeError("Failed to construct 'Blob': "
                + "The object must have a callable @@iterator property.");
        }
        if (typeof options !== "object" && !(0, isFunction_1.isFunction)(options)) {
            throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");
        }
        const encoder = new TextEncoder();
        for (const raw of blobParts) {
            let part;
            if (ArrayBuffer.isView(raw)) {
                part = new Uint8Array(raw.buffer.slice(raw.byteOffset, raw.byteOffset + raw.byteLength));
            }
            else if (raw instanceof ArrayBuffer) {
                part = new Uint8Array(raw.slice(0));
            }
            else if (raw instanceof Blob) {
                part = raw;
            }
            else {
                part = encoder.encode(String(raw));
            }
            __classPrivateFieldSet(this, _Blob_size, __classPrivateFieldGet(this, _Blob_size, "f") + (ArrayBuffer.isView(part) ? part.byteLength : part.size), "f");
            __classPrivateFieldGet(this, _Blob_parts, "f").push(part);
        }
        const type = options.type === undefined ? "" : String(options.type);
        __classPrivateFieldSet(this, _Blob_type, /^[\x20-\x7E]*$/.test(type) ? type : "", "f");
    }
    static [(_Blob_parts = new WeakMap(), _Blob_type = new WeakMap(), _Blob_size = new WeakMap(), Symbol.hasInstance)](value) {
        return Boolean(value
            && typeof value === "object"
            && (0, isFunction_1.isFunction)(value.constructor)
            && ((0, isFunction_1.isFunction)(value.stream)
                || (0, isFunction_1.isFunction)(value.arrayBuffer))
            && /^(Blob|File)$/.test(value[Symbol.toStringTag]));
    }
    get type() {
        return __classPrivateFieldGet(this, _Blob_type, "f");
    }
    get size() {
        return __classPrivateFieldGet(this, _Blob_size, "f");
    }
    slice(start, end, contentType) {
        return new Blob((0, blobHelpers_1.sliceBlob)(__classPrivateFieldGet(this, _Blob_parts, "f"), this.size, start, end), {
            type: contentType
        });
    }
    async text() {
        const decoder = new TextDecoder();
        let result = "";
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
            result += decoder.decode(chunk, { stream: true });
        }
        result += decoder.decode();
        return result;
    }
    async arrayBuffer() {
        const view = new Uint8Array(this.size);
        let offset = 0;
        for await (const chunk of (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"))) {
            view.set(chunk, offset);
            offset += chunk.length;
        }
        return view.buffer;
    }
    stream() {
        const iterator = (0, blobHelpers_1.consumeBlobParts)(__classPrivateFieldGet(this, _Blob_parts, "f"), true);
        return new web_streams_polyfill_1.ReadableStream({
            async pull(controller) {
                const { value, done } = await iterator.next();
                if (done) {
                    return queueMicrotask(() => controller.close());
                }
                controller.enqueue(value);
            },
            async cancel() {
                await iterator.return();
            }
        });
    }
    get [Symbol.toStringTag]() {
        return "Blob";
    }
}
exports.Blob = Blob;
Object.defineProperties(Blob.prototype, {
    type: { enumerable: true },
    size: { enumerable: true },
    slice: { enumerable: true },
    stream: { enumerable: true },
    text: { enumerable: true },
    arrayBuffer: { enumerable: true }
});


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/File.js":
/*!********************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/File.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _File_name, _File_lastModified;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.File = void 0;
const Blob_1 = __webpack_require__(/*! ./Blob */ "../../node_modules/formdata-node/lib/cjs/Blob.js");
class File extends Blob_1.Blob {
    constructor(fileBits, name, options = {}) {
        super(fileBits, options);
        _File_name.set(this, void 0);
        _File_lastModified.set(this, 0);
        if (arguments.length < 2) {
            throw new TypeError("Failed to construct 'File': 2 arguments required, "
                + `but only ${arguments.length} present.`);
        }
        __classPrivateFieldSet(this, _File_name, String(name), "f");
        const lastModified = options.lastModified === undefined
            ? Date.now()
            : Number(options.lastModified);
        if (!Number.isNaN(lastModified)) {
            __classPrivateFieldSet(this, _File_lastModified, lastModified, "f");
        }
    }
    get name() {
        return __classPrivateFieldGet(this, _File_name, "f");
    }
    get lastModified() {
        return __classPrivateFieldGet(this, _File_lastModified, "f");
    }
    get [(_File_name = new WeakMap(), _File_lastModified = new WeakMap(), Symbol.toStringTag)]() {
        return "File";
    }
}
exports.File = File;


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/FormData.js":
/*!************************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/FormData.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _FormData_instances, _FormData_entries, _FormData_setEntry;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormData = void 0;
const util_1 = __webpack_require__(/*! util */ "util");
const File_1 = __webpack_require__(/*! ./File */ "../../node_modules/formdata-node/lib/cjs/File.js");
const isFile_1 = __webpack_require__(/*! ./isFile */ "../../node_modules/formdata-node/lib/cjs/isFile.js");
const isFunction_1 = __webpack_require__(/*! ./isFunction */ "../../node_modules/formdata-node/lib/cjs/isFunction.js");
const deprecateConstructorEntries_1 = __webpack_require__(/*! ./deprecateConstructorEntries */ "../../node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js");
class FormData {
    constructor(entries) {
        _FormData_instances.add(this);
        _FormData_entries.set(this, new Map());
        if (entries) {
            (0, deprecateConstructorEntries_1.deprecateConstructorEntries)();
            entries.forEach(({ name, value, fileName }) => this.append(name, value, fileName));
        }
    }
    static [(_FormData_entries = new WeakMap(), _FormData_instances = new WeakSet(), Symbol.hasInstance)](value) {
        return Boolean(value
            && (0, isFunction_1.isFunction)(value.constructor)
            && value[Symbol.toStringTag] === "FormData"
            && (0, isFunction_1.isFunction)(value.append)
            && (0, isFunction_1.isFunction)(value.set)
            && (0, isFunction_1.isFunction)(value.get)
            && (0, isFunction_1.isFunction)(value.getAll)
            && (0, isFunction_1.isFunction)(value.has)
            && (0, isFunction_1.isFunction)(value.delete)
            && (0, isFunction_1.isFunction)(value.entries)
            && (0, isFunction_1.isFunction)(value.values)
            && (0, isFunction_1.isFunction)(value.keys)
            && (0, isFunction_1.isFunction)(value[Symbol.iterator])
            && (0, isFunction_1.isFunction)(value.forEach));
    }
    append(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
            name,
            fileName,
            append: true,
            rawValue: value,
            argsLength: arguments.length
        });
    }
    set(name, value, fileName) {
        __classPrivateFieldGet(this, _FormData_instances, "m", _FormData_setEntry).call(this, {
            name,
            fileName,
            append: false,
            rawValue: value,
            argsLength: arguments.length
        });
    }
    get(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
            return null;
        }
        return field[0];
    }
    getAll(name) {
        const field = __classPrivateFieldGet(this, _FormData_entries, "f").get(String(name));
        if (!field) {
            return [];
        }
        return field.slice();
    }
    has(name) {
        return __classPrivateFieldGet(this, _FormData_entries, "f").has(String(name));
    }
    delete(name) {
        __classPrivateFieldGet(this, _FormData_entries, "f").delete(String(name));
    }
    *keys() {
        for (const key of __classPrivateFieldGet(this, _FormData_entries, "f").keys()) {
            yield key;
        }
    }
    *entries() {
        for (const name of this.keys()) {
            const values = this.getAll(name);
            for (const value of values) {
                yield [name, value];
            }
        }
    }
    *values() {
        for (const [, value] of this) {
            yield value;
        }
    }
    [(_FormData_setEntry = function _FormData_setEntry({ name, rawValue, append, fileName, argsLength }) {
        const methodName = append ? "append" : "set";
        if (argsLength < 2) {
            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `
                + `2 arguments required, but only ${argsLength} present.`);
        }
        name = String(name);
        let value;
        if ((0, isFile_1.isFile)(rawValue)) {
            if (fileName === undefined) {
                fileName = rawValue.name === undefined ? "blob" : rawValue.name;
            }
            value = new File_1.File([rawValue], String(fileName), {
                type: rawValue.type,
                lastModified: rawValue.lastModified
            });
        }
        else if (fileName) {
            throw new TypeError(`Failed to execute '${methodName}' on 'FormData': `
                + "parameter 2 is not of type 'Blob'.");
        }
        else {
            value = String(rawValue);
        }
        const values = __classPrivateFieldGet(this, _FormData_entries, "f").get(name);
        if (!values) {
            return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [value]);
        }
        if (!append) {
            return void __classPrivateFieldGet(this, _FormData_entries, "f").set(name, [value]);
        }
        values.push(value);
    }, Symbol.iterator)]() {
        return this.entries();
    }
    forEach(callback, thisArg) {
        for (const [name, value] of this) {
            callback.call(thisArg, value, name, this);
        }
    }
    get [Symbol.toStringTag]() {
        return "FormData";
    }
    [util_1.inspect.custom]() {
        return this[Symbol.toStringTag];
    }
}
exports.FormData = FormData;


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/blobHelpers.js":
/*!***************************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/blobHelpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*! Based on fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> & David Frank */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sliceBlob = exports.consumeBlobParts = void 0;
const isFunction_1 = __webpack_require__(/*! ./isFunction */ "../../node_modules/formdata-node/lib/cjs/isFunction.js");
const CHUNK_SIZE = 65536;
async function* clonePart(part) {
    const end = part.byteOffset + part.byteLength;
    let position = part.byteOffset;
    while (position !== end) {
        const size = Math.min(end - position, CHUNK_SIZE);
        const chunk = part.buffer.slice(position, position + size);
        position += chunk.byteLength;
        yield new Uint8Array(chunk);
    }
}
async function* consumeNodeBlob(blob) {
    let position = 0;
    while (position !== blob.size) {
        const chunk = blob.slice(position, Math.min(blob.size, position + CHUNK_SIZE));
        const buffer = await chunk.arrayBuffer();
        position += buffer.byteLength;
        yield new Uint8Array(buffer);
    }
}
async function* consumeBlobParts(parts, clone = false) {
    for (const part of parts) {
        if (ArrayBuffer.isView(part)) {
            if (clone) {
                yield* clonePart(part);
            }
            else {
                yield part;
            }
        }
        else if ((0, isFunction_1.isFunction)(part.stream)) {
            yield* part.stream();
        }
        else {
            yield* consumeNodeBlob(part);
        }
    }
}
exports.consumeBlobParts = consumeBlobParts;
function* sliceBlob(blobParts, blobSize, start = 0, end) {
    end !== null && end !== void 0 ? end : (end = blobSize);
    let relativeStart = start < 0
        ? Math.max(blobSize + start, 0)
        : Math.min(start, blobSize);
    let relativeEnd = end < 0
        ? Math.max(blobSize + end, 0)
        : Math.min(end, blobSize);
    const span = Math.max(relativeEnd - relativeStart, 0);
    let added = 0;
    for (const part of blobParts) {
        if (added >= span) {
            break;
        }
        const partSize = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && partSize <= relativeStart) {
            relativeStart -= partSize;
            relativeEnd -= partSize;
        }
        else {
            let chunk;
            if (ArrayBuffer.isView(part)) {
                chunk = part.subarray(relativeStart, Math.min(partSize, relativeEnd));
                added += chunk.byteLength;
            }
            else {
                chunk = part.slice(relativeStart, Math.min(partSize, relativeEnd));
                added += chunk.size;
            }
            relativeEnd -= partSize;
            relativeStart = 0;
            yield chunk;
        }
    }
}
exports.sliceBlob = sliceBlob;


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/deprecateConstructorEntries.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deprecateConstructorEntries = void 0;
const util_1 = __webpack_require__(/*! util */ "util");
exports.deprecateConstructorEntries = (0, util_1.deprecate)(() => { }, "Constructor \"entries\" argument is not spec-compliant "
    + "and will be removed in next major release.");


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./FormData */ "../../node_modules/formdata-node/lib/cjs/FormData.js"), exports);
__exportStar(__webpack_require__(/*! ./Blob */ "../../node_modules/formdata-node/lib/cjs/Blob.js"), exports);
__exportStar(__webpack_require__(/*! ./File */ "../../node_modules/formdata-node/lib/cjs/File.js"), exports);


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/isFile.js":
/*!**********************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/isFile.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFile = void 0;
const File_1 = __webpack_require__(/*! ./File */ "../../node_modules/formdata-node/lib/cjs/File.js");
const isFile = (value) => value instanceof File_1.File;
exports.isFile = isFile;


/***/ }),

/***/ "../../node_modules/formdata-node/lib/cjs/isFunction.js":
/*!**************************************************************!*\
  !*** ../../node_modules/formdata-node/lib/cjs/isFunction.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isFunction = void 0;
const isFunction = (value) => (typeof value === "function");
exports.isFunction = isFunction;


/***/ }),

/***/ "../../node_modules/urllib/src/cjs/HttpAgent.js":
/*!******************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/HttpAgent.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _HttpAgent_checkAddress;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpAgent = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
const dns_1 = tslib_1.__importDefault(__webpack_require__(/*! dns */ "dns"));
const net_1 = __webpack_require__(/*! net */ "net");
const undici_1 = __webpack_require__(/*! undici */ "../../node_modules/undici/index.js");
class IllegalAddressError extends Error {
    constructor(hostname, ip, family) {
        const message = 'illegal address';
        super(message);
        this.name = this.constructor.name;
        this.hostname = hostname;
        this.ip = ip;
        this.family = family;
        Error.captureStackTrace(this, this.constructor);
    }
}
class HttpAgent extends undici_1.Agent {
    constructor(options) {
        var _a;
        /* eslint node/prefer-promises/dns: off*/
        const _lookup = (_a = options.lookup) !== null && _a !== void 0 ? _a : dns_1.default.lookup;
        const lookup = (hostname, dnsOptions, callback) => {
            _lookup(hostname, dnsOptions, (err, address, family) => {
                if (err)
                    return callback(err, address, family);
                if (options.checkAddress && !options.checkAddress(address, family)) {
                    err = new IllegalAddressError(hostname, address, family);
                }
                callback(err, address, family);
            });
        };
        super({
            connect: { ...options.connect, lookup },
        });
        _HttpAgent_checkAddress.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _HttpAgent_checkAddress, options.checkAddress, "f");
    }
    dispatch(options, handler) {
        if (tslib_1.__classPrivateFieldGet(this, _HttpAgent_checkAddress, "f") && options.origin) {
            const originUrl = typeof options.origin === 'string' ? new URL(options.origin) : options.origin;
            let hostname = originUrl.hostname;
            // [2001:db8:2de::e13] => 2001:db8:2de::e13
            if (hostname.startsWith('[') && hostname.endsWith(']')) {
                hostname = hostname.substring(1, hostname.length - 1);
            }
            const family = (0, net_1.isIP)(hostname);
            if (family === 4 || family === 6) {
                // if request hostname is ip, custom lookup won't excute
                if (!tslib_1.__classPrivateFieldGet(this, _HttpAgent_checkAddress, "f").call(this, hostname, family)) {
                    throw new IllegalAddressError(hostname, hostname, family);
                }
            }
        }
        return super.dispatch(options, handler);
    }
}
exports.HttpAgent = HttpAgent;
_HttpAgent_checkAddress = new WeakMap();
//# sourceMappingURL=HttpAgent.js.map

/***/ }),

/***/ "../../node_modules/urllib/src/cjs/HttpClient.js":
/*!*******************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/HttpClient.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _a, _b, _c;
var _BlobFromStream_stream, _BlobFromStream_type, _HttpClient_instances, _HttpClient_defaultArgs, _HttpClient_dispatcher, _HttpClient_requestInternal, _HttpClient_updateSocketInfo;
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpClient = exports.HEADER_USER_AGENT = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
const events_1 = __webpack_require__(/*! events */ "events");
const util_1 = __webpack_require__(/*! util */ "util");
const zlib_1 = __webpack_require__(/*! zlib */ "zlib");
const buffer_1 = __webpack_require__(/*! buffer */ "buffer");
const stream_1 = __webpack_require__(/*! stream */ "stream");
const stream_2 = tslib_1.__importDefault(__webpack_require__(/*! stream */ "stream"));
const path_1 = __webpack_require__(/*! path */ "path");
const fs_1 = __webpack_require__(/*! fs */ "fs");
const url_1 = __webpack_require__(/*! url */ "url");
const perf_hooks_1 = __webpack_require__(/*! perf_hooks */ "perf_hooks");
const undici_1 = __webpack_require__(/*! undici */ "../../node_modules/undici/index.js");
const formdata_node_1 = __webpack_require__(/*! formdata-node */ "../../node_modules/formdata-node/lib/cjs/index.js");
const form_data_encoder_1 = __webpack_require__(/*! form-data-encoder */ "../../node_modules/form-data-encoder/lib/cjs/index.js");
const default_user_agent_1 = tslib_1.__importDefault(__webpack_require__(/*! default-user-agent */ "../../node_modules/default-user-agent/index.js"));
const mime_types_1 = tslib_1.__importDefault(__webpack_require__(/*! mime-types */ "../../node_modules/urllib/node_modules/mime-types/index.js"));
const pump_1 = tslib_1.__importDefault(__webpack_require__(/*! pump */ "../../node_modules/pump/index.js"));
const HttpAgent_1 = __webpack_require__(/*! ./HttpAgent */ "../../node_modules/urllib/src/cjs/HttpAgent.js");
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/urllib/src/cjs/utils.js");
const symbols_1 = tslib_1.__importDefault(__webpack_require__(/*! ./symbols */ "../../node_modules/urllib/src/cjs/symbols.js"));
const diagnosticsChannel_1 = __webpack_require__(/*! ./diagnosticsChannel */ "../../node_modules/urllib/src/cjs/diagnosticsChannel.js");
const PROTO_RE = /^https?:\/\//i;
const FormData = undici_1.FormData !== null && undici_1.FormData !== void 0 ? undici_1.FormData : formdata_node_1.FormData;
// impl isReadable on Node.js 14
const isReadable = (_a = stream_2.default.isReadable) !== null && _a !== void 0 ? _a : function isReadable(stream) {
    return stream && typeof stream.read === 'function';
};
// impl promise pipeline on Node.js 14
const pipelinePromise = (_c = (_b = stream_2.default.promises) === null || _b === void 0 ? void 0 : _b.pipeline) !== null && _c !== void 0 ? _c : function pipeline(...args) {
    return new Promise((resolve, reject) => {
        (0, pump_1.default)(...args, (err) => {
            if (err)
                return reject(err);
            resolve();
        });
    });
};
function noop() {
    // noop
}
const debug = (0, util_1.debuglog)('urllib:HttpClient');
// https://github.com/octet-stream/form-data
class BlobFromStream {
    constructor(stream, type) {
        _BlobFromStream_stream.set(this, void 0);
        _BlobFromStream_type.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _BlobFromStream_stream, stream, "f");
        tslib_1.__classPrivateFieldSet(this, _BlobFromStream_type, type, "f");
    }
    stream() {
        return tslib_1.__classPrivateFieldGet(this, _BlobFromStream_stream, "f");
    }
    get type() {
        return tslib_1.__classPrivateFieldGet(this, _BlobFromStream_type, "f");
    }
    get [(_BlobFromStream_stream = new WeakMap(), _BlobFromStream_type = new WeakMap(), Symbol.toStringTag)]() {
        return 'Blob';
    }
}
class HttpClientRequestTimeoutError extends Error {
    constructor(timeout, options) {
        const message = `Request timeout for ${timeout} ms`;
        super(message, options);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
exports.HEADER_USER_AGENT = (0, default_user_agent_1.default)('node-urllib', '3.0.0');
function getFileName(stream) {
    const filePath = stream.path;
    if (filePath) {
        return (0, path_1.basename)(filePath);
    }
    return '';
}
function defaultIsRetry(response) {
    return response.status >= 500;
}
class HttpClient extends events_1.EventEmitter {
    constructor(clientOptions) {
        super();
        _HttpClient_instances.add(this);
        _HttpClient_defaultArgs.set(this, void 0);
        _HttpClient_dispatcher.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _HttpClient_defaultArgs, clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.defaultArgs, "f");
        if ((clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.lookup) || (clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.checkAddress) || (clientOptions === null || clientOptions === void 0 ? void 0 : clientOptions.connect)) {
            tslib_1.__classPrivateFieldSet(this, _HttpClient_dispatcher, new HttpAgent_1.HttpAgent({
                lookup: clientOptions.lookup,
                checkAddress: clientOptions.checkAddress,
                connect: clientOptions.connect,
            }), "f");
        }
        (0, diagnosticsChannel_1.initDiagnosticsChannel)();
    }
    async request(url, options) {
        return await tslib_1.__classPrivateFieldGet(this, _HttpClient_instances, "m", _HttpClient_requestInternal).call(this, url, options);
    }
}
exports.HttpClient = HttpClient;
_HttpClient_defaultArgs = new WeakMap(), _HttpClient_dispatcher = new WeakMap(), _HttpClient_instances = new WeakSet(), _HttpClient_requestInternal = async function _HttpClient_requestInternal(url, options, requestContext) {
    var _a, _b, _c, _d, _e, _f, _g;
    const requestId = (0, utils_1.globalId)('HttpClientRequest');
    let requestUrl;
    if (typeof url === 'string') {
        if (!PROTO_RE.test(url)) {
            // Support `request('www.server.com')`
            url = 'http://' + url;
        }
        requestUrl = new URL(url);
    }
    else {
        if (!url.searchParams) {
            // url maybe url.parse(url) object in urllib2
            requestUrl = new URL((0, url_1.format)(url));
        }
        else {
            requestUrl = url;
        }
    }
    const method = ((_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET').toUpperCase();
    const orginalHeaders = options === null || options === void 0 ? void 0 : options.headers;
    const headers = {};
    const args = {
        retry: 0,
        ...tslib_1.__classPrivateFieldGet(this, _HttpClient_defaultArgs, "f"),
        ...options,
        // keep method and headers exists on args for request event handler to easy use
        method,
        headers,
    };
    requestContext = {
        retries: 0,
        ...requestContext,
    };
    const requestStartTime = perf_hooks_1.performance.now();
    // https://developer.chrome.com/docs/devtools/network/reference/?utm_source=devtools#timing-explanation
    const timing = {
        // socket assigned
        queuing: 0,
        // dns lookup time
        // dnslookup: 0,
        // socket connected
        connected: 0,
        // request headers sent
        requestHeadersSent: 0,
        // request sent, including headers and body
        requestSent: 0,
        // Time to first byte (TTFB), the response headers have been received
        waiting: 0,
        // the response body and trailers have been received
        contentDownload: 0,
    };
    const orginalOpaque = args.opaque;
    // using opaque to diagnostics channel, binding request and socket
    const internalOpaque = {
        [symbols_1.default.kRequestId]: requestId,
        [symbols_1.default.kRequestStartTime]: requestStartTime,
        [symbols_1.default.kEnableRequestTiming]: !!args.timing,
        [symbols_1.default.kRequestTiming]: timing,
        [symbols_1.default.kRequestOrginalOpaque]: orginalOpaque,
    };
    const reqMeta = {
        requestId,
        url: requestUrl.href,
        args,
        ctx: args.ctx,
        retries: requestContext.retries,
    };
    const socketInfo = {
        id: 0,
        localAddress: '',
        localPort: 0,
        remoteAddress: '',
        remotePort: 0,
        remoteFamily: '',
        bytesWritten: 0,
        bytesRead: 0,
        handledRequests: 0,
        handledResponses: 0,
    };
    // keep urllib createCallbackResponse style
    const resHeaders = {};
    const res = {
        status: -1,
        statusCode: -1,
        headers: resHeaders,
        size: 0,
        aborted: false,
        rt: 0,
        keepAliveSocket: true,
        requestUrls: [],
        timing,
        socket: socketInfo,
    };
    let headersTimeout = 5000;
    let bodyTimeout = 5000;
    if (args.timeout) {
        if (Array.isArray(args.timeout)) {
            headersTimeout = (_b = args.timeout[0]) !== null && _b !== void 0 ? _b : headersTimeout;
            bodyTimeout = (_c = args.timeout[1]) !== null && _c !== void 0 ? _c : bodyTimeout;
        }
        else {
            headersTimeout = bodyTimeout = args.timeout;
        }
    }
    if (orginalHeaders) {
        // convert headers to lower-case
        for (const name in orginalHeaders) {
            headers[name.toLowerCase()] = orginalHeaders[name];
        }
    }
    // hidden user-agent
    const hiddenUserAgent = 'user-agent' in headers && !headers['user-agent'];
    if (hiddenUserAgent) {
        delete headers['user-agent'];
    }
    else if (!headers['user-agent']) {
        // need to set user-agent
        headers['user-agent'] = exports.HEADER_USER_AGENT;
    }
    // Alias to dataType = 'stream'
    if (args.streaming || args.customResponse) {
        args.dataType = 'stream';
    }
    if (args.dataType === 'json' && !headers.accept) {
        headers.accept = 'application/json';
    }
    // gzip alias to compressed
    if (args.gzip && args.compressed !== false) {
        args.compressed = true;
    }
    if (args.compressed && !headers['accept-encoding']) {
        headers['accept-encoding'] = 'gzip, br';
    }
    if (requestContext.retries > 0) {
        headers['x-urllib-retry'] = `${requestContext.retries}/${args.retry}`;
    }
    if (args.auth && !headers.authorization) {
        headers.authorization = `Basic ${Buffer.from(args.auth).toString('base64')}`;
    }
    try {
        const requestOptions = {
            method,
            keepalive: true,
            maxRedirections: (_d = args.maxRedirects) !== null && _d !== void 0 ? _d : 10,
            headersTimeout,
            bodyTimeout,
            opaque: internalOpaque,
            dispatcher: (_e = args.dispatcher) !== null && _e !== void 0 ? _e : tslib_1.__classPrivateFieldGet(this, _HttpClient_dispatcher, "f"),
        };
        if (args.followRedirect === false) {
            requestOptions.maxRedirections = 0;
        }
        const isGETOrHEAD = requestOptions.method === 'GET' || requestOptions.method === 'HEAD';
        // alias to args.content
        if (args.stream && !args.content) {
            args.content = args.stream;
        }
        if (args.files) {
            if (isGETOrHEAD) {
                requestOptions.method = 'POST';
            }
            const formData = new FormData();
            const uploadFiles = [];
            if (Array.isArray(args.files)) {
                for (const [index, file] of args.files.entries()) {
                    const field = index === 0 ? 'file' : `file${index}`;
                    uploadFiles.push([field, file]);
                }
            }
            else if (args.files instanceof stream_1.Readable || isReadable(args.files)) {
                uploadFiles.push(['file', args.files]);
            }
            else if (typeof args.files === 'string' || Buffer.isBuffer(args.files)) {
                uploadFiles.push(['file', args.files]);
            }
            else if (typeof args.files === 'object') {
                for (const field in args.files) {
                    uploadFiles.push([field, args.files[field]]);
                }
            }
            // set normal fields first
            if (args.data) {
                for (const field in args.data) {
                    formData.append(field, args.data[field]);
                }
            }
            for (const [index, [field, file]] of uploadFiles.entries()) {
                if (typeof file === 'string') {
                    // FIXME: support non-ascii filename
                    // const fileName = encodeURIComponent(basename(file));
                    // formData.append(field, await fileFromPath(file, `utf-8''${fileName}`, { type: mime.lookup(fileName) || '' }));
                    const fileName = (0, path_1.basename)(file);
                    const fileReadable = (0, fs_1.createReadStream)(file);
                    formData.append(field, new BlobFromStream(fileReadable, mime_types_1.default.lookup(fileName) || ''), fileName);
                }
                else if (Buffer.isBuffer(file)) {
                    formData.append(field, new buffer_1.Blob([file]), `bufferfile${index}`);
                }
                else if (file instanceof stream_1.Readable || isReadable(file)) {
                    const fileName = getFileName(file) || `streamfile${index}`;
                    formData.append(field, new BlobFromStream(file, mime_types_1.default.lookup(fileName) || ''), fileName);
                }
            }
            if (undici_1.FormData) {
                requestOptions.body = formData;
            }
            else {
                // Node.js 14 does not support spec-compliant FormData
                // https://github.com/octet-stream/form-data#usage
                const encoder = new form_data_encoder_1.FormDataEncoder(formData);
                Object.assign(headers, encoder.headers);
                // fix "Content-Length":"NaN"
                delete headers['Content-Length'];
                requestOptions.body = stream_1.Readable.from(encoder);
            }
        }
        else if (args.content) {
            if (!isGETOrHEAD) {
                // handle content
                requestOptions.body = args.content;
                if (args.contentType) {
                    headers['content-type'] = args.contentType;
                }
                else if (typeof args.content === 'string' && !headers['content-type']) {
                    headers['content-type'] = 'text/plain;charset=UTF-8';
                }
            }
        }
        else if (args.data) {
            const isStringOrBufferOrReadable = typeof args.data === 'string'
                || Buffer.isBuffer(args.data)
                || isReadable(args.data);
            if (isGETOrHEAD) {
                if (!isStringOrBufferOrReadable) {
                    for (const field in args.data) {
                        requestUrl.searchParams.append(field, args.data[field]);
                    }
                }
            }
            else {
                if (isStringOrBufferOrReadable) {
                    requestOptions.body = args.data;
                }
                else {
                    if (args.contentType === 'json'
                        || args.contentType === 'application/json'
                        || ((_f = headers['content-type']) === null || _f === void 0 ? void 0 : _f.startsWith('application/json'))) {
                        requestOptions.body = JSON.stringify(args.data);
                        if (!headers['content-type']) {
                            headers['content-type'] = 'application/json';
                        }
                    }
                    else {
                        headers['content-type'] = 'application/x-www-form-urlencoded;charset=UTF-8';
                        requestOptions.body = new URLSearchParams(args.data).toString();
                    }
                }
            }
        }
        debug('Request#%d %s %s, headers: %j, headersTimeout: %s, bodyTimeout: %s', requestId, requestOptions.method, requestUrl.href, headers, headersTimeout, bodyTimeout);
        requestOptions.headers = headers;
        if (this.listenerCount('request') > 0) {
            this.emit('request', reqMeta);
        }
        let response = await (0, undici_1.request)(requestUrl, requestOptions);
        // handle digest auth
        if (response.statusCode === 401 && response.headers['www-authenticate'] &&
            !requestOptions.headers.authorization && args.digestAuth) {
            const authenticate = response.headers['www-authenticate'];
            if (authenticate.startsWith('Digest ')) {
                debug('Request#%d %s: got digest auth header WWW-Authenticate: %s', requestId, requestUrl.href, authenticate);
                requestOptions.headers.authorization = (0, utils_1.digestAuthHeader)(requestOptions.method, `${requestUrl.pathname}${requestUrl.search}`, authenticate, args.digestAuth);
                debug('Request#%d %s: auth with digest header: %s', requestId, url, requestOptions.headers.authorization);
                if (response.headers['set-cookie']) {
                    // FIXME: merge exists cookie header
                    requestOptions.headers.cookie = response.headers['set-cookie'].join(';');
                }
                response = await (0, undici_1.request)(requestUrl, requestOptions);
            }
        }
        const context = response.context;
        let lastUrl = '';
        if (context === null || context === void 0 ? void 0 : context.history) {
            for (const urlObject of context === null || context === void 0 ? void 0 : context.history) {
                res.requestUrls.push(urlObject.href);
                lastUrl = urlObject.href;
            }
        }
        else {
            res.requestUrls.push(requestUrl.href);
            lastUrl = requestUrl.href;
        }
        const contentEncoding = response.headers['content-encoding'];
        const isCompressedContent = contentEncoding === 'gzip' || contentEncoding === 'br';
        res.headers = response.headers;
        res.status = res.statusCode = response.statusCode;
        if (res.headers['content-length']) {
            res.size = parseInt(res.headers['content-length']);
        }
        let data = null;
        let responseBodyStream;
        if (args.dataType === 'stream') {
            // streaming mode will disable retry
            args.retry = 0;
            const meta = {
                status: res.status,
                statusCode: res.statusCode,
                headers: res.headers,
                timing,
                socket: socketInfo,
            };
            // only auto decompress on request args.compressed = true
            if (args.compressed === true && isCompressedContent) {
                // gzip or br
                const decoder = contentEncoding === 'gzip' ? (0, zlib_1.createGunzip)() : (0, zlib_1.createBrotliDecompress)();
                responseBodyStream = Object.assign((0, stream_1.pipeline)(response.body, decoder, noop), meta);
            }
            else {
                responseBodyStream = Object.assign(response.body, meta);
            }
        }
        else if (args.writeStream) {
            // streaming mode will disable retry
            args.retry = 0;
            if (args.compressed === true && isCompressedContent) {
                const decoder = contentEncoding === 'gzip' ? (0, zlib_1.createGunzip)() : (0, zlib_1.createBrotliDecompress)();
                await pipelinePromise(response.body, decoder, args.writeStream);
            }
            else {
                await pipelinePromise(response.body, args.writeStream);
            }
        }
        else {
            // buffer
            data = Buffer.from(await response.body.arrayBuffer());
            if (isCompressedContent && data.length > 0) {
                try {
                    data = contentEncoding === 'gzip' ? (0, zlib_1.gunzipSync)(data) : (0, zlib_1.brotliDecompressSync)(data);
                }
                catch (err) {
                    if (err.name === 'Error') {
                        err.name = 'UnzipError';
                    }
                    throw err;
                }
            }
            if (args.dataType === 'text') {
                data = data.toString();
            }
            else if (args.dataType === 'json') {
                if (data.length === 0) {
                    data = null;
                }
                else {
                    data = (0, utils_1.parseJSON)(data.toString(), args.fixJSONCtlChars);
                }
            }
        }
        res.rt = (0, utils_1.performanceTime)(requestStartTime);
        // get real socket info from internalOpaque
        tslib_1.__classPrivateFieldGet(this, _HttpClient_instances, "m", _HttpClient_updateSocketInfo).call(this, socketInfo, internalOpaque);
        const clientResponse = {
            opaque: orginalOpaque,
            data,
            status: res.status,
            statusCode: res.status,
            headers: res.headers,
            url: lastUrl,
            redirected: res.requestUrls.length > 1,
            requestUrls: res.requestUrls,
            res: responseBodyStream !== null && responseBodyStream !== void 0 ? responseBodyStream : res,
        };
        if (args.retry > 0 && requestContext.retries < args.retry) {
            const isRetry = (_g = args.isRetry) !== null && _g !== void 0 ? _g : defaultIsRetry;
            if (isRetry(clientResponse)) {
                if (args.retryDelay) {
                    await (0, utils_1.sleep)(args.retryDelay);
                }
                requestContext.retries++;
                return await tslib_1.__classPrivateFieldGet(this, _HttpClient_instances, "m", _HttpClient_requestInternal).call(this, url, options, requestContext);
            }
        }
        if (this.listenerCount('response') > 0) {
            this.emit('response', {
                requestId,
                error: null,
                ctx: args.ctx,
                req: {
                    ...reqMeta,
                    options: args,
                },
                res,
            });
        }
        return clientResponse;
    }
    catch (e) {
        debug('Request#%d throw error: %s', requestId, e);
        let err = e;
        if (err.name === 'HeadersTimeoutError') {
            err = new HttpClientRequestTimeoutError(headersTimeout, { cause: e });
        }
        else if (err.name === 'BodyTimeoutError') {
            err = new HttpClientRequestTimeoutError(bodyTimeout, { cause: e });
        }
        err.opaque = orginalOpaque;
        err.status = res.status;
        err.headers = res.headers;
        err.res = res;
        // make sure requestUrls not empty
        if (res.requestUrls.length === 0) {
            res.requestUrls.push(requestUrl.href);
        }
        res.rt = (0, utils_1.performanceTime)(requestStartTime);
        tslib_1.__classPrivateFieldGet(this, _HttpClient_instances, "m", _HttpClient_updateSocketInfo).call(this, socketInfo, internalOpaque);
        if (this.listenerCount('response') > 0) {
            this.emit('response', {
                requestId,
                error: err,
                ctx: args.ctx,
                req: {
                    ...reqMeta,
                    options: args,
                },
                res,
            });
        }
        throw err;
    }
}, _HttpClient_updateSocketInfo = function _HttpClient_updateSocketInfo(socketInfo, internalOpaque) {
    const socket = internalOpaque[symbols_1.default.kRequestSocket];
    if (socket) {
        socketInfo.id = socket[symbols_1.default.kSocketId];
        socketInfo.handledRequests = socket[symbols_1.default.kHandledRequests];
        socketInfo.handledResponses = socket[symbols_1.default.kHandledResponses];
        socketInfo.localAddress = socket.localAddress;
        socketInfo.localPort = socket.localPort;
        socketInfo.remoteAddress = socket.remoteAddress;
        socketInfo.remotePort = socket.remotePort;
        socketInfo.remoteFamily = socket.remoteFamily;
        socketInfo.bytesRead = socket.bytesRead;
        socketInfo.bytesWritten = socket.bytesWritten;
    }
};
//# sourceMappingURL=HttpClient.js.map

/***/ }),

/***/ "../../node_modules/urllib/src/cjs/diagnosticsChannel.js":
/*!***************************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/diagnosticsChannel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initDiagnosticsChannel = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "../../node_modules/tslib/tslib.es6.js");
const diagnostics_channel_1 = tslib_1.__importDefault(__webpack_require__(/*! diagnostics_channel */ "diagnostics_channel"));
const perf_hooks_1 = __webpack_require__(/*! perf_hooks */ "perf_hooks");
const util_1 = __webpack_require__(/*! util */ "util");
const symbols_1 = tslib_1.__importDefault(__webpack_require__(/*! ./symbols */ "../../node_modules/urllib/src/cjs/symbols.js"));
const utils_1 = __webpack_require__(/*! ./utils */ "../../node_modules/urllib/src/cjs/utils.js");
const debug = (0, util_1.debuglog)('urllib:DiagnosticsChannel');
let initedDiagnosticsChannel = false;
// https://undici.nodejs.org/#/docs/api/DiagnosticsChannel
// client --> server
// undici:request:create => { request }
//   -> [optional] undici:client:connected => { socket } [first request will create socket]
//   -> undici:client:sendHeaders => { socket, request }
//     -> undici:request:bodySent => { request }
//
// server --> client
// undici:request:headers => { request, response }
//   -> undici:request:trailers => { request, trailers }
function initDiagnosticsChannel() {
    // makre sure init global DiagnosticsChannel once
    if (initedDiagnosticsChannel)
        return;
    initedDiagnosticsChannel = true;
    let kHandler;
    // This message is published when a new outgoing request is created.
    // Note: a request is only loosely completed to a given socket.
    diagnostics_channel_1.default.channel('undici:request:create').subscribe((message, name) => {
        var _a, _b;
        const { request } = message;
        if (!kHandler) {
            const symbols = Object.getOwnPropertySymbols(request);
            for (const symbol of symbols) {
                if (symbol.description === 'handler') {
                    kHandler = symbol;
                    break;
                }
            }
        }
        const opaque = (_b = (_a = request[kHandler]) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.opaque;
        // ignore non HttpClient Request
        if (!opaque || !opaque[symbols_1.default.kRequestId])
            return;
        debug('[%s] Request#%d %s %s, path: %s', name, opaque[symbols_1.default.kRequestId], request.method, request.origin, request.path);
        if (!opaque[symbols_1.default.kEnableRequestTiming])
            return;
        opaque[symbols_1.default.kRequestTiming].queuing = (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime]);
    });
    // diagnosticsChannel.channel('undici:client:beforeConnect')
    // diagnosticsChannel.channel('undici:client:connectError')
    // This message is published after a connection is established.
    diagnostics_channel_1.default.channel('undici:client:connected').subscribe((message, name) => {
        const { socket } = message;
        socket[symbols_1.default.kSocketId] = (0, utils_1.globalId)('UndiciSocket');
        socket[symbols_1.default.kSocketStartTime] = perf_hooks_1.performance.now();
        socket[symbols_1.default.kHandledRequests] = 0;
        socket[symbols_1.default.kHandledResponses] = 0;
        debug('[%s] Socket#%d connected', name, socket[symbols_1.default.kSocketId]);
    });
    // This message is published right before the first byte of the request is written to the socket.
    diagnostics_channel_1.default.channel('undici:client:sendHeaders').subscribe((message, name) => {
        var _a, _b;
        const { request, socket } = message;
        if (!kHandler)
            return;
        const opaque = (_b = (_a = request[kHandler]) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.opaque;
        if (!opaque || !opaque[symbols_1.default.kRequestId])
            return;
        socket[symbols_1.default.kHandledRequests]++;
        // attach socket to opaque
        opaque[symbols_1.default.kRequestSocket] = socket;
        debug('[%s] Request#%d send headers on Socket#%d (handled %d requests)', name, opaque[symbols_1.default.kRequestId], socket[symbols_1.default.kSocketId], socket[symbols_1.default.kHandledRequests]);
        if (!opaque[symbols_1.default.kEnableRequestTiming])
            return;
        opaque[symbols_1.default.kRequestTiming].requestHeadersSent = (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime]);
        // first socket need to caculate the connected time
        if (socket[symbols_1.default.kHandledRequests] === 1) {
            // kSocketStartTime - kRequestStartTime = connected time
            opaque[symbols_1.default.kRequestTiming].connected =
                (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime], socket[symbols_1.default.kSocketStartTime]);
        }
    });
    diagnostics_channel_1.default.channel('undici:request:bodySent').subscribe((message, name) => {
        var _a, _b;
        const { request } = message;
        if (!kHandler)
            return;
        const opaque = (_b = (_a = request[kHandler]) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.opaque;
        if (!opaque || !opaque[symbols_1.default.kRequestId])
            return;
        debug('[%s] Request#%d send body', name, opaque[symbols_1.default.kRequestId]);
        if (!opaque[symbols_1.default.kEnableRequestTiming])
            return;
        opaque[symbols_1.default.kRequestTiming].requestSent = (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime]);
    });
    // This message is published after the response headers have been received, i.e. the response has been completed.
    diagnostics_channel_1.default.channel('undici:request:headers').subscribe((message, name) => {
        var _a, _b;
        const { request, response } = message;
        if (!kHandler)
            return;
        const opaque = (_b = (_a = request[kHandler]) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.opaque;
        if (!opaque || !opaque[symbols_1.default.kRequestId])
            return;
        // get socket from opaque
        const socket = opaque[symbols_1.default.kRequestSocket];
        socket[symbols_1.default.kHandledResponses]++;
        debug('[%s] Request#%d get %s response headers on Socket#%d (handled %d responses)', name, opaque[symbols_1.default.kRequestId], response.statusCode, socket[symbols_1.default.kSocketId], socket[symbols_1.default.kHandledResponses]);
        if (!opaque[symbols_1.default.kEnableRequestTiming])
            return;
        opaque[symbols_1.default.kRequestTiming].waiting = (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime]);
    });
    // This message is published after the response body and trailers have been received, i.e. the response has been completed.
    diagnostics_channel_1.default.channel('undici:request:trailers').subscribe((message, name) => {
        var _a, _b;
        const { request } = message;
        if (!kHandler)
            return;
        const opaque = (_b = (_a = request[kHandler]) === null || _a === void 0 ? void 0 : _a.opts) === null || _b === void 0 ? void 0 : _b.opaque;
        if (!opaque || !opaque[symbols_1.default.kRequestId])
            return;
        debug('[%s] Request#%d get response body and trailers', name, opaque[symbols_1.default.kRequestId]);
        if (!opaque[symbols_1.default.kEnableRequestTiming])
            return;
        opaque[symbols_1.default.kRequestTiming].contentDownload = (0, utils_1.performanceTime)(opaque[symbols_1.default.kRequestStartTime]);
    });
    // diagnosticsChannel.channel('undici:request:error')
}
exports.initDiagnosticsChannel = initDiagnosticsChannel;
//# sourceMappingURL=diagnosticsChannel.js.map

/***/ }),

/***/ "../../node_modules/urllib/src/cjs/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getGlobalDispatcher = exports.setGlobalDispatcher = exports.Dispatcher = exports.Agent = exports.ProxyAgent = exports.MockAgent = exports.USER_AGENT = exports.HttpClient = exports.request = void 0;
const HttpClient_1 = __webpack_require__(/*! ./HttpClient */ "../../node_modules/urllib/src/cjs/HttpClient.js");
let httpclient;
async function request(url, options) {
    if (!httpclient) {
        if (options === null || options === void 0 ? void 0 : options.socketPath) {
            httpclient = new HttpClient_1.HttpClient({
                connect: { socketPath: options.socketPath },
            });
        }
        else {
            httpclient = new HttpClient_1.HttpClient({});
        }
    }
    return await httpclient.request(url, options);
}
exports.request = request;
var HttpClient_2 = __webpack_require__(/*! ./HttpClient */ "../../node_modules/urllib/src/cjs/HttpClient.js");
Object.defineProperty(exports, "HttpClient", ({ enumerable: true, get: function () { return HttpClient_2.HttpClient; } }));
Object.defineProperty(exports, "USER_AGENT", ({ enumerable: true, get: function () { return HttpClient_2.HEADER_USER_AGENT; } }));
var undici_1 = __webpack_require__(/*! undici */ "../../node_modules/undici/index.js");
Object.defineProperty(exports, "MockAgent", ({ enumerable: true, get: function () { return undici_1.MockAgent; } }));
Object.defineProperty(exports, "ProxyAgent", ({ enumerable: true, get: function () { return undici_1.ProxyAgent; } }));
Object.defineProperty(exports, "Agent", ({ enumerable: true, get: function () { return undici_1.Agent; } }));
Object.defineProperty(exports, "Dispatcher", ({ enumerable: true, get: function () { return undici_1.Dispatcher; } }));
Object.defineProperty(exports, "setGlobalDispatcher", ({ enumerable: true, get: function () { return undici_1.setGlobalDispatcher; } }));
Object.defineProperty(exports, "getGlobalDispatcher", ({ enumerable: true, get: function () { return undici_1.getGlobalDispatcher; } }));
exports["default"] = {
    request,
    USER_AGENT: HttpClient_1.HEADER_USER_AGENT,
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/urllib/src/cjs/symbols.js":
/*!****************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/symbols.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = {
    kSocketId: Symbol('socket id'),
    kSocketStartTime: Symbol('socket start time'),
    kHandledRequests: Symbol('handled requests per socket'),
    kHandledResponses: Symbol('handled responses per socket'),
    kRequestSocket: Symbol('request on the socket'),
    kRequestId: Symbol('request id'),
    kRequestStartTime: Symbol('request start time'),
    kEnableRequestTiming: Symbol('enable request timing or not'),
    kRequestTiming: Symbol('request timing'),
    kRequestOrginalOpaque: Symbol('request orginal opaque'),
};
//# sourceMappingURL=symbols.js.map

/***/ }),

/***/ "../../node_modules/urllib/src/cjs/utils.js":
/*!**************************************************!*\
  !*** ../../node_modules/urllib/src/cjs/utils.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.performanceTime = exports.globalId = exports.digestAuthHeader = exports.sleep = exports.parseJSON = void 0;
const crypto_1 = __webpack_require__(/*! crypto */ "crypto");
const perf_hooks_1 = __webpack_require__(/*! perf_hooks */ "perf_hooks");
const JSONCtlCharsMap = {
    '"': '\\"',
    '\\': '\\\\',
    '\b': '\\b',
    '\f': '\\f',
    '\n': '\\n',
    '\r': '\\r',
    '\t': '\\t', // \u0009
};
/* eslint no-control-regex: "off"*/
const JSONCtlCharsRE = /[\u0000-\u001F\u005C]/g;
function replaceOneChar(c) {
    return JSONCtlCharsMap[c] || '\\u' + (c.charCodeAt(0) + 0x10000).toString(16).substring(1);
}
function replaceJSONCtlChars(value) {
    return value.replace(JSONCtlCharsRE, replaceOneChar);
}
function parseJSON(data, fixJSONCtlChars) {
    if (typeof fixJSONCtlChars === 'function') {
        data = fixJSONCtlChars(data);
    }
    else if (fixJSONCtlChars) {
        // https://github.com/node-modules/urllib/pull/77
        // remote the control characters (U+0000 through U+001F)
        data = replaceJSONCtlChars(data);
    }
    try {
        data = JSON.parse(data);
    }
    catch (err) {
        if (err.name === 'SyntaxError') {
            err.name = 'JSONResponseFormatError';
        }
        if (data.length > 1024) {
            // show 0~512 ... -512~end data
            err.message += ' (data json format: ' +
                JSON.stringify(data.slice(0, 512)) + ' ...skip... ' + JSON.stringify(data.slice(data.length - 512)) + ')';
        }
        else {
            err.message += ' (data json format: ' + JSON.stringify(data) + ')';
        }
        throw err;
    }
    return data;
}
exports.parseJSON = parseJSON;
function sleep(ms) {
    return new Promise(resolve => {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
function md5(s) {
    const sum = (0, crypto_1.createHash)('md5');
    sum.update(s, 'utf8');
    return sum.digest('hex');
}
const AUTH_KEY_VALUE_RE = /(\w{1,100})=["']?([^'"]+)["']?/;
let NC = 0;
const NC_PAD = '00000000';
function digestAuthHeader(method, uri, wwwAuthenticate, userpass) {
    // WWW-Authenticate: Digest realm="testrealm@host.com",
    //                       qop="auth,auth-int",
    //                       nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
    //                       opaque="5ccc069c403ebaf9f0171e9517f40e41"
    // Authorization: Digest username="Mufasa",
    //                    realm="testrealm@host.com",
    //                    nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093",
    //                    uri="/dir/index.html",
    //                    qop=auth,
    //                    nc=00000001,
    //                    cnonce="0a4f113b",
    //                    response="6629fae49393a05397450978507c4ef1",
    //                    opaque="5ccc069c403ebaf9f0171e9517f40e41"
    // HA1 = MD5( "Mufasa:testrealm@host.com:Circle Of Life" )
    //      = 939e7578ed9e3c518a452acee763bce9
    //
    //  HA2 = MD5( "GET:/dir/index.html" )
    //      = 39aff3a2bab6126f332b942af96d3366
    //
    //  Response = MD5( "939e7578ed9e3c518a452acee763bce9:\
    //                   dcd98b7102dd2f0e8b11d0f600bfb0c093:\
    //                   00000001:0a4f113b:auth:\
    //                   39aff3a2bab6126f332b942af96d3366" )
    //           = 6629fae49393a05397450978507c4ef1
    const parts = wwwAuthenticate.split(',');
    const opts = {};
    for (const part of parts) {
        const m = part.match(AUTH_KEY_VALUE_RE);
        if (m) {
            opts[m[1]] = m[2].replace(/["']/g, '');
        }
    }
    if (!opts.realm || !opts.nonce) {
        return '';
    }
    let qop = opts.qop || '';
    const [user, pass] = userpass.split(':');
    let nc = String(++NC);
    nc = `${NC_PAD.substring(nc.length)}${nc}`;
    const cnonce = (0, crypto_1.randomBytes)(8).toString('hex');
    const ha1 = md5(`${user}:${opts.realm}:${pass}`);
    const ha2 = md5(`${method.toUpperCase()}:${uri}`);
    let s = `${ha1}:${opts.nonce}`;
    if (qop) {
        qop = qop.split(',')[0];
        s += `:${nc}:${cnonce}:${qop}`;
    }
    s += `:${ha2}`;
    const response = md5(s);
    let authstring = `Digest username="${user}", realm="${opts.realm}", nonce="${opts.nonce}", uri="${uri}", response="${response}"`;
    if (opts.opaque) {
        authstring += `, opaque="${opts.opaque}"`;
    }
    if (qop) {
        authstring += `, qop=${qop}, nc=${nc}, cnonce="${cnonce}"`;
    }
    return authstring;
}
exports.digestAuthHeader = digestAuthHeader;
const MAX_ID_VALUE = Math.pow(2, 31) - 10;
const globalIds = {};
function globalId(category) {
    if (!globalIds[category] || globalIds[category] >= MAX_ID_VALUE) {
        globalIds[category] = 0;
    }
    return ++globalIds[category];
}
exports.globalId = globalId;
function performanceTime(startTime, now) {
    return Math.floor(((now !== null && now !== void 0 ? now : perf_hooks_1.performance.now()) - startTime) * 1000) / 1000;
}
exports.performanceTime = performanceTime;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "../../node_modules/urllib/node_modules/mime-db/db.json":
/*!**************************************************************!*\
  !*** ../../node_modules/urllib/node_modules/mime-db/db.json ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"minicode","publisher":"alipay","author":"alipay","displayName":"%extension.name%","description":"%extension.description%","version":"1.9.23","private":true,"engines":{"vscode":"^1.60.0"},"scripts":{"vscode:prepublish":"yarn run build","clean":"rm -rf ./dist && rm -rf ./analyze","prebuild":"yarn clean","build:prod":"../../node_modules/.bin/webpack --mode production","build":"../../node_modules/.bin/webpack","watch":"../../node_modules/.bin/webpack --mode development --watch","test:e2e":"../../node_modules/.bin/tsc -p ./test/tsconfig.json && node ./test/e2e-out/codeTestRunner.js lsp","test:e2e:prod":"yarn run compile:prod && tsc -p ./test/tsconfig.json && node ./test/e2e-out/codeTestRunner.js lsp --test-prod","test":"../../node_modules/.bin/jest","ci":"yarn build && yarn test","ci:cov":"yarn run ci --coverage","pack-ext":"yarn run compile:prod && yarn run realpack","realpack":"../../node_modules/.bin/vsce package -o ./ --yarn","compile":"yarn run compile:tmLanguage && yarn build","compile:prod":"yarn run compile:tmLanguage && yarn run build:prod","compile:tmLanguage":"node scripts/axml.tmLanguage.js","analyze":"sh ./scripts/analyze.sh"},"categories":["Snippets","Programming Languages","Formatters","Linters"],"bugs":{"url":"https://github.com/ant-mini-program/vscode-alipay-minicode/issues","email":"minicode@alibaba-inc.com"},"repository":"https://github.com/ant-mini-program/vscode-alipay-minicode","activationEvents":["workspaceContains:**/app.json","workspaceContains:**/app.js","workspaceContains:**/*.axml","workspaceContains:**/*.acss","workspaceContains:**/*.sjs","workspaceContains:**/mini.project.json","workspaceContains:**/ext.json","workspaceContains:**/plugin.json","onCommand:mini-program.newComponent","onCommand:mini-program.newPage","onCommand:appx.restartLanguageServer"],"icon":"icon.png","main":"./dist/extension.js","extensionDependencies":["vscode.css-language-features","vscode.css"],"contributes":{"configurationDefaults":{"[axml]":{"editor.semanticHighlighting.enabled":false,"editor.quickSuggestions":{"other":true,"strings":true,"comments":false}}},"commands":[{"command":"mini-program.newPage","title":"%extension.commands.newPage%"},{"command":"mini-program.newComponent","title":"%extension.commands.newComponent%"},{"command":"appx.restartLanguageServer","title":"%extension.commands.refresh%","alias":"Restart Mini Program Language Server"},{"command":"appx.downloadApiTyping","title":"%extension.commands.appx.downloadApiTyping%","alias":"Download Latest API Typing"},{"command":"appx.downloadLatestMiniResources","title":"%extension.commands.appx.downloadLatestMiniResources%","alias":"Download Latest Mini Program Resources(JSON Schemas/AXML Language Facts)"}],"languages":[{"id":"css","aliases":["ACSS"],"extensions":[".acss"]},{"id":"axml","aliases":["AXML"],"extensions":[".axml"],"mimetypes":["text/axml"],"configuration":"./syntaxes/axml-language-configuration.json"},{"id":"javascript","extensions":[".sjs"]}],"grammars":[{"language":"axml","scopeName":"source.axml","path":"./syntaxes/axml.tmLanguage.json","embeddedLanguages":{"source.js":"javascript","source.ts":"typescript"}},{"path":"./syntaxes/acss.tmLanguage.injection.json","scopeName":"acss-rpx.injection","injectTo":["source.css"]}],"configuration":{"type":"object","title":"%extension.configuration.title%","properties":{"Mini-Program.miniProjectJsonPath":{"type":"string","default":"./mini.project.json","description":"%extension.configuration.miniProjectJsonPath%"},"Mini-Program.enabledJSAPIComplete":{"type":"boolean","default":true,"description":"%extension.configuration.enableJSComplete%"},"Mini-Program.disableAutoUpdateTypings":{"type":"boolean","default":false,"description":"%extension.configuration.disableAutoUpdateTypings%"},"Mini-Program.disableAutoUpdateResources":{"type":"boolean","default":false,"description":"%extension.configuration.disableAutoUpdateResources%"},"Mini-Program.scaffold.path":{"type":"string","default":"","description":"%extension.configuration.scaffold.path%"},"Mini-Program.scaffold.createTs":{"type":"boolean","default":false,"description":"%extension.configuration.scaffold.createTs%"},"Mini-Program.scaffold.createLess":{"type":"boolean","default":false,"description":"%extension.configuration.scaffold.createLess%"},"Mini-Program.ide.path":{"type":"string","default":"","description":"%extension.configuration.ide.path%"},"Mini-Program.autoGeneratePageWhenAppJsonChanged":{"type":"boolean","default":false,"description":"%extension.configuration.autoGeneratePageWhenAppJsonChanged%"},"Mini-Program.js.disableTyping":{"type":"boolean","default":false,"description":"%extension.configuration.js.disableTyping%"},"Mini-Program.axml.disableDiagnosis":{"type":"boolean","default":false,"description":"%extension.configuration.axml.disableDiagnosis%"},"Mini-Program.axml.disableHover":{"type":"boolean","default":false,"description":"%extension.configuration.axml.disableHover%"},"Mini-Program.axml.disableTagCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.axml.disableTagCompletion%"},"Mini-Program.axml.disableExpressionCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.axml.disableExpressionCompletion%"},"Mini-Program.axml.disableStyleCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.axml.disableStyleCompletion%"},"Mini-Program.axml.format.attributeWrapLineLength":{"type":"number","default":80,"description":"%extension.configuration.axml.format.attributeWrapLineLength%"},"Mini-Program.axml.format.wrapAttributesMode":{"type":"string","enum":["force-expand-multiline"],"enumDescriptions":["%extension.configuration.axml.format.wrapAttributesMode.forceExpandMultiline%"],"default":"force-expand-multiline","description":"%extension.configuration.axml.format.wrapAttributesMode%"},"Mini-Program.axml.legacyFormat.enable":{"type":"boolean","default":false,"description":"%extension.configuration.axml.legacyFormat.enable%"},"Mini-Program.axml.legacyFormat.attributeWrapLineLength":{"type":"number","default":80,"description":"%extension.configuration.axml.legacyFormat.attributeWrapLineLength%"},"Mini-Program.axml.legacyFormat.wrapAttributesMode":{"type":"string","enum":["auto","force","force-aligned","force-expand-multiline","aligned-multiple"],"enumDescriptions":["%extension.configuration.axml.legacyFormat.wrapAttributesMode.auto%","%extension.configuration.axml.legacyFormat.wrapAttributesMode.force%","%extension.configuration.axml.legacyFormat.wrapAttributesMode.forceAligned%","%extension.configuration.axml.legacyFormat.wrapAttributesMode.forceExpandMultiline%","%extension.configuration.axml.legacyFormat.wrapAttributesMode.alignedMultiple%"],"default":"auto","description":"%extension.configuration.axml.legacyFormat.wrapAttributesMode%"},"Mini-Program.json.disableHover":{"type":"boolean","default":false,"description":"%extension.configuration.json.disableHover%"},"Mini-Program.json.disablePageCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.json.disablePageCompletion%"},"Mini-Program.json.disableComponentCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.json.disableComponentCompletion%"},"Mini-Program.acss.disableRpxCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.acss.disableRpxCompletion%"},"Mini-Program.acss.disableImportCompletion":{"type":"boolean","default":false,"description":"%extension.configuration.acss.disableImportCompletion%"}}},"menus":{"explorer/context":[{"when":"explorerResourceIsFolder","command":"mini-program.newPage","group":"1_modification@1"},{"when":"explorerResourceIsFolder","command":"mini-program.newComponent","group":"1_modification@2"}]},"typescriptServerPlugins":[{"name":"@alipay/mini-ts-plugin","enableForWorkspaceTypeScriptVersions":true}]},"keywords":["miniprogram","支付宝","小程序","支付宝小程序","axml","alipay","appx"],"dependencies":{"@alipay/mini-language-server":"^1.0.2","@alipay/mini-language-service":"^1.0.12","@alipay/mini-ts-plugin":"^1.0.2","@alipay/mini-types-alipay":"^1.1.9","@mini-types/global":"^2.0.19","typescript":"4.6.4"},"devDependencies":{"@alipay/mac-address":"^0.0.2","@alipay/mini-extensions-shared":"^1.0.12","@alipay/mini-program-config-loader":"^1.13.5","vscode-languageclient":"7.1.0-next.5"},"publishConfig":{"registry":"https://registry.npm.alibaba-inc.com"},"files":["out","config"]}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/extension.ts");
/******/ 	module.exports = __webpack_exports__;
/******/ 	
/******/ })()
;
//# sourceMappingURL=extension.js.map