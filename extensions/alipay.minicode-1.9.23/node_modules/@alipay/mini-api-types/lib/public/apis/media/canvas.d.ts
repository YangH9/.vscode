import { API, Type, TypeRef, APIType } from '../../type';
export interface TypeExport<S> {
    [Type.CanvasContext.Context]: CanvasContext<S>;
    [Type.CanvasContext.Draw]: draw<S>;
    [Type.CanvasContext.DrawImage]: drawImage<S>;
    [Type.CanvasContext.addColorStop]: addColorStop;
    [Type.CanvasContext.arc]: arc;
    [Type.CanvasContext.beginPath]: beginPath;
    [Type.CanvasContext.bezierCurveTo]: bezierCurveTo;
    [Type.CanvasContext.clearRect]: clearRect;
    [Type.CanvasContext.clip]: clip;
    [Type.CanvasContext.closePath]: closePath;
    [Type.CanvasContext.createCircularGradient]: createCircularGradient;
    [Type.CanvasContext.createLinearGradient]: createLinearGradient;
    [Type.CanvasContext.fill]: fill;
    [Type.CanvasContext.fillRect]: fillRect;
    [Type.CanvasContext.fillText]: fillText;
    [Type.CanvasContext.getImageData]: getImageData;
    [Type.CanvasContext.lineTo]: lineTo;
    [Type.CanvasContext.measureText]: measureText;
    [Type.CanvasContext.moveTo]: moveTo;
    [Type.CanvasContext.putImageData]: putImageData;
    [Type.CanvasContext.quadraticCurveTo]: quadraticCurveTo;
    [Type.CanvasContext.rect]: rect;
    [Type.CanvasContext.restore]: restore;
    [Type.CanvasContext.rotate]: rotate;
    [Type.CanvasContext.save]: save;
    [Type.CanvasContext.scale]: scale;
    [Type.CanvasContext.setFillStyle]: setFillStyle;
    [Type.CanvasContext.setFontSize]: setFontSize;
    [Type.CanvasContext.setGlobalAlpha]: setGlobalAlpha;
    [Type.CanvasContext.setLineCap]: setLineCap;
    [Type.CanvasContext.setLineDash]: setLineDash;
    [Type.CanvasContext.setLineJoin]: setLineJoin;
    [Type.CanvasContext.setLineWidth]: setLineWidth;
    [Type.CanvasContext.setMiterLimit]: setMiterLimit;
    [Type.CanvasContext.setShadow]: setShadow;
    [Type.CanvasContext.setStrokeStyle]: setStrokeStyle;
    [Type.CanvasContext.setTextAlign]: setTextAlign;
    [Type.CanvasContext.setTextBaseline]: setTextBaseline;
    [Type.CanvasContext.setTransform]: setTransform;
    [Type.CanvasContext.stroke]: stroke;
    [Type.CanvasContext.strokeRect]: strokeRect;
    [Type.CanvasContext.toDataURL]: toDataURL;
    [Type.CanvasContext.toTempFilePath]: toTempFilePath;
    [Type.CanvasContext.transform]: transform;
    [Type.CanvasContext.translate]: translate;
}
/**
 * @name 2D画布
 */
export interface APIExport<S> {
    [API.createCanvasContext]: createCanvasContext<S>;
    [API.canvasToTempFilePath]: canvasToTempFilePath;
    [API.preloadCanvasImage]: preloadCanvasImage;
}
/**
 * @description 把当前画布指定区域的内容导出生成指定大小的图片。在 `draw()` 回调里调用该方法才能保证图片导出成功。
 */
interface canvasToTempFilePath {
    type: APIType.Async;
    request: {
        /**
         * @description
         */
        canvasId: string;
        /**
         * @description 指定的画布区域的左上角横坐标。
         */
        x?: number;
        /**
         * @description 指定的画布区域的左上角纵坐标。
         */
        y?: number;
        /**
         * @description 指定的画布区域的宽度。
         * @default canvas宽度
         */
        width?: number;
        /**
         * @description 指定的画布区域的高度。
         * @default canvas高度
         */
        height?: number;
        /**
         * @description 输出的图片的宽度。
         * @default canvas宽度
         */
        destWidth?: number;
        /**
         * @description 输出的图片的高度。
         * @default canvas高度
         */
        destHeight?: number;
        /**
         * @description 目标文件的类型。
         * @default png
         */
        fileType?: `${EFileType}`;
        /**
         * @description 图片的质量，目前仅对 `jpg` 有效。取值范围为 `(0, 1]`，不在范围内时当作 `1` 处理。
         */
        quality?: number;
    };
    response: {
        /**
         * @description 生成文件的临时路径 (本地路径)。
         */
        filePath: string;
    };
}
declare const enum EFileType {
    /**
     * @description jpg 图片。
     */
    Jpg = "jpg",
    /**
     * @description png 图片。
     */
    Png = "png"
}
/**
 * @description 向 `canvas` 中批量预加载图片，后续渲染时直接使用，而无需等待。
 */
interface preloadCanvasImage {
    type: APIType.Async;
    request: {
        /**
         * @description 需要加载的图片路径集合。
         */
        urls: string[];
    };
    response: {
        /**
         * @description 加载成功的图片。
         */
        loaded: Record<string, ImageData>;
        /**
         * @description 加载失败的图片。
         */
        failed: Record<string, ImageData>;
    };
}
interface ImageData {
    /**
     * @description
     */
    id: string | number | -1;
    /**
     * @description 加载成功则返回图片宽度。
     */
    width: number | void;
    /**
     * @description 加载成功则返回图片高度。
     */
    height: number | void;
    /**
     * @description 图片 url。
     */
    url: string;
}
/**
 * @description 创建 `canvas` 绘图上下文。
 */
interface createCanvasContext<S> {
    type: APIType.Fn;
    fn: (canvasId: string) => TypeRef<S, Type.CanvasContext.Context>;
}
/**
 * @name CanvasContext
 */
interface CanvasContext<S> {
    type: APIType.Property;
    property: {
        draw: TypeRef<S, Type.CanvasContext.Draw>;
        drawImage: TypeRef<S, Type.CanvasContext.DrawImage>;
        addColorStop: TypeRef<S, Type.CanvasContext.addColorStop>;
        arc: TypeRef<S, Type.CanvasContext.arc>;
        beginPath: TypeRef<S, Type.CanvasContext.beginPath>;
        bezierCurveTo: TypeRef<S, Type.CanvasContext.bezierCurveTo>;
        clearRect: TypeRef<S, Type.CanvasContext.clearRect>;
        clip: TypeRef<S, Type.CanvasContext.clip>;
        closePath: TypeRef<S, Type.CanvasContext.closePath>;
        createCircularGradient: TypeRef<S, Type.CanvasContext.createCircularGradient>;
        createLinearGradient: TypeRef<S, Type.CanvasContext.createLinearGradient>;
        fill: TypeRef<S, Type.CanvasContext.fill>;
        fillRect: TypeRef<S, Type.CanvasContext.fillRect>;
        fillText: TypeRef<S, Type.CanvasContext.fillText>;
        getImageData: TypeRef<S, Type.CanvasContext.getImageData>;
        lineTo: TypeRef<S, Type.CanvasContext.lineTo>;
        measureText: TypeRef<S, Type.CanvasContext.measureText>;
        moveTo: TypeRef<S, Type.CanvasContext.moveTo>;
        putImageData: TypeRef<S, Type.CanvasContext.putImageData>;
        quadraticCurveTo: TypeRef<S, Type.CanvasContext.quadraticCurveTo>;
        rect: TypeRef<S, Type.CanvasContext.rect>;
        restore: TypeRef<S, Type.CanvasContext.restore>;
        rotate: TypeRef<S, Type.CanvasContext.rotate>;
        save: TypeRef<S, Type.CanvasContext.save>;
        scale: TypeRef<S, Type.CanvasContext.scale>;
        setFillStyle: TypeRef<S, Type.CanvasContext.setFillStyle>;
        setFontSize: TypeRef<S, Type.CanvasContext.setFontSize>;
        setGlobalAlpha: TypeRef<S, Type.CanvasContext.setGlobalAlpha>;
        setLineCap: TypeRef<S, Type.CanvasContext.setLineCap>;
        setLineDash: TypeRef<S, Type.CanvasContext.setLineDash>;
        setLineJoin: TypeRef<S, Type.CanvasContext.setLineJoin>;
        setLineWidth: TypeRef<S, Type.CanvasContext.setLineWidth>;
        setMiterLimit: TypeRef<S, Type.CanvasContext.setMiterLimit>;
        setShadow: TypeRef<S, Type.CanvasContext.setShadow>;
        setStrokeStyle: TypeRef<S, Type.CanvasContext.setStrokeStyle>;
        setTextAlign: TypeRef<S, Type.CanvasContext.setTextAlign>;
        setTextBaseline: TypeRef<S, Type.CanvasContext.setTextBaseline>;
        setTransform: TypeRef<S, Type.CanvasContext.setTransform>;
        stroke: TypeRef<S, Type.CanvasContext.stroke>;
        strokeRect: TypeRef<S, Type.CanvasContext.strokeRect>;
        toDataURL: TypeRef<S, Type.CanvasContext.toDataURL>;
        toTempFilePath: TypeRef<S, Type.CanvasContext.toTempFilePath>;
        transform: TypeRef<S, Type.CanvasContext.transform>;
        translate: TypeRef<S, Type.CanvasContext.translate>;
    };
}
/**
 * @description 绘制图像，图像保持原始尺寸。
 */
interface drawImage<S> {
    type: APIType.Fn;
    fn: {
        /**
         * @description 用于绘制图像，图像保持原始尺寸
         * @param imageSource 图片资源, 支持 CanvasContext, Base64, URL(需要支持跨域 Access-Control-Allow-Origin: *)
         * @param x 截取图像左上角 x 坐标。
         * @param y 截取图像左上角 y 坐标。
         */
        (imageSource: string | TypeRef<S, Type.CanvasContext.Context>, x: number, y: number): void;
        /**
         * @description 用于绘制图像，图像为指定尺寸
         * @param imageSource 图片资源, 支持 CanvasContext, Base64, URL(需要支持跨域 Access-Control-Allow-Origin: *)
         * @param x 截取图像的左上角 x 坐标
         * @param y 截取图像的左上角 y 坐标
         * @param width 截取图像 x 轴距离
         * @param height 截取图像 y 轴距离
         */
        (imageSource: string | TypeRef<S, Type.CanvasContext.Context>, x: number, y: number, width: number, height: number): void;
        /**
         * @description 用于绘制图像，将指定图像的裁剪区域绘制到目标位置，允许缩放
         * @param sx 截取图像的左上角 x 坐标
         * @param sy 截取图像的左上角 y 坐标
         * @param sWidth 截取图像 x 轴距离
         * @param sHeight 截取图像 y 轴距离
         * @param dx 源图左上角在目标中的 x 轴坐标
         * @param dy 源图左上角在目标中的 y 轴坐标
         * @param dWidth 源图在目标中的 x 轴的绘制宽度
         * @param dHeight 源图在目标中的 y 轴的绘制高度
         */
        (imageSource: string | TypeRef<S, Type.CanvasContext.Context>, sx: number, sy: number, sWidth: number, sHeight: number, dx: number, dy: number, dWidth: number, dHeight: number): void;
    };
}
/**
 * @description 将之前在绘图上下文中的描述指令（路径、变形、样式）提交到 canvas 中
 */
interface draw<S> {
    type: APIType.Fn;
    /**
     * @param reverse 本次绘制是否接着上一次绘制
     * @param callbackk 绘制完成后执行的回调函数
     */
    fn: (reverse?: boolean, callback?: TypeRef<S, Type.Shared.Callback>) => void;
}
/**
 * @description 创建一个圆形的渐变色。
 */
interface addColorStop {
    type: APIType.Fn;
    /**
     * @param stop 表示渐变中开始与结束之间的位置，范围 0-1。
     * @param color 渐变点的颜色。
     */
    fn: (stop: number, color: string) => void;
}
/**
 * @description 画一条弧线。
 */
interface arc {
    type: APIType.Fn;
    /**
     * @param x 圆 x 坐标。
     * @param y 圆 y 坐标。
     * @param r 圆半径。
     * @param sAngle 起始弧度，单位弧度（在3点钟方向）。
     * @param eAngle 终止弧度。
     * @param counterclockwise 指定弧度的方向是逆时针还是顺时针，默认为 `false`。
     */
    fn: (x: number, y: number, r: number, sAngle: number, eAngle: number, counterclockwise?: boolean) => void;
}
/**
 * @description 开始创建一个路径，需要调用 fill 或者 stroke 才会使用路径进行填充或描边。
 */
interface beginPath {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 创建三次方贝塞尔曲线路径。
 */
interface bezierCurveTo {
    type: APIType.Fn;
    /**
     * @param cp1x 第一个贝塞尔控制点 x 坐标。
     * @param cp1y 第一个贝塞尔控制点 y 坐标。
     * @param cp2x 第二个贝塞尔控制点 x 坐标。
     * @param cp2y 第二个贝塞尔控制点 y 坐标。
     * @param x 结束点 x 坐标。
     * @param y 结束点 y 坐标。
     */
    fn: (cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number) => void;
}
/**
 * @description 清除画布上在该矩形区域内的内容。
 */
interface clearRect {
    type: APIType.Fn;
    /**
     * @param x 矩形左上角的 x 坐标。
     * @param y 矩形左上角的 y 坐标。
     * @param width 矩形宽度。
     * @param height 矩形高度。
     */
    fn: (x: number, y: number, width: number, height: number) => void;
}
/**
 * @description 将当前创建的路径设置为当前剪切路径。
 */
interface clip {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 关闭一个路径。
 */
interface closePath {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 创建一个圆形的渐变色。起点在圆心，终点在圆环。
 */
interface createCircularGradient {
    type: APIType.Fn;
    /**
     * @param x 圆心 x 坐标。
     * @param y 圆心 y 坐标。
     * @param r 圆半径。
     */
    fn: (x: number, y: number, r: number) => void;
}
/**
 * @description 创建一个线性的渐变色。
 */
interface createLinearGradient {
    type: APIType.Fn;
    /**
     * @param x0 起点 x 坐标。
     * @param y0 起点 y 坐标。
     * @param x1 终点 x 坐标。
     * @param y1 终点 y 坐标。
     */
    fn: (x0: number, y0: number, x1: number, y1: number) => void;
}
/**
 * @description 对当前路径中的内容进行填充。
 */
interface fill {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 填充矩形。
 */
interface fillRect {
    type: APIType.Fn;
    /**
     * @param x 矩形左上角的 x 坐标。
     * @param y 矩形左上角的 y 坐标。
     * @param width 矩形路径宽度。
     * @param height 矩形路径高度。
     */
    fn: (x: number, y: number, width: number, height: number) => void;
}
/**
 * @description 在画布上绘制被填充的文本。
 */
interface fillText {
    type: APIType.Fn;
    /**
     * @param text 文本。
     * @param x 绘制文本的左下角 x 坐标。
     * @param y 绘制文本的左下角 y 坐标。
     */
    fn: (text: string, x: number, y: number) => void;
}
/**
 * @description 获取 canvas 区域隐含的像素数据。
 */
interface getImageData {
    type: APIType.Fn;
    /**
     * @param width 图像数据矩形的宽度。
     * @param height 图像数据矩形的高度。
     */
    fn: (width: number, height: number) => void;
}
/**
 * @description 增加一个新点，然后创建一条从上次指定点到目标点的线。
 */
interface lineTo {
    type: APIType.Fn;
    /**
     * @param x 目标位置 x 坐标。
     * @param y 目标位置 y 坐标。
     */
    fn: (x: number, y: number) => void;
}
/**
 * @description 测量文本尺寸信息，目前仅返回文本宽度。同步接口。
 */
interface measureText {
    type: APIType.Fn;
    /**
     * @param 要测量的文本。
     */
    fn: (text: string) => TextMetrics;
}
interface TextMetrics {
    /**
     * @description 文本的宽度，为设备的像素值。**注意**：因 `Android` 系统和 `iOS` 系统两端字体处理方式不同，导致实际的返回值会存在一定的差异，建议在各自系统上做兼容处理。
     */
    width: number;
}
/**
 * @description 把路径移动到画布中的指定点，不创建线条。
 */
interface moveTo {
    type: APIType.Fn;
    /**
     * @param x 目标位置 x 坐标。
     * @param y 目标位置 y 坐标。
     */
    fn: (x: number, y: number) => void;
}
/**
 * @description 将像素数据绘制到画布。
 */
interface putImageData {
    type: APIType.Async;
    request: {
        /**
         * @description 图像像素点数据，一维数组，每四项表示一个像素点的 rgba。
         */
        data: Uint8ClampedArray;
        /**
         * @description 源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）。
         */
        x: number;
        /**
         * @description 源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）。
         */
        y: number;
        /**
         * @description 源图像数据矩形区域的宽度 。
         */
        width: number;
        /**
         * @description 源图像数据矩形区域的高度。
         */
        height: number;
    };
}
/**
 * @description 创建二次贝塞尔曲线路径。
 */
interface quadraticCurveTo {
    type: APIType.Fn;
    /**
     * @param cpx 贝塞尔控制点 x 坐标。
     * @param cpy 贝塞尔控制点 y 坐标。
     * @param x 结束点 x 坐标。
     * @param y 结束点 y 坐标。
     */
    fn: (cpx: number, cpy: number, x: number, y: number) => void;
}
/**
 * @description 创建二次贝塞尔曲线路径。
 */
interface rect {
    type: APIType.Fn;
    /**
     * @param x 矩形左上角的 x 坐标。
     * @param y 矩形左上角的 y 坐标。
     * @param width 矩形路径宽度。
     * @param height 矩形路径高度。
     */
    fn: (x: number, y: number, width: number, height: number) => void;
}
/**
 * @description 恢复之前保存的绘图上下文。
 */
interface restore {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 以原点为中心，原点可以用 `translate` 方法修改。顺时针旋转当前坐标轴。多次调用 `rotate`，旋转的角度会叠加。
 */
interface rotate {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 保存当前的绘图上下文。
 */
interface save {
    type: APIType.Fn;
    /**
     * @param rotate 旋转角度，以弧度计（`degrees * Math.PI/180`；`degrees` 范围为 `0~360`）。
     */
    fn: (rotate: number) => void;
}
/**
 * @description 在调用scale方法后，之后创建的路径其横纵坐标会被缩放。多次调用scale，倍数会相乘。
 */
interface scale {
    type: APIType.Fn;
    /**
     * @param scaleWidth 横坐标缩放倍数 (1 = 100%，0.5 = 50%，2 = 200%)。
     * @param scaleHeight 纵坐标轴缩放倍数 (1 = 100%，0.5 = 50%，2 = 200%)。
     */
    fn: (scaleWidth: number, scaleHeight: number) => void;
}
/**
 * @description 设置填充色。
 */
interface setFillStyle {
    type: APIType.Fn;
    /**
     * @param color 颜色。
     */
    fn: (color: string) => void;
}
/**
 * @description 设置字体大小。
 */
interface setFontSize {
    type: APIType.Fn;
    /**
     * @param fontSize 字号。
     */
    fn: (fontSize: number) => void;
}
/**
 * @description 设置全局画笔透明度。
 */
interface setGlobalAlpha {
    type: APIType.Fn;
    /**
     * @param alpha 透明度，`0` 为完全透明，`1` 为完全不透明。取值范围为 `0~1`。
     */
    fn: (alpha: number) => void;
}
/**
 * @description 设置线条的端点样式。
 */
interface setLineCap {
    type: APIType.Fn;
    /**
     * @param lineCap 线条的结束端点样式。
     */
    fn: (lineCap: `${ELineCap}`) => void;
}
declare enum ELineCap {
    Round = "round",
    Butt = "butt",
    Square = "square"
}
/**
 * @description 设置虚线的样式。
 */
interface setLineDash {
    type: APIType.Fn;
    /**
     * @param 一组用于描述交替绘制线段和间距（坐标空间单位）长度的数字。 如果数组元素的数量是奇数， 数组的元素会被复制并重复。例如：[5, 15, 25] 会变成 [5, 15, 25, 5, 15, 25]。
     */
    fn: (segments: number[]) => void;
}
/**
 * @description 设置线条的交点样式。
 */
interface setLineJoin {
    type: APIType.Fn;
    /**
     * @param lineJoin 线条的结束交点样式。
     */
    fn: (lineJoin: `${ELineJoin}`) => void;
}
declare enum ELineJoin {
    Round = "round",
    Bevel = "bevel",
    Miter = "miter"
}
/**
 * @description 设置线条的宽度。
 */
interface setLineWidth {
    type: APIType.Fn;
    /**
     * @param lineWidth 线条宽度，单位为 px。
     */
    fn: (lineWidth: number) => void;
}
/**
 * @description 设置最大斜接长度。
 */
interface setMiterLimit {
    type: APIType.Fn;
    /**
     * @param miterLimit 最大斜接长度。
     */
    fn: (miterLimit: number) => void;
}
/**
 * @description 设置阴影样式。
 */
interface setShadow {
    type: APIType.Fn;
    /**
     * @param offsetX 阴影相对于形状水平方向的偏移，默认值为 `0`。
     * @param offsetY 阴影相对于形状竖直方向的偏移，默认值为 `0`。
     * @param blur 阴影的模糊级别，值越大越模糊，取值范围为 `0~100`，默认值为 `0`。
     * @param color 阴影颜色，默认值为 `black`。
     */
    fn: (offsetX?: number, offsetY?: number, blur?: number, color?: string) => void;
}
/**
 * @description 设置边框颜色。
 */
interface setStrokeStyle {
    type: APIType.Fn;
    /**
     * @param color 颜色。
     */
    fn: (color: string) => void;
}
/**
 * @description Canvas 2D API 描述绘制文本时，文本的对齐方式的属性。
 */
interface setTextAlign {
    type: APIType.Fn;
    /**
     * @param textAlign 文本对齐方式。
     */
    fn: (textAlign: `${ETextAlign}`) => void;
}
declare enum ETextAlign {
    Left = "left",
    Right = "right",
    Center = "center",
    Start = "start",
    End = "end"
}
/**
 * @description Canvas 2D API 描述绘制文本时，当前文本基线的属性。
 */
interface setTextBaseline {
    type: APIType.Fn;
    /**
     * @param textBaseline 文本基线的属性。
     */
    fn: (textBaseline: `${ETextBaseLine}`) => void;
}
declare enum ETextBaseLine {
    Top = "top",
    Hanging = "hanging",
    Middle = "middle",
    Alphabetic = "alphabetic",
    Ideographic = "ideographic",
    Bottom = "bottom"
}
/**
 * @description 使用单位矩阵重新设置（覆盖）当前的变换并调用变换的方法，此变换由方法的变量进行描述。
 */
interface setTransform {
    type: APIType.Fn;
    /**
     * @param scaleX 水平缩放。
     * @param skewX 水平倾斜。
     * @param skewY 垂直倾斜。
     * @param scaleY 垂直缩放。
     * @param translateX 水平移动。
     * @param translateY 垂直移动。
     */
    fn: (scaleX: number, skewX: number, skewY: number, scaleY: number, translateX: number, translateY: number) => void;
}
/**
 * @description 画出当前路径的边框。默认 black。
 */
interface stroke {
    type: APIType.Fn;
    fn: () => void;
}
/**
 * @description 画一个矩形（非填充）。
 */
interface strokeRect {
    type: APIType.Fn;
    /**
     * @param x 矩形左上角的 x 坐标。
     * @param y 矩形左上角的 y 坐标。
     * @param width 矩形路径宽度。
     * @param height 矩形路径高度。
     */
    fn: (x: number, y: number, width: number, height: number) => void;
}
/**
 * @description 获取画布指定区域的 data URL数据。
 */
interface toDataURL {
    type: APIType.Fn;
    /**
     * @param x 将要被提取的矩形区域的左上角横坐标，默认值为 `0`。
     * @param y 将要被提取的矩形区域的左上角纵坐标，默认值为 `0`。
     * @param width 将要被提取的矩形区域的宽度，默认值为被提取的矩形区域的左上角到画布右下角的横向距离。
     * @param height 将要被提取的矩形区域的高度，默认值为被提取的矩形区域的左上角到画布右下角的纵向距离。
     * @param destWidth 将要被提取的矩形区域提取后的宽度，默认等于 `width`。
     * @param destHeight 将要被提取的矩形区域提取后的高度，默认等于 `height`。
     * @param fileType 图片格式，默认为 `png`.
     * @param quality 图片格式为 `jpg` 的情况下，data URL 对应的图片的质量。取值范围为 `0~1`，如果超出取值范围，将会默认该值为 `1`，其他图片格式该参数会被忽略。
     * @returns 提取的 data URL 字符串。
     */
    fn: (x?: number, y?: number, width?: number, height?: number, destWidth?: number, destHeight?: number, fileType?: `${EFileType}`, quality?: number) => Promise<string>;
}
/**
 * @description 把当前画布的内容导出生成图片，并返回文件路径。
 */
interface toTempFilePath {
    type: APIType.Async;
    request: {
        /**
         * @description 画布 x 轴起点。
         * @default 0
         */
        x?: number;
        /**
         * @description 画布 y 轴起点。
         * @default 0
         */
        y?: number;
        /**
         * @description 画布宽度。
         * @default 默认为 canvas 宽度 x
         */
        width?: number;
        /**
         * @description 画布高度。
         * @default 默认为 canvas 高度 y
         */
        height?: number;
        /**
         * @description 输出的图片宽度。
         * @default 默认为 width
         */
        destWidth?: number;
        /**
         * @description 输出的图片高度。
         * @default 默认为 height
         */
        destHeight?: number;
        /**
         * @description 图片格式。
         * @default png
         */
        fileType?: `${EFileType}`;
        /**
         * @description 图片的质量，目前仅对 `jpg` 有效，取值范围为 (0, 1]，不在范围内时当作 1.0 处理。
         */
        quality?: number;
    };
    response: {
        /**
         * @description 客户端内部路径，例如 `"/sdcard/xxx"`，小程序内不识别。
         */
        tempFilePath: string;
        /**
         * @description http 协议临时路径，例如 `"http://res/xxx.image"`，小程序内可正常使用。
         */
        apFilePath: string;
    };
    error: {
        /**
         * @description 错误信息。
         */
        error: string;
    };
}
/**
 * @description 使用矩阵多次叠加当前变换的方法，矩阵由方法的参数进行描述。可以缩放、旋转、移动和倾斜上下文。
 */
interface transform {
    type: APIType.Fn;
    /**
     * @param scaleX 水平缩放。
     * @param skewX 水平倾斜。
     * @param skewY 垂直倾斜。
     * @param scaleY 垂直缩放。
     * @param translateX 水平移动。
     * @param translateY 垂直移动。
     */
    fn: (scaleX: number, skewX: number, skewY: number, scaleY: number, translateX: number, translateY: number) => void;
}
/**
 * @description 对当前坐标系的原点(0, 0)进行变换，默认的坐标系原点为页面左上角。
 */
interface translate {
    type: APIType.Fn;
    /**
     * @param x 水平坐标平移量。
     * @param y 竖直坐标平移量。
     */
    fn: (x: number, y: number) => void;
}
export {};
//# sourceMappingURL=canvas.d.ts.map