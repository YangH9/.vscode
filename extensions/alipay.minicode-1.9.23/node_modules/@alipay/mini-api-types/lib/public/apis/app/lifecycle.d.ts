import { API, APIType, Type, TypeRef } from '../../type';
export interface TypeExport<S> {
}
/**
 * @name 生命周期
 */
export interface APIExport<S> {
    [API.onAppShow]: onAppShow<S>;
    [API.offAppShow]: offAppShow<S>;
    [API.onAppHide]: onAppHide<S>;
    [API.offAppHide]: offAppHide<S>;
    [API.exit]: exit<S>;
    [API.onPageNotFound]: onPageNotFound<S>;
    [API.offPageNotFound]: offPageNotFound<S>;
}
/**
 * @description 监听小程序切前台事件，与 `App.onShow` 一致，**请勿使用 API 监听匿名函数，否则将无法关闭监听**。
 */
interface onAppShow<S> {
    type: APIType.Event;
    event: void;
}
/**
 * @description 取消监听小程序切前台事件
 */
interface offAppShow<S> {
    type: APIType.Event;
    event: void;
}
/**
 * @description 监听小程序切后台事件，与 `App.onHide` 一致，**请勿使用 API 监听匿名函数，否则将无法关闭监听**。
 */
interface onAppHide<S> {
    type: APIType.Event;
    event: void;
}
/**
 * @description 取消监听小程序切后台事件
 */
interface offAppHide<S> {
    type: APIType.Event;
    event: void;
}
/**
 * @description 退出当前小程序
 */
interface exit<S> {
    type: APIType.Fn;
    fn: TypeRef<S, Type.Shared.Callback>;
}
/**
 * @description 监听小程序要打开的页面不存在事件。该事件与 `App.onPageNotFound`（添加链接） 的回调时机一致。
 * - 开发者可以在回调中进行页面重定向，但必须在回调中同步处理，异步处理（例如 setTimeout 异步执行）无效。
 * - 若开发者没有调用 `onPageNotFound` 绑定监听，也没有声明 `App.onPageNotFound`（添加链接），当跳转页面不存在时，将推入页面不存在提示页面。
 * - 如果回调中又重定向到另一个不存在的页面，将推入页面不存在提示页面，并且不再第二次回调。
 */
interface onPageNotFound<S> {
    type: APIType.Event;
    event: {
        /**
         * @description 不存在页面的路径 (代码包路径)。
         */
        path: string;
        /**
         * @description 打开不存在页面的 query 参数。
         */
        query: object;
        /**
         * @description 是否本次启动的首个页面（例如从分享等入口进来，首个页面是开发者配置的分享页面）。
         */
        isEntryPage: boolean;
    };
}
/**
 * @description 取消监听小程序要打开的页面不存在事件。
 */
interface offPageNotFound<S> {
    type: APIType.Fn;
    fn: (callback: Function) => void;
}
export {};
//# sourceMappingURL=lifecycle.d.ts.map