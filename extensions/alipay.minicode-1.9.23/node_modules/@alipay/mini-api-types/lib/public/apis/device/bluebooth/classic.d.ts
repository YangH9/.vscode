import { API, APIDefaultErrorResponse, APIType, Flag, FlagDef, Type, TypeRef } from '../../../type';
export interface TypeExport<S> {
}
/**
 * @name 经典蓝牙
 * @description 本文用于介绍 **经典蓝牙** (classic Bluetooth) 接口的使用，完整链接流程如下
 * ![](http://mdn.alipayobjects.com/afts/img/A*FoPBTqHoP1sAAAAAAAAAAABkAa8wAA/original?bz=openpt_doc&t=ahoz2azNPv_9wUCIO3OU3wAAAABkMK8AAAAA)
 */
export interface APIExport<S> {
    [API.openBluetoothAdapter]: openBluetoothAdapter;
    [API.closeBluetoothAdapter]: closeBluetoothAdapter<S>;
    [API.getBluetoothAdapterState]: getBluetoothAdapterState<S>;
    [API.startBluetoothDevicesDiscovery]: startBluetoothDevicesDiscovery<S>;
    [API.stopBluetoothDevicesDiscovery]: stopBluetoothDevicesDiscovery<S>;
    [API.getBluetoothDevices]: getBluetoothDevices<S>;
    [API.getConnectedBluetoothDevices]: getConnectedBluetoothDevices<S>;
    [API.onBluetoothAdapterStateChange]: onBluetoothAdapterStateChange<S>;
    [API.offBluetoothAdapterStateChange]: offBluetoothAdapterStateChange;
    [API.onBluetoothDeviceFound]: onBluetoothDeviceFound<S>;
    [API.offBluetoothDeviceFound]: offBluetoothDeviceFound;
}
/**
 * @description 初始化小程序蓝牙模块。
 * - 生效周期为调用 `openBluetoothAdapter` 至调用 `closeBluetoothAdapter` 或小程序被销毁为止。
 * - 在小程序蓝牙适配器模块生效期间，开发者可以正常调用下面的小程序 API，并会收到蓝牙模块相关的 on 事件回调。
 */
interface openBluetoothAdapter {
    type: APIType.Async;
    request: {
        /**
         * @description 表示是否在离开当前页面时自动断开蓝牙。仅支持 `Android` 系统。
         * @default true
         */
        autoClose?: boolean;
    };
    response: {
        /**
         * @description 是否支持 BLE
         */
        isSupportBLE: boolean;
    };
    error: openBluetoothAdapterError;
}
interface openBluetoothAdapterError extends APIDefaultErrorResponse {
    /**
     * @description 错误码1。
     */
    error: EErrorCode4Init;
}
/**
 * @description 关闭本机蓝牙模块。调用该方法将断开所有已建立的蓝牙连接并释放系统资源。
 */
interface closeBluetoothAdapter<S> {
    type: APIType.Async;
    request: void;
    response: void;
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 获取本机蓝牙模块状态。
 */
interface getBluetoothAdapterState<S> {
    type: APIType.Async;
    request: void;
    response: {
        /**
         * @description 是否正在搜索设备。
         */
        discovering: boolean;
        /**
         * @description 蓝牙模块是否可用（需支持 BLE 并且蓝牙是打开状态）。
         */
        available: boolean;
    };
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 开始搜寻附近的蓝牙外围设备。搜索结果将在 `onBluetoothDeviceFound` 事件中返回。该操作比较耗费系统资源，请在搜索并连接到设备后调用 stop 方法停止搜索。
 */
interface startBluetoothDevicesDiscovery<S> {
    type: APIType.Async;
    request: {
        /**
         * @description 蓝牙设备主 service 的 UUID 列表。
         */
        services?: string[];
        /**
         * @description 是否允许重复上报同一设备。如果允许重复上报，则 `onBluetoothDeviceFound` 方法会多次上报同一设备，但是 RSSI 值会有不同。
         */
        allowDuplicatesKey?: FlagDef<S, boolean, Flag.Bluetooth.DiscoveryFeature>;
        /**
         * @description 上报设备的间隔，意思是找到新设备立即上报，否则根据传入的间隔上报。
         * @default 0
         */
        interval?: FlagDef<S, number, Flag.Bluetooth.DiscoveryFeature>;
    };
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 停止搜寻附近的蓝牙外围设备
 */
interface stopBluetoothDevicesDiscovery<S> {
    type: APIType.Async;
    request: void;
    response: void;
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 获取所有已发现的蓝牙设备，包括已经和本机处于连接状态的设备。
 */
interface getBluetoothDevices<S> {
    type: APIType.Async;
    response: {
        /**
         * @description 已发现的设备列表。
         */
        devices: IBluetoothDevice[];
    };
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 获取处于已连接状态的设备。若小程序在之前已有搜索过某个蓝牙设备，即可直接传入之前搜索获取的 deviceId 尝试连接该设备，无需进行搜索操作。
 */
interface getConnectedBluetoothDevices<S> {
    type: APIType.Async;
    response: {
        /**
         * @description 蓝牙设备 ID。
         */
        deviceId: string;
    };
    error: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
}
/**
 * @description 监听本机蓝牙状态变化事件。
 */
interface onBluetoothAdapterStateChange<S> {
    type: APIType.Event;
    event: {
        /**
         * @description 蓝牙模块是否可用。
         */
        available: boolean;
        /**
         * @description 蓝牙模块是否处于搜索状态。
         */
        discovering: boolean;
        error?: TypeRef<S, Type.Bluetooth.BlueBoothCommonError>;
    };
}
/**
 * @description 移除本机蓝牙状态变化的事件监听。
 */
interface offBluetoothAdapterStateChange {
    type: APIType.Fn;
    /**
     * @param callback
     * - 不传递 `callback` 值，则会移除监听**所有**的事件回调。
     * - 传递 `callback` 值，只移除**对应**的 `callback` 事件。
     */
    fn: (callback?: Function) => void;
}
/**
 * @description 搜索到新的蓝牙设备时触发的事件。若在 `onBluetoothDeviceFound` 回调中包含了某个蓝牙设备，则此设备会添加到 `getBluetoothDevices` 接口获取到的数组中。
 */
interface onBluetoothDeviceFound<S> {
    type: APIType.Event;
    event: {
        /**
         * @description 新搜索到的设备列表。
         */
        devices: IBluetoothDevice[];
    };
}
/**
 * @description 移除寻找到新的蓝牙设备事件监听。
 */
interface offBluetoothDeviceFound {
    type: APIType.Fn;
    /**
     * @param callback
     * - 不传递 `callback` 值，则会移除监听**所有**的事件回调。
     * - 传递 `callback` 值，只移除**对应**的 `callback` 事件。
     */
    fn: (callback?: Function) => void;
}
interface IBluetoothDevice {
    /**
     * @description 蓝牙设备名称（某些设备可能没有）。
     */
    name: string;
    /**
     * @description 低版本客户端提供，与 name 一致
     */
    deviceName: string;
    /**
     * @description 广播设备名称。
     */
    localName: string;
    /**
     * @description 设备 ID。Android 上为设备 MAC 地址，iOS 上为设备 UUID。需要分平台处理，iOS 可根据设备属性（ localName / advertisData / manufacturerData 等属性）进行动态匹配
     */
    deviceId: string;
    /**
     * @description 设备信号强度。
     */
    RSSI: string;
    /**
     * @description 设备的广播内容。为 16 进制Hex字符串
     */
    advertisData: string;
    /**
     * @description 设备的 manufacturerData。为 16 进制Hex字符串
     */
    manufacturerData: string;
}
declare const enum EErrorCode4Init {
    /**
     * @description 蓝牙未打开。
     */
    '_12' = 12,
    /**
     * @description 与系统服务的链接暂时丢失。
     */
    '_13' = 13,
    /**
     * @description 未授权支付宝使用蓝牙功能。
     */
    '_14' = 14,
    /**
     * @description 未知错误。
     */
    '_15' = 15
}
export {};
//# sourceMappingURL=classic.d.ts.map