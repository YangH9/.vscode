import { API, APIDefaultErrorResponse, APIType } from '../../type';
export interface TypeExport<S> {
}
/**
 * @name 传输层请求(TCP/UDP)
 * @description TCP socket 目前只提供作为 client 使用，不支持作为 server。
 */
export interface APIExport<S> {
    [API.createTCPSocket]: createTCPSocket;
    [API.createUDPSocket]: createUDPSocket;
}
/**
 * @description 创建一个 TCPSocket 实例。
 */
interface createTCPSocket {
    type: APIType.Fn;
    fn: (option?: CreateTCPSocketOption) => TCPSocket;
}
/**
 * @name createTCPSocket.option
 */
interface CreateTCPSocketOption {
    /**
     * @description 是否绑定到当前 WiFi; 用于 WiFi 无法上网，仍需要与 WiFi 通信的场景。Android 专用, iOS 忽略此参数。
     * @default false
     */
    bindToWifi?: boolean;
}
/**
 * @description TCPSocket 实例。
 */
interface TCPSocket {
    /**
     * @description 连接到指定的 server，连接成功回调 onConnect。
     */
    connect(option: TCPSocketConnectOption): void;
    /**
     * @description 发送消息，收到 onConnect 回调后可用。可多次调用。
     */
    send(option: TCPSocketSendOption): void;
    /**
     * @description close 后 TCPSocket 实例不能再用来发送消息，也不会再收到 onMessage 回调。关闭后回调 onClose。
     */
    close: Function;
    /**
     * @description 监听连接成功的事件。
     */
    onConnect(callback: (event: TCPSocketConnectEvent) => void): void;
    /**
     * @description 取消监听连接成功的事件。callback 即 onConnect 事件传入的回调函数。
     */
    offConnect(callback: Function): void;
    /**
     * @description 监听收到消息的事件，native 收到一段数据回调一次。小程序将多次收到的数据进行拼接，根据业务逻辑判断收到的数据是否完整。
     */
    onMessage(callback: (event: TCPSocketMessageEvent) => void): void;
    /**
     * @description 取消监听收到消息的事件。callback 即 onMessage 事件传入的回调函数。
     */
    offMessage(callback: Function): void;
    /**
     * @description 监听关闭的事件。
     */
    onClose(callback: Function): void;
    /**
     * @description 取消监听关闭的事件。callback 即 onClose 事件传入的回调函数。
     */
    offClose(callback: Function): void;
    /**
     * @description 监听错误事件。
     */
    onError(callback: (event: TCPSocketErrorEvent) => void): void;
    /**
     * @description 取消监听错误事件。callback 即 onError 事件传入的回调函数。
     */
    offError(callback: Function): void;
}
/**
 * @name TCPSocket.connect.option
 */
interface TCPSocketConnectOption {
    /**
     * @description 目标地址。
     */
    address: string;
    /**
     * @description 目标端口号。
     */
    port: string;
    /**
     * @description 连接超时时间，单位：毫秒。
     * @default 20000
     */
    timeout?: number;
}
/**
 * @name TCPSocket.send.option
 */
interface TCPSocketSendOption {
    /**
     * @description 要发送的数据。
     */
    mesasge: string | ArrayBuffer;
    /**
     * @description 发送数据的偏移量，仅当 message 为 ArrayBuffer 类型时有效。offset 必须与 length 同时指定。
     * @default 0
     */
    offset?: number;
    /**
     * @description 发送数据的长度，仅当 message 为 ArrayBuffer 类型时有效。offset 必须与 length 同时指定。
     * @default message.byteLength
     */
    length?: number;
}
/**
 * @name TCPSocket.onConnect.event
 */
interface TCPSocketConnectEvent {
    /**
     * @description 本地端口号。
     */
    port: string;
}
/**
 * @name TCPSocket.onMessage.event
 */
interface TCPSocketMessageEvent {
    /**
     * @description 要发送的数据。
     */
    mesasge: string | ArrayBuffer;
    /**
     * @description 消息来源的结构化信息。
     */
    remoteInfo: remoteInfo;
}
/**
 * @name TCPSocket.onError.event
 */
interface TCPSocketErrorEvent extends APIDefaultErrorResponse {
    /**
     * @description 错误码。
     */
    error: ETCPSocketError;
}
declare const enum ETCPSocketError {
    /**
     * @description 非法参数，查看 errorMessage。
     */
    '_2' = 2,
    /**
     * @description 未知异常，查看 errorMessage。
     */
    '_3' = 3,
    /**
     * @description appX 调用JSAPI 会出现的错误。
     */
    '_60000' = 60000,
    /**
     * @description 关闭失败，具体看错误信息。
     */
    '_60101' = 60101,
    /**
     * @description socket 已关闭，不能再调 send, connect 等。
     */
    '_60104' = 60104,
    /**
     * @description send 失败。
     */
    '_60105' = 60105,
    /**
     * @description 连接失败。
     */
    '_60200' = 60200,
    /**
     * @description 发送数据，未连接。
     */
    '_60201' = 60201
}
/**
 * @description 创建一个 UDP Socket 实例。
 */
interface createUDPSocket {
    type: APIType.Fn;
    fn: (option?: CreateUDPSocketOption) => UDPSocket;
}
/**
 * @name createUDPSocket.option
 */
interface CreateUDPSocketOption {
    /**
     * @description 是否开启广播。
     * @default false
     */
    broadcast?: boolean;
    /**
     * @description 是否开启组播。
     * @default false
     */
    multicast?: boolean;
    /**
     * @description 是否绑定到当前 WiFi; 用于 WiFi 无法上网，仍需要与 WiFi 通信的场景。Android 专用, iOS 忽略此参数。
     * @default false
     */
    bindToWifi?: boolean;
}
/**
 * @description UDP Socket 实例。
 */
interface UDPSocket {
    /**
     * @description 绑定一个系统随机分配的可用端口，或绑定一个指定的端口号。
     */
    bind(option?: UDPSocketBindOption): UDPSocketBindReturn;
    /**
     * @description 向指定的 IP 和 port 发送消息。
     */
    send(option?: UDPSocketSendOption): void;
    /**
     * @description 关闭 UDP Socket 实例，相当于销毁。 在关闭之后，UDP Socket 实例不能再发送消息，每次调用 UDPSocket.send 将会触发错误事件，并且 message 事件回调函数也不会再也执行。
     */
    close: Function;
    /**
     * @description 开始监听数据包消息的事件。
     */
    onListening(callback: (event: UDPSocketListenEvent) => void): void;
    /**
     * @description 取消监听数据包消息的事件。callback 即 onListening 事件传入的回调函数。
     */
    offListening(callback: Function): void;
    /**
     * @description 监听收到消息的事件。
     */
    onMessage(callback: (event: UDPSocketMessageEvent) => void): void;
    /**
     * @description 取消监听收到消息的事件。callback 即 onMessage 事件传入的回调函数。
     */
    offMessage(callback: Function): void;
    /**
       * @description 监听关闭的事件。
       */
    onClose(callback: Function): void;
    /**
     * @description 取消监听关闭的事件。callback 即 onClose 事件传入的回调函数。
     */
    offClose(callback: Function): void;
    /**
     * @description 监听错误事件。
     */
    onError(callback: (event: UDPSocketErrorEvent) => void): void;
    /**
     * @description 取消监听错误事件。callback 即 onError 事件传入的回调函数。
     */
    offError(callback: Function): void;
}
/**
 * @name UDPSocket.bind.option
 */
interface UDPSocketBindOption {
    /**
     * @description 指定要绑定的端口号。
     */
    port?: number;
    /**
     * @description 是否接收广播消息。
     * @default false
     */
    broadcast?: boolean;
}
/**
 * @name UDPSocket.bind.return
 */
interface UDPSocketBindReturn {
    /**
     * @description 绑定成功的端口号。
     */
    port: number;
}
/**
 * @name UDPSocket.send.option
 */
interface UDPSocketSendOption {
    /**
     * @description 要发消息的地址。
     */
    address: string;
    /**
     * @description 要发送消息的端口号。
     */
    port: number;
    /**
     * @description 要发送的数据。当 message 是 ArrayBuffer 时，如果指定了 offset 和 length，则只发送从 offset 开始的 length 个字节。
     */
    message: string | ArrayBuffer;
    /**
     * @description 发送数据的偏移量，仅当 message 为 ArrayBuffer 类型时有效。offset 必须与 length 同时指定。
     * @default 0
     */
    offset?: number;
    /**
     * @description 发送数据的长度，仅当 message 为 ArrayBuffer 类型时有效。offset 必须与 length 同时指定。
     * @default message.byteLength
     */
    length?: number;
}
/**
 * @name UDPSocket.onListen.event
 */
interface UDPSocketListenEvent {
    /**
     * @description 监听的端口号。
     */
    port: number;
}
/**
 * @name UDPSocket.onMessage.event
 */
interface UDPSocketMessageEvent {
    /**
     * @description 要发送的数据。
     */
    mesasge: string | ArrayBuffer;
    /**
     * @description 消息来源的结构化信息。
     */
    remoteInfo: remoteInfo;
}
interface remoteInfo {
    /**
     * @description 发送消息的 socket 的地址。
     */
    address: string;
    /**
     * @description 使用的协议族，为 IPv4 或者 IPv6。
     */
    family: string;
    /**
     * @description 端口号。
     */
    port: number;
    /**
     * @description message 的大小，单位：字节。
     */
    size: number;
}
/**
 * @name UDPSocket.onError.event
 */
interface UDPSocketErrorEvent extends APIDefaultErrorResponse {
    /**
     * @description 错误码。
     */
    error: EUDPSocketError;
}
declare const enum EUDPSocketError {
    /**
     * @description 非法参数，查看 errorMessage。
     */
    '_2' = 2,
    /**
     * @description 未知异常，查看 errorMessage。
     */
    '_3' = 3,
    /**
     * @description appX 调用JSAPI 会出现的错误。
     */
    '_60000' = 60000,
    /**
     * @description socket bind 失败，错误原因看 errorMessage。
     */
    '_60001' = 60001,
    /**
     * @description socket create 失败，查看 errorMessage, 多是端口号被占用。
     */
    '_60100' = 60100,
    /**
     * @description 关闭失败，具体看错误信息。
     */
    '_60101' = 60101,
    /**
     * @description 已经绑定的 socket，不能重新绑定到其他端口。
     */
    '_60102' = 60102,
    /**
     * @description 重复的 bind 请求(已经绑定)。
     */
    '_60103' = 60103,
    /**
     * @description socket 已关闭。close 后不能再 send 或 bind。
     */
    '_60104' = 60104,
    /**
     * @description 发送失败，具体看错误信息。
     */
    '_60105' = 60105,
    /**
     * @description bind 之后会接收消息，接收报错，具体看错误信息(iOS 专用)。
     */
    '_60202' = 60202,
    /**
     * @description 开启广播组播模式错误(iOS 专用)。
     */
    '_60201' = 60201,
    /**
     * @description 获取 MulticastLock 失败，将无法收到广播消息(Android 专用)。非致命错误，消息监听继续。
     */
    '_68000' = 68000
}
export {};
//# sourceMappingURL=transport.d.ts.map