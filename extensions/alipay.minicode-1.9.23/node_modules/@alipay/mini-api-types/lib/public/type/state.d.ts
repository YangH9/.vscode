import { API, Client, Flag, SDK } from './meta';
import { MathType as M } from './number';
export interface FlagStruct {
    client: Client.All | string;
    sdk: SDK.All | string;
}
export declare type TypeFlagStruct = {
    [K in Flag.Flags]?: FlagStruct;
};
export declare type APIFlagStruct = {
    [K in API]?: FlagStruct;
};
export interface BridgeState {
    flag: {
        type: TypeFlagStruct;
        api: APIFlagStruct;
    };
    client: Client.All | string;
    sdk: SDK.All | string;
    namespace?: string | void;
    extra?: {};
}
export declare type StringedVersion<A extends string, B extends string, C extends string> = `${A}.${B}.${C}`;
export declare type GeneralStringedVersion = StringedVersion<string, string, string>;
export interface BridgeStateWithStringedVersion extends Pick<BridgeState, 'flag' | 'namespace'> {
    client: GeneralStringedVersion;
    sdk: GeneralStringedVersion;
}
export declare type StringedVersion2Seq3<T extends GeneralStringedVersion> = T extends `${infer A}.${infer B}.${infer C}` ? M.Seq3<String2Int2<A>, String2Int2<B>, String2Int2<C>> : never;
export declare type FormatVersion2Seq3<T> = T extends M.Seq3<M.Int2, M.Int2, M.Int2> ? T : T extends GeneralStringedVersion ? StringedVersion2Seq3<T> : never;
declare type DefaultInt2 = M.Int2<M.N['0'], M.N['0']>;
declare type KeyofN = keyof M.N;
export declare type String2Int2<T extends string> = T extends `${infer A}${infer B}` ? A extends KeyofN ? B extends KeyofN ? M.Int2<M.N[A], M.N[B]> : B extends '' ? M.Int2<M.N['0'], M.N[A]> : DefaultInt2 : DefaultInt2 : DefaultInt2;
export declare type NormalizeBridgeStateWithStringedVersion<T extends BridgeStateWithStringedVersion> = {
    flag: T['flag'];
    namespace: T['namespace'];
    client: StringedVersion2Seq3<T['client']>;
    sdk: StringedVersion2Seq3<T['sdk']>;
};
export {};
//# sourceMappingURL=state.d.ts.map