import { API, APIType, Client, Flag, SDK, Type } from './meta';
import { APIExport, TypeExport } from '../apis';
import { GetProperty, RequiredKeys } from './lib';
import { BridgeState, FlagStruct, FormatVersion2Seq3 } from './state';
import { MathType } from './number';
export declare type APIExportRequest<S> = {
    [K in keyof APIExport<S>]: GetProperty<APIExport<S>[K], 'request'>;
};
export declare type APIExportResponse<S> = {
    [K in keyof APIExport<S>]: GetProperty<APIExport<S>[K], 'response'>;
};
export declare type APIExportError<S> = {
    [K in keyof APIExport<S>]: GetProperty<APIExport<S>[K], 'error'>;
};
export declare type TypeRef<S, T extends Type.Types, F extends Flag.Flags = Flag.Internal.Zero> = T extends keyof TypeExport<S> ? S extends BridgeState ? FlagOptionalValue<S, F, TypeExportInfer<TypeExport<S>[T]>> : TypeExportInfer<TypeExport<S>[T]> : never;
declare type GetAPIType<O> = GetProperty<O, 'type'>;
declare type GetAPIRequest<O> = GetProperty<O, 'request'>;
declare type GetAPIResponse<O> = GetProperty<O, 'response'>;
declare type GetAPIReturn<O> = GetProperty<O, 'return'>;
declare type GetAPIFn<O> = GetProperty<O, 'fn'>;
declare type GetAPIError<O> = GetProperty<O, 'error'> extends void ? APIDefaultErrorResponse : GetProperty<O, 'error'>;
declare type GetAPIEvent<O> = GetProperty<O, 'event'>;
declare type GetAPIProperty<O> = GetProperty<O, 'property'>;
declare type GetAPIAlias<O> = GetProperty<O, 'alias'>;
interface IOptionSFC<O> {
    success?: (payload: GetAPIResponse<O>) => void;
    fail?: (payload: GetAPIError<O>) => void;
    complete?: (payload: Partial<GetAPIResponse<O> & GetAPIError<O>>) => void;
}
declare type THasSFC<O, K = RequiredKeys<O>> = 'success' extends K ? true : 'fail' extends K ? true : 'complete' extends K ? true : false;
declare type PromiseWithReturn<A, B> = B extends void ? Promise<A> : Promise<A> & B;
declare type APIImpl4Async<O> = void extends GetAPIRequest<O> ? {
    (): PromiseWithReturn<GetAPIResponse<O>, GetAPIReturn<O>>;
    <T extends IOptionSFC<O>>(option: T): (THasSFC<T> extends true ? void : Promise<GetAPIResponse<T>>) & GetAPIReturn<T>;
    (option: IOptionSFC<O>, callback: (payload: GetAPIResponse<O> | GetAPIError<O>) => void): GetAPIReturn<O>;
    (callback: (payload: GetAPIResponse<O> | GetAPIError<O>) => void): GetAPIReturn<O>;
} : {
    <T extends IOptionSFC<O>>(option: Partial<GetAPIRequest<O>> extends GetAPIRequest<O> ? (void | (GetAPIRequest<O> & T)) : (GetAPIRequest<O> & T)): THasSFC<O> extends true ? GetAPIReturn<O> : PromiseWithReturn<GetAPIResponse<O>, GetAPIReturn<O>>;
    (option: GetAPIRequest<O> & IOptionSFC<O>, callback: (payload: GetAPIResponse<O> | GetAPIError<O>) => void): GetAPIReturn<O>;
};
declare type APIImpl4Sync<O> = (option: GetAPIRequest<O>) => GetAPIResponse<O>;
declare type APIImpl4Event<O> = (callback: (event: GetAPIEvent<O>) => void) => void;
declare type APIImpl4Property<O> = GetAPIProperty<O>;
declare type APIImpl4Fn<O> = GetAPIFn<O>;
declare type APIImpl<O> = {
    [APIType.Async]: APIImpl4Async<O>;
    [APIType.Sync]: APIImpl4Sync<O>;
    [APIType.Event]: APIImpl4Event<O>;
    [APIType.Property]: APIImpl4Property<O>;
    [APIType.Fn]: APIImpl4Fn<O>;
};
declare type APITypes = keyof APIImpl<unknown>;
export declare type TypeExportInfer<O> = GetAPIType<O> extends APITypes ? APIImpl<O>[GetAPIType<O>] : O;
export declare type APIExportInfer<S, K> = K extends API ? GetAPIType<APIExport<S>[K]> extends APITypes ? GetAPIType<APIExport<S>[K]> extends APIType.Alias ? APIExportInfer<S, GetAPIAlias<APIExport<S>[K]>> : APIImpl<APIExport<S>[K]>[GetAPIType<APIExport<S>[K]>] : APIImpl<APIExport<S>[K]>[APIType.Async] : void;
export declare type FlagDef<S, T, F extends Flag.Flags = Flag.Internal.Zero> = S extends BridgeState ? MathType.GreaterEqual4Sequence3<FormatVersion2Seq3<S['sdk']>, S['flag']['type'][F] extends FlagStruct ? FormatVersion2Seq3<S['flag']['type'][F]['sdk']> : SDK.v0_0_0> extends true ? MathType.GreaterEqual4Sequence3<FormatVersion2Seq3<S['client']>, S['flag']['type'][F] extends FlagStruct ? FormatVersion2Seq3<S['flag']['type'][F]['client']> : Client.v0_0_0> extends true ? T : (void | T) : (void | T) : never;
export declare type FlagOptionalValue<S extends BridgeState, F extends Flag.Flags, T> = MathType.GreaterEqual4Sequence3<FormatVersion2Seq3<S['sdk']>, FormatVersion2Seq3<S['flag']['type'][F]['sdk']>> extends true ? MathType.GreaterEqual4Sequence3<FormatVersion2Seq3<S['client']>, FormatVersion2Seq3<S['flag']['type'][F]['client']>> extends true ? T : OptionalPartial<T> : OptionalPartial<T>;
export declare type OptionalPartial<T> = {
    [P in keyof T]?: void | T[P];
};
export declare type APIGetSDKVersionOrZero<S extends BridgeState, T extends API> = T extends keyof S['flag']['api'] ? FormatVersion2Seq3<S['flag']['api'][T]['sdk']> : SDK.v0_0_0;
export declare type APIGetClientVersionOrZero<S extends BridgeState, T extends API> = T extends keyof S['flag']['api'] ? FormatVersion2Seq3<S['flag']['api'][T]['client']> : Client.v0_0_0;
export declare type APIGetNamespace<T extends API> = T extends `${infer ns}.${string}` ? ns : void;
export declare type APIRemoveNamespace<NS extends string, T extends API> = T extends `${NS}.${infer method}` ? method : never;
export interface APIDefaultErrorResponse {
    /**
     * @description 错误码
     */
    error: number | string;
    /**
     * @description 错误描述信息。
     */
    errorMessage: string;
}
export {};
//# sourceMappingURL=registry.d.ts.map