/**
 * Get intersection keys of two types
 */
export declare type IntersectionKeys<T, U> = keyof T & keyof U;
/**
 * Get union key of two types
 */
export declare type UnionKeys<T, U> = keyof T | keyof U;
/**
 * Get unique keys of left type.
 */
export declare type UniqueLeftKeys<T, U> = Exclude<UnionKeys<T, U>, keyof U>;
/**
 * Extract left-only types.
 */
export declare type UniqueLeft<T, U> = {
    [P in UniqueLeftKeys<T, U>]: T[P];
};
/**
 * Get unique keys of right type.
 */
export declare type UniqueRightKeys<T, U> = Exclude<UnionKeys<T, U>, keyof T>;
/**
 * Extract right-only types.
 */
export declare type UniqueRight<T, U> = {
    [P in UniqueRightKeys<T, U>]: U[P];
};
/**
 * Filter a type, and remove `boolean`.
 */
export declare type RemoveBoolean<T> = T extends boolean ? never : T;
/**
 * Change all object properties's type to string
 */
export declare type ObjectPropertyToStringProperty<T extends object> = {
    [P in keyof T]?: T[P] extends (infer U)[] ? string : T[P] extends object ? string : T[P];
};
/**
 * Transform union type to tuple.
 *
 * e.g.
 *
 *  type TRenderType = 'web' | 'cube';
 *  type TRenderTypeTuple = UnionToTuple<TRenderType>; // => ["web", "cube"]
 *
 * @since TypeScript 4.1
 */
export declare type UnionToTuple<T extends any> = ((T extends any ? (t: T) => T : never) extends infer U ? (U extends any ? (u: U) => any : never) extends (v: infer V) => any ? V : never : never) extends (_: any) => infer W ? [...UnionToTuple<Exclude<T, W>>, W] : [];
//# sourceMappingURL=conditional-types.d.ts.map