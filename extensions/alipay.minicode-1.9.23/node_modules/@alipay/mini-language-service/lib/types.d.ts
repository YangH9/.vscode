import type * as ts from 'typescript/lib/tsserverlibrary';
import type { TCreateProxyHostReturn } from './proxyHost';
import type { MiniLanguageConfigCenter } from './configCenter';
export interface MiniCompilerOptions {
    target?: 2 | 2.7 | 3;
    strictTemplates?: boolean;
    experimentalRuntimeMode?: 'runtime-dom' | 'runtime-uni-app';
    experimentalImplicitWrapComponentOptionsWithDefineComponent?: boolean | 'onlyJs';
    experimentalImplicitWrapComponentOptionsWithVue2Extend?: boolean | 'onlyJs';
    experimentalDowngradePropsAndEmitsToSetupReturnOnScriptSetup?: boolean | 'onlyJs';
    experimentalTemplateCompilerOptions?: any;
    experimentalTemplateCompilerOptionsRequirePath?: string;
    experimentalDisableTemplateSupport?: boolean;
    experimentalResolveStyleCssClasses?: 'scoped' | 'always' | 'never';
    experimentalAllowTypeNarrowingInInlineHandlers?: boolean;
    experimentalUseScriptLeadingCommentInTemplate?: boolean;
}
export interface LanguageServiceHost extends ts.LanguageServiceHost {
    getTypeScriptModule(): typeof import('typescript/lib/tsserverlibrary');
    getMiniCompilationSettings(): MiniCompilerOptions;
    isTsPlugin?: boolean;
    isTsc?: boolean;
}
export interface TSLanguageService {
    getCompletionsAtPosition(fileName: string, position: number, options: ts.GetCompletionsAtPositionOptions | undefined): ts.CompletionEntry[];
}
export interface ITSUtils {
    getProgram: () => ts.Program;
    getSourceFile: (fileName: string) => ts.SourceFile;
    getNode: (fileName: string, position: number) => ts.Node;
    getChildNode: (sourceFile: ts.SourceFile, position: number) => ts.Node | undefined;
    getTypeChecker: () => ts.TypeChecker;
    /**
     * 匹配 my.aaa.bbb() 的表达式，并且返回一个数组 ['my', 'aaa', 'bbb']
     * 不包含 my.SDKVersion 这种 property 的形式的
     *
     * 并且此时 node 是 CallExpression
     * ts.isCallExpression(node) === true
     */
    getMyDotAsteriskExpression: (node: ts.Node) => string[] | undefined;
    checkIsAPICallStringLiteral(node: ts.Node, apiName: string, propName: string): boolean;
    isNavigateToUrl(node: ts.Node): node is ts.StringLiteral;
    isSwitchTabUrl(node: ts.Node): node is ts.StringLiteral;
    isRedirectToUrl(node: ts.Node): node is ts.StringLiteral;
    isRelaunchToUrl(node: ts.Node): node is ts.StringLiteral;
    isMyCallMethod(node: ts.Node): node is ts.StringLiteral;
    isMyCanIUseMethod(node: ts.Node): node is ts.StringLiteral;
    checkIsMyAPICallStringLiteral: (node: ts.Node, apiName: string) => boolean;
    isMyCallInputParams(node: ts.Node): node is ts.ObjectLiteralElement;
    checkIsMyCallInputParamsLiteral(node: ts.Node): boolean;
    checkIsTypingMyAPI: (node: ts.Node) => string[] | undefined;
}
export interface IMiniLanguageServiceContext {
    tsUtils: ITSUtils;
    ts: typeof ts;
    languageService: ts.LanguageService;
    sjsLanguageService: ts.LanguageService;
    configCenter: MiniLanguageConfigCenter;
    logger: ILogger;
    data: {
        isInsideUser: boolean;
    };
    proxyHost: TCreateProxyHostReturn;
    dispose: () => void;
    updateGlobalTypePath: (params: {
        path: string;
    }) => void;
}
export interface IMiniLanguageServiceConfig {
    globalStoragePath?: string;
}
export interface IMiniLanguageService {
    getCompletionsAtPosition(...params: Parameters<ts.LanguageService['getCompletionsAtPosition']>): ReturnType<ts.LanguageService['getCompletionsAtPosition']>;
    getSuggestionDiagnostics(...params: Parameters<ts.LanguageService['getSuggestionDiagnostics']>): ReturnType<ts.LanguageService['getSuggestionDiagnostics']>;
    dispose(): void;
    updateOptions(options: IMiniLanguageServiceConfig): void;
}
export declare type ICreateMiniLanguageServiceResult = IMiniLanguageService & ts.LanguageService;
export interface ILogger {
    info: (message: string) => void;
    error: (message: string) => void;
}
