"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MiniLanguageConfigCenter = void 0;
const MiniProjectJson_1 = require("./config/MiniProjectJson");
const path_1 = __importDefault(require("path"));
const json_1 = require("@alipay/mini-extensions-shared/lib/utils/json");
const clone_1 = require("@alipay/mini-extensions-shared/lib/utils/clone");
const path_2 = require("./utils/path");
const uri_1 = require("@opensumi/ide-utils/lib/uri");
const MiniProjectJsonPath = './mini.project.json';
class MiniLanguageConfigCenter {
    constructor(ts, host, logger) {
        this.ts = ts;
        this.host = host;
        this.logger = logger;
        this.watcher = [];
        this.cwd = host.getCurrentDirectory();
        this.root = uri_1.URI.file(this.cwd);
        this.readMiniProjectJson();
        this.watcher.push(ts.sys.watchFile(MiniProjectJsonPath, () => {
            this.readMiniProjectJson();
        }, 500 /* Medium */));
        this.logger.info(`miniProjectJson ${JSON.stringify(this.miniProjectJson)}`);
        this.readAppJson();
        this.watcher.push(ts.sys.watchFile(this.appJsonPath, () => {
            this.readAppJson();
        }, 500 /* Medium */));
        this.logger.info(`appJson ${JSON.stringify(this.appJson)}`);
    }
    dispose() {
        this.watcher.forEach((v) => {
            v.close();
        });
    }
    readMiniProjectJson() {
        if (this.host.fileExists(this.miniProjectJsonPath)) {
            const data = this.host.readFile(this.miniProjectJsonPath);
            this.miniProjectJson = (0, MiniProjectJson_1.createMiniProjectJson)(data);
        }
        else {
            this.miniProjectJson = {};
        }
    }
    get miniProjectJsonPath() {
        return path_1.default.join(this.cwd, MiniProjectJsonPath);
    }
    get appJsonPath() {
        var _a;
        const miniprogramRoot = (_a = this.miniProjectJson.miniprogramRoot) !== null && _a !== void 0 ? _a : '';
        const appJsonPath = path_1.default.join(this.cwd, miniprogramRoot, 'app.json');
        return appJsonPath;
    }
    readAppJson() {
        if (this.host.fileExists(this.appJsonPath)) {
            const data = this.host.readFile(this.appJsonPath);
            this.appJson = (0, json_1.parseJson)(data);
        }
        else {
            this.appJson = {};
        }
    }
    getPagesAbsolutePath() {
        return this.getPages().map((v) => {
            return path_1.default.join(this.cwd, v);
        });
    }
    /**
     * 使用的时候要添加一下 prefix /
     */
    getPages(excludeTabbar = false) {
        let pages = this.appJson.pages ? (0, clone_1.clone)(this.appJson.pages) : [];
        const subPages = this.appJson.subPackages
            ? (0, clone_1.clone)(this.appJson.subPackages)
            : [];
        if (Array.isArray(subPages)) {
            subPages.forEach((v) => {
                v.pages.forEach((page) => {
                    page && pages.push(`${v.root}${v.root ? '/' : ''}${page}`);
                });
            });
        }
        if (excludeTabbar) {
            const tabbarPages = new Set(this.getTabbarItemPages());
            pages = pages.filter((v) => !tabbarPages.has(v));
        }
        return pages.map(path_2.normalizeGlobalPagePath);
    }
    getTabbarItemPages() {
        const tabBar = this.appJson.tabBar
            ? (0, clone_1.clone)(this.appJson.tabBar)
            : { items: [] };
        const pages = [];
        tabBar.items.forEach((v) => {
            v.pagePath && pages.push(v.pagePath);
        });
        return pages.filter(Boolean).map(path_2.normalizeGlobalPagePath);
    }
    /**
     * @param inputPath 这里传进来的应该是带有文件名的 fsPath, 如 xx.js
     *
     * 返回的结果 isDir 代表该 page 是文件还是文件夹
     */
    getPageByPath(path_) {
        const uri = uri_1.URI.file(path_);
        return this.getPageByURI(uri);
    }
    getPageByURI(uri) {
        const inputPath = uri.path;
        // 可以通过比较两个 uri 的 path 部分来确定是不是同一个文件
        // 可以见 URI.path 的类型定义
        // * ┌──────────────────────┬────────────┐
        // * │          dir         │    base    │
        // * ├──────┬               ├──────┬─────┤
        // * │ root │               │ name │ ext │
        // * "  /     home/user/dir / file  .txt "
        // * └──────┴───────────────┴──────┴─────┘
        for (const page of this.getPages()) {
            // 转成 fsPath 进行比较
            const pageUri = this.root.resolve(page);
            const pagePath = pageUri.path;
            if (inputPath.dir.isEqual(pagePath.dir) &&
                inputPath.name === pagePath.name) {
                return { page, isDir: false };
            }
            // 如用户声明(pagePath)的是 /page/a/b/c，此时用户打开的(uri)是 /page/a/b/c/index.(js,axml)
            const expandIndex = pagePath.dir.join('index.js');
            if (inputPath.dir.isEqual(expandIndex.dir) &&
                inputPath.name === expandIndex.name) {
                return { page, isDir: true };
            }
        }
    }
    /**
     *
     * @param fileName '/Users/artin/0Ant/api-demo/master/src/page/API/favorite/favorite.js'
     * @param url '../events/events'
     * @returns /page/API/events/events
     */
    resolveRouterUrl(fileName, url) {
        // ../aaa/bbb
        if (url.startsWith('.')) {
            const basePage = this.getPageByPath(fileName);
            if (basePage) {
                let pageUri = this.root.resolve(basePage.page);
                // 如果不是 dir，说明是多了一层 index.axml 的
                if (!basePage.isDir) {
                    pageUri = pageUri.parent;
                }
                // 要多 resolve 一层 .. 把文件名去了
                const targetUrl = pageUri.resolve(url);
                const targetPage = this.getPageByURI(targetUrl);
                return (targetPage === null || targetPage === void 0 ? void 0 : targetPage.page) || url;
            }
        }
        return url;
    }
}
exports.MiniLanguageConfigCenter = MiniLanguageConfigCenter;
