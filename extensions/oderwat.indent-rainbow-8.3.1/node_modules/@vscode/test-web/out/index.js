#!/usr/bin/env node
"use strict";
/* eslint-disable header/header */
Object.defineProperty(exports, "__esModule", { value: true });
exports.open = exports.runTests = void 0;
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
const main_1 = require("./server/main");
const download_1 = require("./server/download");
const playwright = require("playwright");
const minimist = require("minimist");
const path = require("path");
/**
 * Runs the tests in a browser.
 *
 * @param options The options defining browser type, extension and test location.
 */
async function runTests(options) {
    var _a;
    const config = {
        extensionDevelopmentPath: options.extensionDevelopmentPath,
        extensionTestsPath: options.extensionTestsPath,
        build: await getBuild(options.version),
        folderUri: options.folderUri
    };
    const port = 3000;
    const server = await main_1.runServer(port, config);
    const endpoint = `http://localhost:${port}`;
    const result = await openInBrowser({
        browserType: options.browserType,
        endpoint,
        headless: (_a = options.headless) !== null && _a !== void 0 ? _a : true,
        devTools: options.devTools,
        waitForDebugger: options.waitForDebugger,
    });
    server.close();
    if (result) {
        return;
    }
    throw new Error('Test failed');
}
exports.runTests = runTests;
async function getBuild(version) {
    if (version === 'sources') {
        return { type: 'sources' };
    }
    return await download_1.downloadAndUnzipVSCode(version === 'stable' ? 'stable' : 'insider');
}
async function open(options) {
    var _a;
    const config = {
        extensionDevelopmentPath: options.extensionDevelopmentPath,
        build: await getBuild(options.version),
        folderUri: options.folderUri
    };
    const port = 3000;
    await main_1.runServer(port, config);
    const endpoint = `http://localhost:${port}`;
    await openInBrowser({
        browserType: options.browserType,
        endpoint,
        headless: (_a = options.headless) !== null && _a !== void 0 ? _a : false,
        devTools: options.devTools
    });
}
exports.open = open;
const width = 1200;
const height = 800;
function openInBrowser(options) {
    return new Promise(async (s) => {
        var _a;
        const args = [];
        if (process.platform === 'linux' && options.browserType === 'chromium') {
            args.push('--no-sandbox');
        }
        if (options.waitForDebugger) {
            args.push(`--remote-debugging-port=${options.waitForDebugger}`);
        }
        const browser = await playwright[options.browserType].launch({ headless: options.headless, args, devtools: options.devTools });
        const context = await browser.newContext();
        const page = (_a = context.pages()[0]) !== null && _a !== void 0 ? _a : await context.newPage();
        if (options.waitForDebugger) {
            await page.waitForFunction(() => '__jsDebugIsReady' in globalThis);
        }
        await page.setViewportSize({ width, height });
        await page.goto(options.endpoint);
        await page.exposeFunction('codeAutomationLog', (type, args) => {
            console[type](...args);
        });
        await page.exposeFunction('codeAutomationExit', async (code) => {
            try {
                await browser.close();
            }
            catch (error) {
                console.error(`Error when closing browser: ${error}`);
            }
            s(code === 0);
        });
    });
}
function isStringOrUndefined(value) {
    return value === undefined || (typeof value === 'string');
}
function isBooleanOrUndefined(value) {
    return value === undefined || (typeof value === 'boolean');
}
function isBrowserType(browserType) {
    return (typeof browserType === 'string') && ['chromium', 'firefox', 'webkit'].includes(browserType);
}
function isValidVersion(version) {
    return version === undefined || ((typeof version === 'string') && ['insiders', 'stable', 'sources'].includes(version));
}
function getPortNumber(port) {
    if (typeof port === 'string') {
        const number = Number.parseInt(port);
        if (!Number.isNaN(number) && number >= 0) {
            return number;
        }
    }
    return undefined;
}
if (require.main === module) {
    const options = { string: ['extensionDevelopmentPath', 'extensionTestsPath', 'browserType', 'version', 'waitForDebugger', 'folder-uri'], boolean: ['open-devtools', 'headless'] };
    const args = minimist(process.argv.slice(2), options);
    const { browserType, extensionDevelopmentPath, extensionTestsPath, version, waitForDebugger, headless } = args;
    const port = getPortNumber(waitForDebugger);
    if (!isBrowserType(browserType) || !isStringOrUndefined(extensionDevelopmentPath) || !isStringOrUndefined(extensionTestsPath) || !isValidVersion(version) || !isStringOrUndefined(args['folder-uri']) || !isBooleanOrUndefined(args['open-devtools']) || !isBooleanOrUndefined(headless)) {
        console.log('Usage:');
        console.log(`  --browserType 'chromium' | 'firefox' | 'webkit': The browser to launch`);
        console.log(`  --extensionDevelopmentPath path. [Optional]: A path pointing to a extension to include.`);
        console.log(`  --extensionTestsPath path.  [Optional]: A path to a test module to run`);
        console.log(`  --folder-uri.  [Optional]: The folder to open VS Code on`);
        console.log(`  --version. 'insiders' (Default) | 'stable' | 'sources' [Optional]`);
        console.log(`  --open-devtools. Opens the dev tools  [Optional]`);
        console.log(`  --headless. Whether to show the browser. Defaults to true when an extensionTestsPath is provided, otherwise false. [Optional]`);
        process.exit(-1);
    }
    if (extensionTestsPath) {
        runTests({
            extensionTestsPath: extensionTestsPath && path.resolve(extensionTestsPath),
            extensionDevelopmentPath: extensionDevelopmentPath && path.resolve(extensionDevelopmentPath),
            browserType,
            version,
            devTools: args['open-devtools'],
            waitForDebugger: port,
            folderUri: args['folder-uri'],
            headless
        });
    }
    else {
        open({
            extensionDevelopmentPath: extensionDevelopmentPath && path.resolve(extensionDevelopmentPath),
            browserType,
            version,
            devTools: args['open-devtools'],
            waitForDebugger: port,
            folderUri: args['folder-uri'],
            headless
        });
    }
}
