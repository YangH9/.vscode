"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs_1 = require("fs");
const vscode_uri_1 = require("vscode-uri");
const Router = require("@koa/router");
const extensions_1 = require("./extensions");
const download_1 = require("./download");
function asJSON(value) {
    return JSON.stringify(value).replace(/"/g, '&quot;');
}
class Workbench {
    constructor(baseUrl, dev, builtInExtensions = []) {
        this.baseUrl = baseUrl;
        this.dev = dev;
        this.builtInExtensions = builtInExtensions;
    }
    async render(workbenchWebConfiguration) {
        const values = {
            WORKBENCH_WEB_CONFIGURATION: asJSON(workbenchWebConfiguration),
            WORKBENCH_AUTH_SESSION: '',
            WORKBENCH_WEB_BASE_URL: this.baseUrl,
            WORKBENCH_BUILTIN_EXTENSIONS: asJSON(this.builtInExtensions),
            WORKBENCH_MAIN: this.getMain()
        };
        try {
            const workbenchTemplate = (await fs_1.promises.readFile(path.resolve(__dirname, '../../views/workbench.html'))).toString();
            return workbenchTemplate.replace(/\{\{([^}]+)\}\}/g, (_, key) => { var _a; return (_a = values[key]) !== null && _a !== void 0 ? _a : 'undefined'; });
        }
        catch (e) {
            return e;
        }
    }
    getMain() {
        return this.dev
            ? `<script> require(['vs/code/browser/workbench/workbench'], function() {}); </script>`
            : `<script src="${this.baseUrl}/out/vs/workbench/workbench.web.api.nls.js"></script>`
                + `<script src="${this.baseUrl}/out/vs/workbench/workbench.web.api.js"></script>`
                + `<script src="${this.baseUrl}/out/vs/code/browser/workbench/workbench.js"></script>`;
    }
    async renderCallback() {
        return await download_1.fetch(`${this.baseUrl}/out/vs/code/browser/workbench/callback.html`);
    }
}
function valueOrFirst(value) {
    return Array.isArray(value) ? value[0] : value;
}
async function getWorkbenchOptions(ctx, config) {
    const options = {};
    if (config.extensionPath) {
        options.additionalBuiltinExtensions = await extensions_1.scanForExtensions(config.extensionPath, {
            scheme: ctx.protocol,
            authority: ctx.host,
            path: '/static/extensions',
        });
    }
    if (config.extensionDevelopmentPath) {
        const developmentOptions = options.developmentOptions = {};
        developmentOptions.extensions = await extensions_1.scanForExtensions(config.extensionDevelopmentPath, { scheme: ctx.protocol, authority: ctx.host, path: '/static/devextensions' });
        if (config.extensionTestsPath) {
            let relativePath = path.relative(config.extensionDevelopmentPath, config.extensionTestsPath);
            if (process.platform === 'win32') {
                relativePath = relativePath.replace(/\\/g, '/');
            }
            developmentOptions.extensionTestsPath = {
                scheme: ctx.protocol,
                authority: ctx.host,
                path: path.posix.join('/static/devextensions', relativePath),
            };
        }
    }
    if (config.folderUri) {
        options.folderUri = vscode_uri_1.URI.parse(config.folderUri);
    }
    return options;
}
function default_1(config) {
    const router = new Router();
    router.use(async (ctx, next) => {
        if (ctx.query['dev'] || config.build.type === 'sources') {
            try {
                const builtInExtensions = await download_1.fetchJSON('http://localhost:8080/builtin');
                ctx.state.workbench = new Workbench('http://localhost:8080/static', true, builtInExtensions);
            }
            catch (err) {
                console.log(err);
                ctx.throw('Could not connect to localhost:8080, make sure you start `yarn web`', 400);
            }
        }
        else if (config.build.type === 'static') {
            ctx.state.workbench = new Workbench(`${ctx.protocol}://${ctx.host}/static/build`, false);
        }
        else if (config.build.type === 'cdn') {
            ctx.state.workbench = new Workbench(config.build.uri, false);
        }
        await next();
    });
    const callbacks = new Map();
    router.get('/callback', async (ctx) => {
        const { 'vscode-requestId': vscodeRequestId, 'vscode-scheme': vscodeScheme, 'vscode-authority': vscodeAuthority, 'vscode-path': vscodePath, 'vscode-query': vscodeQuery, 'vscode-fragment': vscodeFragment, } = ctx.query;
        if (!vscodeRequestId || !vscodeScheme || !vscodeAuthority) {
            return ctx.throw(400);
        }
        const requestId = valueOrFirst(vscodeRequestId);
        const uri = vscode_uri_1.URI.from({
            scheme: valueOrFirst(vscodeScheme),
            authority: valueOrFirst(vscodeAuthority),
            path: valueOrFirst(vscodePath),
            query: valueOrFirst(vscodeQuery),
            fragment: valueOrFirst(vscodeFragment),
        });
        callbacks.set(requestId, uri);
        ctx.body = await ctx.state.workbench.renderCallback();
    });
    router.get('/fetch-callback', async (ctx) => {
        const { 'vscode-requestId': vscodeRequestId } = ctx.query;
        if (!vscodeRequestId) {
            return ctx.throw(400);
        }
        const requestId = valueOrFirst(vscodeRequestId);
        const uri = callbacks.get(requestId);
        if (!uri) {
            return ctx.throw(400);
        }
        callbacks.delete(requestId);
        ctx.body = uri.toJSON();
    });
    router.get('/', async (ctx) => {
        const options = await getWorkbenchOptions(ctx, config);
        ctx.body = await ctx.state.workbench.render(options);
    });
    return router.routes();
}
exports.default = default_1;
