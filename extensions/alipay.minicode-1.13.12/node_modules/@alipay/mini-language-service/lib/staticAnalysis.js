"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StaticAnalysis = void 0;
class StaticAnalysis {
    constructor(tsModule) {
        this.tsModule = tsModule;
    }
    getChildNode(sourceFile, position) {
        const { tsModule } = this;
        function find(node) {
            if (position >= node.getStart() && position <= node.getEnd()) {
                return tsModule.forEachChild(node, find) || node;
            }
        }
        return find(sourceFile);
    }
    getComponentExpressionRange(sourceFile) {
        const ranges = [];
        sourceFile.forEachChild((statement) => {
            if (!this.tsModule.isExpressionStatement(statement)) {
                return;
            }
            const v = statement.expression;
            if (this.tsModule.isCallExpression(v) &&
                v.expression &&
                this.tsModule.isIdentifier(v.expression) &&
                v.expression.text === 'Component') {
                ranges.push({
                    range: {
                        start: v.getStart(),
                        end: v.getEnd(),
                    },
                });
            }
        });
        return ranges;
    }
    getComponentOrPage(sourceFile) {
        let component;
        sourceFile.forEachChild((statement) => {
            if (!this.tsModule.isExpressionStatement(statement)) {
                return;
            }
            const v = statement.expression;
            if (this.tsModule.isCallExpression(v) &&
                v.expression &&
                this.tsModule.isIdentifier(v.expression) &&
                v.expression.text === 'Component') {
                component = v;
            }
        });
        return component;
    }
    getComponentProps(component) {
        const arg0 = component.arguments[0];
        if (!arg0) {
            return;
        }
        if (!this.tsModule.isObjectLiteralExpression(arg0)) {
            return;
        }
        let propsValueNode;
        arg0.properties.forEach((v) => {
            if (!this.tsModule.isPropertyAssignment(v)) {
                return;
            }
            if (this.tsModule.isIdentifier(v.name) &&
                v.name.text === 'props' &&
                this.tsModule.isObjectLiteralExpression(v.initializer)) {
                propsValueNode = v.initializer;
            }
        });
        if (!propsValueNode) {
            return;
        }
        const result = [];
        propsValueNode.properties.forEach((v) => {
            if (!this.tsModule.isPropertyAssignment(v)) {
                return;
            }
            if (this.tsModule.isIdentifier(v.name)) {
                result.push({
                    start: v.name.pos,
                    end: v.name.end,
                    value: v.name.text,
                });
            }
        });
        return result;
    }
}
exports.StaticAnalysis = StaticAnalysis;
