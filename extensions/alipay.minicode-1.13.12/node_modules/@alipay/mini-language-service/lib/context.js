"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMiniLanguageServiceContextUtils = void 0;
const configCenter_1 = require("./configCenter");
const apiUsages_1 = require("./utils/apiUsages");
const proxyHost_1 = require("./proxyHost");
const i18n_1 = require("./i18n");
function createMiniLanguageServiceContextUtils(ts, info, logger, options) {
    const tsUtils = {
        getProgram,
        getSourceFile,
        getNode,
        getChildNode,
        getTypeChecker,
        getMyDotAsteriskExpression,
        checkIsAPICallStringLiteral,
        isNavigateToUrl,
        isSwitchTabUrl,
        isRedirectToUrl,
        isRelaunchToUrl,
        isMyCallMethod,
        isMyCanIUseMethod,
        checkIsTypingMyAPI,
        checkIsMyAPICallStringLiteral,
        isMyCallInputParams,
        checkIsMyCallInputParamsLiteral,
    };
    const configCenter = new configCenter_1.MiniLanguageConfigCenter(ts, info.languageServiceHost, logger);
    let globalTypePath = options.globalTypePath;
    logger.info('created MiniLanguageConfigCenter');
    const sjsProxyHost = (0, proxyHost_1.createSjsProxyHost)(ts, info, () => {
        return globalTypePath;
    });
    const sjsLanguageService = ts.createLanguageService(sjsProxyHost.host);
    logger.info('created sjsLanguageService');
    let _locale = 'zh';
    const context = {
        tsUtils,
        ts,
        languageService: info.languageService,
        sjsLanguageService,
        configCenter,
        logger,
        proxyHost: sjsProxyHost,
        dispose: () => {
            configCenter.dispose();
            sjsProxyHost.dispose();
            sjsLanguageService.dispose();
        },
        data: {
            isInsideUser: options.isInsideUser,
        },
        updateGlobalTypePath: (params) => {
            globalTypePath = params.path;
        },
        updateLocale(locale) {
            _locale = locale;
        },
        getLocale() {
            return _locale;
        },
        localize(key, ...args) {
            return (0, i18n_1.localize)(key, _locale, ...args);
        },
    };
    return context;
    function getNode(fileName, position) {
        const sourceFile = getSourceFile(fileName);
        if (sourceFile === undefined) {
            logger.info(`file: ${fileName} not exist!`);
            return undefined;
        }
        return getChildNode(sourceFile, position);
    }
    function getSourceFile(fileName) {
        var _a;
        return (_a = getProgram()) === null || _a === void 0 ? void 0 : _a.getSourceFile(fileName);
    }
    function getProgram() {
        return sjsLanguageService.getProgram();
    }
    function getTypeChecker() {
        var _a;
        return (_a = getProgram()) === null || _a === void 0 ? void 0 : _a.getTypeChecker();
    }
    function getChildNode(sourceFile, position) {
        function find(node) {
            if (position >= node.getStart() && position <= node.getEnd()) {
                return ts.forEachChild(node, find) || node;
            }
        }
        return find(sourceFile);
    }
    // 判断 my.call
    function isMyCallMethod(node) {
        return checkIsMyAPICallStringLiteral(node, 'call');
    }
    function isMyCanIUseMethod(node) {
        return checkIsMyAPICallStringLiteral(node, 'canIUse');
    }
    function checkIsMyAPICallStringLiteral(node, apiName) {
        // 在这里查看整个 ast 树的结构：https://ts-ast-viewer.com/#code/LYTwdAxghgNjAUAiRAaABPAlGgvAPjQG8BfTIA
        if (node && ts.isStringLiteral(node)) {
            if (node.parent && ts.isCallExpression(node.parent)) {
                const expression = node.parent.expression;
                if (expression &&
                    ts.isPropertyAccessExpression(expression) &&
                    expression.name &&
                    ts.isIdentifier(expression.name)) {
                    return expression.name.text === apiName;
                }
            }
        }
        return false;
    }
    // 判断 my.call 的入参
    function isMyCallInputParams(node) {
        return checkIsMyCallInputParamsLiteral(node);
    }
    function checkIsMyCallInputParamsLiteral(node) {
        const typeChecker = getTypeChecker();
        if (!typeChecker) {
            return false;
        }
        // 在这里查看整个 ast 树的结构：https://ts-ast-viewer.com/#code/LYTwdAxghgNjAUAiRAaABAbwL4Eog
        if (node && ts.isObjectLiteralExpression(node)) {
            if (node.parent && ts.isCallExpression(node.parent)) {
                const expression = node.parent.expression;
                if (expression &&
                    ts.isPropertyAccessExpression(expression) &&
                    expression.name &&
                    ts.isIdentifier(expression.name) &&
                    expression.name.text === 'call') {
                    return (ts.isObjectLiteralExpression(node.parent.arguments[1]) &&
                        node.parent.arguments[1] === node);
                }
            }
        }
        return false;
    }
    function getMyDotAsteriskExpression(node) {
        let originalExpression = [];
        // this.xx = my.canIUse()
        if (ts.isCallExpression(node)) {
            if (ts.isPropertyAccessExpression(node.expression)) {
                // my.xxx.xx()
                originalExpression = (0, apiUsages_1.getOriginalPropertyAccessIdentifierName)(ts, node.expression);
            }
        }
        // logger.info('originalExpression' + JSON.stringify(originalExpression));
        if (originalExpression[0] === 'my') {
            return originalExpression;
        }
        return;
    }
    /**
     * 自底向上的匹配是不是 my.navigateTo
     * 因为此时光标是在 url: "|" 这里的，所以要从里往外匹配
     *
     * @param node 光标处的节点
     * @param apiName
     * @param propName
     * @returns
     */
    function checkIsAPICallStringLiteral(node, apiName, propName) {
        const typeChecker = getTypeChecker();
        if (!typeChecker) {
            return false;
        }
        // 在这里查看整个 ast 树的结构：https://ts-ast-viewer.com/#code/AQ4WwTwOgOwQwG4EsDmcAuBTAKgewBQDeAUKKAK4BOANgFzABEDpoAvgJRA
        // 目前只支持 navigateTo({ url: "" }) / my.navigateTo({ url: "" })
        if (node && ts.isStringLiteral(node)) {
            if (node.parent && ts.isPropertyAssignment(node.parent)) {
                const propertyAssignment = node.parent;
                if (propertyAssignment.name &&
                    ts.isIdentifier(propertyAssignment.name)) {
                    if (propertyAssignment.name.text === propName) {
                        if (node.parent.parent &&
                            ts.isObjectLiteralExpression(node.parent.parent)) {
                            if (node.parent.parent.parent &&
                                ts.isCallExpression(node.parent.parent.parent)) {
                                const expression = node.parent.parent.parent.expression;
                                if (expression &&
                                    ts.isPropertyAccessExpression(expression) &&
                                    expression.name &&
                                    ts.isIdentifier(expression.name)) {
                                    if (expression.name.text === apiName) {
                                        return true;
                                    }
                                }
                                if (expression && ts.isIdentifier(expression)) {
                                    if (expression.text === apiName) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    function isNavigateToUrl(node) {
        return checkIsAPICallStringLiteral(node, 'navigateTo', 'url');
    }
    function isSwitchTabUrl(node) {
        return checkIsAPICallStringLiteral(node, 'switchTab', 'url');
    }
    function isRedirectToUrl(node) {
        return checkIsAPICallStringLiteral(node, 'redirectTo', 'url');
    }
    function isRelaunchToUrl(node) {
        return checkIsAPICallStringLiteral(node, 'reLaunch', 'url');
    }
    function checkIsTypingMyAPI(node) {
        const typeChecker = getTypeChecker();
        if (!typeChecker) {
            return;
        }
        if (!node) {
            return;
        }
        // 在这里查看整个 ast 树的结构：https://ts-ast-viewer.com/#code/LYTwdAxghgzgJgKAaMUAOr4KA
        // 目前只支持 my.a| 和 my.ap.xx|
        if (ts.isIdentifier(node)) {
            let tmp = node.parent;
            if (tmp && ts.isPropertyAccessExpression(tmp)) {
                // 是一个 . 的操作，网上找，一直找到如果是 my.xx 或者 dd.xx
                tmp = tmp.parent;
            }
            if (ts.isExpressionStatement(tmp) &&
                ts.isPropertyAccessExpression(tmp.expression)) {
                // 拿到用户输入的文字
                const _result = (0, apiUsages_1.getOriginalPropertyAccessIdentifierName)(ts, tmp.expression);
                const result = _result.filter(Boolean);
                // 用户输入的是 my.| ，拿到的是 ['my', '']
                // 用户输入的是 my.ap. 拿到的是 ['my', 'ap', '']
                const first = result[0];
                if (first === 'my') {
                    return result;
                }
            }
        }
        return;
    }
}
exports.createMiniLanguageServiceContextUtils = createMiniLanguageServiceContextUtils;
